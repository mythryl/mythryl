#!/usr/bin/perl -w
use strict;

# This script edits the codebase using edit.c,
# per edit files typically generated by the
# Mythryl compiler per hacks inserted in the
# mythryl.grammar parser file.  (See example at bottom of file.) 

# This is only useful if you have the compiler generating EDIT_REQUESTS
# files.  You turn this on by setting the mythryl parser switch
#     log_edit_requests
# to TRUE either interactively or by changing its default to TRUE in
#     src/lib/compiler/front/parser/main/mythryl-parser.pkg
#

open FIND, "find . -type f -name '*EDIT_REQUESTS'|";
my @logs = <FIND>;
close FIND;

sub file_length {
    my ($filename) = @_;
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size) = stat( $filename );
    return $size;
}

sub nonzero_file_length {
    my ($filename) = @_;
    my $size = file_length( $filename );
    return $size != 0;
}

if (! -d 'sh') {
    print "No directory sh/ -- where ARE you?!\n";
    exit 1;
}
if (! -x 'sh/edit') {
    if (! -f 'sh/edit.c') {
        print "No sh/edit and no sh/edit.c -- where ARE you?!\n";
        exit 1;
    }
    chdir 'sh';
    print "Compiling sh/edit.c ...\n";
    system( "gcc edit.c -o edit" );
    chdir '..';
    if (! -f 'sh/edit') {
        print "No sh/edit and unable to compile it from sh/edit.c -- sorry!\n";
        exit 1;
    }
}

for my $compile_log (@logs) {
    chomp( $compile_log );
    my $size = file_length( $compile_log );
    if (nonzero_file_length ($compile_log ) ) {
        print "candidate: ($size) $compile_log\n";

        if ($compile_log =~ /^(.*).EDIT_REQUESTS$/) {
            my $base_filename = $1;
            if (-r  $base_filename) {
		my $size = file_length( $base_filename );
		print "derivation: ($size) $base_filename\n";

		my $edits_filename = $base_filename . ".EDITS";
		system("sort -n  <$compile_log >$edits_filename");
		$size = file_length( $edits_filename );
		print "sorted edits: ($size) $edits_filename\n";

		my $edited_filename = $base_filename . ".EDITED";
		system("sh/edit $base_filename");

		if ($? == -1) {

		    print "failed to execute $base_filename: $!\n";
		    print "RUN ABORTED\n";   exit 1;

		} elsif ($? & 127) {

		    printf "$base_filename child died with signal %d, %s coredump\n",
			($? & 127),  ($? & 128) ? 'with' : 'without';
		    print "RUN ABORTED\n";   exit 1;

		} elsif (($? >> 8) != 0) {

		    printf "child exited with value %d\n", $? >> 8;
		    print "RUN ABORTED\n";   exit 1;
		}

		$size = file_length( $edited_filename );
		print "edited file: ($size) $edited_filename\n\n";

		my $unedited_filename = $base_filename . ".UNEDITED";
		system("mv $base_filename $unedited_filename");
		system("mv $edited_filename $base_filename");
	    }
        }
    }
}

# A typical example of applying this script:
# Suppose mythryl.grammar contains a rule
#
# an_api:
#       MIXEDCASE_ID			(   SOURCE_CODE_REGION_FOR_API (
# 						API_BY_NAME (make_api_symbol mixedcase_id),
# 				                (mixedcase_idleft, mixedcase_idright)
# 					)   )
# 
#
# and that we'd like to insert a "# Api x is from"
# comment after each such identifier.
#
# First we edit the rule to read   
# an_api:
#       MIXEDCASE_ID			(   {
# 						    case *mythryl_parser::edit_request_stream 
# 						    of
# 							 THE stream
# 							      =>
# 							      {   file::write (
# 								      stream,
# 								      (   (int::to_string (mixedcase_idright - 2))
# 								      ^   ": `` -> `\t\t# Api x is from `\n"
# 								      )
# 								  );
# 							      };
# 
# 							 NULL => ();
# 						    esac;
# 
#                                             SOURCE_CODE_REGION_FOR_API (
# 						API_BY_NAME (make_api_symbol mixedcase_id),
# 				                (mixedcase_idleft, mixedcase_idright)
# 					);}   )
#
# Then we do a complete development cycle
# so that not only has the compiler been
# recompiled, but also all code in the
# codebase has been recompiled with the new
# compiler version, generating zillions of
# .EDIT_REQUESTS files with the appropriate
# edit instructions.
#
# It is a really good idea at this point
# to stop and make a backup tarfile of the
# entire source tree, just in case the
# next step wrecks it entirely!
#
# Now, we run "sh/do-edits" from the
# toplevel, which applies all the edits
# to the codebase.
#
# Now, you just have the problem of doing
# any manual clean-up required so as to
# make the codebase compile again. :)
#
#
# Here's a second example.  Suppose we're
# using the syntax
#    case ... of ... esac
# and we want to switch to
#    case ... in ... esac
# everywhere to be closer to bash's syntax,
# and so we can eliminate 'of' as a reserved
# word, reducing the language design's syntactic
# footprint by one reserved word.
#
# If our grammar rule was
#
#    | CASE_T
#      expression
#      OF_T
#      darrow_rules
#      ESAC_T				(    {
#						 mark_expression (
#						    CASE_EXPRESSION { expression, rules => darrow_rules },
#						    case_tleft, esac_tright
#						 );
#                                             }
#                                        )
#
# then we add a new one to support the new syntax
#
#    | CASE_T
#      expression
#      IN_T
#      darrow_rules
#      ESAC_T				(    {
#						 mark_expression (
#						    CASE_EXPRESSION { expression, rules => darrow_rules },
#						    case_tleft, esac_tright
#						 );
#                                             }
#                                        )
#
# and hack the original one to do the required edits:
#
#    | CASE_T
#      expression
#      OF_T
#      darrow_rules
#      ESAC_T				(    {
# 						    case *mythryl_parser::edit_request_stream 
#
# 							 THE stream
# 							      =>
# 							      {   file::write (
# 								      stream,
# 								      (   (int::to_string (of_tleft - 2))
# 								      +   ": `of` -> `in`\n"
# 								      )
# 								  );
# 							      };
# 
# 							 NULL => ();
# 						    esac;
# 
#						 mark_expression (
#						    CASE_EXPRESSION { expression, rules => darrow_rules },
#						    case_tleft, esac_tright
#						 );
#                                             }
#                                        )   
#
# Run the development cycle once, do sh/do-edits,
# run the development cycle again, remove the
# original "case ... of ... esac "rule completely,
# run the development cycle one last time, and
# Bob's your uncle.
