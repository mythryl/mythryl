#!/bin/sh
#
#
# Install-time script to do initial build of
# compiler, libraries and related tools as
# specified in etc/bundles-to-build.
#
# We're typically invoked from the root Makefile as "sh/make-c-stuff"
# in response to a top-level "make compiler" command.
#
# As soon as we have a system capable of executing compiled Mythryl,
# we pass control to sh/build.d/build.pkg via the wrapper
# sh/build.d/unix-build.pkg.
#
# To get to that point, we must:
#
# o  Patch the various sh/_* scripts to suit the host system,
#    and install the patched versions in bin/
#
# o  Compile the Mythryl runtime from the C source code 
#    under src/c/ and install it as bin/mythryl-runtime-intel32. 
#
#    (The runtime provides compiled Mythryl code with various
#    low-level services such as garbage collection,
#    basic Unix I/O, and loading of compiled Mythryl code
#    from .compiled and .frozen files.)
#
# o  Unpack the precompiled Mythryl code in seed-libraries.tgz.
#    (This gets us around the chicken-and-egg problem of how to
#    do the first compile of a compiler written in itself,
#    and is done by 'unpack_seed_libraries:' in Makefile.)
#
# Author: Matthias Blume (blume@tti-c.org)
#

##-               "Food isn't properly seasoned unless it is painful to eat."
##-
##-                                            -- Freddie Fender


# Some OSs have 'make' in strange
# places, but most of the time
# it is simply on the PATH:
#
MAKE=make

SHELL=/bin/sh
EXECUTABLE=mythryld

if  [ x$1 = xnolib ]
then
    nolib=true
else
    nolib=false
fi

vsay() {
    if  [ x${INSTALL_DEBUG} = xtrue ]
    then
	echo "$@"
    elif [ x${INSTALL_QUIETLY} = xtrue ]
    then
	:
    else
	echo "$@"
    fi
}

complain() {
    echo "$@"
    exit 1
}

this=$0


vsay "                         sh/make-c-stuff:   Using shell $SHELL."

# Set the root directory:
#
REAL_PWD=`pwd`
ROOT=${PWD:-$REAL_PWD}
vsay "                         sh/make-c-stuff:   Root directory is $ROOT."

cat <<EOF >src/c/heapcleaner/shebang-line.h
/* This file automatically generated by sh/make-c-stuff. */

#define SHEBANG_LINE "#!${REAL_PWD}/bin/mythryl-runtime-intel32 --shebang\n"
EOF

cat <<EOF >src/c/o/mythryl-executable.h
/* This file automatically generated by sh/make-c-stuff. */

#define MYTHRYL_EXECUTABLE "/usr/bin/mythryld"
EOF

cd "${INSTALL_DIR:=$ROOT}"
INSTALL_DIR=`pwd`
cd "$ROOT"
vsay "                         sh/make-c-stuff:   Installation directory is ${INSTALL_DIR}."

# Set the various directory and file pathname variables:
#
BIN_DIR=$INSTALL_DIR/bin		# main dir for binary stuff
ETC_DIR=$ROOT/etc
SCRIPTS_DIR=$ROOT/sh
SRC_DIR=$ROOT/src		# where the source tree is rooted


# Note and announce the release version
# that we are building:
#
VERSION=`cat "$ETC_DIR/version"`
vsay "                         sh/make-c-stuff:   Building version $VERSION."
vsay

# Function to make a directory including its ancestors:
#
make_dir() {

    if [ x"$1" = x ] ; then
	:
    elif [ -d "$1" ] ; then
	:
    else
	makedirtmp=`dirname "$1"`
	make_dir "$makedirtmp"
	vsay "                         sh/make-c-stuff:   Making directory $1"
	if mkdir "$1" ; then
	    :
	else
	    complain "                         sh/make-c-stuff:   Unable to make directory $1!"
	fi
    fi
}

######################################################################


# Create various sub-directories:
#
for dir in "$BIN_DIR" ; do
    make_dir "$dir"
done

# Add some OVERVIEW files to the above directories:
#
cp sh/bindir.OVERVIEW   $BIN_DIR/AN_OVERVIEW




# Function to install a wrapper script...
#   This takes care of patching the source of the script with the SHELL,
#   BIN_DIR, and VERSION variables to use.
#
patch_and_install_script() {
    dsrc=$1
    ddst=$2
    vsay "                         sh/make-c-stuff:   Installing wrapper script $SCRIPTS_DIR/$dsrc as $BIN_DIR/$ddst ..."
# We install the wrapper unconditionally. (It would be better to test
# for an outdated wrapper script, but not all "test" commands understand
# the -nt comparison operator....)
#   if [ -x $BIN_DIR/$ddst ]; then
#	echo "                         sh/make-c-stuff:   Script $BIN_DIR/$ddst already exists."
#   else
	rm -f "$BIN_DIR"/"$ddst"
	cat "$SCRIPTS_DIR"/"$dsrc" | \
	sed -e "s,@SHELL@,$SHELL,g" \
	    -e "s,@BIN_DIR@,$BIN_DIR," \
	    -e "s,@VERSION@,$VERSION," \
	    > "$BIN_DIR"/"$ddst"
	chmod 555 "$BIN_DIR"/"$ddst"
	if [ ! -x "$BIN_DIR"/"$ddst" ]; then
	    complain "                         sh/make-c-stuff:   Installation of $BIN_DIR/${ddst} failed."
	fi
#   fi
}

patch_and_install_tk_makefile() {
    vsay "                         sh/make-c-stuff:   Installing template $SCRIPTS_DIR/_src_tk_makefile as src/lib/tk/Makefile ..."

    rm -f src/lib/tk/Makefile
    cat "$SCRIPTS_DIR"/_src_tk_makefile | \
    sed -e "s,@ROOT@,$REAL_PWD,g" \
	-e "s,@VERSION@,$VERSION," \
	> src/lib/tk/Makefile
    chmod 644 src/lib/tk/Makefile
    if [ ! -r src/lib/tk/Makefile ]; then
	complain "                         sh/make-c-stuff:   Installation of src/lib/tk/Makefile failed."
    fi
}
patch_and_install_tk_makefile

patch_and_install_tk_configfile () {
    vsay "                         sh/make-c-stuff:   Installing template $SCRIPTS_DIR/_src_tk_src_sys_conf.pkg as src/lib/tk/src/sys_conf.pkg ..."

    rm -f src/lib/tk/src/sys_conf.pkg
    cat "$SCRIPTS_DIR"/_src_tk_src_sys_conf.pkg | \
    sed -e "s,@ROOT@,$REAL_PWD,g" \
	-e "s,@VERSION@,$VERSION," \
	> src/lib/tk/src/sys_conf.pkg
    chmod 644 src/lib/tk/src/sys_conf.pkg
    if [ ! -r src/lib/tk/src/sys_conf.pkg ]; then
	complain "                         sh/make-c-stuff:   Installation of src/lib/tk/src/sys_conf.pkg failed."
    fi
}
patch_and_install_tk_configfile


# Install the script that sets $ARCHITECTURE and $OS based on `uname -a`:
#
patch_and_install_script _guess-host-architecture-and-os guess-host-architecture-and-os


# Run it to decide what architecture and os we are using,
# and then define the corresponding variables ARCHITECTURE and OS
#
ARCHITECTURE_AND_OS=`"$BIN_DIR"/guess-host-architecture-and-os`
if [ "$?" != "0" ]; then
    echo "sh/make-c-stuff: Script $BIN_DIR/guess-host-architecture-and-os fails on this machine."
    echo "sh/make-c-stuff: You must patch this by hand and repeat the installation."
    exit 2
else
    vsay
    vsay "                         sh/make-c-stuff:   Script $BIN_DIR/guess-host-architecture-and-os reports '$ARCHITECTURE_AND_OS'."
    vsay
fi
eval $ARCHITECTURE_AND_OS


# Now install our other scripts:
#
patch_and_install_script _mythryl-ld                             mythryl-ld
patch_and_install_script _makedepend7                            makedepend7
patch_and_install_script _heap2exec                              heap2exec
patch_and_install_script _build-an-executable-mythryl-heap-image build-an-executable-mythryl-heap-image

case $OS
in
    solaris)
	MAKE=/usr/ccs/bin/make
	;;

    linux)
	EXTRA_DEFS=`$SCRIPTS_DIR/check-whether-symbolmapstack-globals-have-leading-underscore.sh`
	if [ "$?" != "0" ]; then
	    complain "                         sh/make-c-stuff:   Problems checking for underscores in asm names."
	fi
	EXTRA_DEFS="XDEFS=$EXTRA_DEFS"
	;;
esac


# With multi-core machines now common as crabgrass,
# it makes sense to use N-process compile parallelism
# on an N-core machine.
#
CORES=1		# Assume one core by default.
#
# On Linux, we can count cores by peering
# into the /proc/cpuinfo kernel window:
#
if [ -r "/proc/cpuinfo" ]
then
    CORES=`grep processor /proc/cpuinfo | wc -l`
    vsay "                         sh/make-c-stuff:   $CORES cores detected, will run that many parallel compiles"
fi
    #
    # 2012-02-05 CrT:  I wrote the above off the top of my head circa 2010.
    # Googling around I find on   http://stackoverflow.com/questions/2693948/how-do-i-retrieve-the-number-of-processors-on-c-linux
    #                             http://stackoverflow.com/questions/150355/programmatically-find-the-number-of-cores-on-a-machine
    #    
    #     "The way glibc implements sysconf( _SC_NPROCESSORS_ONLN ) is by first trying /proc/stat.
    #      If it's there, it counts lines matching /^cpu[0-9]/ . Otherwise, it looks at /proc/cpuinfo,
    #      whose format varies among architectures."
    #           - Joey Adams Apr 22 '10 at 20:06
    #
    # At the Mythryl level, it is probably best to do just
    #
    #     corecount =  posix_1003_1b::sysconf  "NPROCESSORS_ONLN"; 



# Build 'mythryl-runtime-intel32', our C-coded run-time executable.
#
# Our "executables" are actually heap images which must be
# loaded and executed by mythryl-runtime-intel32, so we have to build
# mythryl-runtime-intel32 before we can do much of anything else.
#
# All our C code lives down under src/runtime.
#
# This part of the build is pure traditional unix make/gcc/a86/ar/ld stuff:
#
if  [ -x "$BIN_DIR"/mythryl-runtime-intel32 ]
then
    vsay "                         sh/make-c-stuff:   Run-time system $BIN_DIR/mythryl-runtime-intel32 already exists."
else
    echo
    echo "                         sh/make-c-stuff:   Entering $SRC_DIR/c/o"
    cd "$SRC_DIR"/c/o
    echo
    echo '######################################################'
    echo "sh/make-c-stuff: Compiling bin/mythryl-runtime-intel32 from C source."
    echo '######################################################'
    echo

    # On x86 linux this invokes   src/c/o/Makefile.intel32-linux
    # which then invokes          src/c/o/Makefile
    # which is built from         src/c/o/Makefile.in
    # with the target             $(RUNTIME)
    #
    echo "                         sh/make-c-stuff:   Doing:   $MAKE --jobs=$CORES  -f Makefile.$ARCHITECTURE-$OS $EXTRA_DEFS"
    $MAKE --jobs=$CORES -f Makefile.$ARCHITECTURE-$OS $EXTRA_DEFS

    if [ -x mythryl-runtime-intel32.$ARCHITECTURE-$OS ]; then

        echo
        echo '--------------------------------------------------------------------------------'
        echo "sh/make-c-stuff installing `pwd`/mythryl-runtime-intel32.$ARCHITECTURE-$OS as $BIN_DIR/mythryl-runtime-intel32"
        echo '--------------------------------------------------------------------------------'
        echo
	mv mythryl-runtime-intel32.$ARCHITECTURE-$OS "$BIN_DIR/mythryl-runtime-intel32"

	if [ -f runx.$ARCHITECTURE-$OS ]; then
            echo "                         sh/make-c-stuff:   Installing `pwd`/runx.$ARCHITECTURE-$OS as $BIN_DIR/runx"
	    mv runx.$ARCHITECTURE-$OS "$BIN_DIR/runx"
	fi

        # echo "sh/make-c-stuff in $SRC_DIR/c/o doing:    $MAKE MAKE=$MAKE clean"
	# $MAKE MAKE=$MAKE clean
    else
	complain "                         sh/make-c-stuff:   Make command failed to construct expected file   `pwd`/mythryl-runtime-intel32.$ARCHITECTURE-$OS"
    fi
fi

echo
echo
echo
echo "                         sh/make-c-stuff:   Returning to $SRC_DIR"
cd "$SRC_DIR"




echo
echo "                         sh/make-c-stuff:   Returning to $ROOT"
cd "$ROOT"

echo "                         sh/make-c-stuff:   Done."
exit 0


# Copyright (c) 1994 AT&T Bell Laboratories.
# Copyright (c) 2003 The Fellowship of SML/NJ
# Subsequent changes by Jeff Prothero Copyright (c) 2010-2011,
# released under Gnu Public Licence version 3.

