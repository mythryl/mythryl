## symbol-path.pkg 

# Compiled by:
#     src/lib/compiler/front/typer-stuff/typecheckdata.sublib

stipulate
    package l2  =  paired_lists;			# paired_lists	is from   src/lib/std/src/paired-lists.pkg
    package sy  =  symbol;				# symbol	is from   src/lib/compiler/front/basics/map/symbol.pkg
herein


    package   symbol_path
    : (weak)  Symbol_Path				# Symbol_Path	is from   src/lib/compiler/front/typer-stuff/basics/symbol-path.api
    {
	Symbol_Path =  SYMBOL_PATH  List( sy::Symbol );	# That's the essence -- a path is just a list of symbols.

	exception BAD_SYMBOL_PATH;

	empty =  SYMBOL_PATH NIL;

	fun null (SYMBOL_PATH p)
	    =
	    list::null p;

	fun extend (   SYMBOL_PATH p: Symbol_Path,
				   s: sy::Symbol
		   )
	    =
	    SYMBOL_PATH (p @ [s]);

	fun prepend ( s:              sy::Symbol,
		       SYMBOL_PATH p: Symbol_Path
		    )
	    =
	    SYMBOL_PATH (s ! p);

	fun append (   SYMBOL_PATH front: Symbol_Path,
		       SYMBOL_PATH back:  Symbol_Path
		   )
	    =
	    SYMBOL_PATH (front @ back);

	fun first (SYMBOL_PATH []: Symbol_Path) =>  raise exception BAD_SYMBOL_PATH;
	    first (SYMBOL_PATH (s ! _)        ) =>  s;
	end;

	fun rest (SYMBOL_PATH []: Symbol_Path) =>  raise exception BAD_SYMBOL_PATH;
	    rest (SYMBOL_PATH(_ ! p)         ) =>  SYMBOL_PATH p;
	end;

	fun length (SYMBOL_PATH p: Symbol_Path)
	    =
	    list::length p;


	# The last element of a path 

	fun last (SYMBOL_PATH p)
	    =
	    list::last p
	    except
		list::EMPTY
		=
		error_message::impossible "symbol_path::last";

	fun equal (   SYMBOL_PATH p1: Symbol_Path,
		      SYMBOL_PATH p2: Symbol_Path
		  )
	    =
	    l2::all symbol::eq (p1, p2);

	result_id =  symbol::make_package_symbol "<result_package>";
	return_id =  symbol::make_package_symbol "<return_package>";

	fun to_string (SYMBOL_PATH p: Symbol_Path)
	    =
	    cat (f p)
	    where
		fun f [s]
			=>
			[symbol::name s];

		    f (a ! r)
			=> 
			if ( (symbol::eq (a, result_id)) or
			     (symbol::eq (a, return_id)) 
			)
			     f r;
			else
			     symbol::name a ! "::" ! f r;
			fi;

		    f NIL
			=>
			["<empty spath>"];
		end;
	    end;

    }; #  package symbol_path 


    package inverse_path: (weak)  Inverse_Path {		# Inverse_Path	is from   src/lib/compiler/front/typer-stuff/basics/symbol-path.api

	package s = symbol;

	Inverse_Path = INVERSE_PATH  List( sy::Symbol );

	exception BAD_INVERSE_PATH;

	empty = INVERSE_PATH NIL;

	fun null (INVERSE_PATH p)
	    =
	    list::null p;

	fun extend (INVERSE_PATH p: Inverse_Path, s: sy::Symbol)
	    =
	    INVERSE_PATH (s ! p);

	fun append (INVERSE_PATH front: Inverse_Path, INVERSE_PATH back: Inverse_Path)
	    =
	    INVERSE_PATH (back @ front);

	fun last (INVERSE_PATH []: Inverse_Path) =>  raise exception BAD_INVERSE_PATH;
	    last (INVERSE_PATH (s ! _))          =>  s;
	end;

	fun last_prefix (INVERSE_PATH []: Inverse_Path) =>  raise exception BAD_INVERSE_PATH;
	    last_prefix (INVERSE_PATH(_ ! p))           =>  INVERSE_PATH p;
	end;

	fun equal (INVERSE_PATH p1: Inverse_Path, INVERSE_PATH p2: Inverse_Path)
	    =
	    l2::all symbol::eq (p1, p2);

	fun to_string (INVERSE_PATH p: Inverse_Path)
	    =
	    cat ("<" ! f p)
	    where
		fun f [s]     =>  [symbol::name s, ">"];
		    f (a ! r) =>   symbol::name a ! "::" ! f r;
		    f NIL     =>  [">"];
		end;
	    end;

    };	#  package inverse_path 


    package invert_path: (weak)  Invert_Path {		# Invert_Path	is from   src/lib/compiler/front/typer-stuff/basics/symbol-path.api

	Spath =  symbol_path::Symbol_Path;
	Ipath =  inverse_path::Inverse_Path;

	fun invert_spath (symbol_path::SYMBOL_PATH p:  Spath) : Ipath
	    =
	    inverse_path::INVERSE_PATH (reverse p);

	fun invert_ipath (inverse_path::INVERSE_PATH p:  Ipath) : Spath
	    =
	    symbol_path::SYMBOL_PATH (reverse p);

    };
end;

# XXX BUGGO FIXME This path/inversepath dichotomy is st00pid, we should just use double-ended lists per the Functional Datastructures book.


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Copyright 1996 by AT&T Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
