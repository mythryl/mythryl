## module-level-declarations.pkg				# Used to be called module.pkg

# Compiled by:
#     src/lib/compiler/front/typer-stuff/typecheckdata.sublib



# Datastructures describing module-level declarations.
#
# In particular, our datatypes
#
#     Api,
#     Package,
#     Generic,
#     Generic_Api,
#
# provide the value types bound by the symbol table
# for those four namespaces -- see
#
#     src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack-entry.pkg
#
# and the OVERVIEW section in
#
#     src/lib/compiler/front/typer-stuff/symbolmapstack/symbolmapstack.pkg
#
# Similarly, our datatypes
#
#     Api_Record
#     Typechecked_Package
#     Typechecked_Generic
#     Typerstore_Record
#
# serve as primary avatars for api/pckage/generic/... values in
#
#     src/lib/compiler/front/typer-stuff/modules/stampmapstack.pkg


stipulate
    package id  =  inlining_data;		# inlining_data			is from   src/lib/compiler/front/typer-stuff/basics/inlining-data.pkg
    package ip  =  inverse_path;		# inverse_path			is from   src/lib/compiler/front/typer-stuff/basics/symbol-path.pkg
    package mp  =  stamppath;			# stamppath			is from   src/lib/compiler/front/typer-stuff/modules/stamppath.pkg
    package ph  =  picklehash;			# picklehash			is from   src/lib/compiler/front/basics/map/picklehash.pkg
    package pl  =  property_list;		# property_list			is from   src/lib/src/property-list.pkg
    package sta =  stamp;			# stamp				is from   src/lib/compiler/front/typer-stuff/basics/stamp.pkg
    package sy  =  symbol;			# symbol			is from   src/lib/compiler/front/basics/map/symbol.pkg
    package syp =  symbol_path;			# symbol_path			is from   src/lib/compiler/front/typer-stuff/basics/symbol-path.pkg
    package ty  =  types;			# types				is from   src/lib/compiler/front/typer-stuff/types/types.pkg
    package vh  =  varhome;			# varhome			is from   src/lib/compiler/front/typer-stuff/basics/varhome.pkg
herein


    package   module_level_declarations
    : (weak)  Module_Level_Declarations		# Module_Level_Declarations			is from   src/lib/compiler/front/typer-stuff/modules/module-level-declarations.api
    {
	#  -------------------- api-related definitions -------------------- 

	Share_Spec = List( syp::Symbol_Path ); #  only internal sharing 

	Api = API  Api_Record
	    | ERRONEOUS_API
	    #
	    # 'Api' is the referent for:
	    #
	    #     symbolmapstack_entry::Symbolmapstack_Entry.NAMED_API
            #     deep_syntax::Declaration.API_DECLARATIONS
	    #     
            #     Api_Element.PACKAGE_IN_API.an_api
	    #     Generic_Api.GENERIC_API.parameter_api
            #     "                     ".body_api 
	    #     Package_Definition.VARIABLE_PACKAGE_DEFINITION.#1
	    #     Package.PACKAGE_API.an_api
            #     Package_Expression.ABSTRACT_PACKAGE.#1
            #     Package_Record.an_api

	# 1. typspec should only be BASE_TYP, with FORMAL or DATATYPE tyckinds, or DEFINED_TYP.
	#
	# 2. the stamp and the path for the BASE_TYP or DEFINED_TYP should be meaningless
	#    (but the stamps are in fact used for relativization of withtype bodies and
	#     the Constructor domains of enum replication specs)
	#
	# 3. Once VALUE_IN_API and VALCON_IN_API are converted to use typspec instead of ty::type
	#    the whole thing can be further cleaned up.
	#	
	also
        Api_Element								# Referent for:   Api_Record.elements   Api_Elements
	  #
	  = TYP_IN_API	       { module_stamp:           sta::Stamp,
					 typ:       		 ty::Typ,
					 is_a_replica:           Bool,
					 scope:                  Int
				       }
	  | PACKAGE_IN_API             { module_stamp:           sta::Stamp,
					 an_api:                 Api,
					 definition:             Null_Or( (Package_Definition, Int) ),
					 slot:                   Int
				       }
	  | GENERIC_IN_API             { module_stamp:           sta::Stamp,
					 a_generic_api:          Generic_Api,
					 slot:                   Int
				       }
	  | VALUE_IN_API               { type:                   ty::Type,
					 slot:                   Int
				       }
	  | VALCON_IN_API    { datatype:             ty::Valcon,
					 slot:                   Null_Or( Int )
				       }

	also
	Generic_Api
            =   
	    GENERIC_API  {   kind:                Null_Or( sy::Symbol ),
			     parameter_api:  	  Api,
			     parameter_variable:  sta::Stamp,
			     parameter_symbol:    Null_Or( sy::Symbol ),
			     body_api:       	  Api
			 }
	    | ERRONEOUS_GENERIC_API
	    #
	    # Generic_api is the referent for:
	    #
	    #     symbolmapstack_entry::Symbolmapstack_Entry.NAMED_GENERIC_API

	also
        External_Definition
            =
	    EXTERNAL_DEFINITION_OF_TYP
	      {            
	        extdef_path:		syp::Symbol_Path,
		extdef_typ:		ty::Typ,
		extdef_is_relative:	Bool         #  Does typ contain typechecked_package paths? 
	      }

	    | EXTERNAL_DEFINITION_OF_PACKAGE  (syp::Symbol_Path, Package_Definition)

	also
        Package_Definition
	    = CONSTANT_PACKAGE_DEFINITION  Package  #  Constant
	    | VARIABLE_PACKAGE_DEFINITION  (Api, mp::Stamppath) #  relative 

	#  ------------------------- packages and generics ---------------------- 

	also
        Package
	    = A_PACKAGE  Package_Record
	    | PACKAGE_API  { stamppath:  mp::Stamppath,
                             an_api:     Api
                           }
	    | ERRONEOUS_PACKAGE
	    #
	    # Package is the referent for:
	    #
	    #     symbolmapstack_entry::Symbolmapstack_Entry.NAMED_PACKAGE
	

	also
	Generic
	    = GENERIC  Generic_Record
	    | ERRONEOUS_GENERIC
	    #
	    # Generic is the referent for:
	    #
	    #     symbolmapstack_entry::Symbolmapstack_Entry.NAMED_GENERIC

	#  ----------------------- typechecked_package-related definitions -------------------- 

	also
        Typerstore_Entry							# Elements of a Typerstore.
	  #
	  = TYP_ENTRY		Typechecked_Typ
	  | PACKAGE_ENTRY		Typechecked_Package
	  | GENERIC_ENTRY		Typechecked_Generic
	  | ERRONEOUS_ENTRY
	  #
	  # We have no Typerstore_Entry variants yet for
	  # values, constructors or exceptions,
	  # but this may change.

	also
	Generic_Closure								# Typechecked_Package for generics 
	  #
	  = GENERIC_CLOSURE
	      {
		parameter_module_stamp:		sta::Stamp,
	        body_package_expression:	Package_Expression,
	        typerstore:			Typerstore
	      }

	also
        Stamp_Expression
	  #
	  = GET_STAMP  Package_Expression
	  | MAKE_STAMP								# Generate a new stamp.
#	  | CONST of sta::Stamp							# An existing stamp 

	also
        Typechecked_Typ_Expression						# Expression evaluating to a type constructor Typechecked_Package 
	  = TYPE_VARIABLE_TYP    mp::Stamppath   				# Selection from cur-EE 
	  | CONSTANT_TYP	    ty::Typ					# Actual typ 
	  | FORMAL_TYP	    ty::Typ					# Formal typ 

	also
        Package_Expression 
	  = VARIABLE_PACKAGE		    mp::Stamppath			# Selection from current Typerstore.
	  | CONSTANT_PACKAGE		    Typechecked_Package
	  | PACKAGE  { stamp:		    Stamp_Expression,
		       module_declaration:  Module_Declaration
		     }
	  | APPLY  (Generic_Expression, Package_Expression)			# The arg Package_Expression contains coercions to match the generic's parameter sig 
	  | PACKAGE_LET  { declaration:	    Module_Declaration,
                           expression:	    Package_Expression
                         }
	  | ABSTRACT_PACKAGE  (Api, Package_Expression)				# Shortcut for abstraction matching.
	  | FORMAL_PACKAGE  Generic_Api						# Formal generic body package.
	  | COERCED_PACKAGE  { boundvar:    sta::Stamp,
			       raw:         Package_Expression,
			       coercion:    Package_Expression
			     }
		# Similar to PACKAGE_LET (m::PACKAGE_DECLARATION (boundvar, Package_Expression), coercion),
		# but with special treatment of inverse_path propagation to support
		# accurate type names in generic results where the generic has
		# a result api constraint.



	also
        Generic_Expression
	  #
	  = VARIABLE_GENERIC  mp::Stamppath #  selection from current Typerstore 
	  | CONSTANT_GENERIC  Typechecked_Generic
	  | LAMBDA            { parameter:   sta::Stamp,	body:  Package_Expression }
	  | LAMBDA_TP         { parameter:   sta::Stamp,	body:  Package_Expression,	an_api:  Generic_Api }
	  | LET_GENERIC       (Module_Declaration, Generic_Expression)



	also
        Module_Expression 
	  #
	  = TYP_EXPRESSION  		Typechecked_Typ_Expression
	  | PACKAGE_EXPRESSION          Package_Expression
	  | GENERIC_EXPRESSION          Generic_Expression
	  | DUMMY_GENERIC_EVALUATION_EXPRESSION
	  | ERRONEOUS_ENTRY_EXPRESSION



	also
        Module_Declaration 
	  #
	  = TYP_DECLARATION			(sta::Stamp, Typechecked_Typ_Expression)
	  | PACKAGE_DECLARATION			(sta::Stamp, Package_Expression, sy::Symbol)
	  | GENERIC_DECLARATION			(sta::Stamp, Generic_Expression)
	  | SEQUENTIAL_DECLARATIONS		List( Module_Declaration )
	  | LOCAL_DECLARATION			(Module_Declaration, Module_Declaration)
	  | ERRONEOUS_ENTRY_DECLARATION
	  | EMPTY_GENERIC_EVALUATION_DECLARATION



	also
        Typerstore 
	  #
	  = MARKED_TYPERSTORE		Typerstore_Record
	  | NAMED_TYPERSTORE		(mp::module_stamp_map::Map( Typerstore_Entry ),   Typerstore)
	  | NULL_TYPERSTORE
	  | ERRONEOUS_ENTRY_DICTIONARY



	also
        Modtree
	  #
	  = PLAIN_TYP_MODTREE_NODE	ty::Plain_Typ_Record
	  | API_MODTREE_NODE		Api_Record
	  | PACKAGE_MODTREE_NODE	Package_Record
	  #
	  | GENERIC_MODTREE_NODE	Generic_Record
	  | TYPERSTORE_MODTREE_NODE  	Typerstore_Record
	  | MODTREE_BRANCH		List( Modtree )



	withtype
        Stub_Info
	  =
	  { owner:			ph::Picklehash,
	    is_lib:			Bool,
	    modtree:			Modtree
	  }



	also
        Api_Record								# 'Api_Record' is the referent for   stampmapstack::Stampmapstack.api_map
	  =
	  { stamp:			sta::Stamp,
	    name:			Null_Or( sy::Symbol ),
	    closed:			Bool,
	    #
	    contains_generic:		Bool,
	    #
	    symbols:			List( sy::Symbol ),
	    api_elements:		List( (sy::Symbol, Api_Element) ),
	    property_list:		pl::Property_List,
	    #
	    type_sharing:		List( Share_Spec ),
	    package_sharing:		List( Share_Spec ),
	    stub:			Null_Or( Stub_Info )
	  }



	also
	Typerstore_Record							# Referent of   stx::Stampmapstack.typerstore_map.   Also Typerstore.MARKED_TYPERSTORE,    Modtree.TYPERSTORE_MODTREE_NODE.
	  =
	  { stamp:			sta::Stamp,
	    typerstore:			Typerstore,
	    stub:			Null_Or( Stub_Info )
	  }



	also
        Typechecked_Package							# Referent of   stx::Stampmapstack.generic_map.    Also Typerstore_Entry.PACKAGE_ENTRY,   Package_Expression.CONSTANT_EXPRESSION.
	  =
	  { stamp:			sta::Stamp,
	    typerstore:			Typerstore,
	    property_list:		pl::Property_List,
	    #
	    inverse_path:		ip::Inverse_Path,
	    stub:			Null_Or( Stub_Info )
	  }



	also
	Typechecked_Generic							# Referent of   stx::Stampmapstack.package_map.    Also Typerstore_Entry.GENERIC_ENTRY,   Generic_Expression.CONSTANT_GENERIC.
	  =
	  { stamp:			sta::Stamp,
	    generic_closure:		Generic_Closure,
	    property_list:		pl::Property_List,			#  lambdaty 
	    #
	    typ_path:			Null_Or( ty::Typ_Path ),
	    inverse_path:		ip::Inverse_Path,
	    stub:			Null_Or( Stub_Info )
	  }



	also
        Package_Record
	  =
	  { an_api:			Api,
	    typechecked_package:	Typechecked_Package,
	    varhome:			vh::Varhome,
	    inlining_data:		id::Inlining_Data
	  }



	also
	Generic_Record
	  =
	  { a_generic_api:		Generic_Api,
	    typechecked_generic:	Typechecked_Generic, 
	    varhome:			vh::Varhome,
	    inlining_data:		id::Inlining_Data
	  }

	
	also
        Typechecked_Typ								# Referent of Typerstore_Entry.TYP_ENTRY
	  =
	  ty::Typ;									# The stamp and arith inside ty::Typ are critical.



#	also constraint  
#	  = { my_path:  syp::Symbol_Path, its_ancestor:  instrep, its_path:  syp::Symbol_Path }


        Api_Elements									# Referent for:   module_level_declarations::
	  =
	  List ((sy::Symbol, Api_Element));

	bogus_package_stamp   =   sta::make_stale_stamp  "bogus_package";
	bogus_generic_stamp   =   sta::make_stale_stamp  "bogus_g";
	bogus_api_stamp       =   sta::make_stale_stamp  "bogus_api";
	bogus_reverse_path    =   ip::INVERSE_PATH [ sy::make_package_symbol "Bogus" ];

	my bogus_typechecked_package:  Typechecked_Package
            =
	    { stamp		=>  bogus_package_stamp, 
	      typerstore	=>  ERRONEOUS_ENTRY_DICTIONARY,
	      property_list	=>  pl::make_property_list (),
	      inverse_path	=>  bogus_reverse_path,
	      stub		=>  NULL
            };

	my bogus_api:  Api
            = 
	    API { stamp            => bogus_api_stamp,
		  name             => NULL,
		  closed           => TRUE,
		  #
		  contains_generic => FALSE,
		  symbols          => [], 
		  api_elements     => [],
		  #
		  property_list    => pl::make_property_list (),
		  type_sharing     => [],
		  #
		  package_sharing  => [],
		  stub             => NULL
	      };

	my bogus_typechecked_generic:  Typechecked_Generic
            =
	    { typ_path	=> NULL,
	      #	
	      stamp		=> bogus_generic_stamp,
	      property_list	=> pl::make_property_list (),
	      #
	      inverse_path	=> bogus_reverse_path,
	      stub		=> NULL,
	      #
	      generic_closure
                  =>
                  GENERIC_CLOSURE {
                      parameter_module_stamp 	=>  mp::bogus_typechecked_package_variable,
		      body_package_expression   =>  CONSTANT_PACKAGE bogus_typechecked_package,
		      typerstore		=>  NULL_TYPERSTORE
                  }
            };
    };										# package module 
end;										# stipulate

## (C) 2001 Lucent Technologies, Bell Labs
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2012,
## released per terms of SMLNJ-COPYRIGHT.


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################
