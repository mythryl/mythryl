## prettyprint-raw-syntax.pkg
## Jing Cao and Lukasz Ziarek 

# Compiled by:
#     src/lib/compiler/front/typer/typer.sublib

# We refer to a literal dump of the raw syntax tree as "prettyprinting".
# We refer to reconstruction of surface syntax from the raw syntax tree as "unparsing".
# Unparsing is good for end-user diagnostics; prettyprinting is good for compiler debugging.
# This is the implementation of our raw syntax prettyprinter.
# For our raw syntax unparser, see  src/lib/compiler/front/typer/print/unparse-raw-syntax.pkg

# 2008-01-08 CrT: This file is a quick clone-and-tweak
#                 conversion of unparse-raw-syntax.pkg.
#
#                 It needs a lot more work to be a full
#                 prettyprinter, starting with doing the
#                 clone-and-convert dance on the unparse_type
#                 and unparse_value packages.



stipulate
    package err =  error_message;			# error_message			is from   src/lib/compiler/front/basics/errormsg/error-message.pkg
    package fxt =  fixity;				# fixity			is from   src/lib/compiler/front/basics/map/fixity.pkg
    package mld =  module_level_declarations;		# module_level_declarations	is from   src/lib/compiler/front/typer-stuff/modules/module-level-declarations.pkg
    package mtt =  more_type_types;			# more_type_types		is from   src/lib/compiler/front/typer/types/more-type-types.pkg
    package pp  =  standard_prettyprint_mill;		# standard_prettyprint_mill	is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package rs  =  raw_syntax;				# raw_syntax			is from   src/lib/compiler/front/parser/raw-syntax/raw-syntax.pkg
    package sci =  sourcecode_info;			# sourcecode_info		is from   src/lib/compiler/front/basics/source/sourcecode-info.pkg
    package sy  =  symbol;				# symbol			is from   src/lib/compiler/front/basics/map/symbol.pkg
    package tc  =  typer_control;			# typer_control			is from   src/lib/compiler/front/typer/basics/typer-control.pkg
    package tpl =  tuples;				# tuples			is from   src/lib/compiler/front/typer-stuff/types/tuples.pkg
    package uj  =  unparse_junk;			# unparse_junk			is from   src/lib/compiler/front/typer/print/unparse-junk.pkg
#   package ut  =  unparse_type;			# unparse_type			is from   src/lib/compiler/front/typer/print/unparse-type.pkg
#   package uv  =  unparse_value;			# unparse_value			is from   src/lib/compiler/front/typer/print/unparse-value.pkg
#   package vac =  variables_and_constructors;		# variables_and_constructors	is from   src/lib/compiler/front/typer-stuff/deep-syntax/variables-and-constructors.pkg

    Pp = pp::Pp;
herein


    package   prettyprint_raw_syntax
    : (weak)  Prettyprint_Raw_Syntax			# Prettyprint_Raw_Syntax	is from   src/lib/compiler/front/typer/print/prettyprint-raw-syntax.api
    {
	internals =  tc::internals;
	#
	lineprint =  REF FALSE;

	fun by f x y
            =
            f y x;

	null_fix = fxt::INFIX (0, 0);
	inf_fix  = fxt::INFIX (1000000, 100000);

	fun stronger_l (fxt::INFIX(_, m), fxt::INFIX (n, _)) => m >= n;
	    stronger_l _ => FALSE;			#  should not matter 
        end;

	fun stronger_r (fxt::INFIX(_, m), fxt::INFIX (n, _)) => n > m;
 	    stronger_r _ => TRUE; 			#  should not matter 
        end;

	fun prpos ( pp:		pp::Prettyprint_Mill,
		    source:	sci::Sourcecode_Info,
                    charpos:	Int
                  )
            =
	    if *lineprint
		#
		(sci::filepos  source  charpos)
		    ->
		    (file: String,  line: Int,  pos: Int);

		pp.lit (int::to_string line);
		pp.lit ".";
		pp.lit (int::to_string pos);
	    else
                pp.lit (int::to_string charpos);
            fi;


	fun bug msg
            =
            err::impossible("unparse_raw_syntax: " + msg);


	arrow_stamp =  mtt::arrow_stamp;


	fun strength type
            =
	    case type
		#              
		rs::TYPEVAR_TYPE(_) =>   1;
		#
		rs::TYPE_TYPE (typ, args)
		    => 
		    case typ
			#
			[typ]
			    =>
			    if (sy::eq (sy::make_type_symbol("->"), typ))   0;
			    else                                               2;
			   fi;

			_   => 2;
		    esac;


		rs::RECORD_TYPE _ => 2;

		rs::TUPLE_TYPE _ => 1;

		_ => 2;
            esac;


	fun checkpat (n, NIL)
                =>
                TRUE;

	    checkpat (n, (symbol, _) ! fields)
                =>
                sy::eq (symbol, tpl::number_to_label n)
                and
                checkpat (n+1, fields);
        end;

	fun checkexp (n, NIL)
                =>
                TRUE;

	    checkexp (n, (symbol, expression) ! fields)
		=>
		sy::eq (symbol, tpl::number_to_label n)
                and
		checkexp (n+1, fields);
        end;

	fun is_tuplepat (rs::RECORD_PATTERN { definition => [_], ...                     } ) =>  FALSE;
	    is_tuplepat (rs::RECORD_PATTERN { definition => defs, is_incomplete => FALSE } ) =>  checkpat (1, defs);
	    is_tuplepat _                                                                    =>  FALSE;
        end;

	fun is_tupleexp (rs::RECORD_IN_EXPRESSION [_])      =>   FALSE;
	    is_tupleexp (rs::RECORD_IN_EXPRESSION fields)   =>   checkexp (1, fields);
	    #
	    is_tupleexp (rs::SOURCE_CODE_REGION_FOR_EXPRESSION (a, _))       =>   is_tupleexp a;
	    is_tupleexp _ => FALSE;
        end;

	fun get_fix (dictionary, symbol)
            =
	    find_in_symbolmapstack::find_fixity_by_symbol  (
                dictionary,
                sy::make_fixity_symbol (sy::name symbol)
            );



	fun strip_source_code_region_data (rs::SOURCE_CODE_REGION_FOR_EXPRESSION (a, _))
		=>
		strip_source_code_region_data a;

	    strip_source_code_region_data x
		=>
		x;
        end;



	fun trim     [x] =>  [];
	    trim (a ! b) =>  a ! trim b;
	    trim      [] =>  [];
        end;


	fun pp_path  pp  symbols
            =
	    {   fun print_one  pp  symbol
                    =
                    uj::unparse_symbol  pp  symbol;
	    
                uj::unparse_sequence
                    pp
		    { separator =>  (fn pp =  (pp.lit "::")),	# Was "."
		      print_one,
		      breakstyle =>  uj::ALIGN
                    }
		    symbols;
	    };

	fun prettyprint_pattern (context as (dictionary, source_opt))  (pp:Pp)
            =
	    {   pp_symbol_list =   pp_path  pp;
		#
		fun prettyprint_pattern' (          rs::WILDCARD_PATTERN,       _)   =>     pp.lit           "rs::WILDCARD_PATTERN ";
		    prettyprint_pattern' (       rs::VARIABLE_IN_PATTERN  p,    d)   =>   { pp.lit        "rs::VARIABLE_IN_PATTERN ";  pp_symbol_list p; };
		    prettyprint_pattern' (   rs::INT_CONSTANT_IN_PATTERN  i,    _)   =>   { pp.lit    "rs::INT_CONSTANT_IN_PATTERN ";  pp.lit (multiword_int::to_string i); };
		    prettyprint_pattern' (   rs::UNT_CONSTANT_IN_PATTERN  w,    _)   =>   { pp.lit    "rs::UNT_CONSTANT_IN_PATTERN ";  pp.lit (multiword_int::to_string w); };
		    prettyprint_pattern' (rs::STRING_CONSTANT_IN_PATTERN  s,    _)   =>   { pp.lit "rs::STRING_CONSTANT_IN_PATTERN ";  uj::unparse_mlstring  pp s; };
		    prettyprint_pattern' (  rs::CHAR_CONSTANT_IN_PATTERN  s,    _)   =>   { pp.lit   "rs::CHAR_CONSTANT_IN_PATTERN ";   uj::unparse_mlstring' pp s;};

		    prettyprint_pattern' (rs::AS_PATTERN { variable_pattern, expression_pattern }, d)
			=>
			{   pp.box .{											pp.rulename "pprs1";
				pp.lit "rs::AS_PATTERN";
				pp.ind " ";

				prettyprint_pattern'(variable_pattern, d);
				pp.exd " ";
				pp.lit "as";
				pp.ind " ";
				prettyprint_pattern'(expression_pattern, d - 1);
			    };
			};

		    prettyprint_pattern' (rs::RECORD_PATTERN { definition => [],   is_incomplete }, _)
			=>
                        {
			    pp.box .{
				pp.lit "rs::RECORD_PATTERN";
				pp.ind " ";
				#
				if   is_incomplete      pp.lit "{... } (==incomplete)";
				else                    pp.lit "() (==complete)";
				fi;
			    };
                        };

		    prettyprint_pattern' (r as rs::RECORD_PATTERN { definition, is_incomplete }, d)
			=>
                        {
			    pp.box .{	
				pp.lit "rs::RECORD_PATTERN";
				pp.ind " ";
				if (is_tuplepat r)
				    #			        
				    uj::unparse_closed_sequence
					pp
					{ front       =>  fn pp = pp.lit "(",
					  separator   =>  fn pp = pp.txt ", ",
					  back       =>   fn pp = pp.lit ")",
					  print_one  =>   fn _ = fn (symbol, pattern) = prettyprint_pattern' (pattern, d - 1),
					  breakstyle =>  uj::ALIGN
					}
					definition;
				else
				    uj::unparse_closed_sequence
					pp
					{ front     =>  fn pp =  pp.txt "{ ",
					  separator =>  fn pp =  pp.txt ", ",
					  back      =>  fn pp =  if is_incomplete  pp.txt ", ... }";
								 else pp.txt " }";
								 fi,
					  print_one =>  fn pp =  fn (symbol, pattern) =  {   uj::unparse_symbol pp symbol;
											     pp.lit "=";
											     prettyprint_pattern' (pattern, d - 1);
											 },
					 breakstyle => uj::ALIGN
					}
					definition;
				fi;
			    };
			};

		    prettyprint_pattern' (rs::LIST_PATTERN NIL, d)
                        =>
                        pp.lit "rs::LIST_PATTERN []";

		    prettyprint_pattern' (rs::LIST_PATTERN l, d)
			=>	
			{   fun print_one _ pattern
                                =
                                prettyprint_pattern' (pattern, d - 1);

			    pp.box .{
				pp.lit "rs::LIST_PATTERN";
				pp.ind " ";
				#
				pp.box .{
				    uj::unparse_closed_sequence
					pp
					{ front      =>  fn pp =  pp.txt "[ ",
					  separator  =>  fn pp =  pp.txt ", ",
					  back       =>  fn pp =  pp.lit " ]",
					  print_one,
					  breakstyle =>  uj::ALIGN
					}
					l;
				};
			    };
			};

		    prettyprint_pattern' (rs::TUPLE_PATTERN t, d)
			=> 
			{   fun print_one _ pattern
                                =
                                prettyprint_pattern'(pattern, d - 1);

			    pp.box .{
				pp.lit "rs::TUPLE_PATTERN"; 
				pp.ind " ";
				#
				pp.box .{
				    uj::unparse_closed_sequence
					pp
					{ front      =>  fn pp =  pp.lit "(",
					  separator  =>  fn pp =  pp.txt ", ",
					  back       =>  fn pp =  pp.lit ")",
					  print_one,
					  breakstyle =>  uj::ALIGN
					}
					t;
				};
			    };
			};

		    prettyprint_pattern' (rs::PRE_FIXITY_PATTERN fap, d)
			=>
			{   fun print_one _ { item, fixity, source_code_region }
                                =
                                prettyprint_pattern'(item, d - 1);		

			    pp.box .{
				pp.lit "rs::PRE_FIXITY_PATTERN";
				pp.ind " ";
				#
				pp.box .{
				    uj::unparse_sequence
					pp
					{   separator  =>  fn pp =  pp.txt " ",
					    print_one,
					    breakstyle =>  uj::ALIGN
					}
					fap;
				};
			    };
			}; 

		    prettyprint_pattern' (rs::APPLY_PATTERN { constructor, argument }, d)
			=> 
			{
                            pp.box .{											pp.rulename "pprs2";
			        pp.lit "rs::APPLY_PATTERN";
				pp.ind " ";
				prettyprint_pattern' (constructor, d);
				pp.lit "as";
				pp.ind " ";
				prettyprint_pattern'(argument, d);
			    };
			};

		    prettyprint_pattern' (rs::TYPE_CONSTRAINT_PATTERN { pattern, type_constraint }, d)
			=> 
			{   pp.box .{													pp.rulename "lptw8";
				pp.lit "rs::TYPE_CONSTRAINT_PATTERN";
				pp.ind " ";
				prettyprint_pattern' (pattern, d - 1);
				pp.txt ": ";
				prettyprint_type context pp (type_constraint, d);
			    };
			};

		    prettyprint_pattern' (rs::VECTOR_PATTERN NIL, d)
			=>
			pp.lit "rs::VECTOR_PATTERN #[]";

		    prettyprint_pattern' (rs::VECTOR_PATTERN v, d)
			=> 
			{   fun print_one _ pattern
                                =
                                prettyprint_pattern'(pattern, d - 1);

			    pp.box .{
				pp.lit "rs::VECTOR_PATTERN";
				pp.ind " ";
				#
				uj::unparse_closed_sequence
				    pp
				    { front     =>  fn pp =  pp.lit "#[ ",
				      separator =>  fn pp =  pp.txt ", ",
				      back      =>  fn pp =  pp.lit " ]",
				      print_one,
				      breakstyle => uj::ALIGN
				    }
				    v;
			    };
			};

		    prettyprint_pattern' (rs::SOURCE_CODE_REGION_FOR_PATTERN (pattern, (s, e)), d)
			=> 
			case source_opt
			    #
			    THE source
				=>
				{
# Commented out to reduce verbosity:
#				      pp.lit "SOURCE_CODE_REGION_FOR_PATTERN [";
#				      prpos (pp, source, s); pp.lit ", ";
#				      prpos (pp, source, e); pp.lit "): ";

				     prettyprint_pattern'(pattern, d);

#                                      pp.lit "]";
				};

			    NULL => {   pp.lit "SOURCE_CODE_REGION_FOR_PATTERN []";
					pp.ind " ";
					prettyprint_pattern'(pattern, d);
				    };
			 esac;

		    prettyprint_pattern' (rs::OR_PATTERN orpat, d)
			=>
			{   fun print_one _ pattern
                                =
                                prettyprint_pattern' (pattern, d - 1);

			    pp.box .{
				pp.lit "rs::OR_PATTERN";
				pp.ind " ";
				#
				uj::unparse_closed_sequence
				    pp
				    { front      =>  fn pp =  pp.txt "( ",
				      separator  =>  fn pp =  { pp.txt " ";   pp.lit "| "; },
				      back       =>  fn pp =  pp.txt " )",
				      print_one,
				      breakstyle => uj::ALIGN
				    }
				    orpat;
			    };
			};
                end;

                prettyprint_pattern';
	    }


	also
	fun prettyprint_expression (context as (dictionary, source_opt))  (pp:Pp)
            =
	    {   fun lparen () = pp.lit "("; 
		fun rparen () = pp.lit ")";
		#
		fun lpcond atom = if atom  pp.lit "(";  fi;      
		fun rpcond atom = if atom  pp.lit ")";  fi;

		pp_symbol_list = pp_path pp;

		fun prettyprint_expression' (_, _, 0) => pp.lit "<rs::Expression>";
		    prettyprint_expression' (rs::VARIABLE_IN_EXPRESSION   p, _, _) => {   pp.lit "rs::VARIABLE_IN_EXPRESSION";     pp.ind " ";  pp_symbol_list (p); };
		    prettyprint_expression' (rs::IMPLICIT_THUNK_PARAMETER p, _, _) => {   pp.lit "rs::IMPLICIT_THUNK_PARAMETER #"; pp.ind " ";  pp_symbol_list (p); };
		    prettyprint_expression' (rs::FN_EXPRESSION NIL, _,          d) =>     pp.lit "FN_EXPRESSION NIL";

		    prettyprint_expression' (rs::FN_EXPRESSION rules, _, d)
			=>	
			{   fun print_one _ pattern
                                =
                                prettyprint_rule context pp (pattern, d - 1);

			    pp.box .{
				pp.lit "rs::FN_EXPRESSION";
				pp.ind " ";
				#
				uj::unparse_sequence
				    pp
				    { separator  =>  fn pp =  pp.txt "| ",
				      print_one,
				      breakstyle =>  uj::ALIGN
				    }
				    rules;
			    };
			};

		    prettyprint_expression' (rs::PRE_FIXITY_EXPRESSION fap, _, d)
			=> 
			{   fun print_one _ { item, fixity, source_code_region }
                                =
                                prettyprint_expression'(item, TRUE, d);		

			    pp.box .{	
				pp.lit "rs::PRE_FIXITY_EXPRESSION [";
				pp.ind " ";

				uj::unparse_sequence
				    pp
				    { separator  =>  fn pp =  pp.txt " ",
				      print_one,
				      breakstyle =>  uj::ALIGN
				    }
				    fap;

				pp.exd " ";
				pp.lit "]";
			    };
			}; 

		    prettyprint_expression' (e as rs::APPLY_EXPRESSION _, atom, d)
			=>
			{
			    pp.box .{
				pp.lit "rs::APPLY_EXPRESSION";
				pp.ind " ";
				#
				infix0 = fxt::INFIX (0, 0);

				lpcond atom;
				prettyprint_app_expression (e, null_fix, null_fix, d);
				rpcond atom;
			    };
			};

		    prettyprint_expression' (rs::OBJECT_FIELD_EXPRESSION { object, field }, atom, d)
			=>
			{   pp.box .{
				pp.lit "rs::OBJECT_FIELD_EXPRESSION";
				pp.ind " ";
				prettyprint_expression'(object, TRUE, d - 1);
				pp.txt "-> ";
				uj::unparse_symbol pp field;
			    };
			};

		    prettyprint_expression' (rs::CASE_EXPRESSION { expression, rules }, _, d)
			=> 
			{   pp.box .{											pp.rulename "pprs3";
				pp.lit "rs::CASE_EXPRESSION";
                                pp.lit "case ";
				pp.ind " ";
				prettyprint_expression'(expression, TRUE, d - 1);
				pp.newline ();

				uj::ppvlist pp (
				    "",
				    ";",		# Was "   | ",
				    (fn pp =  fn r =  prettyprint_rule context pp (r, d - 1)),
				    trim rules
				);
				pp.exd " ";
				pp.lit "esac;";
			    };
			};

		    prettyprint_expression' (rs::LET_EXPRESSION { declaration, expression }, _, d)
			=>
			{   pp.box .{											pp.rulename "pprs4";
				pp.lit "rs::LET_EXPRESSION";
				pp.txt " ";
                                pp.lit "stipulate ";
				pp.ind " ";
				pp.box .{										pp.rulename "pprs5";
					prettyprint_declaration context pp (declaration, d - 1); 
				};
				pp.exd " ";
				pp.lit "herein";
				pp.ind " ";
				pp.box .{										pp.rulename "pprs6";
				    prettyprint_expression'(expression, FALSE, d - 1);
				};
				pp.exd " ";
				pp.lit "end";
			    };
			};

		    prettyprint_expression' (rs::SEQUENCE_EXPRESSION exps, _, d)
			=>
                        {
			    pp.lit "rs::SEQUENCE_EXPRESSION";
			    pp.ind " ";
			    #
			    uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp =  {  pp.lit    "{";   pp.ind " ";                  },
				  separator  =>  fn pp =  {  pp.endlit ";";   pp.txt "   ";                },
				  back       =>  fn pp =  {  pp.endlit ";";   pp.exd " ";      pp.lit "}"; },
				  #
				  print_one  =>  fn _ = fn expression = prettyprint_expression' (expression, FALSE, d - 1),
				  breakstyle =>  uj::ALIGN
				}
				exps;
                        };

		    prettyprint_expression' (   rs::INT_CONSTANT_IN_EXPRESSION   i, _, _)   =>   pp.box .{ pp.lit    "rs::INT_CONSTANT_IN_EXPRESSION";  pp.ind " ";  pp.lit (multiword_int::to_string i); };
		    prettyprint_expression' (   rs::UNT_CONSTANT_IN_EXPRESSION   w, _, _)   =>   pp.box .{ pp.lit "   rs::UNT_CONSTANT_IN_EXPRESSION";  pp.ind " ";  pp.lit (multiword_int::to_string w); };
		    prettyprint_expression' ( rs::FLOAT_CONSTANT_IN_EXPRESSION   r, _, _)   =>   pp.box .{ pp.lit  "rs::FLOAT_CONSTANT_IN_EXPRESSION";  pp.ind " ";  pp.lit r; };
		    prettyprint_expression' (rs::STRING_CONSTANT_IN_EXPRESSION   s, _, _)   =>   pp.box .{ pp.lit "rs::STRING_CONSTANT_IN_EXPRESSION";  pp.ind " ";  uj::unparse_mlstring  pp s; };
		    prettyprint_expression' (  rs::CHAR_CONSTANT_IN_EXPRESSION   s, _, _)   =>   pp.box .{ pp.lit   "rs::CHAR_CONSTANT_IN_EPXRESSION";  pp.ind " ";  uj::unparse_mlstring' pp s; };

		    prettyprint_expression'(r as rs::RECORD_IN_EXPRESSION fields, _, d)
			=>
                        pp.box .{   

			    pp.lit "rs::RECORD EXPRESSION";
			    pp.ind " ";	
			    #
			    if (is_tupleexp r)
				#			        
				uj::unparse_closed_sequence
				    pp
				    { front      =>  fn pp =  pp.lit "(",
				      separator  =>  fn pp =  pp.txt ", ",
				      back       =>  fn pp =  pp.lit ")",
				      print_one  =>  fn _ = fn (_, expression) = prettyprint_expression'(expression, FALSE, d - 1),
				      breakstyle =>  uj::ALIGN
				    }
				    fields;
			    else
				uj::unparse_closed_sequence
				    pp
				    { front     =>  fn pp =  pp.txt "{ ",
				      separator =>  fn pp =  pp.txt ", ",
				      back      =>  fn pp =  pp.txt " }",
				      print_one =>  (fn pp = fn (name, expression)
							      =
							      pp.box .{
								  uj::unparse_symbol pp name;
								  pp.ind " ";
								  pp.txt "= ";
								  prettyprint_expression'(expression, FALSE, d);
							      }
						),
				      breakstyle =>  uj::ALIGN
				    }
				    fields;
			    fi;
			};

		    prettyprint_expression' (rs::LIST_EXPRESSION p, _, d)
			=> 
			pp.box .{
			    pp.lit "rs::LIST_EXPRESSION";
			    pp.ind " ";
			    #
			    uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp =  pp.txt "[ ",
				  separator  =>  fn pp =  pp.txt ", ",
				  back       =>  fn pp =  pp.txt " ]",
				  print_one  =>  fn pp = fn expression =  prettyprint_expression' (expression, FALSE, d - 1),
				  breakstyle =>  uj::ALIGN
				}
				p;
			};

		    prettyprint_expression' (rs::TUPLE_EXPRESSION p, _, d)
			=>
			pp.box .{
			    pp.lit "rs::TUPLE_EXPRESSION";
			    pp.ind " ";
			    #
			    uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp =  pp.txt "( ",
				  separator  =>  fn pp =  pp.txt ", ",
				  back       =>  fn pp =  pp.txt " )",
				  print_one  =>  fn pp = fn expression =  prettyprint_expression' (expression, FALSE, d - 1),
				  breakstyle =>  uj::ALIGN
				}
				p;
			};

		    prettyprint_expression' (rs::RECORD_SELECTOR_EXPRESSION name, atom, d)
			=>
			{   pp.box .{											pp.rulename "pprs7";
				pp.txt "rs::RECORD_SELECTOR_EXPRESSION(";
				pp.ind " ";
				lpcond atom;
				uj::unparse_symbol pp name;
				rpcond atom;
				pp.exd " ";
				pp.lit ")";
			    };
			};

		    prettyprint_expression' (rs::TYPE_CONSTRAINT_EXPRESSION { expression, constraint }, atom, d)
			=> 
			{   pp.box .{													pp.rulename "lptw9";
				pp.lit "rs::TYPE_CONSTRAINT_EXPRESSION";
				pp.ind " ";
				lpcond atom;
				prettyprint_expression' (expression, FALSE, d);
				pp.txt ": ";
				prettyprint_type context pp (constraint, d);
				rpcond atom;
			    };
			};

		    prettyprint_expression' (rs::EXCEPT_EXPRESSION { expression, rules }, atom, d)
			=>
			{   pp.box .{											pp.rulename "pprs8";
				pp.lit "rs::EXCEPT_EXPRESSION";
				pp.ind " ";
				lpcond atom;
				prettyprint_expression'(expression, atom, d - 1);
				pp.txt " ";
				pp.lit "except ";
				pp.box .{
				    uj::ppvlist pp (
					"  ",
					"; ",			# Was "| ",
					(fn pp =  fn r =  prettyprint_rule context pp (r, d - 1)),
					rules
				    );
				};
				rpcond atom;
			    };
			};

		    prettyprint_expression' (rs::RAISE_EXPRESSION expression, atom, d)
			=> 
			{   pp.box .{											pp.rulename "pprs9";
				pp.lit "rs::RAISE_EXPRESSION";
				pp.ind " ";
				lpcond atom;
				pp.lit "raise exception ";
				prettyprint_expression'(expression, TRUE, d - 1);
				rpcond atom;
			    };
			};

		    prettyprint_expression' (rs::IF_EXPRESSION { test_case, then_case, else_case }, atom, d)
			=>
			{   pp.box .{											pp.rulename "pprs10";
				pp.lit "rs::IF_EXPRESSION";
				pp.ind " ";
                        	lpcond atom;
				pp.lit "if (";
				pp.box .{										pp.rulename "pprs11";
				    prettyprint_expression' (test_case, FALSE, d - 1);
				};
				pp.txt ") ";
				pp.box .{										pp.rulename "pprs12";
				    prettyprint_expression' (then_case, FALSE, d - 1);
				};
				pp.exd " ";
				pp.txt "else";
				pp.ind " ";
				pp.box .{										pp.rulename "pprs13";
				    prettyprint_expression' (else_case, FALSE, d - 1);
				};
				pp.exd " ";
				pp.txt "fi";
				rpcond atom;
			    };
			};

		    prettyprint_expression' (rs::AND_EXPRESSION (e1, e2), atom, d)
			=>
			{   pp.box .{											pp.rulename "pprs14";
				pp.lit "rs::AND_EXPRESSION";
				pp.ind " ";
				lpcond atom;
				pp.box .{										pp.rulename "pprs15";
				    prettyprint_expression' (e1, TRUE, d - 1);
				};
				pp.txt " and ";
				pp.box .{										pp.rulename "pprs16";
				    prettyprint_expression' (e2, TRUE, d - 1);
				};
				rpcond  atom;
			    };
			 };

		    prettyprint_expression' (rs::OR_EXPRESSION (e1, e2), atom, d)
			=>
			{   pp.box .{											pp.rulename "pprs17";
				pp.lit "rs::OR_EXPRESSION";
				pp.ind " ";
				lpcond atom;
				pp.box .{										pp.rulename "pprs18";
				    prettyprint_expression' (e1, TRUE, d - 1);
				};
				pp.txt " or ";
				pp.box .{										pp.rulename "pprs19";
				    prettyprint_expression' (e2, TRUE, d - 1);
				};
				rpcond  atom;
			    };
			};

		    prettyprint_expression' (rs::WHILE_EXPRESSION { test, expression }, atom, d)
			=>
			{   pp.box .{											pp.rulename "pprs20";
				pp.lit "rs::WHILE_EXPRESSION";
				pp.ind " ";

				pp.lit "for (";
				pp.box .{										pp.rulename "pprs21";
				    prettyprint_expression'(test, FALSE, d - 1);
				};
				pp.txt ") ";
				pp.box .{										pp.rulename "pprs22";
				    prettyprint_expression'(expression, FALSE, d - 1);
				};
			    };
			};

		    prettyprint_expression' (rs::VECTOR_IN_EXPRESSION NIL, _, d)
			=>
			pp.lit "rs::VECTOR_IN_EXPRESSION NIL ";

		    prettyprint_expression' (rs::VECTOR_IN_EXPRESSION exps, _, d)
			=>
			{   fun print_one _ expression
				=
				prettyprint_expression'(expression, FALSE, d - 1);

			    pp.box .{
				pp.lit "rs::VECTOR EXPRESSION";
				pp.ind " ";
				#	
				uj::unparse_closed_sequence
				    pp
				    { front      =>  fn pp =  pp.txt "#[ ",
				      separator  =>  fn pp =  pp.txt ", ",
				      back       =>  fn pp =  pp.txt " ]",
				      print_one,
				      breakstyle =>  uj::ALIGN
				    }
				    exps;
			    };
			};

		    prettyprint_expression' (rs::SOURCE_CODE_REGION_FOR_EXPRESSION (expression, (s, e)), atom, d)
			=>
			case source_opt
			    #
			    THE source
				=>
				{
# Commented out to reduce verbosity:
#				     pp.lit "rs::SOURCE_CODE_REGION_FOR_EXPRESSION [ ";
#				     prpos (pp, source, s); pp.lit ", ";
#				     prpos (pp, source, e); pp.lit "): ";
				     prettyprint_expression'(expression, FALSE, d);
#				     pp.lit " ] ";
				};

			    NULL =>
				{
# Commented out to reduce verbosity:
#				     pp.lit "rs::SOURCE_CODE_REGION_FOR_EXPRESSION [ ";
				     prettyprint_expression'(expression, atom, d);
#                                    pp.lit " ] "; 
				};
			esac;
                   end 

		    also
		    fun prettyprint_app_expression (_, _, _, 0)
			    =>
			    pp.lit "<expression>";

			prettyprint_app_expression arg
			    =>
			    {   fun fixitypp (name, operand, left_fix, right_fix, d)
				    =
				    {   dname = symbol_path::to_string (symbol_path::SYMBOL_PATH name);
					#
					this_fix =  case name
							[id] =>  get_fix (dictionary, id);
							   _ =>  fxt::NONFIX;
						    esac;

					fun pr_non  expression
					    =
					    {   pp.box .{													pp.rulename "pprscw1";
						    pp.lit dname;
						    pp.txt " ";
						    prettyprint_expression'(expression, TRUE, d - 1);
						};
					    };

					case this_fix
					    #
					    fxt::INFIX _ =>  case (strip_source_code_region_data operand)
							    #						  	
							    rs::RECORD_IN_EXPRESSION [(_, pl), (_, pr)]
								=>
								{   atom =   stronger_l (left_fix, this_fix)
									 or  stronger_r (this_fix, right_fix);

								    my (left, right)
									=
									atom  ??  (null_fix, null_fix)
									      ::  (left_fix, right_fix);

								    {   pp.box .{										pp.rulename "pprscw2";
									    lpcond atom;
									    prettyprint_app_expression (pl, left, this_fix, d - 1);
									    pp.txt " ";
									    pp.lit dname;
									    pp.txt " ";
									    prettyprint_app_expression (pr, this_fix, right, d - 1);
									    rpcond atom;
									};
								    };
								};

						    e' => pr_non e';
						esac;

					   fxt::NONFIX => pr_non operand;
				       esac;
				    };

				fun apply_print (_, _, _, 0)
					=>
					pp.lit "#";

				    apply_print (rs::APPLY_EXPRESSION { function=>operator, argument=>operand }, l, r, d)
					=>
					case (strip_source_code_region_data operator)
					    #
					    rs::VARIABLE_IN_EXPRESSION v
						=>
						{   path = v;
						    #
						    fixitypp (path, operand, l, r, d);
						};

					    operator
						=>
						{   pp.box .{													pp.rulename "pprscw3";
							prettyprint_expression'(operator, TRUE, d - 1);   pp.txt " ";
							prettyprint_expression'(operand,  TRUE, d - 1);
						    };
						};
					esac;


				    apply_print (rs::SOURCE_CODE_REGION_FOR_EXPRESSION (expression, (s, e)), l, r, d)
					=>
					case source_opt
					    #
					    THE source
						=>
						{
# Commented out to reduce verbosity:
#						    pp.lit "SOURCE_CODE_REGION_FOR_EXPRESSION [ ";
#						    prpos (pp, source, s); pp.lit ", ";
#						    prpos (pp, source, e); pp.lit "): ";
						    prettyprint_expression'(expression, FALSE, d);
#						    pp.lit " ] ";

						};

					    NULL => apply_print (expression, l, r, d);
					esac;

				   apply_print (e, _, _, d)
				    =>
				    prettyprint_expression'(e, TRUE, d); end;

				apply_print arg;
			    };
                end;
	    
                fn (expression, depth)
                    =
                    prettyprint_expression' (expression, FALSE, depth);
	    }

	also
	fun prettyprint_rule (context as (dictionary, source_opt)) pp (rs::CASE_RULE { pattern, expression }, d)
            =
	    if (d == 0) 
                pp.lit "<rs::CASE_RULE>";
	    else
		pp.box .{											pp.rulename "pprs23";
		    pp.lit "rs::CASE_RULE";
		    pp.ind " ";
		    prettyprint_pattern context pp (pattern, d - 1);
		    pp.lit " =>";
		    pp.txt " ";
		    prettyprint_expression context pp (expression, d - 1);
		};
            fi

	also
	fun prettyprint_package_expression (context as (_, source_opt)) pp
            =
	    {   pp_symbol_list = pp_path pp;
		#
		fun prettyprint_package_expression'(_, 0)
			=>
			pp.lit "<package_expression>";

		    prettyprint_package_expression' (rs::PACKAGE_BY_NAME p, d)
			=>
			pp.box .{
			    pp.lit "rs::PACKAGE_BY_NAME";
			    pp.ind " ";
			    pp_symbol_list (p);
			};

		    prettyprint_package_expression' (rs::PACKAGE_DEFINITION (rs::SEQUENTIAL_DECLARATIONS NIL), d)
			=>
			pp.box .{
			    pp.lit "rs::PACKAGE_DEFINITION (rs::SEQUENTIAL_DECLARATIONS_NIL)";
			    pp.txt " ";
			    pp.lit "end";
			};

		    prettyprint_package_expression' (rs::PACKAGE_DEFINITION de, d)
			=>
			pp.box .{   
			    pp.lit "rs::PACKAGE_DEFINITION {";
			    pp.ind " ";

			    prettyprint_declaration context pp (de, d - 1);

			    pp.exd " ";
			    pp.lit "}";
			};

		    prettyprint_package_expression' (rs::PACKAGE_CAST (stre, constraint), d)
			=>
			{   pp.box .{													pp.rulename "lptw10";

				pp.lit "rs::PACKAGE_CAST";
				pp.ind " ";

				prettyprint_package_expression' (stre, d - 1);

				case constraint
				    #
				    rs::NO_PACKAGE_CAST
					=>
					pp.lit "rs::NO_PACKAGE_CAST ";

				    rs::WEAK_PACKAGE_CAST api_expression
					=> 
					{   pp.txt "rs::WEAK_PACKAGE_CAST:";
					    pp.ind " ";
					    prettyprint_api_expression context pp (api_expression, d - 1);
					};

				    rs::PARTIAL_PACKAGE_CAST api_expression
					=> 
					{   pp.txt "rs::PARTIAL_PACKAGE_CAST:";
					    pp.ind " ";
					    prettyprint_api_expression context pp (api_expression, d - 1);
					};

				    rs::STRONG_PACKAGE_CAST api_expression
					=> 
					{   pp.txt "rs::STRONG_PACKAGE_CAST:";
					    pp.ind " ";
					    prettyprint_api_expression context pp (api_expression, d - 1);
					};
				esac;
			    };	
			};

		    prettyprint_package_expression' (rs::CALL_OF_GENERIC (path, str_list), d)
			=> 
			{   fun print_one pp (strl, bool)
				=
				{   pp.lit "(";
				    prettyprint_package_expression context pp (strl, d);
				    pp.lit ")";
				};

			    pp.box .{
				pp.lit "rs::CALL_OF_GENERIC";
				pp.ind " ";
				pp_symbol_list  path;

				uj::unparse_sequence
				    pp
				    { separator  =>  fn pp =  pp.txt " ",
				      print_one,
				      breakstyle =>  uj::ALIGN
				    }
				    str_list;
			    };	
			};	

		    prettyprint_package_expression' (rs::INTERNAL_CALL_OF_GENERIC (path, str_list), d)
			=> 
			{   fun print_one pp (strl, bool)
				=
				  {   pp.lit "(";
				      prettyprint_package_expression context pp (strl, d);
				      pp.lit ")";
				  };

			    pp.box .{
				pp.lit "rs::INTERNAL_CALL_OF_GENERIC";
				pp.ind " ";

				pp_symbol_list path;

				uj::unparse_sequence
				    pp
				    { separator  =>  fn pp =  pp.txt " ",
				      print_one,
				      breakstyle =>  uj::ALIGN
				    }
				    str_list;
			    };
			};	

		    prettyprint_package_expression' (rs::LET_IN_PACKAGE (declaration, body), d)
			=>
			pp.box .{
			    pp.lit "rs::LET_IN_PACKAGE[";
			    pp.ind " ";

			    prettyprint_declaration context pp (declaration, d - 1); 

			    pp.exd " ";
			    pp.lit ";LET_IN_PACKAGE";
			    pp.ind " ";
			    pp.newline();

			    prettyprint_package_expression'(body, d - 1);

			    pp.exd " ";
			    pp.lit "]";
			};

		    prettyprint_package_expression' (rs::SOURCE_CODE_REGION_FOR_PACKAGE (body, (s, e)), d)
			=>
			{
# Commented out to reduce verbosity:
#			     pp.lit "rs::SOURCE_CODE_REGION_FOR_PACKAGE (...) ";
			    prettyprint_package_expression' (body, d);
			};
                end;

	/*	      (case source_opt
			of THE source =>
			   (pp.lit "rs::SOURCE_CODE_REGION_FOR_PACKAGE(";
			      prettyprintPackageexpression'(body, d); pp.lit ", ";
			      prpos (pp, source, s); pp.lit ", ";
			      prpos (pp, source, e); pp.lit ")")
			 | NULL => prettyprintPackageexpression'(body, d))
	*/
	    
		prettyprint_package_expression';
	    }

	also
	fun prettyprint_generic_expression (context as (_, source_opt)) pp
            =
	    {   pp_symbol_list = pp_path pp;

		fun prettyprint_generic_expression'(_, 0)
                        =>
                        pp.lit "<generic_expression>";

		    prettyprint_generic_expression' (rs::GENERIC_BY_NAME (p, _), d)
                        =>
                        pp.box .{
			    #
			    pp.lit "rs::GENERIC_BY_NAME";
			    pp.ind " ";
                            pp_symbol_list p;
                        };

		    prettyprint_generic_expression'(rs::LET_IN_GENERIC (declaration, body), d)
			=>
			pp.box .{											pp.rulename "pprs27";
			    pp.lit "rs::LET_IN_GENERIC";
			    pp.ind " ";
                            pp.box .{
				pp.lit "stipulate";
				pp.ind " ";
				prettyprint_declaration context pp (declaration, d - 1); 
				pp.exd " ";
				pp.lit "herein";
				pp.ind " ";
				prettyprint_generic_expression'(body, d - 1);
				pp.exd " ";
				pp.lit "end";
			    };
			};

		    prettyprint_generic_expression' (rs::CONSTRAINED_CALL_OF_GENERIC (path, sblist, fsigconst), d)
			=>
			pp.box .{											pp.rulename "pprs28";
			    #
                            fun print_one pp (package_expression, _)
				=
				{   pp.lit "(";
				    prettyprint_package_expression context pp (package_expression, d);
				    pp.lit ")";
				};

			    pp.lit "rs::CONSTRAINED_GENERIC";
			    pp.ind " ";

			    pp_symbol_list path;

			    uj::unparse_sequence
				pp
				{ separator =>  fn pp =  pp.txt " ",
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				sblist;
			};

		    prettyprint_generic_expression' (rs::SOURCE_CODE_REGION_FOR_GENERIC (body, (s, e)), d)
			=>
                        {   pp.lit "rs::SOURCE_CODE_REGION_FOR_GENERIC (...) ";
			    #
			    prettyprint_generic_expression' (body, d);
                        };


		    prettyprint_generic_expression' (rs::GENERIC_DEFINITION _, d)
			=>
                        {   pp.lit "rs::GENERIC DEFINITION <- NOT LEGAL HERE!! ";
                        };
                end;
	    
		prettyprint_generic_expression';
	    }

	also
	fun prettyprint_where_spec (context as (dictionary, source_opt))  (pp:Pp)
            =
	    prettyprint_where_spec'
	    where	
	        fun prettyprint_where_spec'(_, 0)
                        =>
                        pp.lit "<WhereSpec>";


		    prettyprint_where_spec' (rs::WHERE_TYPE([],[], type), d)
                        =>
                        pp.box .{
			    #
			    pp.lit "rs::WHERE TYPE";
			    pp.txt " ";
                            prettyprint_type context pp (type, d);
                        };

		    prettyprint_where_spec' (rs::WHERE_TYPE (slist, tvlist, type), d)
			=> 
			pp.box .{
			    #
                            fun print_one _ symbol
				=
				uj::unparse_symbol pp symbol;

			    fun print_one' _ tyv
				=
				prettyprint_typevar context pp (tyv, d);

			    pp.txt "rs::WHERE_TYPE ";
			    pp.lit "typeX";
			    pp.ind " ";	

			    uj::unparse_sequence
				pp
				{ separator =>  fn pp =  pp.txt " ",
				  print_one =>  print_one',
				  breakstyle =>  uj::ALIGN
				}
				tvlist;

			    pp.txt " ";

			    uj::unparse_sequence
				pp
				{ separator  =>  fn pp =  pp.txt " ",
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				slist;	 

			    pp.exd " ";
			    pp.lit"=";
			    pp.ind " ";

			    prettyprint_type context pp (type, d);
			};

		    prettyprint_where_spec' (rs::WHERE_PACKAGE (slist, slist'), d)
			=>
			pp.box .{
			    #
                            fun print_one _ symbol
				=
				uj::unparse_symbol pp symbol;

			    pp.lit "rs::WHERE_PACKAGE";
			    pp.ind " ";
			    pp.txt "packageZ ";

			    uj::unparse_sequence
				pp
				{ separator  =>  fn pp =  pp.txt " ",
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				slist;

			    pp.txt " ";

			    uj::unparse_sequence
				pp
				{ separator  =>  fn pp =  pp.txt " ",
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				slist';
			};
                end;
	    end

	also
	fun prettyprint_api_expression (context as (dictionary, source_opt)) pp
            =
	    prettyprint_api_expression'
	    where
	        fun prettyprint_api_expression'(_, 0)
                        =>
                        pp.lit "<api_expression>";

		    prettyprint_api_expression' (rs::API_BY_NAME s, d)
                        =>
                        pp.box .{
			    #
			    pp.lit "rs::API_BY_NAME";
			    pp.ind " ";
                            uj::unparse_symbol  pp  s;
                        }; 

		    prettyprint_api_expression' (rs::API_WITH_WHERE_SPECS (an_api, wherel), d)
			=>
			pp.box .{
			    pp.lit "rs::API_WITH_WHERE_SPECS";
			    pp.ind " ";

                            prettyprint_api_expression' (an_api, d);

			    pp.txt " ";

			    case an_api
			        #
				rs::API_BY_NAME s
				    =>
				    pp.box .{
					#
					pp.lit "rs::API_BY_NAME";
					pp.ind " ";
					uj::ppvlist pp (
					    "where ",
					    "also ",
					    (fn pp =  fn r =  prettyprint_where_spec context pp (r, d - 1)),
					    wherel
					);
				    };

				rs::SOURCE_CODE_REGION_FOR_API (rs::API_BY_NAME s, r)
				    =>
				    pp.box .{
					#
					pp.lit "rs::SOURCE_CODE_REGION_FOR_API";
					pp.ind " ";
					uj::ppvlist pp (
					    "where ",
					    "also ",
					    (fn pp =  fn r =  prettyprint_where_spec context pp (r, d - 1)),
					    wherel
					);
				    };
				_
				    =>
				    pp.box .{
				    #
				    uj::ppvlist pp (
					"where ",
					"also ",
					(fn pp =  fn r =  prettyprint_where_spec context pp (r, d - 1)),
					wherel
				    );
				};
			    esac;
			};

		    prettyprint_api_expression' (rs::API_DEFINITION [], d)
			=>	
			pp.box .{
			    pp.lit "rs::API_DEFINITION";
			    pp.ind " ";
                            pp.lit "api";
			    pp.lit " ";
			    pp.lit "end;";
			};

		    prettyprint_api_expression' (rs::API_DEFINITION specl, d)
			=> 
			pp.box .{											pp.rulename "pprs29";
			    #
                            fun print_one pp speci
                                =
                                prettyprint_specification context pp (speci, d);

			    pp.lit "rs::API_DEFINITION";
			    pp.ind " ";

			    pp.txt "api ";

			    uj::unparse_sequence
				pp
				{ separator  =>  (fn pp =  pp.newline()),
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				specl;

			    pp.exd " ";
			    pp.lit "end;";
			};

		    prettyprint_api_expression' (rs::SOURCE_CODE_REGION_FOR_API (m, r), d)
                        =>
                        pp.box .{
			    pp.lit "rs::SOURCE_CODE_REGION_FOR_API (...)";
			    pp.ind " ";
                            prettyprint_api_expression context pp (m, d);
                        };
                end;
	    end

	also
	fun prettyprint_generic_api_expression (context as (dictionary, source_opt)) pp
            =
	    prettyprint_generic_api_expression'
	    where
	        fun prettyprint_generic_api_expression'(_, 0)
                        =>
                        pp.lit "<generic_api_expression>";

		    prettyprint_generic_api_expression' (rs::GENERIC_API_BY_NAME s, d)
                        =>
                        pp.box .{
			    #
			    pp.lit "rs::GENERIC_API_BY_NAME";
			    pp.ind " ";
                            uj::unparse_symbol pp s;
                        };

		    prettyprint_generic_api_expression' (rs::GENERIC_API_DEFINITION { parameter, result }, d)
			=>
			pp.box .{
			    #
                            fun print_one pp (THE symbol, api_expression)
				    =>
				    pp.box .{
					pp.lit "(";
                                        uj::unparse_symbol pp symbol;
                                        pp.txt ": ";
					prettyprint_api_expression context pp (api_expression, d);
					pp.txt " ";
					pp.lit ")";
				    };

			        print_one pp (NULL, api_expression)
				    =>
				    pp.box .{
					pp.lit "(";
					prettyprint_api_expression context pp (api_expression, d);
                                        pp.lit ")";
                                    };
                            end;

			    pp.lit "rs::GENERIC_API_DEFINITION";
			    pp.ind " ";

			    uj::unparse_sequence
				pp
				{ separator  =>  fn pp = pp.txt " ",
				  print_one,
				  breakstyle => uj::ALIGN
				}
				parameter;

			    pp.txt " ";
			    pp.lit "=> ";
			    prettyprint_api_expression context pp (result, d);
			};

		    prettyprint_generic_api_expression' (rs::SOURCE_CODE_REGION_FOR_GENERIC_API (m, r), d)
			=>
                        pp.box .{
			    #
			    pp.lit "rs::SOURCE_CODE_REGION_FOR_GENERIC_API (...)";
			    pp.ind " ";
			    prettyprint_generic_api_expression context pp (m, d);
                        };
                end;
	    end

	also
	fun prettyprint_specification (context as (dictionary, source_opt))  (pp:Pp)
            =
	    prettyprint_specification'
	    where
		fun pp_tyvar_list ([], d)
                        =>
                        ();

		    pp_tyvar_list ( [typevar], d)
			=> 
			{   prettyprint_typevar context pp (typevar, d);
			    pp.txt " ";
			};

		    pp_tyvar_list (tyvar_list, d)
			=> 
			{   fun print_one _ (typevar)
				=
				(prettyprint_typevar context pp (typevar, d));

			    uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp =  pp.lit "(",
				  separator  =>  fn pp =  pp.txt ", ",
				  back       =>  fn pp =  pp.lit ")",
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				tyvar_list;
			};
                end;

		fun prettyprint_specification'(_, 0)
                        =>
                        pp.lit "<Specification>";

		    prettyprint_specification' (rs::PACKAGES_IN_API sspo_list, d)
			=>
			pp.box .{
			    #
			    fun print_one _ (symbol, api_expression, path)
				=
				case path
				    #				  
				    THE p => {   uj::unparse_symbol pp symbol;
						 pp.lit " = ";
						 prettyprint_api_expression context pp (api_expression, d);
						 pp.txt " ";
						 pp_path pp p;
					     };

				    NULL  => {   uj::unparse_symbol pp symbol;
						 pp.lit " = ";
						 prettyprint_api_expression context pp (api_expression, d);
					     };
				esac;

			    pp.lit "rs::PACKAGES_IN_API";
			    pp.ind " ";

			    uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp =  pp.lit "packageY ",
				  separator  =>  fn pp =  pp.txt ", ",
				  back       =>  fn pp =  pp.lit "",
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				sspo_list;
			}; 

		    prettyprint_specification' (rs::TYPES_IN_API (stto_list, bool), d)
			=> 
			pp.box .{
			    #
			    fun print_one _ (symbol, tyvar_list, tyo)
				=
				case tyo
				    #
				    THE type => {   pp_tyvar_list (tyvar_list, d);
						    uj::unparse_symbol pp symbol;
						    pp.lit " =  ";
						    prettyprint_type context pp (type, d);
						};

				    NULL =>     {    pp_tyvar_list (tyvar_list, d);
						     uj::unparse_symbol pp symbol;
						};
				esac;


			    pp.lit "rs::TYPES_IN_API";
			    pp.ind " ";

                            uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp =  pp.lit "",			# Was "type "
				  separator  =>  fn pp =  pp.txt "| ",
				  back       =>  fn pp =  pp.endlit ";",
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				stto_list;
			}; 

		    prettyprint_specification' (rs::GENERICS_IN_API sf_list, d)
			=>
			pp.box .{											pp.rulename "pprs30";
			    #
                            fun pr pp (symbol, generic_api_expression)
				=
				{   uj::unparse_symbol pp symbol;
                                    pp.lit " : ";
				    prettyprint_generic_api_expression context pp (generic_api_expression, d - 1);
				}; 

			    pp.lit "rs::GENERICS_IN_API";
			    pp.ind " ";

			    uj::ppvlist pp ("generic package ", "also ", pr, sf_list);
			}; 

		    prettyprint_specification' (rs::VALUES_IN_API st_list, d)
			=> 
			pp.box .{											pp.rulename "pprs31";
			    #
                            fun pr pp (symbol, type)
				= 
				{   uj::unparse_symbol pp symbol;
                                    pp.lit ":   ";
                                    prettyprint_type context pp (type, d);
                                }; 

			    pp.lit "rs::VALUES_IN_API";
			    pp.ind " ";

			    uj::ppvlist pp (
				"",		# Was "my ",
				"also ",
				pr, 
				st_list
			    );

			    pp.exd " ";
			    pp.endlit ";";
			}; 

		    prettyprint_specification' (rs::VALCONS_IN_API { sumtypes, with_types => [] }, d)
			=> 
			pp.box .{											pp.rulename "pprs32";
			    #
                            fun pr pp dbing
				=
				(prettyprint_sumtype context pp (dbing, d));

			    pp.lit "rs::VALCONS_IN_API";
			    pp.ind " ";

			    uj::ppvlist pp ("", "also ", pr, sumtypes);
			}; 

		    prettyprint_specification' (rs::VALCONS_IN_API { sumtypes, with_types }, d)
			=> 
			pp.box .{										pp.rulename "pprs33";
			    #
                            fun prd pp (dbing) = (prettyprint_sumtype context pp (dbing, d));
			    fun prw pp (tbing) = (prettyprint_named_type context pp (tbing, d));

			    pp.lit "rs::VALCONS_IN_API ";
			    pp.ind " ";

			    uj::ppvlist pp ("", "also ", prd, sumtypes);

			    pp.txt " ";

			    uj::ppvlist pp ("", "also ", prw, with_types);
			};

		    prettyprint_specification' (rs::EXCEPTIONS_IN_API sto_list, d)
			=> 
			pp.box .{											pp.rulename "pprs34";
			    #
                            fun pr pp (symbol, tyo)
				=
				case tyo
				    #
				    THE type => {   uj::unparse_symbol pp symbol;
						    pp.lit " : ";
						    prettyprint_type context pp (type, d);
						};

				    NULL =>     uj::unparse_symbol pp symbol;
				esac;

			    pp.lit "rs::EXCEPTIONS_IN_API";
			    pp.ind " ";

			    uj::ppvlist pp ("exception ", "also ", pr, sto_list);
			}; 

		    prettyprint_specification' (rs::PACKAGE_SHARING_IN_API paths, d)
			=> 
			pp.box .{											pp.rulename "pprs35";
			    #
			    pp.lit "rs::PACKAGE_SHARING_IN_API";
			    pp.ind " ";

			    uj::ppvlist pp ("sharing ", " = ", pp_path, paths);
			};

		    prettyprint_specification' (rs::TYPE_SHARING_IN_API paths, d)
			=> 
			pp.box .{											pp.rulename "pprs36";
			    #
			    pp.lit "rs::TYPE_SHARING_IN_API";
			    pp.ind " ";

			    uj::ppvlist pp ("sharing ", " = ", pp_path, paths);
			};

		    prettyprint_specification' (rs::IMPORT_IN_API api_expression, d)
			=>
                        pp.box .{
			    #
			    pp.lit "rs::IMPORT_IN_API";
			    pp.ind " ";

			    prettyprint_api_expression context pp (api_expression, d);
                        };

		    prettyprint_specification' (rs::SOURCE_CODE_REGION_FOR_API_ELEMENT (m, r), d)
			=>
                        pp.box .{
			    #
			    pp.lit "rs::SOURCE_CODE_REGION_FOR_API_ELEMENT";
			    pp.ind " ";

			    prettyprint_specification context pp (m, d);
                        };
                end;
	    end

	also
	fun prettyprint_declaration (context as (dictionary, source_opt)) pp
            =
            prettyprint_declaration'
	    where
	        pp_symbol_list =  pp_path  pp;
		#
		fun prettyprint_declaration'(_, 0)
                        =>
                        pp.lit "<declaration>";

		    prettyprint_declaration' (rs::VALUE_DECLARATIONS (vbs, typevars), d)
			=>
			pp.box .{											pp.rulename "pprs37";
			    pp.lit "rs::VALUE_DECLARATIONS [";
			    pp.ind " ";

			    uj::ppvlist pp (
				"",
				" ;rs::VALUE_DECLARATIONS ",
				(fn pp =  fn named_value =  prettyprint_named_value context pp (named_value, d - 1)),
				vbs
			    );

			    pp.exd " ";
                            pp.lit "]";
			};

		    prettyprint_declaration' (rs::FIELD_DECLARATIONS (fields, typevars), d)
			=>
			pp.box .{											pp.rulename "pprs38";
			    #
			    pp.lit "rs::FIELD_DECLARATIONS [";
			    pp.ind " ";

			    uj::ppvlist pp (
				"",
				" ;rs::FIELD_DECLARATIONS ",
				(fn pp =  fn named_field =  prettyprint_named_field context pp (named_field, d - 1)),
				fields
			    );

			    pp.exd " ";
			    pp.lit "]";
			};

		    prettyprint_declaration' (rs::RECURSIVE_VALUE_DECLARATIONS (rvbs, typevars), d)
			=> 
			pp.box .{											pp.rulename "pprs39";
			    #
			    pp.lit "rs::RECURSIVE_VALUE_DECLARATIONS";
			    pp.ind " ";

			    uj::ppvlist
				pp
				(   "[ ",
				    " ;rs::RECURSIVE_VALUE_DECLARATIONS ",
				    (  fn pp =
				       fn named_recursive_values =
				       prettyprint_named_recursive_values
					   context
					   pp
					   (named_recursive_values, d - 1)
				    ),
				    rvbs
				);

			    pp.exd " ";
			    pp.lit "]";
			};

		    prettyprint_declaration' (rs::FUNCTION_DECLARATIONS (fbs, typevars), d)
			=>
			pp.box .{											pp.rulename "pprs40";
			    pp.lit "rs::FUNCTION_DECLARATIONS [";
			    pp.ind " ";

			    uj::ppvlist'
				pp
				(   "",
				    " ;rs::FUNCTION_DECLARATIONS ",
				    (   fn pp =
					fn str =
					fn fb =
					prettyprint_named_function
					    context
					    pp
					    str
					    (fb, d - 1)
				    ),
				    fbs
				);

			    pp.exd " ";
			    pp.lit "]";
			};

		    prettyprint_declaration' (rs::NADA_FUNCTION_DECLARATIONS (fbs, typevars), d)
			=>
			pp.box .{											pp.rulename "pprs41";
			    #
			    pp.lit "rs::NADA_FUNCTION_DECLARATIONS";
			    pp.ind " ";

			    uj::ppvlist'
				pp
				(   "fun ",
				    "also ",
				    (   fn pp =
					fn str =
					fn fb =
					prettyprint_named_lib7function
					    context
					    pp
					    str
					    (fb, d - 1)
				    ),
				    fbs
				);
			};

		    prettyprint_declaration' (rs::TYPE_DECLARATIONS types, d)
			=>
			pp.box .{
			    #
                            fun print_one pp type
				=
				(prettyprint_named_type context pp (type, d));

			    pp.lit "rs::TYPE_DECLARATIONS [";
			    pp.ind " ";

			    uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp =  pp.lit "",	# Was "type "
				  separator  =>  fn pp =  pp.txt " ",
				  back       =>  fn pp =  pp.endlit ";",
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				types;

			    pp.exd " ";
                            pp.lit "]";
			}; 	

		    prettyprint_declaration' (rs::SUMTYPE_DECLARATIONS { sumtypes, with_types => [] }, d)
			=> 
			pp.box .{
			    #
                            fun print_one _ dbing
				=
				prettyprint_sumtype context pp (dbing, d);


			    pp.lit "rs::SUMTYPE_DECLARATIONS [";
			    pp.ind " ";

			    uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp =  pp.lit "",
				  separator  =>  fn pp =  pp.txt " ",
				  back       =>  fn pp =  pp.endlit ";",
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				sumtypes;

			    pp.exd " ";
                            pp.lit "]";
			};             

		    prettyprint_declaration' (rs::SUMTYPE_DECLARATIONS { sumtypes, with_types }, d)
			=> 
			pp.box .{											pp.rulename "pprs42";
			    #
                            fun prd pp dbing = (prettyprint_sumtype context pp (dbing, d));
			    fun prw pp tbing = (prettyprint_named_type context pp (tbing, d));

			    pp.lit "rs::SUMTYPE_DECLARATIONS [";
			    pp.ind " ";
			    #
			    uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp =  pp.lit "",
				  separator  =>  fn pp =  pp.txt " ",
				  back       =>  fn pp =  pp.endlit ";",
				  print_one  =>  prd,
				  breakstyle =>  uj::ALIGN
				}
				sumtypes;

			    pp.txt " ";

			    uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp = pp.lit "withtype ",
				  separator  =>  fn pp = pp.txt " ",
				  back       =>  fn pp = pp.lit "",
				  print_one  =>  prw,
				  breakstyle =>  uj::ALIGN
				}
				with_types;

			    pp.exd " ";
			    pp.lit "]";
			};

		    prettyprint_declaration' (rs::ABSTRACT_TYPE_DECLARATIONS { abstract_types, with_types => [], body }, d)
			=> 
			pp.box .{											pp.rulename "pprs43";
			    #
                            fun prd pp dbing = (prettyprint_sumtype context pp (dbing, d));
			    fun prw pp tbing = (prettyprint_named_type     context pp (tbing, d));

			    pp.lit "rs::ABSTRACT_TYPE_DECLARATIONS";
			    pp.ind " ";

			    uj::unparse_closed_sequence
				    pp
				    { front      =>  fn pp = pp.lit "",
				      separator  =>  fn pp = pp.txt " ",
				      back       =>  fn pp = pp.endlit ";",
				      print_one  =>  prd,
				      breakstyle =>  uj::ALIGN
				    }
				    abstract_types;

			    pp.txt " ";
			    prettyprint_declaration' (body, d);
			};

		    prettyprint_declaration' (rs::ABSTRACT_TYPE_DECLARATIONS { abstract_types, with_types, body }, d)
			=> 
			pp.box .{											pp.rulename "pprs44";
			    #
                            fun prd _ (dbing) = (prettyprint_sumtype context pp (dbing, d));
			    fun prw _ (tbing) = (prettyprint_named_type context pp (tbing, d));

			    pp.lit "rs::ABSTRACT_TYPE_DECLARATIONS";
			    pp.ind " ";

			    uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp =  pp.lit "",
				  separator  =>  fn pp =  pp.txt " ",
				  back       =>  fn pp =  pp.endlit ";",
				  print_one  =>  prd,
				  breakstyle =>  uj::ALIGN
				}
				abstract_types;

			    pp.txt " ";

			    uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp =  pp.lit "withtype ",
				  separator  =>  fn pp =  pp.txt " ",
				  back       =>  fn pp =  pp.lit "",
				  print_one  =>  prw,
				  breakstyle =>  uj::ALIGN
				}
				with_types;

			    pp.txt " ";
			    prettyprint_declaration' (body, d);
			};

		    prettyprint_declaration' (rs::EXCEPTION_DECLARATIONS ebs, d)
			=>
			pp.box .{											pp.rulename "pprs45";
 			    #
			    pp.lit "rs::EXCEPTION_DECLARATIONS [";
			    pp.ind " ";

			    (   (fn pp =  fn eb =  prettyprint_named_exception context pp (eb, d - 1)),   ebs   );	# ?? this must be a bug...

			    pp.exd " ";
			    pp.lit "]";
			};

		    prettyprint_declaration' (rs::PACKAGE_DECLARATIONS sbs, d)
			=>
			pp.box .{
			    pp.lit "rs::PACKAGE_DECLARATIONS";
			    pp.ind " ";

                            fun print_one _ sbing
				=
				prettyprint_named_package context pp (sbing, d);

			    uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp =  pp.txt "[ ",
				  separator  =>  fn pp =  pp.txt " ",
				  back       =>  fn pp =  pp.endlit ";",
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				sbs;

			    pp.exd " ";
                            pp.lit "]";
			};

		    prettyprint_declaration' (rs::GENERIC_DECLARATIONS fbs, d)
			=> 
			pp.box .{											pp.rulename "pprs46";
			    #
                            fun f pp generic_naming
				=
				prettyprint_named_generic context pp (generic_naming, d);

			    pp.lit "rs::GENERIC_DECLARATIONS";
			    pp.ind " ";

			    uj::ppvlist pp ("generic package ", "also ", f, fbs);
			};

		    prettyprint_declaration' (rs::API_DECLARATIONS sigvars, d)
			=> 
			pp.box .{											pp.rulename "pprs47";
			    #
                            fun f pp (rs::NAMED_API { name_symbol=>fname, definition=>def } )
				=>
				{   uj::unparse_symbol  pp  fname;
				    pp.newline();
                                    pp.lit "=";
				    prettyprint_api_expression context pp (def, d);
				};

				f pp (rs::SOURCE_CODE_REGION_FOR_NAMED_API (t, r))
                                    =>
                                    f pp t;
			    end;

			    pp.lit "rs::API_DECLARATIONS";
			    pp.ind " ";

			    uj::ppvlist pp ("api ", "also ", f, sigvars);	# Was "api "
			};

		    prettyprint_declaration' (rs::GENERIC_API_DECLARATIONS sigvars, d)
			=> 
			pp.box .{											pp.rulename "pprs48";
			    #
                            fun print_one pp sigv
				=
				prettyprint_generic_api_naming context pp (sigv, d);

			    pp.lit "rs::GENERIC_API_DECLARATIONS";
			    pp.ind " ";

			    uj::unparse_sequence
				pp
				{ separator  =>  pp::newline,
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				sigvars;
			};

		    prettyprint_declaration' (rs::LOCAL_DECLARATIONS (inner, outer), d)
			=>
			pp.box .{											pp.rulename "pprs49";
			    #
			    pp.lit "rs::LOCAL_DECLARATIONS";
			    pp.txt " ";
			    pp.lit "with";
			    pp.ind " ";

			    prettyprint_declaration'(inner, d - 1);

			    pp.exd " ";
			    pp.lit "do";
			    pp.ind " ";

			    prettyprint_declaration'(outer, d - 1);

			    pp.exd " ";
			    pp.lit "end;\t\t# with";
			};

		    prettyprint_declaration' (rs::SEQUENTIAL_DECLARATIONS decs, d)
			=>
			pp.box .{											pp.rulename "pprs52";

                            pp.lit "rs::SEQUENTIAL_DECLARATIONS [";
			    pp.ind " ";

			    uj::unparse_sequence
				pp
				{ separator  =>  fn pp =  pp.txt ";SEQUENTIAL_DECLARATIONS ",
				  print_one  =>  fn pp =  fn declaration =  prettyprint_declaration'(declaration, d),
				  breakstyle =>   uj::ALIGN
				}
				decs;

			    pp.exd " ";
                            pp.lit "]";
			};

		    prettyprint_declaration' (rs::INCLUDE_DECLARATIONS named_packages, d)
			=> 
			pp.box .{											pp.rulename "pprs53";
			    #
			    pp.lit "rs::INCLUDE_DECLARATIONS ";
			    pp.ind " ";

			    pp.lit "include";
			    pp.txt " ";

			    uj::unparse_sequence
				pp
				{ separator  =>  fn pp =  pp.txt " ",
				  print_one  =>  fn pp =  fn sp =  pp_symbol_list sp,
				  breakstyle =>  uj::ALIGN
				}
				named_packages;
			};

		    prettyprint_declaration' (rs::OVERLOADED_VARIABLE_DECLARATION (symbol, type, explist, extension), d)
		        =>
		        pp.box .{
			    pp.lit "rs::OVERLOADED_VARIABLE_DECLARATION";
			    pp.ind " ";

                            uj::unparse_symbol pp symbol;
                        };

		    prettyprint_declaration' (rs::FIXITY_DECLARATIONS { fixity, ops }, d)
			=>
			pp.box .{											pp.rulename "pprs54";
			    pp.lit "rs::FIXITY_DECLARATIONS";
			    pp.ind " ";

			    case fixity
				# 
				fxt::NONFIX => pp.lit "fxt::NONFIX ";

				fxt::INFIX (i, _)
				    => 
				    {   if (i % 2 == 0)	  pp.lit "fxt::INFIX ";
					else		  pp.lit "fxt::INFIXR ";
					fi;

					if (i / 2 > 0)
					    #  
					    pp.lit (int::to_string (i / 2));
					    pp.lit " ";
					fi;
				    };
			   esac;

			   uj::unparse_sequence
			       pp
			       { separator  =>  fn pp =  pp.txt " ",
				 print_one  =>  uj::unparse_symbol,
				 breakstyle =>  uj::ALIGN
			       }
			       ops;
			};

		    prettyprint_declaration' (rs::SOURCE_CODE_REGION_FOR_DECLARATION (declaration, (s, e)), d)
			=>  
			case source_opt
			    #                          
			    THE source
				 =>
				 {
# Commented out to reduce verbosity:
#				     pp.lit "rs::SOURCE_CODE_REGION_FOR_DECLARATION [ ";

				     prettyprint_declaration'(declaration, d);

#				     pp.lit ", ";
#				     prpos (pp, source, s); pp.lit ", ";
#				     prpos (pp, source, e); pp.lit " ] ";
				 };

			    NULL => {
# Commented out to reduce verbosity:
#					pp.lit "rs::SOURCE_CODE_REGION_FOR_DECLARATION <...> ";
					prettyprint_declaration' (declaration, d);
				    };
			esac;

		    prettyprint_declaration' (rs::PRE_COMPILE_CODE string, d)
			=>
			pp.lit ("rs::PRE_COMPILE_CODE \"" + string + "\"");
                  end;
	      end

	also
	fun prettyprint_named_value (context as (dictionary, source_opt)) pp
            =
	    {   fun prettyprint_named_value' (_, 0)
                        =>
                        pp.lit "<naming>";

		    prettyprint_named_value' (rs::NAMED_VALUE { pattern, expression, ... }, d)
			=> 
			pp.box .{											pp.rulename "pprs55";

			    pp.lit "rs::NAMED_VALUE [";
			    pp.ind " ";

			    prettyprint_pattern context pp (pattern, d - 1);

			    pp.exd " ";
			    pp.lit " = (NAMED_VALUE)";
			    pp.ind " ";

			    prettyprint_expression context pp (expression, d - 1);

			    pp.exd " ";	
			    pp.lit "]";
			};

		    prettyprint_named_value' (rs::SOURCE_CODE_REGION_FOR_NAMED_VALUE (named_value, source_code_region), d)
			=>
                        {
# Commented out to reduce verbosity:
#			    pp.lit "rs::SOURCE_CODE_REGION_FOR_NAMED_VALUE ";
			    prettyprint_named_value' (named_value, d);
                        };
                end;
	    
		prettyprint_named_value';
	    }

	also
	fun prettyprint_named_field (context as (dictionary, source_opt)) pp
            =
	    prettyprint_named_field'
	    where
	        fun prettyprint_named_field'(_, 0)
                        =>
                        pp.lit "<field>";

		    prettyprint_named_field' (rs::NAMED_FIELD { name, type, init }, d)
			=> 
			pp.box .{											pp.rulename "pprs57";
			    #
			    pp.lit "rs::NAMED_FIELD [";
			    pp.ind " ";

			    pp_path pp [name];

			    pp.exd " ";
                            pp.lit ": (rs::NAMED_FIELD)";
			    pp.ind " ";

			    prettyprint_type context pp (type, d);

			    pp.exd " ";
			    pp.lit "]";
			};

		    prettyprint_named_field' (rs::SOURCE_CODE_REGION_FOR_NAMED_FIELD (named_field, source_code_region), d)
			=>
                        {
# Commented out to reduce verbosity:
#			    pp.lit "rs::SOURCE_CODE_REGION_FOR_NAMED_FIELD ";
			    prettyprint_named_field' (named_field, d);
                        };
                end;
	    end

	also
	fun prettyprint_named_recursive_values (context as (_, source_opt)) pp
            = 
	    prettyprint_named_recursive_values'
	    where
	        fun prettyprint_named_recursive_values'(_, 0)=> pp.lit "<rec naming>";

		    prettyprint_named_recursive_values' (rs::NAMED_RECURSIVE_VALUE { variable_symbol, expression, ... }, d)
			=>
			pp.box .{													pp.rulename "lptw11";
			    uj::unparse_symbol pp variable_symbol;

			    pp.lit " =";
			    pp.txt " ";

			    prettyprint_expression context pp (expression, d - 1);
			};

		    prettyprint_named_recursive_values' (rs::SOURCE_CODE_REGION_FOR_RECURSIVELY_NAMED_VALUE (named_recursive_values, source_code_region), d)
			=>
                        {
# Commented out to reduce verbosity:
#			    pp.lit "rs::SOURCE_CODE_REGION_FOR_RECURSIVELY_NAMED_VALUE ";
			    prettyprint_named_recursive_values' (named_recursive_values, d);
                        };
                end;
	    end

	also
	fun prettyprint_named_function (context as (_, source_opt)) pp head
            = 
	    prettyprint_named_function'
	    where
	        fun prettyprint_named_function'(_, 0)
                        =>
                        pp.lit "<NAMED_FUNCTION>";

		    prettyprint_named_function'(rs::NAMED_FUNCTION { pattern_clauses, is_lazy, kind, null_or_type }, d)
			=>
			pp.box .{											pp.rulename "pprs59";
			    #
                            case kind
				#
			        rs::PLAIN_FUN => pp.lit "rs::NAMED_FUNCTION[";
			       rs::METHOD_FUN => pp.lit "rs::NAMED_FUNCTION[ (method)";
			      rs::MESSAGE_FUN => pp.lit "rs::NAMED_FUNCTION[ (message)";
                            esac;
			    pp.ind " ";

			    case null_or_type
				#
				THE anytype =>  {   prettyprint_type context pp (anytype, d - 1);
						    pp.txt " ";
						};
				NULL => ();
			    esac;

			    uj::ppvlist pp
			      ( head, "  | ",
				(fn pp =  fn (cl: rs::Pattern_Clause) =  (prettyprint_pattern_clause context pp (cl, d))),
				pattern_clauses
			      );

			    pp.exd " ";
                            pp.lit "]";
                        };

		    prettyprint_named_function' (rs::SOURCE_CODE_REGION_FOR_NAMED_FUNCTION (t, r), d)
			=>
                        {
# Commented out to reduce verbosity:
#			    pp.lit "rs::SOURCE_CODE_REGION_FOR_NAMED_FUNCTION ";
			    prettyprint_named_function context pp head (t, d);
                        };
                end;
	    end

	also
	fun prettyprint_pattern_clause (context as (_, source_opt)) pp
            =
	    prettyprint_pattern_clause'
	    where	
	        fun prettyprint_pattern_clause' (rs::PATTERN_CLAUSE { patterns, result_type, expression }, d)
                    =
		    pp.box .{												pp.rulename "pprs81";
			#
			fun print_one _ {   item:		rs::Case_Pattern,
					    fixity:		Null_Or( rs::Symbol ),
					    source_code_region:	rs::Source_Code_Region
					}
			    =
			    case fixity
				#
				THE a =>  prettyprint_pattern context pp (item, d);

				NULL => case item
					    #
					    rs::PRE_FIXITY_PATTERN p
						=>
						pp.box .{
						    pp.lit "rs::PRE_FIXITY_PATTERN";
						    pp.ind " ";
						    pp.lit "(";
						    prettyprint_pattern context pp (item, d);
						    pp.lit ")";
						};

					    rs::TYPE_CONSTRAINT_PATTERN p
						=>
						pp.box .{
						    pp.lit "rs::TYPE_CONSTRAINT_PATTERN";
						    pp.ind " ";
						    pp.lit "(";
						    prettyprint_pattern context pp (item, d);
						    pp.lit ")";
						};

					    rs::AS_PATTERN p
						=>
						pp.box .{
						    pp.lit "rs::AS_PATTERN";
						    pp.ind " ";
						    pp.lit "(";
						    prettyprint_pattern context pp (item, d);
						    pp.lit ")";
						};

					    rs::OR_PATTERN p
						=>
						pp.box .{
						    pp.lit "rs::OR_PATTERN";
						    pp.ind " ";
						    pp.lit "(";
						    prettyprint_pattern context pp (item, d);
						    pp.lit ")";
						};

					    _   =>
						prettyprint_pattern context pp (item, d);
					esac;
			    esac;

			pp.lit "rs::PATTERN_CLAUSE [";
			pp.ind " ";

			uj::unparse_sequence
			    pp
			    { separator  =>  fn pp =  pp.txt " ",
			      print_one,
			      breakstyle =>  uj::ALIGN
			    }
			    patterns;

			case result_type
			    #			  
			    THE type
				=>
				{   pp.txt ": ";
				    prettyprint_type context pp (type, d);
				};

			    NULL => ();
			esac;

			pp.exd " ";
			pp.lit "= (PATTERN_CLAUSE) ";
			pp.ind " ";

			prettyprint_expression context pp (expression, d);

			pp.exd " ";
			pp.lit "]";
		    }; 
	    end

	also
	fun prettyprint_named_lib7function (context as (_, source_opt)) pp head
            = 
	    prettyprint_named_lib7function'
	    where
		fun prettyprint_named_lib7function' (_, 0)
                        =>
                        pp.lit "<rs::NADA_NAMED_FUNCTION>";

		    prettyprint_named_lib7function' (rs::NADA_NAMED_FUNCTION (clauses, ops), d)
			=>
                        pp.box .{
			    #
			    pp.lit "rs::NADA_NAMED_FUNCTION";
			    pp.ind " ";

			    uj::ppvlist pp ( head, "  | ",
					     (fn pp = fn (cl: rs::Nada_Pattern_Clause) = (prettyprint_lib7pattern_clause context pp (cl, d))),
					     clauses
					   );
                        };

		    prettyprint_named_lib7function' (rs::SOURCE_CODE_REGION_FOR_NADA_NAMED_FUNCTION (t, r), d)
			=>
			pp.box .{
			    pp.lit "rs::SOURCE_CODE_REGION_FOR_NADA_NAMED_FUNCTION";
			    pp.ind " ";
			    #
			    prettyprint_named_lib7function context pp head (t, d);
                        };
                end;
	    end

	also
	fun prettyprint_lib7pattern_clause (context as (_, source_opt)) pp
            =
	    prettyprint_lib7pattern_clause'
	    where
	        fun prettyprint_lib7pattern_clause' (rs::NADA_PATTERN_CLAUSE { pattern, result_type, expression }, d)
                    =
                    pp.box .{													pp.rulename "lptw12";
			#
		        fun print_one _ (item:   rs::Case_Pattern)
                            =
                            #  XXX BUGGO FIXME:  Need to be more intelligent about paren insertion: 
			    {   pp.lit "(";
                                prettyprint_pattern context pp (item, d);
				pp.lit ")";
                            };

		    
			pp.lit "rs::NADA_PATTERN_CLAUSE";
			pp.ind " ";

			uj::unparse_sequence
			    pp
			    { separator  =>  fn pp =  pp.txt " ",
			      print_one,
			      breakstyle =>  uj::ALIGN
			    }
			    [ pattern ];         #  XXX BUGGO FIXME this list is always len 1 (obviously) so the logic here can probably be simplified. 


			case result_type
			    # 
			    THE type
				=>
				{   pp.txt ": ";
				    prettyprint_type context pp (type, d);
				};

			    NULL => ();
			esac;


			pp.lit " =";
			pp.txt " ";

			prettyprint_expression context pp (expression, d);
		    }; 
	    end

	also
	fun prettyprint_named_type (context as (_, source_opt))  (pp:Pp)
            = 
	    prettyprint_named_type'
	    where
	        fun pp_tyvar_list (symbol_list, d)
                    =
		    pp.box .{
		        fun print_one _ (typevar)
                            =
                            prettyprint_typevar  context  pp  (typevar, d);
		    
                        uj::unparse_sequence
                            pp
			    { separator  =>  fn pp =   pp.txt ", ",		# Was "*"
			      print_one,
			      breakstyle =>  uj::ALIGN
                            }
			    symbol_list;
		    };

		fun prettyprint_named_type'(_, 0)
                        =>
                        pp.lit "<t::naming>";

		    prettyprint_named_type' (rs::NAMED_TYPE { name_symbol, definition, typevars }, d)
			=> 
			pp.box .{													pp.rulename "lptw13";
			    pp.lit "rs::NAMED_TYPE [";
			    pp.ind " ";

			    uj::unparse_symbol pp  name_symbol;
			    pp.txt " ";

			    pp_tyvar_list (typevars, d);

			    pp.exd " ";
			    pp.lit "=";
			    pp.ind " ";

			    prettyprint_type context pp (definition, d);

			    pp.exd " ";
                            pp.lit "]";
			};

		    prettyprint_named_type' (rs::SOURCE_CODE_REGION_FOR_NAMED_TYPE (t, r), d)
			=>
                        {
# Commented out to reduce verbosity:
#			    pp.lit "rs::SOURCE_CODE_REGION_FOR_NAMED_TYPE ";
			    prettyprint_named_type context pp (t, d);
                        };
                end;
	    end

	also
	fun prettyprint_sumtype  (context as (_, source_opt))  pp
            = 
	    prettyprint_sumtype'
	    where
		fun pp_tyvar_list (symbol_list, d)
                    =
		    pp.box .{
			fun print_one _ typevar
                            =
                            (prettyprint_typevar context pp (typevar, d));
		    
                        uj::unparse_sequence
                            pp
			    { separator  =>  fn pp =  pp.txt ", ",	# Was "*"
			      print_one,
			      breakstyle => uj::ALIGN
                            }
			    symbol_list;
		    };

		fun prettyprint_sumtype'(_, 0)
                        =>
                        pp.lit "<rs::SUM_TYPE>";

		    prettyprint_sumtype' (rs::SUM_TYPE { name_symbol, typevars, right_hand_side, is_lazy }, d)
			=> 
			pp.box .{													pp.rulename "lptw14";
			    #
			    pp.lit "rs::SUM_TYPE";
			    pp.ind " ";
			    #
			    uj::unparse_symbol pp  name_symbol;

			    pp.exd " ";
			    pp.lit "=";
			    pp.ind " ";

			    prettyprint_sumtype_right_hand_side context pp (right_hand_side, d);
			};

		    prettyprint_sumtype' (rs::SOURCE_CODE_REGION_FOR_UNION_TYPE (t, r), d)
			=>
                        {
# Commented out to reduce verbosity:
#			    pp.lit "rs::SOURCE_CODE_REGION_FOR_UNION_TYPE ";
			    #
			    prettyprint_sumtype context pp (t, d);
                        };
                end;
	    end

	also
	fun prettyprint_sumtype_right_hand_side (context as (_, source_opt))  (pp:Pp)
            =
	    prettyprint_sumtype_right_hand_side'
	    where
	        fun prettyprint_sumtype_right_hand_side' (_, 0)
                        =>
                        pp.lit "<rs::VALCONS>";

		    prettyprint_sumtype_right_hand_side' (rs::VALCONS const, d)
			=> 
			pp.box .{
			    #
                            fun print_one  pp  (symbol: rs::Symbol,  tv: Null_Or(rs::Any_Type))
				=
				case tv
				    #  
				    THE a =>    {   uj::unparse_symbol pp symbol;
						    pp.lit " ";					# Was " of "
						    prettyprint_type context pp (a, d);
						};

				    NULL  =>  (uj::unparse_symbol pp symbol);
				esac;

			    pp.lit "rs::VALCONS";
			    pp.ind " ";

			    uj::unparse_sequence
				pp
				{ separator   => (fn pp = {  pp.txt " ";  pp.lit "| "; }),
				  print_one,
				  breakstyle => uj::ALIGN
				}
				const;
			};

		    prettyprint_sumtype_right_hand_side' (rs::REPLICAS symlist, d)
			=> 
                        pp.box .{
			    #
			    pp.lit "rs::REPLICAS";
			    pp.ind " ";

			    uj::unparse_sequence
				pp
				{ separator  =>  (fn pp =  {   pp.txt " ";  pp.lit "| "; }),
				  print_one  =>  (fn pp =  fn symbol =  uj::unparse_symbol pp symbol),
				  breakstyle =>  uj::ALIGN
				}
				symlist;
                        };
                end;
	    end

	also
	fun prettyprint_named_exception (context as (_, source_opt)) pp
            =
	    prettyprint_named_exception'
	    where
	        pp_symbol_list = pp_path pp;

		fun prettyprint_named_exception'(_, 0)
                        =>
                        pp.lit "<Eb>";

		    prettyprint_named_exception' (   rs::NAMED_EXCEPTION {
                                                         exception_symbol => exn,
                                                         exception_type   => etype
                                                     },
                                                     d
                                                 )
			=> 
                        pp.box .{
			    #
			    pp.lit "rs::EXCEPTION NAMING";
			    pp.txt " ";

			    case etype
			        #
				THE a =>    pp.box .{											pp.rulename "pprs63";
						uj::unparse_symbol pp exn;
						pp.lit " =";
						pp.txt " ";
						prettyprint_type context pp (a, d - 1);
					    };

				NULL =>     pp.box .{											pp.rulename "pprs64";
						uj::unparse_symbol pp exn; 
					    };
			    esac;
			};

		    prettyprint_named_exception' (rs::DUPLICATE_NAMED_EXCEPTION { exception_symbol=>exn, equal_to=>edef }, d)
			=> 
			# ASK MACQUEEN IF WE NEED TO PRINT EDEF XXX BUGGO FIXME 
			pp.box .{													pp.rulename "pprs65";
			    pp.lit "rs::DUPLICATE_NAMED_EXCEPTION";
			    pp.ind " ";

			    uj::unparse_symbol pp exn;

			    pp.txt " ";
			    pp.txt "= ";

			    pp_symbol_list (edef);
			};

		    prettyprint_named_exception' (rs::SOURCE_CODE_REGION_FOR_NAMED_EXCEPTION (t, r), d)
			=>
                        {
# Commented out to reduce verbosity:
#			    pp.lit "rs::SOURCE_CODE_REGION_FOR_NAMED_EXCEPTION ";
			    prettyprint_named_exception context pp (t, d);
                        };
                end;
	    end

	also
	fun prettyprint_named_package (context as (_, source_opt)) pp
            =
	    prettyprint_named_package'
	    where
	        fun prettyprint_named_package' (_, 0)
                        =>
                        pp.lit "<rs::NAMED_PACKAGE>";

		    prettyprint_named_package' (rs::NAMED_PACKAGE { name_symbol=>name, definition=>def, constraint, kind }, d)
			=> 
			pp.box .{													pp.rulename "pprs66";
			    #	
			    pp.lit "rs::NAMED_PACKAGE";
			    pp.ind " ";

			    case kind
				rs::PLAIN_PACKAGE  =>  ();
				rs::CLASS_PACKAGE  =>  pp.lit "(class) ";
				rs::CLASS2_PACKAGE =>  pp.lit "(class2) ";
			    esac;


			    uj::unparse_symbol pp name;

			    case constraint
				rs::NO_PACKAGE_CAST => ();
				rs::WEAK_PACKAGE_CAST    api_expression => { pp.lit ": (weak) ";    prettyprint_api_expression context pp (api_expression, d); };
				rs::STRONG_PACKAGE_CAST  api_expression => { pp.lit ": ";           prettyprint_api_expression context pp (api_expression, d); };
				rs::PARTIAL_PACKAGE_CAST api_expression => { pp.lit ": (partial) "; prettyprint_api_expression context pp (api_expression, d); };
			    esac; 

			    pp.exd " ";
			    pp.lit "=";
			    pp.ind " ";

			    prettyprint_package_expression context pp (def, d - 1);
			};

		    prettyprint_named_package' (rs::SOURCE_CODE_REGION_FOR_NAMED_PACKAGE (t, r), d)
			=>
                        {
# Commented out to reduce verbosity:
#			    pp.lit "rs::SOURCE_CODE_REGION_FOR_NAMED_PACKAGE ";
			    prettyprint_named_package context pp (t, d);
                        };
                end;
	    end

	also
	fun prettyprint_named_generic (context as (_, source_opt)) pp
            =
	    prettyprint_named_generic'
	    where
		fun prettyprint_named_generic' (_, 0)
                        =>
                        pp.lit "<rs::NAMED_GENERIC>";

		    prettyprint_named_generic' (
                        rs::NAMED_GENERIC {
                            name_symbol =>  name,
                            definition  =>  rs::GENERIC_DEFINITION { parameters, body, constraint }
                        },
                        d
                    )
			=>
			pp.box .{													pp.rulename "pprs67";
			    #
			    fun print_one pp (THE symbol, api_expression)
				    =>
				    {   pp.lit "(";
					uj::unparse_symbol pp symbol;
					pp.lit " : ";
					prettyprint_api_expression context pp (api_expression, d);
					pp.lit ")";
				    };

				print_one pp (NULL, api_expression)
				    =>
				    {   pp.lit "(";
					prettyprint_api_expression context pp (api_expression, d);
					pp.lit ")";
				    };
			    end;

			    pp.lit "rs::NAMED_GENERIC";
                            pp.ind " ";
				#
			    uj::unparse_symbol  pp  name;

                            pp.txt " ";

			    uj::unparse_sequence
				pp
				{ separator  =>  fn pp =  pp.txt " ",
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				parameters;

			    case constraint
				#
				rs::NO_PACKAGE_CAST
				    =>
				    pp.txt "rs::NO_PACKAGE_CAST";

				rs::WEAK_PACKAGE_CAST api_expression
				    => 
				    pp.box .{
					pp.txt "rs::WEAK_PACKAGE_CAST: ";
					prettyprint_api_expression context pp (api_expression, d);
				    };

				rs::PARTIAL_PACKAGE_CAST api_expression
				    => 
				    pp.box .{
					pp.txt "rs::PARTIAL_PACKAGE_CAST: ";
					prettyprint_api_expression context pp (api_expression, d);
				    };

				rs::STRONG_PACKAGE_CAST (api_expression)
				    => 
				    pp.box .{
					pp.txt "rs::STRONG_PACKAGE_CAST: ";
					prettyprint_api_expression context pp (api_expression, d);
				    };
			    esac;

			    pp.exd " ";
			    pp.lit "=";
			    pp.ind " ";

			    prettyprint_package_expression context pp (body, d);
			};

		    prettyprint_named_generic' (rs::NAMED_GENERIC { name_symbol=>name, definition=>def }, d)
			=>
			pp.box .{													pp.rulename "pprs68";
			    #
			    pp.lit "rs::NAMED_GENERIC";
			    pp.ind " ";

			    uj::unparse_symbol pp name;

			    pp.exd " ";
			    pp.lit "=";
			    pp.ind " ";

			    prettyprint_generic_expression context pp (def, d - 1);
			}; 

		    prettyprint_named_generic' (rs::SOURCE_CODE_REGION_FOR_NAMED_GENERIC (t, r), d)
			=>
                        pp.box .{
			    pp.lit "rs::SOURCE_CODE_REGION_FOR_NAMED_GENERIC";
			    pp.ind " ";
	
			    prettyprint_named_generic context pp (t, d);
                        };
                end;
	    
	    end

	also
	fun prettyprint_generic_api_naming (context as (_, source_opt)) pp
            =
	    prettyprint_generic_api_naming'
	    where
		fun prettyprint_generic_api_naming'(_, 0)
                        =>
                        pp.lit "<NAMED_GENERIC_API>";

		    prettyprint_generic_api_naming' (rs::NAMED_GENERIC_API { name_symbol=>name, definition=>def }, d)
			=> 
			pp.box .{													pp.rulename "pprs69";
			    #
			    pp.lit "rs::NAMED_GENERIC_API";
			    pp.ind " ";

			    pp.lit "funsig ";
			    uj::unparse_symbol pp name;

			    pp.exd " ";
			    pp.lit "=";
			    pp.ind " ";

			    prettyprint_generic_api_expression context pp (def, d - 1);
			};

		    prettyprint_generic_api_naming' (rs::SOURCE_REGION_FOR_NAMED_GENERIC_API (t, r), d)
			=>
                        pp.box .{
			    pp.lit "rs::SOURCE_REGION_FOR_NAMED_GENERIC_API";
			    pp.ind " ";

			    prettyprint_generic_api_naming context pp (t, d);
                        };
                end;
	    end

	also
	fun prettyprint_typevar (context as (_, source_opt)) pp
            =
	    prettyprint_typevar'
	    where
	        fun prettyprint_typevar' (_, 0)
                        =>
                        pp.lit "<typevar>";

		    prettyprint_typevar' (rs::TYPEVAR s, d)
                        =>
                        pp.box .{
			    pp.lit "rs::TYPEVAR [";
			    pp.ind " ";

                            uj::unparse_symbol pp s;

			    pp.exd " ";
                            pp.lit "]";
                        };

		    prettyprint_typevar' (rs::SOURCE_CODE_REGION_FOR_TYPEVAR (t, r), d)
                        =>
                        {
# Commented out to reduce verbosity:
#			    pp.lit "rs::SOURCE_CODE_REGION_FOR_TYPEVAR ";
                            prettyprint_typevar context pp (t, d);
                        };
                end;
	    end

	also
	fun prettyprint_type (context as (dictionary, source_opt)) pp
            =			
	    {   fun prettyprint_type' (_, 0)
                        =>
                        pp.lit "<type>";

		    prettyprint_type' (rs::TYPEVAR_TYPE t, d)
                        =>
                        pp.box .{
			    pp.lit "rs::TYPEVAR_TYPE [";
			    pp.ind " ";	

                            prettyprint_typevar context pp (t, d);

			    pp.exd " ";
                            pp.lit "]";
                        };

		    prettyprint_type' (rs::TYPE_TYPE (typ, []), d)
			=>
			pp.box .{													pp.rulename "pprscb1";
			    pp.lit "rs::TYPE_TYPE [";
			    pp.ind " ";

			    pp_path pp typ;

			    pp.exd " ";
                            pp.lit "]";
			};

		    prettyprint_type' (rs::TYPE_TYPE (typ, args), d)
			=> 
			pp.box .{													pp.rulename "pprscb2";
			    #
			    pp.lit "rs::TYPE_TYPE [";
			    pp.ind " ";

			    case typ
				#			      
				[typ]
				    =>
				    if (sy::eq (sy::make_type_symbol("->"), typ))
					#				         
					case args
					    #
					    [dom, ran]
						=>
						pp.box .{
						    prettyprint_type' (dom, d - 1);
						    pp.txt " ";
						    pp.lit "-> ";
						    prettyprint_type' (ran, d - 1);
						};

					    _   =>
						err::impossible "wrong args for -> type";
					esac;

				    else
					uj::unparse_symbol  pp  typ;
					pp.lit " ";
					prettyprint_type_args  (args, d);
				    fi;

				_ => {   pp_path  pp  typ;
					 pp.lit " ";
					 prettyprint_type_args  (args, d);
				     };
			    esac;

                            pp.exd " ";
                            pp.lit "]";
			};

		    prettyprint_type' (rs::RECORD_TYPE s, d)
			=> 
			pp.box .{
			    # 
                            fun print_one  pp  (symbol: rs::Symbol,  tv: rs::Any_Type)
				= 
				{   uj::unparse_symbol pp symbol;
				    pp.lit ":";
				    prettyprint_type context pp (tv, d);
				};

			    pp.lit "rs::RECORD_TYPE";
			    pp.ind " ";

			    uj::unparse_closed_sequence
				pp
				{ front      =>  fn pp = pp.txt "{ ",
				  separator  =>  fn pp = pp.txt ", ",
				  back       =>  fn pp = pp.txt " }",
				  print_one,
				  breakstyle => uj::ALIGN
				}
				s;
			};

		    prettyprint_type' (rs::TUPLE_TYPE t, d)
			=> 
			pp.box .{
			    #
                            fun print_one _ (tv: rs::Any_Type)
				=
				(prettyprint_type context pp (tv, d));

			    pp.lit "rs::TUPLE_TYPE";
			    pp.ind " ";

			    uj::unparse_sequence 
				pp
				{ separator   =>  fn pp =  pp.txt ", ",				# Was " *"
				  print_one,
				  breakstyle =>  uj::ALIGN
				}
				t;
			};

		    prettyprint_type' (rs::SOURCE_CODE_REGION_FOR_TYPE (t, r), d)
			=>
                        {
# Commented out to reduce verbosity:
#			    pp.lit "rs::SOURCE_CODE_REGION_FOR_TYPE ";
			    prettyprint_type context pp (t, d);
                        };
                end 

		also
		fun prettyprint_type_args ([], d)
                        =>
                        ();

		    prettyprint_type_args ( [type], d)
			=> 
			pp.box .{													pp.rulename "pprscw4";
			    #
			    if (strength type <= 1)
			        #
				pp.box .{
				    pp.lit "("; 
				    prettyprint_type' (type, d); 
				    pp.lit ")";
				};
			    else 
				prettyprint_type' (type, d);
			    fi;
			};

		    prettyprint_type_args (tys, d)
			=>
			uj::unparse_closed_sequence
			    pp 
			    { front      =>  fn pp =  pp.lit "(",
			      separator  =>  fn pp =  pp.txt ", ",
			      back       =>  fn pp =  pp.txt ")",
			      breakstyle =>  uj::ALIGN, 
			      print_one  =>  fn _ =  fn type =  prettyprint_type' (type, d)
			    }
			    tys;
                end; 
	    
                prettyprint_type';
	    };
    };						# package unparse_raw_syntax 
end;						# top-level stipulate









##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## Copyright 2003 by University of Chicago 
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2013,
## released per terms of SMLNJ-COPYRIGHT.
