## translate-machcode-to-execode-sparc32-g.codemade.pkg
#
# This file generated at   2011-09-06:02:36:55   by
#
#     src/lib/compiler/back/low/tools/arch/make-sourcecode-for-translate-machcode-to-execode-xxx-g-package.pkg
#
# from the architecture description file
#
#     src/lib/compiler/back/low/sparc32/sparc32.architecture-description
#
# Edits to this file will be LOST on next system rebuild.

# Compiled by:
#     src/lib/compiler/back/low/sparc32/backend-sparc32.lib


# We are invoked from:
#
#     src/lib/compiler/back/low/main/sparc32/backend-lowhalf-sparc32.pkg
#
stipulate
    package lbl =  codelabel;							# codelabel			is from   src/lib/compiler/back/low/code/codelabel.pkg
    package lem =  lowhalf_error_message;					# lowhalf_error_message		is from   src/lib/compiler/back/low/control/lowhalf-error-message.pkg
    package rkj =  registerkinds_junk;						# registerkinds_junk		is from   src/lib/compiler/back/low/code/registerkinds-junk.pkg
    package u32 =  one_word_unt;							# one_word_unt				is from   src/lib/std/one-word-unt.pkg
herein

    generic package translate_machcode_to_execode_sparc32_g (
        #
        package mcf: Machcode_Sparc32;						# Machcode_Sparc32		is from   src/lib/compiler/back/low/sparc32/code/machcode-sparc32.codemade.api
        
        package tce: Treecode_Eval						# Treecode_Eval			is from   src/lib/compiler/back/low/treecode/treecode-eval.api
                     where
                         tcf == mcf::tcf;					# "tcf" == "treecode_form".
        
        package cst: Codebuffer;						# Codebuffer			is from   src/lib/compiler/back/low/code/codebuffer.api
        
        package csb: Code_Segment_Buffer;					# Code_Segment_Buffer		is from   src/lib/compiler/execution/code-segments/code-segment-buffer.api
    )
    : (weak) Machcode_Codebuffer
    {
        									# Machcode_Codebuffer		is from   src/lib/compiler/back/low/emit/machcode-codebuffer.api
        # Export to client packages:
        #
        package cst = cst;
        package mcf = mcf;							# "mcf"  == "machcode_form" (abstract machine code).
        
        # Local abbreviations:
        #
        package rgk =  mcf::rgk;							# "rgk" == "registerkinds".
        package lac =  mcf::lac;							# "lac" == "late_constant".
        package csb =  csb;
        package pop =  cst::pop;
        
        # SPARC32 is big endian.
        
        fun error msg
            =
            lem::error ("SPARC32MC", msg);
        fun make_codebuffer _
            =
            {   infix val & | << >> >>> ;
                #
                (<<)  = u32::(<<);
                (>>)  = u32::(>>);
                (>>>) = u32::(>>>);
                (|)   = u32::bitwise_or;
                (&)   = u32::bitwise_and;
        
                fun put_bool FALSE => 0u0:  u32::Unt;
                    put_bool TRUE  => 0u1:  u32::Unt;
                end;
        
                put_int = u32::from_int;
        
                fun put_word w = w;
                fun put_label l = u32::from_int (lbl::get_codelabel_address l);
                fun put_label_expression le = u32::from_int (tce::value_of le);
                fun put_const lateconst = u32::from_int (lac::late_constant_to_int lateconst);
        
                loc = REF 0;
        
                # Emit a byte:
                #
                fun put_byte  byte
                    =
                    {   offset = *loc;
                        loc := offset + 1;
                        csb::write_byte_to_code_segment_buffer { offset, byte };
                    };
        
                # Emit the low order byte of a word.
                # Note: from_large_unt strips the high order bits!
                #
                fun put_byte_w  word
                    =
                    {   offset = *loc;
                        loc := offset + 1; 
                        csb::write_byte_to_code_segment_buffer { offset, byte => one_byte_unt::from_large_unt word };
                    };
        
                fun do_nothing _ = ();
                fun fail _ = raise exception FAIL "MCEmitter";
                fun get_notes () = error "get_notes";
        
                fun put_pseudo_op  pseudo_op
                    =
                    pop::put_pseudo_op { pseudo_op, loc => *loc, put_byte };
        
                fun start_new_cccomponent  size_in_bytes
                    =
                    {    csb::initialize_code_segment_buffer { size_in_bytes };
                         loc := 0;
                    };
        
        

        fun e_word32 w 
            =
            {   b8 = w;
                w = w >> 0ux8;
                b16 = w;
                w = w >> 0ux8;
                b24 = w;
                w = w >> 0ux8;
                b32 = w;

                    {   put_byte_w b32; 
                        put_byte_w b24; 
                        put_byte_w b16; 
                        put_byte_w b8; 
                    };
            };

        fun put_int_register r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun put_float_register r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun put_flags_register r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun put_ram_byte r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun put_control_dependency r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun put_y r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun put_psr r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun put_fsr r 
            =
            u32::from_int (rkj::hardware_register_id_of r)

        also
        fun put_registerset r 
            =
            u32::from_int (rkj::hardware_register_id_of r);

        fun put_load (mcf::LDSB) => (0ux9 : one_word_unt::Unt);
            put_load (mcf::LDSH) => (0uxA : one_word_unt::Unt);
            put_load (mcf::LDUB) => (0ux1 : one_word_unt::Unt);
            put_load (mcf::LDUH) => (0ux2 : one_word_unt::Unt);
            put_load (mcf::LD) => (0ux0 : one_word_unt::Unt);
            put_load (mcf::LDX) => (0uxB : one_word_unt::Unt);
            put_load (mcf::LDD) => (0ux3 : one_word_unt::Unt);
        end

        also
        fun put_store (mcf::STB) => (0ux5 : one_word_unt::Unt);
            put_store (mcf::STH) => (0ux6 : one_word_unt::Unt);
            put_store (mcf::ST) => (0ux4 : one_word_unt::Unt);
            put_store (mcf::STX) => (0uxE : one_word_unt::Unt);
            put_store (mcf::STD) => (0ux7 : one_word_unt::Unt);
        end

        also
        fun put_fload (mcf::LDF) => (0ux20 : one_word_unt::Unt);
            put_fload (mcf::LDDF) => (0ux23 : one_word_unt::Unt);
            put_fload (mcf::LDQF) => (0ux22 : one_word_unt::Unt);
            put_fload (mcf::LDFSR) => (0ux21 : one_word_unt::Unt);
            put_fload (mcf::LDXFSR) => (0ux21 : one_word_unt::Unt);
        end

        also
        fun put_fstore (mcf::STF) => (0ux24 : one_word_unt::Unt);
            put_fstore (mcf::STDF) => (0ux27 : one_word_unt::Unt);
            put_fstore (mcf::STFSR) => (0ux25 : one_word_unt::Unt);
        end

        also
        fun put_arith (mcf::AND) => (0ux1 : one_word_unt::Unt);
            put_arith (mcf::ANDCC) => (0ux11 : one_word_unt::Unt);
            put_arith (mcf::ANDN) => (0ux5 : one_word_unt::Unt);
            put_arith (mcf::ANDNCC) => (0ux15 : one_word_unt::Unt);
            put_arith (mcf::OR) => (0ux2 : one_word_unt::Unt);
            put_arith (mcf::ORCC) => (0ux12 : one_word_unt::Unt);
            put_arith (mcf::ORN) => (0ux6 : one_word_unt::Unt);
            put_arith (mcf::ORNCC) => (0ux16 : one_word_unt::Unt);
            put_arith (mcf::XOR) => (0ux3 : one_word_unt::Unt);
            put_arith (mcf::XORCC) => (0ux13 : one_word_unt::Unt);
            put_arith (mcf::XNOR) => (0ux7 : one_word_unt::Unt);
            put_arith (mcf::XNORCC) => (0ux17 : one_word_unt::Unt);
            put_arith (mcf::ADD) => (0ux0 : one_word_unt::Unt);
            put_arith (mcf::ADDCC) => (0ux10 : one_word_unt::Unt);
            put_arith (mcf::TADD) => (0ux20 : one_word_unt::Unt);
            put_arith (mcf::TADDCC) => (0ux30 : one_word_unt::Unt);
            put_arith (mcf::TADDTV) => (0ux22 : one_word_unt::Unt);
            put_arith (mcf::TADDTVCC) => (0ux32 : one_word_unt::Unt);
            put_arith (mcf::SUB) => (0ux4 : one_word_unt::Unt);
            put_arith (mcf::SUBCC) => (0ux14 : one_word_unt::Unt);
            put_arith (mcf::TSUB) => (0ux21 : one_word_unt::Unt);
            put_arith (mcf::TSUBCC) => (0ux31 : one_word_unt::Unt);
            put_arith (mcf::TSUBTV) => (0ux23 : one_word_unt::Unt);
            put_arith (mcf::TSUBTVCC) => (0ux33 : one_word_unt::Unt);
            put_arith (mcf::UMUL) => (0uxA : one_word_unt::Unt);
            put_arith (mcf::UMULCC) => (0ux1A : one_word_unt::Unt);
            put_arith (mcf::SMUL) => (0uxB : one_word_unt::Unt);
            put_arith (mcf::SMULCC) => (0ux1B : one_word_unt::Unt);
            put_arith (mcf::UDIV) => (0uxE : one_word_unt::Unt);
            put_arith (mcf::UDIVCC) => (0ux1E : one_word_unt::Unt);
            put_arith (mcf::SDIV) => (0uxF : one_word_unt::Unt);
            put_arith (mcf::SDIVCC) => (0ux1F : one_word_unt::Unt);
            put_arith (mcf::MULX) => (0ux9 : one_word_unt::Unt);
            put_arith (mcf::SDIVX) => (0ux2D : one_word_unt::Unt);
            put_arith (mcf::UDIVX) => (0uxD : one_word_unt::Unt);
        end

        also
        fun put_shift (mcf::SLL) => (0ux25, 0ux0);
            put_shift (mcf::SRL) => (0ux26, 0ux0);
            put_shift (mcf::SRA) => (0ux27, 0ux0);
            put_shift (mcf::SLLX) => (0ux25, 0ux1);
            put_shift (mcf::SRLX) => (0ux26, 0ux1);
            put_shift (mcf::SRAX) => (0ux27, 0ux1);
        end

        also
        fun put_farith1 (mcf::FITOS) => (0uxC4 : one_word_unt::Unt);
            put_farith1 (mcf::FITOD) => (0uxC8 : one_word_unt::Unt);
            put_farith1 (mcf::FITOQ) => (0uxCC : one_word_unt::Unt);
            put_farith1 (mcf::FSTOI) => (0uxD1 : one_word_unt::Unt);
            put_farith1 (mcf::FDTOI) => (0uxD2 : one_word_unt::Unt);
            put_farith1 (mcf::FQTOI) => (0uxD3 : one_word_unt::Unt);
            put_farith1 (mcf::FSTOD) => (0uxC9 : one_word_unt::Unt);
            put_farith1 (mcf::FSTOQ) => (0uxD5 : one_word_unt::Unt);
            put_farith1 (mcf::FDTOS) => (0uxC6 : one_word_unt::Unt);
            put_farith1 (mcf::FDTOQ) => (0uxCE : one_word_unt::Unt);
            put_farith1 (mcf::FQTOS) => (0uxC7 : one_word_unt::Unt);
            put_farith1 (mcf::FQTOD) => (0uxCB : one_word_unt::Unt);
            put_farith1 (mcf::FMOVS) => (0ux1 : one_word_unt::Unt);
            put_farith1 (mcf::FNEGS) => (0ux5 : one_word_unt::Unt);
            put_farith1 (mcf::FABSS) => (0ux9 : one_word_unt::Unt);
            put_farith1 (mcf::FMOVD) => error "FMOVd";
            put_farith1 (mcf::FNEGD) => error "FNEGd";
            put_farith1 (mcf::FABSD) => error "FABSd";
            put_farith1 (mcf::FMOVQ) => error "FMOVq";
            put_farith1 (mcf::FNEGQ) => error "FNEGq";
            put_farith1 (mcf::FABSQ) => error "FABSq";
            put_farith1 (mcf::FSQRTS) => (0ux29 : one_word_unt::Unt);
            put_farith1 (mcf::FSQRTD) => (0ux2A : one_word_unt::Unt);
            put_farith1 (mcf::FSQRTQ) => (0ux2B : one_word_unt::Unt);
        end

        also
        fun put_farith2 (mcf::FADDS) => (0ux41 : one_word_unt::Unt);
            put_farith2 (mcf::FADDD) => (0ux42 : one_word_unt::Unt);
            put_farith2 (mcf::FADDQ) => (0ux43 : one_word_unt::Unt);
            put_farith2 (mcf::FSUBS) => (0ux45 : one_word_unt::Unt);
            put_farith2 (mcf::FSUBD) => (0ux46 : one_word_unt::Unt);
            put_farith2 (mcf::FSUBQ) => (0ux47 : one_word_unt::Unt);
            put_farith2 (mcf::FMULS) => (0ux49 : one_word_unt::Unt);
            put_farith2 (mcf::FMULD) => (0ux4A : one_word_unt::Unt);
            put_farith2 (mcf::FMULQ) => (0ux4B : one_word_unt::Unt);
            put_farith2 (mcf::FSMULD) => (0ux69 : one_word_unt::Unt);
            put_farith2 (mcf::FDMULQ) => (0ux6E : one_word_unt::Unt);
            put_farith2 (mcf::FDIVS) => (0ux4D : one_word_unt::Unt);
            put_farith2 (mcf::FDIVD) => (0ux4E : one_word_unt::Unt);
            put_farith2 (mcf::FDIVQ) => (0ux4F : one_word_unt::Unt);
        end

        also
        fun put_fcmp (mcf::FCMPS) => (0ux51 : one_word_unt::Unt);
            put_fcmp (mcf::FCMPD) => (0ux52 : one_word_unt::Unt);
            put_fcmp (mcf::FCMPQ) => (0ux53 : one_word_unt::Unt);
            put_fcmp (mcf::FCMPES) => (0ux55 : one_word_unt::Unt);
            put_fcmp (mcf::FCMPED) => (0ux56 : one_word_unt::Unt);
            put_fcmp (mcf::FCMPEQ) => (0ux57 : one_word_unt::Unt);
        end

        also
        fun put_branch (mcf::BN) => (0ux0 : one_word_unt::Unt);
            put_branch (mcf::BE) => (0ux1 : one_word_unt::Unt);
            put_branch (mcf::BLE) => (0ux2 : one_word_unt::Unt);
            put_branch (mcf::BL) => (0ux3 : one_word_unt::Unt);
            put_branch (mcf::BLEU) => (0ux4 : one_word_unt::Unt);
            put_branch (mcf::BCS) => (0ux5 : one_word_unt::Unt);
            put_branch (mcf::BNEG) => (0ux6 : one_word_unt::Unt);
            put_branch (mcf::BVS) => (0ux7 : one_word_unt::Unt);
            put_branch (mcf::BA) => (0ux8 : one_word_unt::Unt);
            put_branch (mcf::BNE) => (0ux9 : one_word_unt::Unt);
            put_branch (mcf::BG) => (0uxA : one_word_unt::Unt);
            put_branch (mcf::BGE) => (0uxB : one_word_unt::Unt);
            put_branch (mcf::BGU) => (0uxC : one_word_unt::Unt);
            put_branch (mcf::BCC) => (0uxD : one_word_unt::Unt);
            put_branch (mcf::BPOS) => (0uxE : one_word_unt::Unt);
            put_branch (mcf::BVC) => (0uxF : one_word_unt::Unt);
        end

        also
        fun put_rcond (mcf::RZ) => (0ux1 : one_word_unt::Unt);
            put_rcond (mcf::RLEZ) => (0ux2 : one_word_unt::Unt);
            put_rcond (mcf::RLZ) => (0ux3 : one_word_unt::Unt);
            put_rcond (mcf::RNZ) => (0ux5 : one_word_unt::Unt);
            put_rcond (mcf::RGZ) => (0ux6 : one_word_unt::Unt);
            put_rcond (mcf::RGEZ) => (0ux7 : one_word_unt::Unt);
        end

        also
        fun put_cc (mcf::ICC) => (0ux0 : one_word_unt::Unt);
            put_cc (mcf::XCC) => (0ux2 : one_word_unt::Unt);
        end

        also
        fun put_fbranch (mcf::FBN) => (0ux0 : one_word_unt::Unt);
            put_fbranch (mcf::FBNE) => (0ux1 : one_word_unt::Unt);
            put_fbranch (mcf::FBLG) => (0ux2 : one_word_unt::Unt);
            put_fbranch (mcf::FBUL) => (0ux3 : one_word_unt::Unt);
            put_fbranch (mcf::FBL) => (0ux4 : one_word_unt::Unt);
            put_fbranch (mcf::FBUG) => (0ux5 : one_word_unt::Unt);
            put_fbranch (mcf::FBG) => (0ux6 : one_word_unt::Unt);
            put_fbranch (mcf::FBU) => (0ux7 : one_word_unt::Unt);
            put_fbranch (mcf::FBA) => (0ux8 : one_word_unt::Unt);
            put_fbranch (mcf::FBE) => (0ux9 : one_word_unt::Unt);
            put_fbranch (mcf::FBUE) => (0uxA : one_word_unt::Unt);
            put_fbranch (mcf::FBGE) => (0uxB : one_word_unt::Unt);
            put_fbranch (mcf::FBUGE) => (0uxC : one_word_unt::Unt);
            put_fbranch (mcf::FBLE) => (0uxD : one_word_unt::Unt);
            put_fbranch (mcf::FBULE) => (0uxE : one_word_unt::Unt);
            put_fbranch (mcf::FBO) => (0uxF : one_word_unt::Unt);
        end

        also
        fun put_fsize (mcf::SS) => (0ux4 : one_word_unt::Unt);
            put_fsize (mcf::DD) => (0ux6 : one_word_unt::Unt);
            put_fsize (mcf::QQ) => (0ux7 : one_word_unt::Unt);
        end;

        fun opn { i } 
            =
            {   
###line 491.11 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"

                fun hi22 w 
                    =
                    (u32::from_int w) >>> 0uxA;

###line 492.11 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"

                fun lo10 w 
                    =
                    ((u32::from_int w) & 0ux3FF);

                case i
                    #
                    mcf::REG rs2 => error "opn";
                    mcf::IMMED i => u32::from_int i;
                    mcf::LAB l => u32::from_int (tce::value_of l);
                    mcf::LO l => lo10 (tce::value_of l);
                    mcf::HI l => hi22 (tce::value_of l);
                esac;
            }

        also
        fun rr { op1, 
                 rd, 
                 op3, 
                 rs1, 
                 rs2
               }

            =
            {   rs1 = put_int_register rs1;
                rs2 = put_int_register rs2;

                e_word32 ((op1 << 0ux1E) + ((rd << 0ux19) + ((op3 << 0ux13) + ((rs1 << 0uxE) + rs2))));
            }

        also
        fun ri { op1, 
                 rd, 
                 op3, 
                 rs1, 
                 simm13
               }

            =
            {   rs1 = put_int_register rs1;

                e_word32 ((op1 << 0ux1E) + ((rd << 0ux19) + ((op3 << 0ux13) + ((rs1 << 0uxE) + ((simm13 & 0ux1FFF) + 0ux2000)))));
            }

        also
        fun rix { op1, 
                  op3, 
                  r, 
                  i, 
                  d
                }

            =
            case i
                #
                mcf::REG rs2 => rr { op1, 
                                     op3, 
                                     rs1 => r, 
                                     rs2, 
                                     rd => d
                                   }
;
                _   => ri { op1, 
                            op3, 
                            rs1 => r, 
                            rd => d, 
                            simm13 => opn { i }
                          }
;
            esac

        also
        fun rir { op1, 
                  op3, 
                  r, 
                  i, 
                  d
                }

            =
            {   d = put_int_register d;

                rix { op1, 
                      op3, 
                      r, 
                      i, 
                      d
                    }
;
            }

        also
        fun rif { op1, 
                  op3, 
                  r, 
                  i, 
                  d
                }

            =
            {   d = put_float_register d;

                rix { op1, 
                      op3, 
                      r, 
                      i, 
                      d
                    }
;
            }

        also
        fun load { l, 
                   r, 
                   i, 
                   d
                 }

            =
            {   l = put_load l;

                rir { op1 => 0ux3, 
                      op3 => l, 
                      r, 
                      i, 
                      d
                    }
;
            }

        also
        fun store { s, 
                    r, 
                    i, 
                    d
                  }

            =
            {   s = put_store s;

                rir { op1 => 0ux3, 
                      op3 => s, 
                      r, 
                      i, 
                      d
                    }
;
            }

        also
        fun fload { l, 
                    r, 
                    i, 
                    d
                  }

            =
            {   l = put_fload l;

                rif { op1 => 0ux3, 
                      op3 => l, 
                      r, 
                      i, 
                      d
                    }
;
            }

        also
        fun fstore { s, 
                     r, 
                     i, 
                     d
                   }

            =
            {   s = put_fstore s;

                rif { op1 => 0ux3, 
                      op3 => s, 
                      r, 
                      i, 
                      d
                    }
;
            }

        also
        fun sethi { rd, 
                    imm22
                  }

            =
            {   rd = put_int_register rd;
                imm22 = put_int imm22;

                e_word32 ((rd << 0ux19) + ((imm22 & 0ux3FFFFF) + 0ux1000000));
            }

        also
        fun nop' { } 
            =
            e_word32 0ux1000000

        also
        fun unimp { const22 } 
            =
            {   const22 = put_int const22;

                e_word32 const22;
            }

        also
        fun delay { nop } 
            =
            if  nop   (nop' { });
            fi

        also
        fun arith { a, 
                    r, 
                    i, 
                    d
                  }

            =
            {   a = put_arith a;

                rir { op1 => 0ux2, 
                      op3 => a, 
                      r, 
                      i, 
                      d
                    }
;
            }

        also
        fun shiftr { rd, 
                     op3, 
                     rs1, 
                     x, 
                     rs2
                   }

            =
            {   rs2 = put_int_register rs2;

                e_word32 ((rd << 0ux19) + ((op3 << 0ux13) + ((rs1 << 0uxE) + ((x << 0uxC) + (rs2 + 0ux80000000)))));
            }

        also
        fun shifti { rd, 
                     op3, 
                     rs1, 
                     x, 
                     count
                   }

            =
            e_word32 ((rd << 0ux19) + ((op3 << 0ux13) + ((rs1 << 0uxE) + ((x << 0uxC) + ((count & 0ux3F) + 0ux80002000)))))

        also
        fun shift { s, 
                    r, 
                    i, 
                    d
                  }

            =
            {   s = put_shift s;
                r = put_int_register r;
                d = put_int_register d;

                    {   
###line 530.13 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"
                        my (op3, x) = s;

                        case i
                            #
                            mcf::REG rs2 => shiftr { op3, 
                                                     rs1 => r, 
                                                     rs2, 
                                                     rd => d, 
                                                     x
                                                   }
;
                            _   => shifti { op3, 
                                            rs1 => r, 
                                            count => opn { i }, 
                                            rd => d, 
                                            x
                                          }
;
                        esac;
                    };
            }

        also
        fun save { r, 
                   i, 
                   d
                 }

            =
            rir { op1 => 0ux2, 
                  op3 => 0ux3C, 
                  r, 
                  i, 
                  d
                }


        also
        fun restore { r, 
                      i, 
                      d
                    }

            =
            rir { op1 => 0ux2, 
                  op3 => 0ux3D, 
                  r, 
                  i, 
                  d
                }


        also
        fun bicc { a, 
                   b, 
                   disp22
                 }

            =
            {   a = put_bool a;
                b = put_branch b;

                e_word32 ((a << 0ux1D) + ((b << 0ux19) + ((disp22 & 0ux3FFFFF) + 0ux800000)));
            }

        also
        fun fbfcc { a, 
                    b, 
                    disp22
                  }

            =
            {   a = put_bool a;
                b = put_fbranch b;

                e_word32 ((a << 0ux1D) + ((b << 0ux19) + ((disp22 & 0ux3FFFFF) + 0ux1800000)));
            }

        also
        fun call { disp30 } 
            =
            e_word32 ((disp30 & 0ux3FFFFFFF) + 0ux40000000)

        also
        fun jmpl { r, 
                   i, 
                   d
                 }

            =
            rir { op1 => 0ux2, 
                  op3 => 0ux38, 
                  r, 
                  i, 
                  d
                }


        also
        fun jmp { r, 
                  i
                }

            =
            rix { op1 => 0ux2, 
                  op3 => 0ux38, 
                  r, 
                  i, 
                  d => 0ux0
                }


        also
        fun ticcr { op1, 
                    rd, 
                    op3, 
                    rs1, 
                    cc, 
                    rs2
                  }

            =
            {   rs1 = put_int_register rs1;
                cc = put_cc cc;
                rs2 = put_int_register rs2;

                e_word32 ((op1 << 0ux1E) + ((rd << 0ux19) + ((op3 << 0ux13) + ((rs1 << 0uxE) + ((cc << 0uxB) + rs2)))));
            }

        also
        fun ticci { op1, 
                    rd, 
                    op3, 
                    rs1, 
                    cc, 
                    sw_trap
                  }

            =
            {   rs1 = put_int_register rs1;
                cc = put_cc cc;

                e_word32 ((op1 << 0ux1E) + ((rd << 0ux19) + ((op3 << 0ux13) + ((rs1 << 0uxE) + ((cc << 0uxB) + ((sw_trap & 0ux7F) + 0ux2000))))));
            }

        also
        fun ticcx { op1, 
                    op3, 
                    cc, 
                    r, 
                    i, 
                    d
                  }

            =
            case i
                #
                mcf::REG rs2 => ticcr { op1, 
                                        op3, 
                                        cc, 
                                        rs1 => r, 
                                        rs2, 
                                        rd => d
                                      }
;
                _   => ticci { op1, 
                               op3, 
                               cc, 
                               rs1 => r, 
                               rd => d, 
                               sw_trap => opn { i }
                             }
;
            esac

        also
        fun ticc { t, 
                   cc, 
                   r, 
                   i
                 }

            =
            {   t = put_branch t;

                ticcx { op1 => 0ux2, 
                        d => t, 
                        op3 => 0ux3A, 
                        cc, 
                        r, 
                        i
                      }
;
            }

        also
        fun rdy { d } 
            =
            {   d = put_int_register d;

                e_word32 ((d << 0ux19) + 0ux81400000);
            }

        also
        fun wdy { r, 
                  i
                }

            =
            rix { op1 => 0ux2, 
                  op3 => 0ux30, 
                  r, 
                  i, 
                  d => 0ux0
                }


        also
        fun fop_1 { d, 
                    a, 
                    r
                  }

            =
            e_word32 ((d << 0ux19) + ((a << 0ux5) + (r + 0ux81A00000)))

        also
        fun fop1 { a, 
                   r, 
                   d
                 }

            =
            {   a = put_farith1 a;
                r = put_float_register r;
                d = put_float_register d;

                fop_1 { a, 
                        r, 
                        d
                      }
;
            }

        also
        fun fdouble { a, 
                      r, 
                      d
                    }

            =
            {   a = put_farith1 a;
                r = put_float_register r;
                d = put_float_register d;

                    {   fop_1 { a, 
                                r, 
                                d
                              }
; 
                        fop_1 { a => 0ux1, 
                                r => r + 0ux1, 
                                d => d + 0ux1
                              }
; 
                    };
            }

        also
        fun fquad { a, 
                    r, 
                    d
                  }

            =
            {   a = put_farith1 a;
                r = put_float_register r;
                d = put_float_register d;

                    {   fop_1 { a, 
                                r, 
                                d
                              }
; 
                        fop_1 { a => 0ux1, 
                                r => r + 0ux1, 
                                d => d + 0ux1
                              }
; 
                        fop_1 { a => 0ux1, 
                                r => r + 0ux2, 
                                d => d + 0ux2
                              }
; 
                        fop_1 { a => 0ux1, 
                                r => r + 0ux3, 
                                d => d + 0ux3
                              }
; 
                    };
            }

        also
        fun fop2 { d, 
                   r1, 
                   a, 
                   r2
                 }

            =
            {   d = put_float_register d;
                r1 = put_float_register r1;
                a = put_farith2 a;
                r2 = put_float_register r2;

                e_word32 ((d << 0ux19) + ((r1 << 0uxE) + ((a << 0ux5) + (r2 + 0ux81A00000))));
            }

        also
        fun fcmp { rs1, 
                   opf, 
                   rs2
                 }

            =
            {   rs1 = put_float_register rs1;
                opf = put_fcmp opf;
                rs2 = put_float_register rs2;

                e_word32 ((rs1 << 0uxE) + ((opf << 0ux5) + (rs2 + 0ux81A80000)));
            }

        also
        fun cmovr { op3, 
                    rd, 
                    cc2, 
                    cond, 
                    cc1, 
                    cc0, 
                    rs2
                  }

            =
            e_word32 ((op3 << 0ux18) + ((rd << 0ux13) + ((cc2 << 0ux12) + ((cond << 0uxE) + ((cc1 << 0uxC) + ((cc0 << 0uxB) + (rs2 + 0ux80000000)))))))

        also
        fun cmovi { op3, 
                    rd, 
                    cc2, 
                    cond, 
                    cc1, 
                    cc0, 
                    simm11
                  }

            =
            e_word32 ((op3 << 0ux18) + ((rd << 0ux13) + ((cc2 << 0ux12) + ((cond << 0uxE) + ((cc1 << 0uxC) + ((cc0 << 0uxB) + ((simm11 & 0ux7FF) + 0ux80002000)))))))

        also
        fun cmov { op3, 
                   cond, 
                   cc2, 
                   cc1, 
                   cc0, 
                   i, 
                   rd
                 }

            =
            case i
                #
                mcf::REG rs2 => cmovr { op3, 
                                        cond, 
                                        rs2 => put_int_register rs2, 
                                        rd, 
                                        cc0, 
                                        cc1, 
                                        cc2
                                      }
;
                _   => cmovi { op3, 
                               cond, 
                               rd, 
                               cc0, 
                               cc1, 
                               cc2, 
                               simm11 => opn { i }
                             }
;
            esac

        also
        fun movicc { b, 
                     i, 
                     d
                   }

            =
            {   b = put_branch b;
                d = put_int_register d;

                cmov { op3 => 0ux2C, 
                       cond => b, 
                       i, 
                       rd => d, 
                       cc2 => 0ux1, 
                       cc1 => 0ux0, 
                       cc0 => 0ux0
                     }
;
            }

        also
        fun movfcc { b, 
                     i, 
                     d
                   }

            =
            {   b = put_fbranch b;
                d = put_int_register d;

                cmov { op3 => 0ux2C, 
                       cond => b, 
                       i, 
                       rd => d, 
                       cc2 => 0ux0, 
                       cc1 => 0ux0, 
                       cc0 => 0ux0
                     }
;
            }

        also
        fun fmovicc { size, 
                      b, 
                      r, 
                      d
                    }

            =
            {   size = put_fsize size;
                b = put_branch b;
                r = put_float_register r;
                d = put_float_register d;

                cmovr { op3 => 0ux2C, 
                        cond => b, 
                        rs2 => r, 
                        rd => d, 
                        cc2 => 0ux1, 
                        cc1 => 0ux0, 
                        cc0 => 0ux0
                      }
;
            }

        also
        fun fmovfcc { size, 
                      b, 
                      r, 
                      d
                    }

            =
            {   size = put_fsize size;
                b = put_fbranch b;
                r = put_float_register r;
                d = put_float_register d;

                cmovr { op3 => 0ux2C, 
                        cond => b, 
                        rs2 => r, 
                        rd => d, 
                        cc2 => 0ux0, 
                        cc1 => 0ux0, 
                        cc0 => 0ux0
                      }
;
            }

        also
        fun movrr { rd, 
                    rs1, 
                    rcond, 
                    rs2
                  }

            =
            {   rd = put_int_register rd;
                rs1 = put_int_register rs1;
                rs2 = put_int_register rs2;

                e_word32 ((rd << 0ux19) + ((rs1 << 0uxE) + ((rcond << 0uxA) + (rs2 + 0ux81780000))));
            }

        also
        fun movri { rd, 
                    rs1, 
                    rcond, 
                    simm10
                  }

            =
            {   rd = put_int_register rd;
                rs1 = put_int_register rs1;

                e_word32 ((rd << 0ux19) + ((rs1 << 0uxE) + ((rcond << 0uxA) + ((simm10 & 0ux3FF) + 0ux81782000))));
            }

        also
        fun movr { rcond, 
                   r, 
                   i, 
                   d
                 }

            =
            {   rcond = put_rcond rcond;

                case i
                    #
                    mcf::REG rs2 => movrr { rcond, 
                                            rs1 => r, 
                                            rs2, 
                                            rd => d
                                          }
;
                    _   => movri { rcond, 
                                   rs1 => r, 
                                   rd => d, 
                                   simm10 => opn { i }
                                 }
;
                esac;
            };

###line 609.7 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"

        fun disp label 
            =
            (u32::from_int ((lbl::get_codelabel_address label) - (deref loc))) >>> 0ux2;

###line 610.7 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"
        r15 = rgk::get_ith_hardware_register_of_kind rkj::INT_REGISTER 15;

###line 611.7 "src/lib/compiler/back/low/sparc32/sparc32.architecture-description"
        r31 = rgk::get_ith_hardware_register_of_kind rkj::INT_REGISTER 31;
            fun emitter instruction
                =
                {

        fun put_op (mcf::LOAD { l, 
                                d, 
                                r, 
                                i, 
                                ramregion
                              }
            )   => load { l, 
                          r, 
                          i, 
                          d
                        }
;
            put_op (mcf::STORE { s, 
                                 d, 
                                 r, 
                                 i, 
                                 ramregion
                               }
            )   => store { s, 
                           r, 
                           i, 
                           d
                         }
;
            put_op (mcf::FLOAD { l, 
                                 r, 
                                 i, 
                                 d, 
                                 ramregion
                               }
            )   => fload { l, 
                           r, 
                           i, 
                           d
                         }
;
            put_op (mcf::FSTORE { s, 
                                  d, 
                                  r, 
                                  i, 
                                  ramregion
                                }
            )   => fstore { s, 
                            r, 
                            i, 
                            d
                          }
;
            put_op (mcf::UNIMP { const22 }) => unimp { const22 };
            put_op (mcf::SETHI { i, 
                                 d
                               }
            )   => sethi { imm22 => i, 
                           rd => d
                         }
;
            put_op (mcf::ARITH { a, 
                                 r, 
                                 i, 
                                 d
                               }
            )   => arith { a, 
                           r, 
                           i, 
                           d
                         }
;
            put_op (mcf::SHIFT { s, 
                                 r, 
                                 i, 
                                 d
                               }
            )   => shift { s, 
                           r, 
                           i, 
                           d
                         }
;
            put_op (mcf::MOVICC { b, 
                                  i, 
                                  d
                                }
            )   => movicc { b, 
                            i, 
                            d
                          }
;
            put_op (mcf::MOVFCC { b, 
                                  i, 
                                  d
                                }
            )   => movfcc { b, 
                            i, 
                            d
                          }
;
            put_op (mcf::MOVR { rcond, 
                                r, 
                                i, 
                                d
                              }
            )   => movr { rcond, 
                          r, 
                          i, 
                          d
                        }
;
            put_op (mcf::FMOVICC { size, 
                                   b, 
                                   r, 
                                   d
                                 }
            )   => fmovicc { size, 
                             b, 
                             r, 
                             d
                           }
;
            put_op (mcf::FMOVFCC { size, 
                                   b, 
                                   r, 
                                   d
                                 }
            )   => fmovfcc { size, 
                             b, 
                             r, 
                             d
                           }
;
            put_op (mcf::BICC { b, 
                                a, 
                                label, 
                                nop
                              }
            )   => {   bicc { b, 
                              a, 
                              disp22 => disp label
                            }
; 
                       delay { nop }; 
                   };
            put_op (mcf::FBFCC { b, 
                                 a, 
                                 label, 
                                 nop
                               }
            )   => {   fbfcc { b, 
                               a, 
                               disp22 => disp label
                             }
; 
                       delay { nop }; 
                   };
            put_op (mcf::BR { rcond, 
                              p, 
                              r, 
                              a, 
                              label, 
                              nop
                            }
            )   => error "BR";
            put_op (mcf::BP { b, 
                              p, 
                              cc, 
                              a, 
                              label, 
                              nop
                            }
            )   => error "BP";
            put_op (mcf::JMP { r, 
                               i, 
                               labs, 
                               nop
                             }
            )   => {   jmp { r, 
                             i
                           }
; 
                       delay { nop }; 
                   };
            put_op (mcf::JMPL { r, 
                                i, 
                                d, 
                                defs, 
                                uses, 
                                cuts_to, 
                                nop, 
                                ramregion
                              }
            )   => {   jmpl { r, 
                              i, 
                              d
                            }
; 
                       delay { nop }; 
                   };
            put_op (mcf::CALL { defs, 
                                uses, 
                                label, 
                                cuts_to, 
                                nop, 
                                ramregion
                              }
            )   => {   call { disp30 => disp label }; 
                       delay { nop }; 
                   };
            put_op (mcf::TICC { t, 
                                cc, 
                                r, 
                                i
                              }
            )   => ticc { t, 
                          r, 
                          cc, 
                          i
                        }
;
            put_op (mcf::FPOP1 { a, 
                                 r, 
                                 d
                               }
            )   => case a
                       #
                       mcf::FMOVD => fdouble { a => mcf::FMOVS, 
                                               r, 
                                               d
                                             }
;
                       mcf::FNEGD => fdouble { a => mcf::FNEGS, 
                                               r, 
                                               d
                                             }
;
                       mcf::FABSD => fdouble { a => mcf::FABSS, 
                                               r, 
                                               d
                                             }
;
                       mcf::FMOVQ => fquad { a => mcf::FMOVS, 
                                             r, 
                                             d
                                           }
;
                       mcf::FNEGQ => fquad { a => mcf::FNEGS, 
                                             r, 
                                             d
                                           }
;
                       mcf::FABSQ => fquad { a => mcf::FABSS, 
                                             r, 
                                             d
                                           }
;
                       _   => fop1 { a, 
                                     r, 
                                     d
                                   }
;
                   esac;
            put_op (mcf::FPOP2 { a, 
                                 r1, 
                                 r2, 
                                 d
                               }
            )   => fop2 { a, 
                          r1, 
                          r2, 
                          d
                        }
;
            put_op (mcf::FCMP { cmp, 
                                r1, 
                                r2, 
                                nop
                              }
            )   => {   fcmp { opf => cmp, 
                              rs1 => r1, 
                              rs2 => r2
                            }
; 
                       delay { nop }; 
                   };
            put_op (mcf::SAVE { r, 
                                i, 
                                d
                              }
            )   => save { r, 
                          i, 
                          d
                        }
;
            put_op (mcf::RESTORE { r, 
                                   i, 
                                   d
                                 }
            )   => restore { r, 
                             i, 
                             d
                           }
;
            put_op (mcf::RDY { d }) => rdy { d };
            put_op (mcf::WRY { r, 
                               i
                             }
            )   => wdy { r, 
                         i
                       }
;
            put_op (mcf::RET { leaf, 
                               nop
                             }
            )   => {   jmp { r => if  leaf   r31;
                                  else   r15;
                                  fi, 
                             i => mcf::IMMED 8
                           }
; 
                       delay { nop }; 
                   };
            put_op (mcf::SOURCE { }) => ();
            put_op (mcf::SINK { }) => ();
            put_op (mcf::PHI { }) => ();
        end;
        
                put_op instruction;
            };
        
        fun put_op (mcf::NOTE { op, ... } ) =>  put_op  op;
            put_op (mcf::BASE_OP i) => emitter i;
            put_op (mcf::LIVE _)  => ();
            put_op (mcf::DEAD _)  => ();
            put_op _ => error "put_op";
        end;
        
         { start_new_cccomponent, 
           put_pseudo_op, 
           put_op, 
           get_completed_cccomponent=>fail, 
           put_private_label=>do_nothing, 
           put_public_label=>do_nothing, 
           put_comment=>do_nothing, 
           put_fn_liveout_info=>do_nothing, 
           put_bblock_note=>do_nothing, 
           get_notes
         };
        };
    };
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.            #
#  ^C @ ^T hides all Text. (Leaves all headings.)                        #
#  ^C @ ^A shows All of file.                                            #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)     #
#  ^C @ ^I shows Immediate children of node.                             #
#  ^C @ ^S Shows all of a node.                                          #
#  ^C @ ^D hiDes all of a node.                                          #
#  ^HFoutline-mode gives more details.                                   #
#  (Or do ^HI and read emacs:outline mode.)                              #
#                                                                        #
# Local variables:                                                       #
# mode: outline-minor                                                    #
# outline-regexp: "[{ \t]*\\(fun \\)"                                    #
# End:                                                                   #
##########################################################################
