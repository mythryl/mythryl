## architecture-description-language.grammar
#
#      "a simple tool for generating various modules in the
#       [...] code generator directly from architecture descriptions.
#       These descriptions contain architectural information such as:
#          1) How the the register file(s) are organized.
#          2) How instructions are encoded in machine code:
#          3) How instructions are pretty printed in assembly
#          4) How instructions are internally represented in MLRISC."
#
#                            -- http://www.cs.nyu.edu/leunga/MLRISC/Doc/html/mlrisc-md.html
#
# Surface syntax for our architecture description language. 
# It contains a large subset of SML, plus special extentions
# for describing machine instructions, primarily in the form
# of new qualifiers for constructors in datatype definitions,
# specialized to describe assembly language and machine instruction
# syntax and semantics. (We model an instruction set as a datatype
# with one constructor per instruction.)
#
# The parser we generate, with the help of the lexer
#
#     src/lib/compiler/back/low/tools/parser/architecture-description-language.lex
#
# reads an architecture description file such as
#
#     src/lib/compiler/back/low/intel32/intel32.architecture-description
#
# and returns a raw syntax tree as defined in
#
#     src/lib/compiler/back/low/tools/adl-syntax/adl-raw-syntax-form.api
#     src/lib/compiler/back/low/tools/adl-syntax/adl-raw-syntax-form.pkg
#
# which is then processed into internal form in
#
#     src/lib/compiler/back/low/tools/arch/architecture-description.pkg
#
# after which it drives the per-source-file code-generation packages
#
#     src/lib/compiler/back/low/tools/arch/make-sourcecode-for-machcode-xxx-package.pkg
#     src/lib/compiler/back/low/tools/arch/make-sourcecode-for-registerkinds-xxx-package.pkg
#     src/lib/compiler/back/low/tools/arch/make-sourcecode-for-translate-machcode-to-asmcode-xxx-g-package.pkg
#     src/lib/compiler/back/low/tools/arch/make-sourcecode-for-translate-machcode-to-execode-xxx-g-package.pkg
#     ...
#
# which generate corresponding compiler backend lowhalf packages such as
#
#     src/lib/compiler/back/low/intel32/code/machcode-intel32.codemade.api
#     src/lib/compiler/back/low/intel32/code/machcode-intel32-g.codemade.pkg
#     src/lib/compiler/back/low/intel32/code/registerkinds-intel32.codemade.pkg
#     src/lib/compiler/back/low/intel32/emit/translate-machcode-to-asmcode-intel32-g.codemade.pkg
#     src/lib/compiler/back/low/intel32/emit/translate-machcode-to-execode-intel32-g.codemade.pkg.unused
#     ...
#
#
#  There are 30 shift/reduce errors 

# Compiled by:
#     src/lib/compiler/back/low/tools/architecture-parser.lib

package lnd =  line_number_database;					# line_number_database		is from   src/lib/compiler/back/low/tools/line-number-db/line-number-database.pkg
package spp =  simple_prettyprinter;					# simple_prettyprinter		is from   src/lib/prettyprint/simple/simple-prettyprinter.pkg
package prp =  precedence_parser;					# precedence_parser		is from   src/lib/compiler/back/low/tools/precedence-parser/precedence-parser.pkg
package raw =  adl_raw_syntax_form;					# adl_raw_syntax_form		is from   src/lib/compiler/back/low/tools/adl-syntax/adl-raw-syntax-form.pkg
package rsu =  raw_syntax_unparser;					# raw_syntax_unparser		is from   src/lib/compiler/back/low/tools/adl-syntax/adl-raw-syntax-unparser.pkg


precedence_stacks
    =
    REF []:   Ref List  prp::Precedence_Stack;


fun new_scope precedence_stack
    =
    precedence_stacks := *precedence_stack ! *precedence_stacks;


fun old_scope  precedence_stack
    = 
    case *precedence_stacks
	#
	head ! tail =>  {   precedence_stack  := head;
			    precedence_stacks := tail;
			};

	_	    =>  raise exception FAIL "Compiler bug: Unsupported case in old_scope";
    esac;


fun infix_fn precedence_stack (p,[])
        =>
        ();

    infix_fn precedence_stack (p, id ! ids)
	=> 
	{   precedence_stack
                :=
                prp::declare (*precedence_stack, id, prp::INFIX p); 

	    infix_fn precedence_stack (p, ids);
	};
end;
    

fun infixr_fn precedence_stack (p,[])
        =>
        ();

    infixr_fn precedence_stack (p, id ! ids)
        => 
	{   precedence_stack
                :=
                prp::declare(*precedence_stack, id, prp::INFIXR p); 

	    infixr_fn precedence_stack (p, ids);
	};
end;

fun nonfix_fn precedence_stack ([])
        =>
        ();

    nonfix_fn precedence_stack (id ! ids)
	=> 
	{   precedence_stack
                :=
                prp::declare (*precedence_stack, id, prp::NONFIX); 

	    nonfix_fn precedence_stack ids;
	};
end;

fun p2s p   =   spp::prettyprint_expression_to_string (rsu::pattern p);
fun e2s e   =   spp::prettyprint_expression_to_string (rsu::expression e);

fun ps2s ps =   spp::prettyprint_expression_to_string (spp::CAT (map  rsu::pattern  ps));


fun boolean_expression b
    =
    raw::LITERAL_IN_EXPRESSION (raw::BOOL_LIT b);


fun precedence_error  err  loc  msg
    =
    err (loc, msg);


fun parse_expression  precedence_stack  err  loc  tokens
     =
     prp::parse { error =>   precedence_error err loc,
		  apply =>   raw::APPLY_EXPRESSION,
                  tuple =>   raw::TUPLE_IN_EXPRESSION,
                  id    =>   fn id =  raw::ID_IN_EXPRESSION( raw::IDENT([], id)),
                  stack =>  *precedence_stack,
                  to_string => e2s,
                  kind => "expression"
		}
                tokens;

fun parse_pattern precedence_stack err loc toks
    = 
    {   fun apply_pattern (raw::IDPAT id,          p) =>   raw::CONSPAT(raw::IDENT([], id), THE p);
	    apply_pattern (raw::CONSPAT(id, NULL), p) =>   raw::CONSPAT(id, THE p);
	    apply_pattern (p1,               p2) =>   {   err(loc, "pattern " + p2s p1 + " " + p2s p2);
                                                         p1;
                                                     };
        end;

	case (prp::parse
		 {   error => precedence_error err loc,
		     apply => apply_pattern,
		     tuple => raw::TUPLEPAT,
		     id    => raw::IDPAT,
		     stack =>  *precedence_stack,
		     kind  => "pattern",
		     to_string => p2s
		 }
                 toks
	    )

	    raw::CONSPAT(raw::IDENT([], "not"), THE p) => raw::NOTPAT p;
	    #
	    p => p;
	esac;     
    };

fun parse_function_pattern  precedence_stack  err  loc  toks
    = 
    {   fun pr (THE f, ps) =>   f + " " + ps2s ps;
	    pr(NULL, ps)  =>   ps2s ps;
        end;

	fun apply_pattern ((f, ps), (NULL, ps'))  =>   (f, ps @ ps');
	    apply_pattern ((f, ps), (THE g, ps')) =>   (f, ps @ [raw::IDPAT g] @ ps');
        end; 

	#  apply_pattern (p1, p2) => (err(loc, "fun pattern (" + pr p1 + ") " + pr p2); p1);

	fun lower (NULL, [p]) =>   p;
 	    lower (THE f,[] ) =>   raw::IDPAT f;
	    lower _           =>   raise exception FAIL "Compiler bug: Unsupported case in parse_function_pattern/lower.";
        end;

	fun tuple ps =   (NULL, [raw::TUPLEPAT(map lower ps)]);

	fun id n =   (THE n,[]);

	fun to_string (NULL,  ps) =>   ps2s ps;
	    to_string(THE f, ps) =>   f + " " + ps2s ps;
        end;

        prp::parse { error => precedence_error err loc,
		   apply => apply_pattern,
		   tuple,
		   id, 
		   stack =>  *precedence_stack,
		   kind => "function argument",
		   to_string
		  } (map (fn prp::EXP p => prp::EXP(NULL,[p]);
			     prp::ID id => prp::ID id;
                          end
			 ) toks);
    };


fun mark_declaration  line_number_db  (decl, left, right)						# Note in parsetree the source-code region for a declaration.
     = 
     raw::SOURCE_CODE_REGION_FOR_DECLARATION (lnd::location line_number_db (left, right), decl);

fun mark_expression  line_number_db  (expression, left, right)						# Note in parsetree the source-code region for an expression.
     = 
     raw::SOURCE_CODE_REGION_FOR_EXPRESSION (lnd::location line_number_db (left, right), expression);

exception BAD;  # Does this serve any purpose?

fun enum_pattern (err, loc, id, ps)
    = 
    map fn  raw::IDPAT x => raw::IDPAT(id + x) ;
            p            => {   err (loc, "bad pattern " + spp::prettyprint_expression_to_string (rsu::pattern p));
				p;
			    };
        end
	#
        ps;

fun enum_pattern' (err, loc, ps, id)
    = 
    map (fn raw::IDPAT x => raw::IDPAT(x + id) ;
                  p => { err(loc, "bad pattern " + spp::prettyprint_expression_to_string(rsu::pattern p)); p; };
         end 
                ) ps;
 
fun enum_expression (err, loc, id, es)
    = 
    map (fn raw::ID_IN_EXPRESSION(raw::IDENT ([], x)) => raw::ID_IN_EXPRESSION( raw::IDENT ([], id + x));
            e => { err(loc, "bad expression " + spp::prettyprint_expression_to_string(rsu::expression e)); e; };
         end
                ) es;

fun enum_expression' (err, loc, es, id)
    = 
    map  fn raw::ID_IN_EXPRESSION(raw::IDENT ([], x)) => raw::ID_IN_EXPRESSION (raw::IDENT ([], x + id));
                   e => { err(loc, "bad expression " + spp::prettyprint_expression_to_string(rsu::expression e)); e; };
         end

         es;

fun clause (pats, guard, exn, return_ty, e)
    = 
    {   e = case exn        NULL => e; THE x    => raw::MATCH_FAIL_EXCEPTION_IN_EXPRESSION (e, x);  esac;	# Some odd extension -- 'x' names an exception 'FOO', from surface syntax   <pattern> <guard> exception FOO => <expression>;
        e = case return_ty  NULL => e; THE type => raw::TYPED_EXPRESSION (e, type);                 esac;
	#
        raw::CLAUSE (pats, guard, e);
    };

fun seqdecl [d] => d;
    seqdecl ds  => raw::SEQ_DECL ds;
end;

fun idty (raw::IDENT ([], "unit")) => raw::TUPLETY [];
    idty x => raw::IDTY x;
end;

%%
%header ( generic package adl_parser_g (
	      package token:                      Token;
              package raw_syntax_unparser: 	  Adl_Raw_Syntax_Unparser;			# Adl_Raw_Syntax_Unparser		is from   src/lib/compiler/back/low/tools/adl-syntax/adl-raw-syntax-unparser.api
          )
        )

%arg	(line_number_db, err, an_import, precedence_stack, extra_cells) 
   :    ( lnd::Sourcemap,
	  ((lnd::Location, String) -> Void),
	  ((lnd::Location, String) -> List raw::Declaration),
	  Ref prp::Precedence_Stack,
	  List raw::Register_Set
	)

%name	Adl

# Define the grammar 'terminals' -- the tokens
# we actually get from the lexer in
#
#     src/lib/compiler/back/low/tools/parser/architecture-description-language.lex
#
# The _T suffix stands for "token", and serves to
# keep the token name "end_t" from conflicting with
# the reserved word "end" (etc).
#     
%term	ARCHITECTURE		# "architecture"
      | END_T			# "end"
      | LOCAL_T			# "local"
      | IN_T			# "in"
      | OF_T			# "of"
      | CASE_T			# "case"
      | DATATYPE		# "datatype"
      |	TYPE_T			# "type"
      | EQ			# "="
      | DOLLAR			# "$"
      | TIMES			# "*"
      | AND_T			# "and"
      | DEREF			# "!"
      | NOT			# "not"
      | MELD			# "^^"
      |	LLBRACKET		#			(The lexer appears not to actually generate this token.)
      | RRBRACKET		#			(The lexer appears not to actually generate this token.)
      | LHASHBRACKET		# "#["
      | LPAREN			# "("
      | RPAREN			# ")"
      | LBRACKET		# "["
      | RBRACKET		# "]"
      | LBRACE			# "{"
      | RBRACE			# "}"
      | SEMICOLON		# ";"
      | LDQUOTE			# ``
      | RDQUOTE			# ''
      | LMETA			# "<"
      | RMETA			# ">"
      | REGISTERSET		# "registerset"
      | FN_T			# "fn"
      | STORAGE			# "storage"
      | LOCATIONS		# "locations"
      | HASH			# "#"
      |	COMMA			# ","
      | COLON			# ":"
      | COLONGREATER		# ":>"
      | DOT			# "."
      | DOTDOT			# ".."			Used in bitslice notation: 'foo at [16..18]'  extracts 3 bits from foo -- same as one_word_unt::andb(one_word_unt::(>>)(foo, 0w16),0w7)
      | AT			# "at"			Used in bitslice notation: 'foo at [16..18]'  extracts 3 bits from foo -- same as one_word_unt::andb(one_word_unt::(>>)(foo, 0w16),0w7)
      | BAR			# "|"
      | ARROW			# "->"
      | DARROW			# "=>"
#     | PAR			#			(The lexer appears not to actually generate this token. The grammer never references it either.)
      | BITS			# "bits"
      | IF_T			# "if"
      | THEN_T			# "then"
      | ELSE_T			# "else"
      | TRUE			# "true"
      | FALSE			# "false"
      | WILD			# "_"
      | RAISE_T			# "raise"
      | EXCEPT_T		# "handle"		<===================
      | LET_T			# "let"
      | PACKAGE_T		# "structure"		<===================
      | GENERIC_T		# "functor"		<===================
      | API_T			# "signature"		<===================
      | BEGIN_API		# "sig"			<===================
      | STRUCT			# "struct"
      | WHERE_T			# "where"
      | SHARING_T		# "sharing"
      | INSTRUCTION		# "instruction"
      | BASE_OP			# "base_op"
      | REGISTER		# "register"
      | CELL			# "cell"
      | CELLS			# "cells"
      | ORDERING		# "ordering"
      | FIELD_T			# "field"
      | FIELDS			# "fields"
      | SIGNED			# "signed"
      | UNSIGNED		# "unsigned"
      | FORMATS			# "formats"
      | AS_T			# "as"
      | ENCODING		#			(The lexer appears not to actually generate this token.)
      | WITHTYPE_T		# "withtype"
      | FUN_T			# "fun"
      | MY_T			# "val"			<===================
      | INCLUDE_T		# "include"
      | OPEN			# "open"
      | OP_T			# "op"
      | LITTLE			# "little"
      | BIG			# "big"
      | ENDIAN			# "endian"
      | PIPELINE		# "pipeline"
#     | PREDICATED		# "predicated"		(The grammer never references this.)
      | LOWERCASE		# "lowercase"
      | UPPERCASE		# "uppercase"
      | VERBATIM		# "verbatim"
#     | WHEN			# 			(The lexer appears not to actually generate this token. The grammer never references it either.)
#     | BRANCHING		# 			(The lexer table entry for this is commented out.) 
#     | TAKEN			#  			(The lexer appears not to actually generate this token. The grammer never references it either.)
      | ASSEMBLY		# "assembly"
      | RTL			# "rtl"
      | SPAN			# "span"
      | DEPENDENT		# "dependent"
#     | ASSIGN			#   			(The lexer appears not to actually generate this token. The grammer never references it either.)
      | DELAYSLOT		# "delayslot"
#     | FORWARDS		#    			(The lexer appears not to actually generate this token.)
      | ALWAYS			# "always"		(Synonym for 'true')
      | NEVER			# "never"		(Synonym for 'false')
#     | BACKWARDS		#    			(The lexer appears not to actually generate this token.)
#     |	CANDIDATE		# "candidate"
      | NONFIX_T		# "nonfix"
      | INFIX_T			# "infix"
      | INFIXR_T		# "infixr"
      | DEBUG_T			# "debug"
      | ASM_COLON		# "asm:"
      | MC_COLON		# "mc:"
      | RTL_COLON		# "rtl:"
      | DELAYSLOT_COLON		# "delayslot:"
      | NULLIFIED_COLON		# "nullified:"
      | PADDING_COLON		# "padding:"
      | CANDIDATE_COLON		# "candidate:"
      | AGGREGABLE		# "aggregable"
      | ALIASING		# "aliasing"
      | RESOURCE		# "resource"
      | CPU			# "cpu"
#     | RESERVATION		# "reservation"
#     | TABLE			# "table"
      | LATENCY			# "latency"
#     | EQUATION		# "equation"
      | EXCEPTION_T		# "exception"
      |	ID of String		# [A-Za-z_][A-Za-z0-9_\']*
      |	SYMBOL of String	# (\-|[=+~/*:!@#$%^&*|?<>])+|``|''
      |	TYVAR of String		# '[A-Za-z_][A-Za-z0-9_\']*
      |	UNT of one_word_unt::Unt
      |	INT of Int
      |	INTEGER of multiword_int::Int
      |	REAL_T of String	# (-?)[0-9]+\.[0-9]+(e(-?)[0-9]+)?
      |	STRING_T of String	# \"([^\\\n\t"]|\\.)*\"
      |	CHAR_T of Char		# #\"([^\\\n\t"]|\\.)*\"
      |	ASMTEXT_T of String	# [^\n\t<>']+|'    -- by default, introduced by ``...'' quotes.
      |	EOF_T			# Actual end-of-file.

%nonterm architecture of List raw::Declaration
       | structexp of raw::Package_Exp
       | sigcon of raw::Package_Cast
       | opt_of of Void
       | id of raw::Id
       | sym of raw::Id
       | symb of raw::Id
       | ident of raw::Ident
       | ident2 of raw::Ident
       | tid of raw::Id
       | tid2 of raw::Id
       | tident of raw::Ident
       | tpath of ((List raw::Id), raw::Id)
       | idents of List raw::Ident
       | syms of List raw::Id
       | path of List raw::Id
       | decls of List raw::Declaration
       | scopeddecls of List raw::Declaration
       | genericarg of List raw::Declaration
       | scopedmldecls of List raw::Declaration
       | new_scope of Void
       | old_scope of Void
       | mldecls of List raw::Declaration
       | exception_def of raw::Exception
       | exception_defs of List raw::Exception
       | decl of raw::Declaration
#       | locdecl of (raw::Loc, raw::Declaration)
#       | loc of raw::Loc
       | mldecl of raw::Declaration
       | mymldecl of raw::Declaration
       | mddecl of raw::Declaration
       | mymddecl of raw::Declaration
       | sharingdecl of raw::Share
       | sharingdecls of List raw::Share
       | sharelist of List raw::Ident
       | aexp of raw::Expression
       | aexp2 of prp::Token raw::Expression
       | appexp of List prp::Token raw::Expression
       | expression of raw::Expression
       | typedexp of raw::Expression
       | guard of Null_Or raw::Expression
       | funguard of Null_Or raw::Expression
       | cont of Null_Or raw::Id
       | region of Null_Or raw::Id
       | opt_exp of Null_Or raw::Expression
       | exps of List raw::Expression
       | exps1 of List raw::Expression
       | exps2 of List raw::Expression
       | expseq of List raw::Expression
       | expseq2 of List raw::Expression
       | label_expressions0 of List( (raw::Id, raw::Expression) )
       | label_expressions of List( (raw::Id, raw::Expression) )
       | label_expression of (raw::Id, raw::Expression )
       | apat of raw::Pattern
       | asapat of raw::Pattern
       | apat2 of prp::Token raw::Pattern
       | apppat of List prp::Token raw::Pattern
       | pattern of raw::Pattern
       | typedpat of raw::Pattern
       | pats of List raw::Pattern
       | pats1 of List raw::Pattern
       | pats2 of List raw::Pattern
       | orpats2 of List raw::Pattern
       | andpats2 of List raw::Pattern
       | labpat of (raw::Id, raw::Pattern)
       | labpats0 of (List( (raw::Id, raw::Pattern) ), Bool)
       | labpats of (List( (raw::Id, raw::Pattern) ), Bool)
       | of_ty of Null_Or raw::Type
       | ty of raw::Type
       | return_ty of Null_Or raw::Type
       | aty of raw::Type
       | appty of raw::Type
       | tys2 of List raw::Type
       | labty of (raw::Id, raw::Type)
       | labtys of List( (raw::Id, raw::Type) )
       | labtys1 of List( (raw::Id, raw::Type) )
       | tuplety of List raw::Type
       | signedness of raw::Signedness
       | unt of one_word_unt::Unt
       | unsignedint of one_word_unt::Unt
       | maybe_value of Null_Or one_word_unt::Unt
       | maybe_width of raw::Width
       | int of Int
       | intopt of Int
       | integer of multiword_int::Int
       | real of String
       | endian of raw::Endian
       | string of String
       | char of Char
       | bool of Bool
       | literal of raw::Literal
       | slice of (Int, Int)
       | slices of List( (Int, Int) )
       | storagedecl of raw::Register_Set
       | aliasing of Null_Or raw::Id
       | printcell of raw::Expression
       | storagedecls of List raw::Register_Set
       | cellcount of Null_Or Int
       | special_register of raw::Special_Register
       | special_registers of List raw::Special_Register
       | fieldx of raw::Instruction_Bitfield
       | field_id of raw::Id
       | maybe_cnv of raw::Cnv
       | fields of List raw::Instruction_Bitfield
       | instruction_format of raw::Instruction_Format
       | instruction_formats of List raw::Instruction_Format
       | datatypes of List raw::Datatype
       | datatype of raw::Datatype
       | constructors of List raw::Constructor
       | constructor of raw::Constructor
       | consencoding of Null_Or raw::Mc
       | maybe_sdi of Null_Or raw::Expression
       | maybe_latency of Null_Or raw::Expression
       | maybe_pipeline of Null_Or raw::Expression
       | nop of raw::Flag
       | flag of raw::Flag
       | flagguard of raw::Expression
       | nullified of raw::Flag
       | delayslot of Null_Or raw::Expression
       | delayslot_candidate of Null_Or raw::Expression
#       | delay of raw::Delayslot
#       | branching of raw::Branching
       | consassembly of Null_Or raw::Assembly
       | type_aliases of List raw::Type_Alias
       | withtypeclause of List raw::Type_Alias
       | type_alias of raw::Type_Alias
       | typevariable of raw::Typevar_Ref
       | type_variables of List raw::Typevar_Ref
       | typevar_seq of List raw::Typevar_Ref
       | clause of raw::Clause
       | clauses of List raw::Clause
       | funclause of (raw::Id, raw::Clause)
       | funclauses of (raw::Id, List raw::Clause)
       | function of raw::Fun
       | functions of List raw::Fun
       | named_value of raw::Named_Value
       | named_values of List raw::Named_Value
       | assemblycase of raw::Assemblycase
       | rtl of Null_Or raw::Expression
       | rtlterm of raw::Rtlterm
       | rtlterms of List raw::Rtlterm
       | opcode_encoding of Null_Or List Int
       | encoding_exp of List Int
       | encoding_exps of List Int
       | field_type of Null_Or raw::Id
       | asms of List raw::Asm
       | asm_strings of List raw::Asm
       | asm of raw::Asm
       | has_asm of Bool
       | sigsub of raw::Api_Exp -> raw::Api_Exp
       | sigsubs of raw::Api_Exp -> raw::Api_Exp
       | api_expression of raw::Api_Exp
       | true of Void
       | false of Void
       | default of (Int, raw::Expression)
       | default_list of List( (Int, raw::Expression))
       | defaults of List( (Int, raw::Expression))
       | aggregable of Bool
       | bitsize of (Int, Bool)
       | resourcebinds of List raw::Id
       | cpus of List raw::Cpu
       | cpu of raw::Cpu
       | aliases of List String
       | resources of List( (Int, raw::Id) )
       | resource of (Int, raw::Id)
       | pipelines of List raw::Pipeline
       | pipeline of raw::Pipeline
       | pipelineclauses of List( (raw::Id, raw::Pattern, raw::Pipeline_Cycles) )
       | pipelineclause of (raw::Id, raw::Pattern, raw::Pipeline_Cycles)
       | maybe_pipeline_cycles of List raw::Pipeline_Cycle
       | pipeline_cycles of List raw::Pipeline_Cycle
       | pipeline_cycle of raw::Pipeline_Cycle 
       | latencies of List raw::Latency
       | latency of raw::Latency
       | latency_clauses of List( (raw::Id, raw::Pattern, raw::Expression) )
       | latency_clause of (raw::Id, raw::Pattern, raw::Expression)
       | optsemi of Void


%verbose
%nodefault
%pos Int
%eop EOF_T

%left DARROW 
%left IF_T THEN_T ELSE_T RAISE_T EXCEPT_T CASE_T FN_T OF_T SEMICOLON COMMA
%left DOT
%left EQ
%right ARROW 
%left AT
%left TIMES
%left DEREF NOT
/* %left BITS CELL */
/* %left BAR
%left AND_T*/

/*%left DARROW */

%%

architecture:	decls						(decls)

decls:			  					([])
|		decl decls					(decl ! decls)

mldecls:							([])
|		mldecl mldecls					(mldecl ! mldecls)

optsemi:							()
|		SEMICOLON optsemi				()

decl:		mldecl optsemi					(mldecl)	# Standard SML syntax declarations.
|		mddecl optsemi					(mddecl)	# Special Architecture-Description declarations.
|		INCLUDE_T string optsemi			(seqdecl  (an_import  (lnd::location  line_number_db  (include_tleft, stringright), string)))

mldecl:		mymldecl					(mark_declaration line_number_db (mymldecl, mymldeclleft, mymldeclright))
mddecl: 	mymddecl					(mark_declaration line_number_db (mymddecl, mymddeclleft, mymddeclright))

mymddecl:	ARCHITECTURE id EQ STRUCT decls END_T		(raw::ARCHITECTURE_DECL (id, decls))
#
|		LITTLE ENDIAN					(raw::BIG_VS_LITTLE_ENDIAN_DECL raw::LITTLE)
|		BIG ENDIAN					(raw::BIG_VS_LITTLE_ENDIAN_DECL raw::BIG)
#
|		assemblycase ASSEMBLY				(raw::ASSEMBLY_CASE_DECL assemblycase) 
#
|		INSTRUCTION FORMATS int BITS instruction_formats 	(raw::INSTRUCTION_FORMATS_DECL (THE int, instruction_formats))
|		INSTRUCTION FORMATS          instruction_formats	(raw::INSTRUCTION_FORMATS_DECL (NULL,    instruction_formats))
#
|		STORAGE storagedecls				(raw::REGISTERS_DECL(storagedecls @ extra_cells))
|		LOCATIONS special_registers			(raw::SPECIAL_REGISTERS_DECL special_registers)
|		BASE_OP constructors				(raw::BASE_OP_DECL constructors)
|		DEBUG_T id					(raw::DEBUG_DECL id)
|		RESOURCE resourcebinds				(raw::RESOURCE_DECL resourcebinds)
|		CPU cpus					(raw::CPU_DECL cpus)
|		PIPELINE pipelines				(raw::PIPELINE_DECL pipelines)
|		LATENCY latencies				(raw::LATENCY_DECL latencies)

resourcebinds: 	id						([id])
|		id AND_T resourcebinds 				(id ! resourcebinds)

cpus:		cpu						([cpu])
|		cpu AND_T cpus					(cpu ! cpus)

cpu:		id aliases int LBRACKET resources RBRACKET	(raw::CPU { name => id, aliases, max_issues => int, resources => resources})

aliases:        						([])
|		string aliases					(string ! aliases)

resources:	resource					([resource])
|		resource COMMA resources			(resource ! resources)

resource:	int id						(int, id)
|		id						(1, id)

pipelines:	pipeline					([pipeline])
|		pipeline AND_T pipelines 			(pipeline ! pipelines)

pipeline:	pipelineclauses					( {   name = #1 (head pipelineclauses);
								      #		
								      clauses = map (fn (_, x, y) =  (x, y))
										    pipelineclauses;
								      #		
								      (raw::PIPELINE (name, clauses));
								  }
								)

pipelineclauses:	pipelineclause				([pipelineclause])
|			pipelineclause BAR pipelineclauses	(pipelineclause ! pipelineclauses)

pipelineclause:	id
		pattern
		EQ
		LBRACKET maybe_pipeline_cycles RBRACKET		(id, pattern, raw::PIPELINE_CYCLES maybe_pipeline_cycles) 

maybe_pipeline_cycles:						([])
|		pipeline_cycles					(pipeline_cycles)

pipeline_cycles:
		pipeline_cycle					([pipeline_cycle])
|		pipeline_cycle COMMA pipeline_cycles		(pipeline_cycle ! pipeline_cycles)

pipeline_cycle:	id		  				(raw::ID_CYCLE id)
|		pipeline_cycle MELD pipeline_cycle		(raw::OR_CYCLE (pipeline_cycle1, pipeline_cycle2))
|		pipeline_cycle TIMES int 			(raw::REPEAT_CYCLE (pipeline_cycle, int))
|		LPAREN pipeline_cycle RPAREN			(pipeline_cycle)

latencies:	latency						([latency])
|		latency AND_T latencies 			(latency ! latencies)

latency:	latency_clauses 				( {   name = #1 (head latency_clauses);
								      #
								      clauses = map (fn (_, x, y) =  (x, y))
										    latency_clauses;
								      #
								      (raw::LATENCY (name, clauses));
								  }
								)

latency_clauses:
		latency_clause					([latency_clause])
|		latency_clause BAR latency_clauses		(latency_clause ! latency_clauses)

latency_clause:	id pattern EQ expression			(id, pattern, expression)

mymldecl:	DATATYPE datatypes withtypeclause 		(raw::DATATYPE_DECL (datatypes, withtypeclause))
|		TYPE_T type_aliases				(raw::DATATYPE_DECL ([], type_aliases))
|		FUN_T functions					(raw::FUN_DECL functions)
|		RTL id LBRACE labpats0 RBRACE EQ expression	(raw::RTL_DECL( raw::IDPAT id,
										raw::FN_IN_EXPRESSION [raw::CLAUSE([raw::RECORD_PATTERN labpats0], NULL, expression)],
										lnd::location  line_number_db  (rtlleft, expressionright)
									      )
								)
|		RTL asapat EQ expression			(raw::RTL_DECL(asapat, expression, lnd::location line_number_db (rtlleft, expressionright)))
|		RTL syms COLON ty				(raw::RTL_SIG_DECL (syms, ty))
|		MY_T named_values				(raw::VAL_DECL (named_values ))
|		MY_T syms COLON ty				(raw::VALUE_API_DECL (syms, ty))
|		TYPE_T typevar_seq tid				(raw::TYPE_API_DECL (tid, typevar_seq))
|		LOCAL_T scopeddecls IN_T scopeddecls END_T 	(raw::LOCAL_DECL (scopeddecls1, scopeddecls2))
|		PACKAGE_T id EQ structexp 			(raw::PACKAGE_DECL (id,[], NULL, structexp))
|		PACKAGE_T id sigcon EQ structexp 		(raw::PACKAGE_DECL (id,[], THE sigcon, structexp))
|		PACKAGE_T id COLON api_expression		(raw::PACKAGE_API_DECL (id, api_expression))
|		API_T id EQ api_expression			(raw::API_DECL (id, api_expression))

|		GENERIC_T id LPAREN genericarg RPAREN
                             EQ structexp			(raw::PACKAGE_DECL(id, genericarg, NULL, structexp))

|		GENERIC_T id LPAREN genericarg RPAREN sigcon
                             EQ structexp			(raw::PACKAGE_DECL(id, genericarg, THE sigcon, structexp))

|		GENERIC_T id EQ structexp 			(raw::GENERIC_DECL(id,[], NULL, structexp))

|		SHARING_T sharingdecls				(raw::SHARING_DECL sharingdecls)
|		INFIX_T intopt syms				({ infix_fn precedence_stack (intopt, syms);   raw::INFIX_DECL (intopt, syms);})
|		INFIXR_T intopt syms				({ infixr_fn precedence_stack (intopt, syms); raw::INFIXR_DECL(intopt, syms);})
|		NONFIX_T syms					({ nonfix_fn precedence_stack (syms);                raw::NONFIX_DECL(        syms);})
|		OPEN idents					(raw::OPEN_DECL(idents))
|		INCLUDE_T api_expression			(raw::INCLUDE_API_DECL api_expression)
|		EXCEPTION_T exception_defs			(raw::EXCEPTION_DECL exception_defs)

exception_defs: exception_def					([exception_def])
|		exception_def AND_T exception_defs		(exception_def ! exception_defs)

exception_def:	id 						(raw::EXCEPTION (id, NULL))
|		id OF_T ty					(raw::EXCEPTION (id, THE ty))
|		id EQ ident					(raw::EXCEPTION_ALIAS (id, ident))


genericarg:	scopeddecls					(scopeddecls)
|		id sigcon					([raw::GENERIC_ARG_DECL(id, sigcon)])

api_expression:	ident						(raw::ID_API ident)
|		BEGIN_API decls END_T				(raw::DECLARATIONS_API decls)
|		api_expression WHERE_T sigsubs 			(sigsubs api_expression)

sigcon:		COLON        api_expression			( { abstract => FALSE, api_expression => api_expression})
|		COLONGREATER api_expression			( { abstract => TRUE,  api_expression => api_expression})

sigsubs:	sigsub						(sigsub)
|		sigsub AND_T sigsubs				(sigsub o sigsubs)

sigsub:		TYPE_T ident EQ ty				(fn s =  raw::WHERETYPE_API(s, ident, ty))
|		ident EQ structexp				(fn s =  raw::WHERE_API(s, ident, structexp))

sharingdecls:	sharingdecl					([sharingdecl])
|		sharingdecl AND_T sharingdecls			(sharingdecl ! sharingdecls)

sharingdecl:	TYPE_T sharelist				(raw::TYPE_SHARE sharelist)
|		sharelist					(raw::PACKAGE_SHARE sharelist)

sharelist:	ident EQ ident					([ident1, ident2])
|		ident EQ sharelist				(ident ! sharelist)

scopedmldecls:	new_scope mldecls old_scope			(mldecls)

scopeddecls:	new_scope decls old_scope			(decls)

new_scope:							(new_scope precedence_stack)
old_scope:							(old_scope precedence_stack)

syms:		sym						([sym])
|		sym syms					(sym ! syms)

idents:		ident						([ident])
|		ident idents					(ident ! idents)

assemblycase:	LOWERCASE					(raw::LOWERCASE)
|		UPPERCASE					(raw::UPPERCASE)
|		VERBATIM					(raw::VERBATIM)

rtl:		RTL_COLON expression				(THE expression)
|								(NULL)

rtlterms:	rtlterm						([rtlterm])
|		rtlterm rtlterms				(rtlterm ! rtlterms)

rtlterm:	string						(raw::LITRTL string)
|		sym						(raw::IDRTL sym)
|		HASH id 					(raw::COMPOSITERTL id)

structexp:	ident						(raw::IDSEXP ident)
|		STRUCT scopeddecls END_T			(raw::DECLSEXP scopeddecls)
|		structexp LPAREN scopeddecls RPAREN 		(raw::APPSEXP(structexp, raw::DECLSEXP scopeddecls))
|		structexp LPAREN ident RPAREN			(raw::APPSEXP(structexp, raw::IDSEXP ident))

datatypes:	datatype					([datatype])
|		datatype AND_T datatypes			(datatype ! datatypes)


datatype:	typevar_seq									# Optional explicit type variable declarations. Never used in practice.
                id										# Name of datatype.
                opcode_encoding									# [12..13] or such.
                field_type									# : Foo
                has_asm										# !    -- special flag triggering synthesis of asmcode functions mapping constructors FOO | BAR ... to "foo" | "bar" ...
                EQ
		constructors 					( {   asm = has_asm
									    or
									    list::exists fn raw::CONSTRUCTOR { asm => THE _, ... } =>  TRUE;
											    _                                      =>  FALSE;
											 end
											 constructors;

								      raw::DATATYPE
								        { name => id,
									  type_variables => typevar_seq,
									  mc => opcode_encoding,
									  asm,
									  field' => field_type,
									  cbs => constructors
									};
								  }
								)

|		typevar_seq
		id
		opcode_encoding
		field_type
		has_asm
		EQ DATATYPE ty					(raw::DATATYPE_ALIAS { name => id, type_variables => typevar_seq, type => ty})

has_asm:	DEREF						(TRUE)				# !    -- special flag triggering synthesis of asmcode functions mapping constructors FOO | BAR ... to "foo" | "bar" ...
|								(FALSE)

field_type:							(NULL)
|		COLON id					(THE id)

opcode_encoding:						(NULL)
|		LBRACKET encoding_exps RBRACKET			(THE encoding_exps)

encoding_exps:	encoding_exp					(encoding_exp)
|		encoding_exp COMMA encoding_exps		(encoding_exp @ encoding_exps)

encoding_exp:	int						([int])

|		int DOTDOT int					( {   fun f i =   if (i > int2)   [];
                                                                                  else            i ! f(i+1);
                                                                                  fi;
								      f int1;
								  }
								)

|		int int DOTDOT int				(  {   inc = int2 - int1;
								       #	
								       fun f i =   if (i > int3)   [];
										   else            i ! f(i+inc);
										   fi;
								       f int1;
								   }
								)

constructors:
		constructor					([constructor])
|		constructor BAR constructors			(constructor ! constructors)

constructor:
		sym
		of_ty
		consassembly
		consencoding
		rtl
		nop 
		nullified
		delayslot
		delayslot_candidate
		maybe_sdi
                maybe_latency
		maybe_pipeline					( {  cand = case delayslot_candidate
										#
										THE _ => delayslot_candidate;
										#
										_     => case (nop, nullified)
										             (raw::FLAGOFF, raw::FLAGOFF) =>  NULL;
										             _                            =>  (THE (boolean_expression FALSE));
										         esac;
									    esac;

								    raw::CONSTRUCTOR
								      { name => sym,
									type => of_ty,
									mc => consencoding,		# Binary   encoding of the instruction, if the constructor represents a machine instruction.
									asm => consassembly,		# Assembly encoding of the instruction, if the constructor represents a machine instruction.
									rtl,				# RTL semantics     of the instruction, if the constructor represents a machine instruction.
									nop,
									sdi => maybe_sdi,
									nullified, 
									delayslot,
									delayslot_candidate => cand,
									latency  => maybe_latency,
									pipeline => maybe_pipeline,
									loc => lnd::location line_number_db (symleft, maybe_sdiright)
								      };
								 }
								)

maybe_latency:	LATENCY COLON expression			(THE expression)
|								(NULL)	

maybe_pipeline:
		PIPELINE COLON expression			(THE expression)
|								(NULL)	

delayslot_candidate:						(NULL)					# Instruction is not a candidate to fill a delay slot.
|	DELAYSLOT CANDIDATE_COLON expression			(THE expression)

of_ty:								(NULL)
|		OF_T ty						(THE ty)

nop:								(raw::FLAGOFF)
|		PADDING_COLON flag				(flag)
|		PADDING_COLON false				(raw::FLAGOFF)
|		PADDING_COLON true				(raw::FLAGON)

true:		TRUE						()
|		ALWAYS						()

false:		FALSE						()
|		NEVER						()

flag:		id          flagguard				(raw::FLAGID (id, TRUE,  flagguard))
|		NOT id      flagguard				(raw::FLAGID (id, FALSE, flagguard))
|		id EQ true  flagguard 				(raw::FLAGID (id, TRUE,  flagguard))
|		id EQ false flagguard				(raw::FLAGID (id, FALSE, flagguard))

flagguard:							(boolean_expression TRUE)
|		AND_T expression				(expression)

nullified:							(raw::FLAGOFF)
|		NULLIFIED_COLON FALSE				(raw::FLAGOFF)
|		NULLIFIED_COLON flag				(flag)

delayslot:      						(NULL)
|		DELAYSLOT_COLON expression			(THE expression)

# branching:	BRANCHING FORWARDS				(raw::BRANCHFORWARDS)
# |		BRANCHING BACKWARDS				(raw::BRANCHBACKWARDS)
	
maybe_sdi:							(NULL)
|		SPAN DEPENDENT expression			(THE expression)

consencoding:							(NULL)
|		unsignedint					(THE(raw::WORDMC(unsignedint)))
|		LPAREN expseq RPAREN				(THE(raw::EXPMC(raw::SEQUENTIAL_EXPRESSIONS expseq)))
|		LPAREN exps2 RPAREN				(THE(raw::EXPMC(raw::TUPLE_IN_EXPRESSION exps2)))

|		id LBRACE label_expressions0 RBRACE		(THE(raw::EXPMC(raw::APPLY_EXPRESSION (raw::ID_IN_EXPRESSION (raw::IDENT([], id)),
									raw::RECORD_IN_EXPRESSION label_expressions0))))

|		MC_COLON expression 				(THE(raw::EXPMC expression))

# Here we're defining the assembly code for an instruction.
# The surface syntax looks like one of
#     | INSTRUCTION_FOO ``this and <that> and <tother>'' -- the most general case
#     | INSTRUCTION_FOO asm: "that"                      -- equivalent to INSTRUCTION_FOO ``<that>''
#     | INSTRUCTION_FOO "this"
# In the general case the <brokets> become raw::EXPASM clauses
# and the remaining running text   becomes raw::TEXT_ASM clauses.
# The raw::TEXT_ASM stuff is straight text, the raw::EXPASM
# is text-valued expressions which we'll compute when we actually
# generate the assembly code.
#
consassembly:							(NULL)
|		string						(THE (raw::STRINGASM string))
|		asm_strings					(THE (raw::ASMASM asm_strings))
|		ASM_COLON expression				(THE (raw::ASMASM [raw::EXPASM expression]))

asm_strings:
 	LDQUOTE asms RDQUOTE					(asms)
|	LDQUOTE asms RDQUOTE asm_strings			(asms @ asm_strings)

asms:	asm 							([asm])
|	asm asms						(asm ! asms)

asm:	 	LMETA expression RMETA				(raw::EXPASM expression)
|		ASMTEXT_T					(raw::TEXTASM asmtext_t)

opt_of:								()
|		OF_T						()

withtypeclause:							([])
|		WITHTYPE_T type_aliases				(type_aliases)


type_aliases:	type_alias					([type_alias])
|		type_alias AND_T type_aliases			(type_alias ! type_aliases)

type_alias:	typevar_seq tid EQ ty				(raw::TYPE_ALIAS (tid, typevar_seq, ty))

typevar_seq:							([])
|		typevariable					([typevariable])
|		LPAREN type_variables RPAREN			(type_variables)

type_variables:		typevariable				([typevariable])
|		typevariable COMMA type_variables		(typevariable ! type_variables)

instruction_formats:
		instruction_format				([instruction_format])

|		instruction_format
		BAR
		instruction_formats				(instruction_format ! instruction_formats)

# Define one binary execode
# instruction format for this architecture:
#
instruction_format:
		id
		opt_of
		LBRACE fields RBRACE opt_exp			(raw::INSTRUCTION_FORMAT (id, fields, opt_exp))

opt_exp:							(NULL)
|		EQ expression					(THE expression)

fields:		fieldx						([fieldx])
|		fieldx COMMA fields				(fieldx ! fields)

fieldx:		field_id
		COLON
		maybe_cnv
		signedness
		maybe_width
		maybe_value	 				(raw::INSTRUCTION_BITFIELD { id => field_id, cnv => maybe_cnv, width => maybe_width, sign => signedness, value => maybe_value})

|		id 						(raw::INSTRUCTION_BITFIELD { id, cnv => raw::NOCNV, width => raw::WIDTH 0, sign => raw::UNSIGNED, value => NULL})

field_id:	id						(id)
|		WILD						("")

maybe_cnv:							(raw::NOCNV)
|		id						(raw::FUNCNV id)
|		DOLLAR id					(raw::CELLCNV id)

maybe_width:							(raw::WIDTH 0)
|		int						(raw::WIDTH int)
|		int DOTDOT int					(raw::RANGE(int1, int2))

unsignedint:	int						(one_word_unt::from_int int)
|		unt						(unt)

maybe_value:							(NULL)
|		EQ unsignedint					(THE unsignedint)

signedness:	SIGNED						(raw::SIGNED)
|		UNSIGNED					(raw::UNSIGNED)
|								(raw::UNSIGNED)

functions:	function					([function])
|		function AND_T functions			(function ! functions)

function:	funclauses					(raw::FUN funclauses)

named_values:	named_value					([named_value])
|		named_value AND_T named_values			(named_value ! named_values)

# 'named_value' is a bit of a misnomer here,
# since 'pattern' can bind multiple names
# to values:
#
named_value:	pattern EQ typedexp				(raw::NAMED_VARIABLE (pattern, typedexp))

literal:	unt						(raw::UNT1_LIT unt)
|		int						(raw::INT_LIT int)	
|		integer						(raw::INTEGER_LIT integer)	
|		string						(raw::STRING_LIT string)	
|		char						(raw::CHAR_LIT char)	
|		bool						(raw::BOOL_LIT bool)	
|		real						(raw::FLOAT_LIT real)	

aexp:		literal						(raw::LITERAL_IN_EXPRESSION literal)
|		ident2						(raw::ID_IN_EXPRESSION ident2)
|		HASH id						(raw::TYPE_IN_EXPRESSION (raw::TYVARTY(raw::INTTV id))) 
|		OP_T symb					(raw::ID_IN_EXPRESSION (raw::IDENT ([], symb)))
|		LPAREN symb RPAREN				(raw::ID_IN_EXPRESSION (raw::IDENT ([], symb)))
/* |		LPAREN expression COLON ty RPAREN		(raw::TYPED_EXPRESSION (expression, ty))*/
|		asm_strings 					(raw::ASM_IN_EXPRESSION (raw::ASMASM asm_strings))
|		LPAREN RPAREN					(raw::TUPLE_IN_EXPRESSION [])
|		LPAREN typedexp RPAREN				(typedexp)
|		LPAREN exps2 RPAREN				(raw::TUPLE_IN_EXPRESSION exps2)
|		LPAREN expseq2 RPAREN				(raw::SEQUENTIAL_EXPRESSIONS expseq2)
|		LBRACKET exps RBRACKET				(raw::LIST_IN_EXPRESSION (exps, NULL))
|		LHASHBRACKET exps RBRACKET			(raw::VECTOR_IN_EXPRESSION exps)
|		LBRACE label_expressions0 RBRACE		(raw::RECORD_IN_EXPRESSION label_expressions0)
|		DOLLAR id LBRACKET expression region RBRACKET	(raw::REGISTER_IN_EXPRESSION (id, expression, region))
|		LLBRACKET rtlterms RRBRACKET			(raw::RTL_IN_EXPRESSION (rtlterms))				# Can't happen -- the lexer does not currently produce LLBRACKET or RRBRACKET.

|		sym MELD LBRACKET exps RBRACKET 		(   {   loc = lnd::location line_number_db (symleft, rbracketright);
									#
								        raw::LIST_IN_EXPRESSION (enum_expression (err, loc, sym, exps), NULL);
								    }
								)

|		LBRACKET exps RBRACKET MELD sym			(   {   loc = lnd::location line_number_db (symleft, rbracketright);
									# 	
								        raw::LIST_IN_EXPRESSION (enum_expression'(err, loc, exps, sym), NULL);
								    }
								)

|		sym MELD LBRACKET exps RBRACKET MELD sym	(   {   loc = lnd::location line_number_db (symleft, rbracketright);
									#
								        raw::LIST_IN_EXPRESSION (enum_expression'(err, loc, enum_expression (err, loc, sym1, exps), sym2), NULL); 
								    }
								)

|		LET_T decls IN_T expseq END_T			(raw::LET_EXPRESSION (decls, expseq))

region:								(NULL)
|	COLON id						(THE id) 

aexp2:
    aexp							(prp::EXP aexp)
  | sym								(prp::ID sym)
  | EQ								(prp::ID "=")

  | aexp2 AT LBRACKET slices RBRACKET				(   prp::EXP(
									raw::BITFIELD_IN_EXPRESSION
									  (
									    case aexp2
										#
										prp::EXP e =>  e;
										prp::ID x  =>  raw::ID_IN_EXPRESSION (raw::IDENT ([], x));
									    esac,

									    slices
									  )
								    )
								)

label_expressions0:						([])
|		label_expressions				(label_expressions)

label_expressions:	label_expression			([label_expression])
|		label_expression COMMA label_expressions	(label_expression ! label_expressions)

label_expression:	id EQ typedexp				(id, typedexp)
|		id						(id, raw::ID_IN_EXPRESSION (raw::IDENT ([], id)))

appexp:		aexp2						([aexp2])
|		appexp aexp2					(appexp @ [aexp2])

expression: 	appexp						(parse_expression precedence_stack err 
                 (lnd::location line_number_db			(appexpleft, appexpright)) appexp)
|		IF_T typedexp THEN_T typedexp ELSE_T expression	(raw::IF_EXPRESSION(typedexp1, typedexp2, expression))
|		CASE_T typedexp OF_T clauses			(raw::CASE_EXPRESSION(typedexp, clauses))
|		FN_T clauses					(raw::FN_IN_EXPRESSION clauses)
|		expression EXCEPT_T clauses			(raw::EXCEPT_EXPRESSION(expression, clauses))
|		RAISE_T expression				(raw::RAISE_EXPRESSION expression)

typedexp:	expression					(expression)
|		typedexp COLON ty 				(raw::TYPED_EXPRESSION(typedexp, ty))

expseq:		typedexp					([typedexp])
|		typedexp SEMICOLON expseq			(typedexp ! expseq)

expseq2:	typedexp SEMICOLON expseq			(typedexp ! expseq)

exps1:		typedexp					([typedexp])
|		typedexp COMMA exps1				(typedexp ! exps1)

exps2:		typedexp COMMA exps1				(typedexp ! exps1)

exps:								([])
|		exps1						(exps1)

apat:		ident2						(raw::CONSPAT(ident2, NULL))
|		literal						(raw::LITPAT literal)
|		WILD						(raw::WILDCARD_PATTERN)
|		LPAREN RPAREN					(raw::TUPLEPAT [])
|		LBRACKET pats RBRACKET				(raw::LISTPAT(pats, NULL))
|		LHASHBRACKET pats RBRACKET			(raw::VECTOR_PATTERN pats)
|		LPAREN pats2 RPAREN				(raw::TUPLEPAT pats2)
|		LPAREN orpats2 RPAREN				(raw::OR_PATTERN orpats2)
|		LPAREN andpats2 RPAREN				(raw::ANDPAT andpats2)
|		LPAREN typedpat RPAREN				(typedpat)
|		LPAREN typedpat WHERE_T typedexp RPAREN		(raw::WHEREPAT(typedpat, typedexp))

|		LPAREN typedpat WHERE_T typedexp
				IN_T typedpat RPAREN		(raw::NESTEDPAT(typedpat1, typedexp, typedpat2))

|		LBRACE labpats0 RBRACE				(raw::RECORD_PATTERN(labpats0))

|		sym MELD LBRACKET pats RBRACKET 		( { loc = lnd::location line_number_db 
										   (symleft, rbracketright);
								    raw::LISTPAT(enum_pattern(err, loc, sym, pats), NULL);
								  }
								)

|		sym MELD LBRACKET pats RBRACKET MELD sym	( { loc = lnd::location line_number_db 
										   (symleft, rbracketright);
								    raw::LISTPAT(enum_pattern'(err, loc,
										enum_pattern(err, loc, sym1, pats), sym2), NULL);
								   }
								)

|		LBRACKET pats RBRACKET MELD sym			( { loc = lnd::location line_number_db 
										   (symleft, rbracketright);
								    raw::LISTPAT(enum_pattern'(err, loc, pats, sym), NULL);
								  }
								)


orpats2:	typedpat BAR typedpat				([typedpat1, typedpat2])
|		typedpat BAR orpats2				(typedpat ! orpats2)

andpats2:	typedpat AND_T typedpat				([typedpat1, typedpat2])
|		typedpat AND_T andpats2				(typedpat ! andpats2)

apat2:		apat						(prp::EXP apat)
|		sym						(prp::ID sym)
|		OP_T sym					(prp::ID sym)

apppat:		apat2						([apat2])
|		apppat apat2					(apppat @ [apat2])

pattern:	apppat						(parse_pattern precedence_stack err 
								    (lnd::location line_number_db 
									(apppatleft, apppatright)
								    )
								    apppat
								)

|		id AS_T pattern					(raw::ASPAT(id, pattern))


typedpat:	pattern						(pattern)
|		typedpat COLON ty 				(raw::TYPEDPAT(typedpat, ty)) 

asapat:		apat						(apat)
|		id AS_T asapat					(raw::ASPAT(id, asapat))

pats:								([])
|		pats1						(pats1)

pats1:		typedpat					([typedpat])
|		typedpat COMMA pats1				(typedpat ! pats1)

pats2:		typedpat COMMA pats1				(typedpat ! pats1)

labpats0:							([], FALSE)
|		labpats						(labpats)

labpats:	labpat						([labpat], FALSE)
|		labpat COMMA DOTDOT 				([labpat], TRUE)
|		labpat COMMA labpats				(labpat ! #1 labpats, #2 labpats)

labpat:		sym						(sym, raw::IDPAT sym)
|		sym EQ typedpat					(sym, typedpat)
|		sym AS_T typedpat 				(sym, raw::ASPAT(sym, typedpat))
|		sym WHERE_T typedexp				(sym, raw::WHEREPAT(raw::IDPAT sym, typedexp))
|		sym WHERE_T typedexp IN_T typedpat 		(sym, raw::NESTEDPAT(raw::IDPAT sym, typedexp, typedpat))

clause:		typedpat guard cont DARROW expression		(clause([typedpat], guard, cont, NULL, expression))

cont:								(NULL)
|		EXCEPTION_T id					(THE id) 

guard:								(NULL)
|		WHERE_T typedexp				(THE typedexp)

clauses:	clause						([clause])
|		clause BAR clauses				(clause ! clauses)

funclause:	apppat funguard return_ty cont EQ typedexp	( {   loc = lnd::location line_number_db (apppatleft, typedexpright);

								      case (parse_function_pattern  precedence_stack  err  loc  apppat)
									  #
									  (THE f, ps) => (f, clause(ps, funguard, cont, return_ty, typedexp));
									  #
									  (NULL, ps) => {   err(
												loc,
												   "in clause " + 
												     spp::prettyprint_expression_to_string(rsu::clause (raw::CLAUSE(ps, funguard, typedexp)))
											     );

											     ("dummy", clause(ps, funguard, cont, return_ty, typedexp));
											};
								      esac;
								  }
								)

return_ty:							(NULL)
|		COLON ty					(THE ty)

funguard:							(NULL)
|		WHERE_T LPAREN typedexp RPAREN			(THE typedexp)

funclauses:	funclause					(#1 funclause,[#2 funclause])
|		funclause BAR funclauses			(#1 funclause,#2 funclause ! #2 funclauses)

aty:		tident						(idty(tident))
|		HASH int					(raw::INTVARTY int)
|		typevariable					(raw::TYVARTY typevariable)
|		DOLLAR id					(raw::REGISTER_TYPE id)			# This (with id=="bar") came from a   foo: $bar   declaration -- the '$' distinguishes these from regular type declarations.
|		LPAREN RPAREN					(raw::TUPLETY [])
|		LPAREN ty RPAREN				(ty)
|		LBRACE labtys RBRACE				(raw::RECORDTY labtys)

appty:		aty						(aty)
|		appty tident					(raw::APPTY(tident,[appty]))
|		LPAREN tys2 RPAREN tident 			(raw::APPTY(tident, tys2))

# "tid" appears to mean "type id":
#
tid:		id						(id)
|		tid2						(tid2)

tid2:		BITS						("bits")
|		CELL						("cell")
|		INSTRUCTION					("instruction")
	
# "tident" appears to mean "type identifier":
#
tident:		tid						(raw::IDENT ([], tid))
|		tpath						(raw::IDENT (reverse(#1 tpath), #2 tpath))

tpath:		tid DOT tid					([tid1], tid2)
|		tpath DOT tid					(#2 tpath ! #1 tpath, tid)


tys2:		ty COMMA ty					([ty1, ty2])
|		ty COMMA tys2					(ty ! tys2)

ty: 		ty ARROW ty					(raw::FUNTY(ty1, ty2))
|		tuplety						(raw::TUPLETY tuplety)	
|		appty						(appty)

labtys:								([])
|		labtys1						(labtys1)

labtys1:	labty						([labty])
|		labty COMMA labtys1				(labty ! labtys1)

labty:		id COLON ty					(id, ty)

tuplety:	appty TIMES appty				([appty1, appty2])
|		appty TIMES tuplety				(appty ! tuplety)

storagedecls:	storagedecl	 				([storagedecl])
|		storagedecl BAR storagedecls			(storagedecl ! storagedecls)

storagedecl:	id EQ DOLLAR id
		      LBRACKET cellcount RBRACKET
		      bitsize
                      aliasing defaults printcell 		(raw::REGISTER_SET
								  { name       => id1,
								    nickname   => id2,
								    #
								    bits       => #1 bitsize,
								    count      => cellcount,
								    #
								    alias      => aliasing,
								    aggregable =>  #2 bitsize,
								    #
								    from       => REF 0,
								    to         => REF 0,
								    #
								    print      => printcell,
								    defaults   => defaults
								  }
								)

aggregable:							(FALSE)
|		AGGREGABLE					(TRUE)

bitsize:	OF_T int aggregable BITS			(int, aggregable)
|								(0, FALSE)

cellcount:	int 						(THE int)
|								(NULL) 

special_register:
		id EQ expression				(raw::SPECIAL_REGISTER(id, NULL, expression))
|		id pattern EQ expression			(raw::SPECIAL_REGISTER(id, THE pattern, expression))

special_registers:
		special_register				([ special_register ])
|		special_register AND_T special_registers	(special_register ! special_registers)

unt:		UNT						(unt)

int:		INT						(int)

intopt:		int						(int)
|								(0)

integer:		INTEGER						(integer)

real:		REAL_T						(real_t)

aliasing:							(NULL)
|		ALIASING  id					(THE id)

printcell:	ASM_COLON string 				(raw::FN_IN_EXPRESSION [raw::CLAUSE ([raw::WILDCARD_PATTERN], NULL, raw::LITERAL_IN_EXPRESSION (raw::STRING_LIT string))])

|		ASM_COLON LPAREN expression RPAREN		(expression)

defaults:	 						([])
|		WHERE_T default_list				(default_list)

default_list:	default 					([default])
|		default AND_T default_list			(default ! default_list)

default:	DOLLAR id LBRACKET int RBRACKET EQ expression	(int, expression) 

slices:		slice						([slice])
|		slice COMMA slices				(slice ! slices)

slice:		int DOTDOT int					(int1, int2)
|		int						(int1, int1)

id:		ID						(id)
|		SYMBOL						(symbol)
|		REGISTERSET					("registerset")

sym:		id						(id)
|		symb 						(symb)

symb:		TIMES 						("*")
|		NOT 						("not")
|		DEREF						("!")

ident:		id						(raw::IDENT ([], id))
|		ident2						(ident2)

ident2:		path						(raw::IDENT (reverse (tail path), head path))

path:		id DOT sym					([sym, id])
|		path DOT sym					(sym ! path)

typevariable:	TYVAR						(raw::VARTV tyvar)
|		HASH id 					(raw::INTTV id)

string:		STRING_T					(string_t)

char:		CHAR_T						(char_t)

bool:		false						(FALSE)
|		true						(TRUE)
