## spill.pkg


api SPILL = api
  my spill:  List( CPS::function ) -> List( CPS::function )
end #  Api SPILL 

generic spill_g (machine_specification:  Machine_Specification) : SPILL
{
local
  use CPS
  package lv = lambda_variable
  error = error_message::impossible
  pr = controls::print::say
  maxgpfree = machine_specification::spillAreaSz div (2 * machine_specification::valueSize)
  maxfpfree = machine_specification::spillAreaSz div (2 * machine_specification::realSize)
  spillname = symbol::make_value_symbol "spillrec" 
  fun sortp x = list_mergesort::sort (fn ((i: Int, _), (j, _)) => i>j) x
  app2 = paired_lists::apply
  unboxedfloat = machine_specification::unboxedFloats
  package cg_options = control::CG

in

/*****************************************************************************
 *                     MISC AND UTILITY FUNCTIONS                            *
 *****************************************************************************/
fun enter (new: Int, l) =
  let fun f [] = [new]
	| f (l as h . t) = if new<h then new . l else if new>h then h . f t else l
  in  f l
  end

fun uniq l =
    let fun loop([], acc) = acc
	  | loop (a . r, acc) = loop (r, enter (a, acc))
    in loop (l,[])
    end

fun merge (a,[]) = a
  | merge([], a) = a
  | merge (l as (i: Int) . a, m as j . b) = 
      if j<i then j . merge (l, b) else i . merge (a, if i<j then m else b)

local fun loop (a . b . rest) = loop (merge (a, b) . loop rest)
        | loop l = l
in fun foldmerge l = hd (loop l) except Hd => []
end

fun rmv (x:  Int, l) =
    let fun loop NIL = NIL
	  | loop (a . b) = if x==a then b else a . loop b
    in loop l
    end

fun member l (e: Int) =
  let fun f [] = FALSE
	| f (h . t) = if h<e then f t else e==h
  in  f l
  end

fun intersect (NIL, _) = NIL
  | intersect(_, NIL) = NIL
  | intersect (l as (a: Int) . b, r as c . d) =
	if a==c then a . intersect (b, d)
	else if a<c then intersect (b, r)
	else intersect (l, d)

nonfix before
my       \/ = merge and /\ = intersect
infix 70 \/   infix 80  /\

fun enterV (VAR v, l) = enter (v, l)
  | enterV(_, l) = l

fun unzip l = 
  let fun h((a, b) . l, r1, r2) = h (l, a . r1, b . r2)
        | h([], r1, r2) = (reverse r1, reverse r2)
   in h (l,[],[])
  end

fun sublist test =
  let fun subl (a . r) = if test a then a . (subl r) else subl r
        | subl [] = []
   in subl
  end

fun spillLvar() = lv::make_named_lambda_variable spillname

ilist = print_utilities::print_int_path

fun sayv (VAR v) = pr (lv::name_of_Lambda_variable v)
  | sayv (LABEL v) = pr("(L)" + lv::name_of_Lambda_variable v)
  | sayv (INT i) = pr (int::to_string i)
  | sayv (REAL r) = pr r
  | sayv (STRING s) = (pr "\""; pr s; pr "\"")
  | sayv _ = error "sayv in spill.pkg"

vallist = print_utilities::print_closed_sequence("[", ", ", "]") sayv

fun cut (0, _) = []
  | cut (i, a . x) = a . cut (i - 1, x)
  | cut(_,[]) = []

fun nextuse x =
 let infinity = 1000000
     fun xin[] = FALSE | xin (VAR y . r) = x=y or xin r | xin(_ . r) = xin r
     fun g (level, a) =
     let my rec f =
      fn ([],[]) => infinity
       | ([], next) => g (level+1, next)
       | (SWITCH (v, c, l) . r, next) => if xin[v] then level else f (r, l@next)
       | (RECORD(_, l, w, c) . r, next) =>
	    if xin (map #1 l) then level else f (r, c . next)
       | (SELECT (i, v, w, _, c) . r, next) => if xin[v] then level else f (r, c . next)
       | (OFFSET (i, v, w, c) . r, next) => if xin[v] then level else f (r, c . next)
       | (SETTER (i, a, c) . r, next) => if xin a then level else f (r, c . next)
       | (LOOKER (i, a, w, _, c) . r, next) => if xin a then level else f (r, c . next)
       | (ARITH (i, a, w, _, c) . r, next) => if xin a then level else f (r, c . next)
       | (PURE (i, a, w, _, c) . r, next) => if xin a then level else f (r, c . next)
       | (BRANCH (i, a, c, e1, e2) . r, next) => 
			   if xin a then level else f (r, e1 . e2 . next)
       | (APPLY (v, vl) . r, next) => if xin (v . vl) then level else f (r, next)
       | _ => error "next use in spill.pkg"
     in f (a,[])
     end
     fun h y = g (0,[y])
  in h
 end

fun sortdups (cexp, dups) =
  map #2 (sortp (map (fn dup as (v, w) => (nextuse v cexp, dup)) dups))

fun next_n_dups (0, cexp, dups) = []
  | next_n_dups (n, cexp, dups) =
      if (n >= length dups) then dups else cut (n, sortdups (cexp, dups))
    
fun clean l = 
  let fun vars (l, VAR x . rest) = vars (enter (x, l), rest)
        | vars (l, _ . rest) = vars (l, rest)
        | vars (l, NIL) = l
   in vars([], l)
  end

fun partition f l = 
  fold_right (fn (e, (a, b)) => if f e then (e . a, b) else (a, e . b)) ([], []) l


/***************************************************************************
 *   MAIN FUNCTION   spillit:  CPS::function -> CPS::function                *
 ***************************************************************************/

exception SpillCtyMap

my ctymap:  int_hash_table::Hash_Table( cty )
          = int_hash_table::make_table (32, SpillCtyMap)

fun clearCtyMap() = int_hash_table::clear ctymap
fun getty v = the_else (int_hash_table::find ctymap v, bogt)
addty = int_hash_table::set ctymap 
fun copyLvar v = let p = (lv::copy_highcode_variable v, getty v) in addty p; p end
fun floatP v = case (getty v) of FLTt => TRUE | _ => FALSE

enum spillkind = GPRSPILL | FPRSPILL
type spillinfo = Null_Or (List( Lambda_Variable)  * value) 

fun spillit (fkind, func, vl, cl, body, skind) = let 

my (varsP, nvarP, varLen, recordKind, sregN) = 
  case skind 
   of FPRSPILL => (sublist floatP, not o floatP, maxfpfree, RK_FBLOCK, 0)
    | GPRSPILL => 
        (if unboxedfloat then 
              (sublist (not o floatP), floatP, maxgpfree, RK_SPILL, 1)
         else (fn x => x, fn _ => FALSE, maxgpfree, RK_SPILL, 1))

clearCtyMap()
app2 addty (vl, cl)
freevars = 
 let exception SpillFreemap
     m = int_hash_table::make_table (32, SpillFreemap)
	     : int_hash_table::Hash_Table(  List(  Lambda_Variable ) )
     FreeMap::freemap (int_hash_table::set m) body
  in fn x => ((int_hash_table::lookup m x) except SpillFreemap => 
                    (pr "compiler bugs in spill.pkg:  "; 
                     (pr o int::to_string) x; pr "  \n";
                     raise SpillFreemap))
 end

#  INVARIANT: results, uniques have already been sifted through varsP 
fun f (results:  List( Lambda_Variable ), uniques:  List( Lambda_Variable ), dups:   List( Lambda_Variable * Lambda_Variable ),
      spill:  spillinfo, cexp:  cexp) =
  let my (before, after) =  /* variables free in this operation, and after
	  		       not including the newly-bound variables */
	 let my rec free =
	      fn SWITCH (v, _, l) => foldmerge (clean[v] . map free l)
	       | RECORD(_, l, w, c) =>  clean (map #1 l) \/ freevars w
	       | SELECT (i, v, w, _, c) => clean[v] \/ freevars w
	       | OFFSET (i, v, w, c) => clean[v] \/ freevars w
	       | SETTER (i, vl, c) => clean vl \/ free c
	       | LOOKER (i, vl, w, _, c) => clean vl \/ freevars w
	       | ARITH (i, vl, w, _, c) => clean vl \/ freevars w
	       | PURE (i, vl, w, _, c) => clean vl \/ freevars w
	       | BRANCH (i, vl, c, c1, c2) => clean vl \/ free c1 \/ free c2
	       | APPLY (f, vl) => clean (f . vl)
               | _ => error "free in spill 232"
	  in case cexp
	      of SWITCH (v, _, l) => (clean[v], foldmerge (map free l))
	       | RECORD(_, l, w, c) =>  (clean (map #1 l), freevars w)
	       | SELECT (i, v, w, _, c) => (clean[v], freevars w)
	       | OFFSET (i, v, w, c) => (clean[v], freevars w)
	       | SETTER (i, vl, c) => (clean vl, free c)
	       | LOOKER (i, vl, w, _, c) => (clean vl, freevars w)
	       | ARITH (i, vl, w, _, c) => (clean vl, freevars w)
	       | PURE (i, vl, w, _, c) => (clean vl, freevars w)
	       | BRANCH (i, vl, c, c1, c2) => (clean vl, free c1 \/ free c2)
	       | APPLY (f, vl) => (clean (f . vl), [])
               | _ => error "free in spill 233"
	 end

      my (before, after) = (varsP before, varsP after)
      uniques = uniques \/ results #  is this line necessary? 
      uniques_after = uniques /\ after
      uniques_before = (uniques /\ before) \/ uniques_after
      spill_after = 
        (case spill 
          of NULL => NULL
           | THE (contents, _) => 
               (case (uniq contents) /\ after of [] => NULL
                                               | _ => spill))

      maxfree' = case spill of NULL => varLen
                                 | _ => varLen-sregN
      avail = maxfree' - length (uniques_before \/ results)
      dups = next_n_dups (avail, cexp, dups)

      maxfreeafter = case spill_after of NULL => varLen
                                           | THE _ => varLen-sregN

      fun getpath (VAR v) =
           if (member uniques_before v) or (nvarP v) then (VAR v, OFFp 0)
           else let fun find (i, w . l, sv) = 
                          if (v==w) then (sv, SELp (i, OFFp 0))
                          else find (i+1, l, sv)
                      | find _ = error "not found in spill 001"

                    fun try((w, x) . l) = if v==w then (VAR x, OFFp 0) else try l
		      | try [] = (case spill 
                                   of THE (l, sv) => find (0, l, sv)
                                    | _ => error "not found in spill 002")

	         in try dups
	        end
	| getpath x = (x, OFFp 0)

      fun makeSpillRec args = #  Args are already sift-ed 
	let contents = args \/ after
            spillrec = map (getpath o VAR) contents
            sv = spillLvar()
            spinfo = THE (contents, VAR sv)
	    dups' = map (fn x => (x, x)) uniques_before @ dups
            cg_options::spillGen := *cg_options::spillGen + 1;
            header = fn ce => RECORD (recordKind, spillrec, sv, ce)
            nce = f([],[], dups', spinfo, cexp)
 	 in header (if not *cg_options::allocprof then nce
                   else AllocProf::profSpill (length contents) nce)
	end

      #  here args and result are not sifted yet 
      fun g (args, result, conts, temps, gen) = 
        let nargs = varsP (clean args)
            nres = varsP (uniq result)
            allargs = nargs \/ uniques_after
         in if ((length (allargs) + temps > maxfreeafter) or
                (length nres + length uniques_after + temps > maxfreeafter)) 
	    then makeSpillRec nargs
	    else let paths = 
                       map (fn x => (x, getpath (VAR x))) nargs
		     fun fetchit (_, (_, OFFp 0)) = FALSE | fetchit _ = TRUE
	          in case (sublist fetchit paths)
                      of (v, (w, SELp (i, OFFp 0))) . r =>
  		           let my (x, ct) = copyLvar v
                               aftervars = case r of [] => spill_after
                                                       | _ => spill
 		            in /* pr "Fetching "; (pr o int::to_string) v;
		                  pr "\n"; */
		               SELECT (i, w, x, ct,
                                        f([], uniques_before, (v, x) . dups,
                                          aftervars, cexp))
		           end
                       | _ . r => error "unexpected access in g in spill"
	               | [] => let fun f' cexp = f (nres, uniques_after,
					       dups, spill_after, cexp)
		                in gen (map (#1 o getpath) args,
                                       result, map f' conts)
			       end
	         end
        end

   in case cexp
       of SWITCH (v, c, l) => g([v],[], l, 0, fn([v],[], l)=>SWITCH (v, c, l))
        | RECORD (k, l, w, c) =>
	    if (sregN + length uniques_after > maxfreeafter) 
	    then makeSpillRec (varsP (clean (map #1 l)))
	    else let paths = map (fn (v, p) =>
					 let my (v', p') = getpath v 
 					  in (v', combinepaths (p', p))
					 end) l
	          in RECORD (k, paths, w,
                       f (varsP [w], uniques_after, dups, spill_after, c))
		 end
        | SELECT (i, v, w, t, c) => 
            (addty (w, t); g([v],[w],[c], 0, fn([v],[w],[c])=>SELECT (i, v, w, t, c)))
	| OFFSET (i, v, w, c) => g([v],[w],[c], 0, fn([v],[w],[c])=>OFFSET (i, v, w, c))
	| SETTER (i, vl, c) => g (vl,[],[c], 0, fn (vl, _,[c])=>SETTER (i, vl, c))
	| LOOKER (i, vl, w, t, c) => 
            (addty (w, t); g (vl,[w],[c], 0, fn (vl,[w],[c])=>LOOKER (i, vl, w, t, c)))
	| ARITH (i, vl, w, t, c) => 
            (addty (w, t); g (vl,[w],[c], 0, fn (vl,[w],[c])=>ARITH (i, vl, w, t, c)))
	| PURE (i, vl, w, t, c) => 
            (addty (w, t); g (vl,[w],[c], 0, fn (vl,[w],[c])=>PURE (i, vl, w, t, c)))
	| RCC (p, vl, w, t, c) =>
	    (addty (w, t); g (vl,[w],[c], 0, fn (vl,[w],[c])=>RCC (p, vl, w, t, c)))
        | BRANCH (i as p::streq, vl, c, c1, c2) =>
            g (vl,[],[c1, c2], sregN, fn (vl, _,[c1, c2])=>BRANCH (i, vl, c, c1, c2))
        | BRANCH (i as p::strneq, vl, c, c1, c2) =>
            g (vl,[],[c1, c2], sregN, fn (vl, _,[c1, c2])=>BRANCH (i, vl, c, c1, c2))
	| BRANCH (i, vl, c, c1, c2) => 
	    g (vl,[],[c1, c2], 0, fn (vl, _,[c1, c2])=>BRANCH (i, vl, c, c1, c2))
	| APPLY (f, vl) => g (f . vl,[],[], 0, fn (f . vl,[],[])=>APPLY (f, vl))
        | _ => error "spill 2394892"
  end

 in (fkind, func, vl, cl, f([], varsP (uniq vl),[], NULL, body))
end


/*****************************************************************************
 *              CHECK IF SPILLING IS NECESSARY                               *
 *****************************************************************************/
local
  exception TooMany
  exception FLOAT_SET

  my floatset:  int_hash_table::Hash_Table( Bool )
              = int_hash_table::make_table (32, FLOAT_SET)

  fun fltM (v, FLTt) = int_hash_table::set floatset (v, TRUE)
    | fltM _ = ()
  fun fltP v = the_else (int_hash_table::find floatset v, FALSE)
  fun clearSet() = int_hash_table::clear floatset
  dummyM = fn _ => ()
  dummyP = fn _ => TRUE
in

fun check((_, f, args, cl, body), skind) =
  let my (varM, varP, varLen) =
       (case skind 
         of FPRSPILL => (fltM, fltP, maxfpfree)
          | GPRSPILL => if unboxedfloat then (fltM, not o fltP, maxgpfree)
                        else (dummyM, dummyP, maxgpfree))
      clearSet()
      app2 varM (args, cl)

      fun sift (l, vl) = 
        let fun h((VAR x) . r, vl) = 
                  if varP x then h (r, enter (x, vl)) else h (r, vl)
              | h(_ . r, vl) = h (r, vl)
              | h([], vl) = vl
         in h (l, vl)
        end

      fun verify (w, vl) = 
        let nvl = rmv (w, vl)
         in if (length (nvl) >= varLen) then raise TooMany else nvl
        end

      my rec freevars =
        fn APPLY (v, args) => sift (v . args,[])
         | SWITCH (v, c, l) => sift([v], foldmerge (map freevars l))
         | SELECT(_, v, w, t, e) => (varM (w, t); sift([v], verify (w, freevars e)))
         | RECORD(_, l, w, e) => (sift((map #1 l), verify (w, freevars e)))
         | OFFSET(_, v, w, e) => (sift([v], verify (w, freevars e)))
         | SETTER(_, vl, e) => sift (vl, freevars e)
         | LOOKER(_, vl, w, t, e) => (varM (w, t); sift (vl, verify (w, freevars e)))
         | ARITH(_, vl, w, t, e) => (varM (w, t); sift (vl, verify (w, freevars e)))
         | PURE(_, vl, w, t, e) => (varM (w, t); sift (vl, verify (w, freevars e)))
	 | RCC(_, vl, w, t, e) => (varM (w, t); sift (vl, verify (w, freevars e)))
         | BRANCH(_, vl, c, e1, e2) => sift (vl, merge (freevars e1, freevars e2))
         | FIX _ => error "FIX in Freemap::freemap"

   in (freevars body; TRUE) except TooMany => FALSE
  end

end #  local declaration for the "check" function 

/*****************************************************************************
 *  IMPROVE THE REGISTER USAGE BY SIMPLE RENAMING OF RECORD FIELDS           *
 *    (this procedure can be improved by reordering the cps expressions      *
 *     based on the lifetime of each variables; by doing this, we can avoid  *
 *     most of the big cluster of simultaneously live variables. --zsh)      *
 *****************************************************************************/
fun improve cexp = 
  let exception Spillmap

      my m:  int_hash_table::Hash_Table (Ref( Int ) * Int * value)
           = int_hash_table::make_table (32, Spillmap)

      enter = int_hash_table::set m
      lookup = int_hash_table::lookup m
      fun get (VAR x) = (THE (lookup x) except Spillmap => NULL)
        | get _ = NULL
      fun kill (VAR v) = (ignore (int_hash_table::remove m v) except _ => ())
        | kill _ = ()
      fun use v = case get v of THE (r as REF 0, i, w) => r := 1
		              | THE _ => kill v
		              | NULL => ()
      my rec pass1 =
	fn SELECT (i, v, w, _, e) => (kill v; enter (w, (REF 0, i, v)); pass1 e)
	 | OFFSET (i, v, w, e) => (kill v; pass1 e)
#        | RECORD (RK_FBLOCK, vl, w, e) => (apply (kill o #1) vl; pass1 e) 
	 | RECORD(_, vl, w, e) => (apply (use o #1) vl; pass1 e)
	 | APPLY (v, vl) => (kill v; apply kill vl)
	 | FIX (l, e) => error "33832 in spill"
	 | SWITCH (v, _, el) => (kill v; apply pass1 el)
	 | BRANCH (i, vl, c, e1, e2) => (apply kill vl; pass1 e1; pass1 e2)
	 | SETTER (i, vl, e) => (apply kill vl; pass1 e)
	 | LOOKER (i, vl, w, _, e) => (apply kill vl; pass1 e)
	 | ARITH (i, vl, w, _, e) => (apply kill vl; pass1 e)
	 | PURE (i, vl, w, _, e) => (apply kill vl; pass1 e)
	 | RCC (p, vl, w, _, e) => (apply kill vl; pass1 e)

      fun ren (v, p) = case get v of THE(_, i, w) => (w, SELp (i, p))
			         | NULL => (v, p)

      my rec g =
        fn SELECT (i, v, w, t, e) => 
             (case get (VAR w) of THE _ => g e
		               | NULL => SELECT (i, v, w, t, g e))
	 | OFFSET (i, v, w, e) => OFFSET (i, v, w, g e)
#        | RECORD (k as RK_FBLOCK, vl, w, e) => RECORD (k, vl, w, g e) 
	 | RECORD (k, vl, w, e) => RECORD (k, map ren vl, w, g e)
	 | e as APPLY (v, vl) => e
	 | FIX (l, e) => error "33832 in spill"
	 | SWITCH (v, c, el) => SWITCH (v, c, map g el)
	 | BRANCH (i, vl, c, e1, e2) => BRANCH (i, vl, c, g e1, g e2)
	 | SETTER (i, vl, e) => SETTER (i, vl, g e)
	 | LOOKER (i, vl, w, t, e) => LOOKER (i, vl, w, t, g e)
	 | ARITH (i, vl, w, t, e) => ARITH (i, vl, w, t, g e)
	 | PURE (i, vl, w, t, e) => PURE (i, vl, w, t, g e)
	 | RCC (p, vl, w, t, e) => RCC (p, vl, w, t, g e)

      count = (pass1 cexp; int_hash_table::vals_count m)

      if *cg_options::debugcps then
                (pr "count="; (pr o int::to_string) count; pr "\n") 
              else ()
   in if count>0 then THE (g cexp) else NULL
  end		

/*****************************************************************************
 *                     THE EXPORTED "SPILL" FUNCTION                         *
 *****************************************************************************/
fun spillone arg = 
  let (if *cg_options::printit
               then (pr "^^^^^within the spill phase^^^^^^^^ \n";
                     prettyprint_cps::print_cps_function arg;
                     pr "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \n")
               else ())

      fun spillgpr (arg as (fkind, func, vl, cl, body)) = 
        if check (arg, GPRSPILL) then arg
        else (if *cg_options::printit
              then (pr "^^^^ need go through more rounds ^^^^ \n")
              else (); 
              case improve body
               of THE body' => spillgpr (fkind, func, vl, cl, body')
  	        | NULL => spillit (fkind, func, vl, cl, body, GPRSPILL))

      fun spillfpr (arg as (fkind, func, vl, cl, body)) =
        if check (arg, FPRSPILL) then spillgpr arg
        else (if *cg_options::printit
              then (pr "^^^^ need go through more rounds ^^^^ \n")
              else (); 
              case improve body
               of THE body' => spillfpr (fkind, func, vl, cl, body')
                | NULL => spillgpr (spillit (fkind, func, vl, cl, body, FPRSPILL)))

   in if unboxedfloat then spillfpr arg
      else spillgpr arg
  end

spill = map spillone

end #  local 
} #  generic Spill 



## Copyright 1996 by Bell Laboratories
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
