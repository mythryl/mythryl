/* alignment.pkg --- determine if the allocation pointer should be
 *		     aligned on entry to function.
 */
api ALIGNMENT = api
  my build:  List( fatecode::function ) -> (Int -> Bool) 
end

package alignment {

  package fcf = fatecode

  exception Alignment

  fun error msg
      =
      error_message::impossible ("Alignment." + msg)

  fun build (cluster)
      =
      {
	  #  sorted_list should be replaced by int-binary-set 
	  fun hasFloats (fcf::RECORD (rk, _, _, e)) = 
	       (case rk of (fcf::RK_FCONT | fcf::RK_FBLOCK) => TRUE | _ => hasFloats (e))
	    | hasFloats (fcf::GET_FIELD(_, _, _, _, e)) = hasFloats (e)
	    | hasFloats (fcf::OFFSET(_, _, _, e)) = hasFloats (e)
	    | hasFloats (fcf::APPLY _) = FALSE
	    | hasFloats (fcf::FIX _) = error "hasFloats: FIX"
	    | hasFloats (fcf::SWITCH(_, _, el)) = let
		fun iter [] = FALSE
		  | iter (e . el) = hasFloats (e) or iter (el)
	      in iter el
	      end
	    | hasFloats (fcf::BRANCH(_, _, _, e1, e2)) = 
		hasFloats (e1) or hasFloats (e2)
	    | hasFloats (fcf::SETTER(_, _, e)) = hasFloats (e)
	    | hasFloats (fcf::LOOKER(_, _, _, _, e)) = hasFloats (e)
	    | hasFloats (fcf::MATH(_, _, _, _, e)) = hasFloats (e)
	    | hasFloats (fcf::PURE (fcf::P.fwrap, _, _, _, _)) = TRUE
	    | hasFloats (fcf::PURE(_, _, _, _, e)) = hasFloats (e);

	  fun doFunction((_, f, _, _, e), set)
              = 
	      if hasFloats e   then sorted_list::enter (f, set)
                               else set;

          sorted_list::member (list::fold_left doFunction [] cluster);

      }   #  Build 
};

