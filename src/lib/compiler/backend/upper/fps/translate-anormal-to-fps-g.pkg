## translate-anormal-to-fps-g.pkg 

# Compiled by:
#     src/lib/compiler/core.make6

#  This generic defines function   translate_anormal_to_fps
#  which constitutes the transition from the first to the second
#  half of 'highcode', the back end upper half.
#  It is called from   translate_anormal_to_binary   in
#
#      src/lib/compiler/backend/upper/main/backend-g.pkg

# *************************************************************************
#                         IMPORTANT NOTES                                 *
#                                                                         *
#          The FPS code generated by this phase should not                *
#                use OFFSET and RECORD accesspath SELp.                   *
#                  generated by this module.                              *
# *************************************************************************

api Translate_Anormal_To_Fps {

      translate_anormal_to_fps
          :
          anormal::Program				# anormal			is from   src/lib/compiler/backend/upper/anormal/anormal.pkg
          ->
          fate_passing_style::Function; 		# fate_passing_style		is from   src/lib/compiler/backend/upper/fps/fate-passing-style.pkg
};

# We are invoked from:
#
#     

							# Machine_Properties		is from   src/lib/compiler/codegen/main/machine-properties.api
generic package translate_anormal_to_fps_g (

    machine_properties:  Machine_Properties		# Typically	 			  src/lib/compiler/codegen/x86/x86-machine-properties.pkg
)

: (weak) Translate_Anormal_To_Fps			# Translate_Anormal_To_Fps	is from   src/lib/compiler/backend/upper/fps/translate-anormal-to-fps-g.pkg

{
    stipulate

        package da =  var_home;				# var_home			is from   src/lib/compiler/frontend/typecheck-stuff/basics/var-home.pkg
	package lt =  highcode;				# highcode			is from   src/lib/compiler/backend/upper/highcode/highcode.pkg
	package lv =  highcode_var;			# highcode_var			is from   src/lib/compiler/backend/upper/highcode/highcode-var.pkg
	package ap =  highcode_primitive_op;		# highcode_primitive_op		is from   src/lib/compiler/backend/upper/highcode/highcode-primitive-op.pkg
	package di =  debruijn_index;			# debruijn_index		is from   src/lib/compiler/frontend/typechecker/basics/de-bruijn-index.pkg
	package f  =  anormal;				# anormal			is from   src/lib/compiler/backend/upper/anormal/anormal.pkg
#	package as =  anormal_stuff;			# anormal_stuff			is from   src/lib/compiler/backend/upper/anormal/anormal-stuff.pkg
	package m  =  int_binary_map;			# int_binary_map		is from   src/lib/src/int-binary-map.pkg

	include fate_passing_style; 

    herein

	fun bug s
            =
            error_message::impossible ("translate_anormal_to_fps_g: " + s);

	say      = controls::print::say;
	make_var = fn _ =  lv::make_highcode_variable();
	cplv     = lv::copy_highcode_variable;

	fun make_fn f
            =
            {   v = make_var();
                f v;
            };

	ident =  fn le =  le;
	offp0 =  OFFP 0;


	# Test whether two values are
        # equivalent Highcode_Variable values 

	fun veq (VAR x, VAR y)   =>   x == y;
	    veq _                =>   FALSE;
        end;

	# *************************************************************************
	#              CONSTANTS AND UTILITY FUNCTIONS                            *
	# *************************************************************************

	fun unwrapf64 (u, x, ce) =  PURE (p::FUNWRAP,   [u], x, FLTT,   ce);
	fun unwrapi32 (u, x, ce) =  PURE (p::I32UNWRAP, [u], x, INT32T, ce);
	fun wrapf64   (u, x, ce) =  PURE (p::FWRAP,     [u], x, bogt,   ce);
	fun wrapi32   (u, x, ce) =  PURE (p::I32WRAP,   [u], x, bogt,   ce);

	fun all_float (FLTT ! r) =>  all_float r;
	    all_float (_ ! r)    =>  FALSE;
	    all_float []         =>  TRUE;
        end;

	fun select_fl (i, u, x, ct, ce)
            =
            SELECT (i, u, x, ct, ce);

	fun select_nm (i, u, x, ct, ce)
	    =
	    case ct
              
		 FLTT   =>  make_fn (fn v =  SELECT (i, u, v, bogt, unwrapf64 (VAR v, x, ce)));
		 INT32T =>  make_fn (fn v =  SELECT (i, u, v, bogt, unwrapi32 (VAR v, x, ce)));
		 _      =>  SELECT (i, u, x, ct, ce);
            esac;


	fun record_fl (ul, _, w, ce)
            = 
	    RECORD (
                RK_FBLOCK,
                map (fn u =  (u, OFFP 0))
                    ul,
                w,
                ce
            );


	fun record_nm (ul, ts, w, ce)
	    =
	    header (RECORD (RK_RECORD, nul, w, ce))
            where
	        fun g (FLTT ! r, u ! z, l, h)
                        => 
		        make_fn  (fn v = g ( r,
                                             z,
                                             (VAR v, OFFP 0) ! l, 
				             fn ce =  h (wrapf64 (u, v, ce))
                                           )
                                 );

		    g (INT32T ! r, u ! z, l, h)
                        => 
		        make_fn  (fn v = g ( r,
					     z,
					     (VAR v, OFFP 0) ! l, 
					     fn ce = h (wrapi32 (u, v, ce))
					   )
				 );

		    g (_ ! r, u ! z, l, h)
                        =>
                        g (r, z, (u, offp0) ! l, h);

		    g([],[], l, h)
                        =>
                        (reverse l, h);

		    g _ =>
                        bug "unexpected in recordNM in convert";
                end;

		my (nul, header)
                    =
                    g (ts, ul,[], fn x = x);
	    end;

	# *************************************************************************
	#              UTILITY FUNCTIONS FOR PROCESSING THE PRIMOPS               *
	# *************************************************************************

	#  numkind: ap::Numkind -> p::numkind 
	#
	fun numkind (ap::INT   bits) =>  p::INT bits;
	    numkind (ap::UINT  bits) =>  p::UINT bits;
	    numkind (ap::FLOAT bits) =>  p::FLOAT bits;
        end;

	#  Cmpop: ap::stuff -> p::branch 
	#
	fun cmpop stuff
	    = 
	    case stuff
               
		 { oper=>ap::EQL, kind=>ap::INT 31 }
		     =>
		     p::ieql;

		 { oper=>ap::NEQ, kind=>ap::INT 31 }
		     =>
		     p::ineq;

		 { oper, kind=>ap::FLOAT size }
		    => 
		    {   fun c ap::GT    => p::F_GT;
			    c ap::GE    => p::F_GE;
			    c ap::LT    => p::F_LT;
			    c ap::LE    => p::F_LE;
			    c ap::EQL   => p::F_EQ;
			    c ap::NEQ   => p::F_ULG;
			    c _ => bug "cmpop: kind=ap::FLOAT";
			end;

			p::FCMP { oper=> c oper, size };
		    };

		 { oper, kind }
		      => 
		      p::CMP { oper => c oper, kind => numkind kind }
                      where
		          fun check (_, ap::UINT _) => ();
			      check (oper, _) => bug ("check" + oper);
			  end;

			  fun c ap::GT  =>  p::GT;  
			      c ap::GE  =>  p::GE; 
			      c ap::LT  =>  p::LT; 
			      c ap::LE  =>  p::LE;
			      c ap::LEU =>  { check ("leu", kind); p::LE ;};
			      c ap::LTU =>  { check ("ltu", kind); p::LT ;};
			      c ap::GEU =>  { check ("geu", kind); p::GE ;};
			      c ap::GTU =>  { check ("gtu", kind); p::GT ;};
			      c ap::EQL =>  p::EQL;
			      c ap::NEQ =>  p::NEQ;
			  end;
		      end;
            esac;


	# map_branch:  ap::primitive_operation -> p::branch 
	#
	fun map_branch p
	    = 
	    case p
               
	         ap::BOXED     => p::BOXED;
		 ap::UNBOXED   => p::UNBOXED;
		 ap::CMP stuff => cmpop stuff;
		 ap::PTREQL    => p::PEQL;
		 ap::PTRNEQ    => p::PNEQ;

		 _ => bug "unexpected primops in map_branch";
            esac;

	# primwrap: cty -> p::pure 
	#
	fun primwrap (INTT)   => p::IWRAP;
	    primwrap (INT32T) => p::I32WRAP;
	    primwrap (FLTT)   => p::FWRAP;
	    primwrap _        => p::WRAP;
        end;

	# primunwrap: cty -> p::pure 
	#
	fun primunwrap (INTT)   => p::IUNWRAP;
	    primunwrap (INT32T) => p::I32UNWRAP;
	    primunwrap (FLTT)   => p::FUNWRAP;
	    primunwrap _        => p::UNWRAP;
        end;

	# Arithop: ap::arithop -> p::arithop 
	#
	fun arithop ap::NEGATE   => p::NEGATE;
	    arithop ap::ABS      => p::ABS;
	    arithop ap::FSQRT    => p::FSQRT;
	    arithop ap::FSIN     => p::FSIN;
	    arithop ap::FCOS     => p::FCOS;
	    arithop ap::FTAN     => p::FTAN;
	    arithop ap::BITWISENOT     => p::BITWISENOT;
	    arithop ap::REM      => p::REM;
	    arithop ap::DIV      => p::DIV;
	    arithop ap::MOD      => p::MOD;
	    arithop ap::ADD      => p::ADD;
	    arithop ap::SUBTRACT => p::SUBTRACT;
	    arithop ap::MULTIPLY => p::MULTIPLY;
	    arithop ap::DIVIDE   => p::DIVIDE;
	    arithop ap::LSHIFT   => p::LSHIFT;
	    arithop ap::RSHIFT   => p::RSHIFT;
	    arithop ap::RSHIFTL  => p::RSHIFTL;
	    arithop ap::BITWISEAND     => p::BITWISEAND;
	    arithop ap::BITWISEOR      => p::BITWISEOR;
	    arithop ap::BITWISEXOR     => p::BITWISEXOR;
        end;

	# A temporary classifier of various kinds of FPS primops 
	#
	Pkind 
	  = PKS  p::Setter  
	  | PKP  p::Pure
	  | PKL  p::Looker
	  | PKA  p::Arith;

	# map_primop: ap::primitive_operation -> pkind 
	#
	fun map_primop p
	    = 
	    case p
              
	        ap::TEST   (from, to) =>  PKA (p::TEST   (from, to));
	        ap::TESTU  (from, to) =>  PKA (p::TESTU  (from, to));
	        ap::COPY   (from, to) =>  PKP (p::COPY   (from, to));
	        ap::EXTEND (from, to) =>  PKP (p::EXTEND (from, to));
	        ap::TRUNC  (from, to) =>  PKP (p::TRUNC  (from, to));

	        ap::TEST_INF  to => PKA (p::TEST_INF to);
	        ap::TRUNC_INF to => PKP (p::TRUNC_INF to);
	        ap::COPY_INF   from => PKP (p::COPY_INF from);
	        ap::EXTEND_INF from => PKP (p::EXTEND_INF from);

	        ap::ARITH { oper, kind, overflow=>TRUE }
                    =>
		    PKA (p::ARITH { oper=>arithop oper, kind=>numkind kind } );

	        ap::ARITH { oper, kind, overflow=>FALSE }
                    =>
		    PKP (p::PURE_ARITH { oper=>arithop oper, kind=>numkind kind } );

	        ap::ROUND { floor, fromkind, tokind }
                    =>
		    PKA (p::ROUND { floor, fromkind=>numkind fromkind,
			       tokind=>numkind tokind } );

	        ap::REAL { fromkind, tokind }
                    =>
		    PKP (p::REAL { tokind=>numkind tokind, fromkind=>numkind fromkind } );

	        ap::SUBSCRIPTV => PKP (p::SUBSCRIPTV);
	        ap::MAKEREF =>    PKP (p::MAKEREF);
	        ap::LENGTH =>     PKP (p::LENGTH);
	        ap::CHUNKLENGTH =>  PKP (p::CHUNKLENGTH);
	        ap::GETTAG =>     PKP (p::GETTAG);
	        ap::MAKE_SPECIAL =>  PKP (p::MAKE_SPECIAL);
	  #    | ap::THROW =>      PKP (p::CAST) 
	        ap::CAST =>       PKP (p::CAST);
	        ap::MKETAG =>     PKP (p::MAKEREF);
	        ap::NEW_ARRAY0 => PKP (p::NEWARRAY0);
	        ap::GET_SEQ_DATA => PKP (p::GETSEQDATA);
	        ap::SUBSCRIPT_REC => PKP (p::RECSUBSCRIPT);
	        ap::SUBSCRIPT_RAW64 => PKP (p::RAW64SUBSCRIPT);

	        ap::SUBSCRIPT => PKL (p::SUBSCRIPT);
	        ap::NUMSUBSCRIPT { kind, immutable=>FALSE, checked=>FALSE } => 
		     PKL (p::NUMSUBSCRIPT { kind=>numkind kind } );
	        ap::NUMSUBSCRIPT { kind, immutable=>TRUE, checked=>FALSE } => 
		     PKP (p::PURE_NUMSUBSCRIPT { kind=>numkind kind } );
	        ap::DEREF =>     PKL (p::BANG);
	        ap::GETRUNVEC => PKL (p::GETRUNVEC);
	        ap::GETHANDLER =>   PKL (p::GETHANDLER);
	        ap::GET_CURRENT_THREAD_REGISTER  =>   PKL (p::GET_CURRENT_THREAD_REGISTER);
	        ap::GETPSEUDO => PKL (p::GETPSEUDO);
	        ap::GETSPECIAL =>PKL (p::GETSPECIAL);
	        ap::DEFLVAR  =>  PKL (p::DEFLVAR);

	        ap::SETHANDLER => PKS (p::SETHANDLER);
	        ap::NUMUPDATE { kind, checked=>FALSE } =>
		     PKS (p::NUMUPDATE { kind=>numkind kind } );
	        ap::UNBOXED_SET => PKS (p::UNBOXED_SET);
	        ap::BOXED_SET => PKS (p::BOXED_SET);
	        ap::UPDATE => PKS (p::UPDATE);
	        ap::ASSIGN => PKS (p::ASSIGN);
	        ap::UNBOXEDASSIGN => PKS (p::UNBOXEDASSIGN);
	        ap::SET_CURRENT_THREAD_REGISTER => PKS (p::SET_CURRENT_THREAD_REGISTER);
	        ap::SETPSEUDO => PKS (p::SETPSEUDO);
	        ap::SETMARK => PKS (p::SETMARK);
	        ap::DISPOSE => PKS (p::FREE);
	        ap::SETSPECIAL => PKS (p::SETSPECIAL);
	        ap::USELVAR => PKS (p::USELVAR);

	        ap::RAW_LOAD nk => PKL (p::RAWLOAD { kind => numkind nk } );
	        ap::RAW_STORE nk => PKS (p::RAWSTORE { kind => numkind nk } );
	        ap::RAW_RECORD { fblock => FALSE } => PKP (p::RAWRECORD (THE RK_I32BLOCK));
	        ap::RAW_RECORD { fblock => TRUE } => PKP (p::RAWRECORD (THE RK_FBLOCK));

	        _ => bug ("bad primitive_operation in map_primop: " + (ap::pr_primop p) + "\n");
           esac;

	# *************************************************************************
	#                  SWITCH OPTIMIZATIONS AND COMPILATIONS                  *
	# *************************************************************************

	# BUG: The defintion of E_word is clearly incorrect since it can raise exception
	#        an overflow at code generation time. A clean solution would be 
	#        to add a WORD constructor into the FPS language -- daunting! The
	#        revolting hack solution would be to put the right int constant 
	#        that gets converted to the right set of bits for the word constant.  XXX BUGGO FIXME

	fun do_switch_fn ren
            =
            switch::switch {
		e_int    => fn i =  if (i < -0x20000000 or i >= 0x20000000)
				         raise exception switch::TOO_BIG;
                                    else INT i;  fi, 

		e_word   => fn w = # if w >= 0wx20000000 
				   # then raise exception Switch::TOO_BIG else
				   INT (unt::to_int_x w),

		e_real   => (fn s =  REAL s),
		e_switchlimit => 4,
		e_neq    => p::ineq,
		e_w32neq => p::CMP { oper=>p::NEQ, kind=>p::UINT 32 },
		e_i32neq => p::CMP { oper=>p::NEQ, kind=>p::INT 32 },
		e_word32 => INT32,
		e_int32  => INT32, 
		e_wneq   => p::CMP { oper=>p::NEQ, kind=>p::UINT 31 },
		e_pneq   => p::PNEQ,
		e_fneq   => p::fneq,
		e_less   => p::ilt,
		e_branch => (fn (cmp, x, y, a, b) =  BRANCH (cmp,[x, y], make_var(), a, b)),
		e_strneq => (fn (w, str, a, b) =  BRANCH (p::STRNEQ, [INT (size str), w, 
								STRING str], make_var(), a, b)),

		e_switch => (fn (v, l) =  SWITCH (v, make_var(), l)),
		e_add    => (fn (x, y, c) =
				 make_fn (fn v =  ARITH (p::iadd,[x, y], v, INTT, c (VAR v)))),

		e_gettag => (fn (x, c) =  make_fn (fn v =  PURE (p::GETCON,[x], v, INTT, c (VAR v)))), 
		e_unwrap => (fn (x, c) =  make_fn (fn v =  PURE (p::UNWRAP,[x], v, INTT, c (VAR v)))),
		e_getexn => (fn (x, c) =  make_fn (fn v =  PURE (p::GETEXN,[x], v, bogt, c (VAR v)))), 
		e_length => (fn (x, c) =  make_fn (fn v =  PURE (p::LENGTH,[x], v, INTT, c (VAR v)))), 

		e_boxed  => (fn (x, a, b) =  BRANCH (p::BOXED,[x], make_var(), a, b)),

		e_path   =>  fn (da::HIGHCODE_VARIABLE v, k) =>  k (ren v);
			        _                            =>  bug "unexpected path in convpath";
                             end
            };

        ###########################################################################
	#       UTILITY FUNCTIONS FOR DEALING WITH META-LEVEL FATES       #
        ###########################################################################

	Meta_Fate						#  An abstract representation of the meta-level fate.
            =
            META_FATE { count:  List (Value) -> Fps_Expression,
                    ts:   List( Fps_Type )
                  };


	fun appmc (META_FATE { count, ... }, vs)		#  Appmc:  mcont * List (value) -> cexp 
            =
            count  vs;


	fun make_meta_fate (count, ts)				#  make_meta_fate:  (List (value) -> cexp) *  List (cty) -> cexp 
            =
            META_FATE { count, ts };

	fun rttys (META_FATE { ts, ... } )			#  rttys:  mcont ->  List (cty)
            =
            ts;

        ###########################################################################
	#                        THE MAIN FUNCTION                                #
	#   Converts f::Program -> fate_passing_style::function           #
        ###########################################################################

        # This function is invoked (only) as phase "translate_anormal_to_fps" in
        # the toplevel highcode driver module, 
        #
        #     src/lib/compiler/backend/upper/main/backend-g.pkg
        #

	fun translate_anormal_to_fps fdec
            = 
	    {   (recover_type_info::recover_type_info (fdec, TRUE))		# recover_type_info	is from   src/lib/compiler/backend/upper/optimize/recover-type-info.pkg
                    ->
                    { get_lty, clean_up, ... };
                    

		ctypes =  map ctype;

		fun res_ctys f
                    = 
		    {   lt = get_lty (f::VAR f);

		        if   (lt::ltp_fct   lt)    ctypes (#2 (lt::ltd_fct lt));
			elif (lt::ltp_arrow lt)    ctypes (#3 (lt::ltd_arrow lt));
			else                       [ bogt ];
                        fi;
		    };

		fun get_cty v
                    =
                    ctype (get_lty v);

		fun is_float_record u
                    = 
		    lt::ltw_tyc (

                        get_lty u, 

		        fn tc =  lt::tcw_tuple (
                                     tc,
                                     fn l =  all_float (map ctyc l),
				     fn _ =  FALSE
                                 ),

			fn _ =  FALSE
                    );

		bogus_cont = make_var(); 

		fun bogus_header ce
                    = 
		    {   bogus_knownf = make_var();

		        MUTUALLY_RECURSIVE_FNS ([(KNOWN, bogus_knownf, [make_var()], [bogt],
			    APPLY (VAR bogus_knownf, [STRING "bogus"]))], 
			    MUTUALLY_RECURSIVE_FNS ([(FATE, bogus_cont, [make_var()], [bogt],
				 APPLY (VAR bogus_knownf, [STRING "bogus"]))], ce));
		    }; 

#		with

                exception RENAME;

		my m:   int_hash_table::Hash_Table( Value )
                    =   int_hash_table::make_table (32, RENAME);
#		do

		# f::Highcode_Variable -> fate_passing_style::value 
		#
		fun rename v
                    =
                    int_hash_table::get  m  v
                    except
                        RENAME =  VAR v;

		# (f::Highcode_Variable, fate_passing_style::Value) -> Void
		#
		fun newname (v, w)
                    = 
		    {   case w
                          
                             VAR w' =>  lv::share_name (v, w');
                             _      =>  ();
                        esac;

		        int_hash_table::set  m  (v, w);
                    };

		# ( List( f::Highcode_Variable ),
                #   List( fate_passing_style::Value )
                # )
                # -> Void
                #
		fun newnames (v ! vs, w ! ws)
                        =>
                        {   newname (v, w);
                            newnames (vs, ws);
                        };

		    newnames ([], [])
                        =>
                        ();

		    newnames _
                        =>
                        bug "unexpected case in newnames";
                end;

		# is_eta:  cexp * List (value)  -> Null_Or( value )
		#
		fun is_eta (APPLY (w as VAR lv, vl), ul)
                        => 

			# If the function is in the global renaming table and it's
			# renamed to itself, then it's most likely a while loop and
			# should *not* be eta-reduced

			if ( case (int_hash_table::get  m  lv)
                               
				  VAR lv' =>  lv == lv';
				  _       =>  FALSE;
                             esac
			     except
                                 RENAME =  FALSE
			)
                             NULL;
			else
			     h (ul, vl)
                             where
				 fun h (x ! xs, y ! ys)
					 => 
					 (veq (x, y)  and  not (veq (w, y)))
					     ??  h (xs, ys)
					     ::  NULL;

				     h ([], [])
					 =>
					 THE w;

				     h _ =>
					 NULL;
                                 end;
                             end;
                        fi;

		    is_eta _ => NULL;
                end;

#		end #  local of Rename 

		fun prevent_eta (META_FATE { count=>c, ts } )		#  prevent_eta:  mcont -> (cexp -> cexp) * value 
                    = 
		    {   vl = map make_var ts;
			ul = map VAR vl;
			b = c ul;

		        case (is_eta (b, ul) )
			  
                             THE w => (ident, w);

			     NULL
                                 =>
                                 {   f = make_var();

			             (  fn x =   MUTUALLY_RECURSIVE_FNS ([(FATE, f, vl, ts, b)], x),
                                        VAR f
                                     );
			         };
                        esac;
		    };

		do_switch						# Switch optimization 
                    =
                    do_switch_fn rename;



		#  lpvar:  f::value -> value 

		fun lpvar (f::VAR    v) =>  rename v;
		    lpvar (f::WORD32 w) =>  INT32 w;
		    lpvar (f::INT    i) =>  INT i;
		    lpvar (f::WORD   w) =>  INT (unt::to_int_x w);
		    lpvar (f::REAL   r) =>  REAL r;
		    lpvar (f::STRING s) =>  STRING s;

		    lpvar (f::INT32 i)
			=> 
			{   int32to_word32
                                =
                                unt32::from_large_int  o  int32::to_large;

			    INT32 (int32to_word32 i);
			};
                end;


		# lpvars:  List( f::value ) -> List( value )
		#
		fun lpvars vl
		    = 
		    h (vl, [])
                    where
		        fun h (   [], z) =>  reverse z;
			    h (a ! r, z) =>  h (r, (lpvar a) ! z);
                        end;
		    end;

		#  loop:  f::Lambda_Expression * (List( value ) -> cexp) -> cexp 
		#
		fun loop' m (le, c)
                    =
                    {   loop = loop' m;

			case le
                          

			     f::RET vs => appmc (c, lpvars vs);

			     f::LET (vs, e1, e2)
				 =>
				 loop (e1, kont)
                                 where
				     kont = make_meta_fate
                                              ( fn ws = { newnames (vs, ws); loop (e2, c);},
					        map (get_cty o f::VAR) vs
                                              );
				 end;

			     f::MUTUALLY_RECURSIVE_FNS (fds, e)
                                 =>
				 {
				     # lpfd:  f::Function_Declaration -> function
				     #
                                     fun lpfd ((fk, f, vts, e):   f::Function_Declaration)
					 = 
					 {   k = make_var();
					     cl = CNTT ! (map (ctype o #2) vts);

					     kont = make_meta_fate (fn vs = APPLY (VAR k, vs), res_ctys f);

					     my (vl, body)
                                                 =
						 case fk
						   
						      { is_recursive => THE (_, f::TAIL_RECURSIVE_LOOP), ... }
                                                          =>
							  {   # For tail recursive loops, we create a
							      # local function that takes its fate
							      # from the dictionary:

							      f' = cplv f;

							      # Here we add a dumb entry for f' in the
							      # global renaming table just so that is_eta
							      # can avoid eta-reducing it:

							      newname (f', VAR f');
							      vl = k ! (map (cplv o #1) vts);
							      vl' = map #1 vts;
							      cl' = map (ctype o #2) vts;

							      ( vl,
							        MUTUALLY_RECURSIVE_FNS ([(KNOWN_TAIL, f', vl', cl',
								     #  Add the function to the tail map 
								     loop' (m::set (m, f, f')) (e, kont))],
								   APPLY (VAR f', map VAR (tail vl)))
                                                              );
							   };

						    _ => (k ! (map #1 vts), loop (e, kont));

			                         esac;

				             (ESCAPE, f, vl, cl, body);
				         };

			             MUTUALLY_RECURSIVE_FNS (map lpfd fds, loop (e, c));   
			         };

			     f::APPLY (f as f::VAR lv, vs)
				 =>
				 # First check if it's a recursive call to a tail loop:
                                 # 
				 case (m::get (m, lv))
				   
				      THE f'
                                          =>
                                          APPLY (VAR f', lpvars vs);

				      NULL
					  =>
					  # Code for the non-tail case.
					  # Sadly this is *not* exceptional

					  {   my (header, fff) = prevent_eta c;
					      vf = lpvar f;
					      ul = lpvars vs;
					      header (APPLY (vf, fff ! ul));
					  };
                                 esac;

			     f::APPLY _
                                 =>
                                 bug "unexpected APPLY in convert";

			     (f::TYPE_FN _ | f::TYPE_APPLY _)
                                 => 
				 bug "unexpected TYPE_FN and TYPE_APPLY in convert";

			     f::RECORD (f::RK_VECTOR _, [], v, e)
                                 => 
				 bug "zero length vectors in convert";

			     f::RECORD (rk, [], v, e)
                                 => 
				 {  newname (v, INT 0);
				    loop (e, c);
				 };

			     f::RECORD (rk, vl, v, e)
                                 => 
				 {   ts  =  map get_cty vl;
				     nvl =  lpvars vl;
				     ce  =  loop (e, c);

				     case rk 
				       
				          f::RK_TUPLE _
					      => 
					      all_float ts
                                                  ??   record_fl (nvl, ts, v, ce)
					          ::   record_nm (nvl, ts, v, ce);

				          f::RK_VECTOR _
					      => 
					      RECORD (RK_VECTOR, map (fn x => (x, offp0); end ) nvl, v, ce);

				          _   =>
                                              record_nm (nvl, ts, v, ce);
                                     esac;
				 };

			     f::SELECT (u, i, v, e)
                                 => 
				 {   ct =  get_cty (f::VAR v);
				     nu =  lpvar u;
				     ce =  loop (e, c);

				     if (is_float_record u)
                                          select_fl (i, nu, v, ct, ce);
				     else select_nm (i, nu, v, ct, ce); fi;
				 };

			     f::SWITCH (e, l, [ a as (f::DATACON((_, da::CONSTANT 0, _), _, _), _),
					        b as (f::DATACON((_, da::CONSTANT 1, _), _, _), _) ], 
				       NULL)
                                 =>
				 loop (f::SWITCH (e, l,[b, a], NULL), c);

			     f::SWITCH (u, an_api, l, d)
				 => 
				 {   my (header, fff) = prevent_eta c;

				     kont = make_meta_fate   (fn vl = APPLY (fff, vl),   rttys c);

				     body = 
					 {   df = make_var();

					     fun proc (cn as (f::DATACON (dc, _, v)), e)
                                                     => 
						     (cn, loop (f::LET([v], f::RET [u], e), kont));

						 proc (cn, e)
                                                     =>
                                                     (cn, loop (e, kont));
                                              end;

					     b = do_switch { an_api, expression=>lpvar u, 
							       cases=>map proc l,
							       default=>APPLY (VAR df, [INT 0]) };
					     case d 
						  NULL   => b;
						  THE de => MUTUALLY_RECURSIVE_FNS ([(FATE, df, [make_var()], [INTT], 
								  loop (de, kont))], b);
					     esac;
					 };

				     header body;
				 }; 

			     f::CONSTRUCTOR (dc, ts, u, v, e)
				 => 
				 bug "unexpected case CONSTRUCTOR in fps convert"; 

			     f::RAISE (u, lts)
                                 =>
				 {   # Execute the fate
                                     # for side effects: 
				     #
				     appmc (c, (map (fn _ = VAR (make_var()))  lts));

				     h = make_var();

				     LOOKER (p::GETHANDLER, [], h, FUNT,
					    APPLY (VAR h,[VAR bogus_cont, lpvar u]));
				 };

			     f::EXCEPT (e, u)		 #  recover type from u
                                 =>
				 {   my (header, fff) = prevent_eta c;
				     h = make_var();

				     kont = 
				       make_meta_fate (fn vl =
						SETTER (p::SETHANDLER, [VAR h], APPLY (fff, vl)),
					      rttys c);
				     body=                         
					 {   k = make_var();
					     v = make_var();

					     MUTUALLY_RECURSIVE_FNS ([(ESCAPE, k, [make_var(), v], [CNTT, bogt],
						   SETTER (p::SETHANDLER, [VAR h], 
							  APPLY (lpvar u, [fff, VAR v])))],
						 SETTER (p::SETHANDLER, [VAR k], loop (e, kont)));
					 };

				     LOOKER (p::GETHANDLER, [], h, FUNT, header (body));
				 };

			     f::PRIMOP((_, p as (ap::CALLCC | ap::CAPTURE), _, _), [f], v, e)
                                 =>
				 {   my (kont_decs, fff)
					 = 
					 {   k = make_var();
					     ct = get_cty f;
					     ([(FATE, k, [v], [ct], loop (e, c))], VAR k);
					 };

				     my (hdr1, hdr2)
					 = 
					 case p
                                           
					      ap::CALLCC
                                                  =>
						  make_fn (fn h = ( fn e =  SETTER (p::SETHANDLER, [VAR h], e),
								    fn e =  LOOKER (p::GETHANDLER, [], h, bogt, e)
                                                                  )
                                                          );

					       _ => (ident, ident);
					 esac;

				     my (ccont_decs, ccont_var)
					 = 
					 {   k = make_var(); #  Captured fate 
					     x = make_var(); 

					     ([(ESCAPE, k, [make_var(), x], [CNTT, bogt], 
						hdr1 (APPLY (fff, [VAR x])))], k);
					 };

				     MUTUALLY_RECURSIVE_FNS (kont_decs, 
				       hdr2 (MUTUALLY_RECURSIVE_FNS (ccont_decs, 
						APPLY (lpvar f, [fff, VAR ccont_var]))));
				 };

			     f::PRIMOP((_, ap::ISOLATE, lt, ts), [f], v, e)
                                 => 
				 {   my (exndecs, exnvar)
					 = 
					 {   h = make_var ();
					     z = make_var ();
					     x = make_var ();

					     ( [ ( ESCAPE, h, [z, x], [CNTT, bogt], APPLY (VAR bogus_cont, [VAR x]))
                                               ],
                                               h
                                             );
					 };

				     newfdecs
					 = 
					 {   nf = v;

					     z = make_var();
					     x = make_var();

					     [ (ESCAPE, v, [z, x], [CNTT, bogt],
						SETTER (p::SETHANDLER, [VAR exnvar],
						  APPLY (lpvar f, [VAR bogus_cont, VAR x])))
                                             ]; 
					 };

				     MUTUALLY_RECURSIVE_FNS (exndecs, MUTUALLY_RECURSIVE_FNS (newfdecs, loop (e, c)));
				 };

			     f::PRIMOP (po as (_, ap::THROW, _, _), [u], v, e)
                                 => 
				 {   newname (v, lpvar u);
                                     loop (e, c);
                                 }; 
		  #             PURE (p::wrap, [lpvar u], v, FUNt, c (VAR v))          

			     f::PRIMOP (po as (_, ap::WCAST, _, _), [u], v, e)
                                 =>
				 {   newname (v, lpvar u);
                                     loop (e, c);
                                 };

			     f::PRIMOP (po as (_, ap::WRAP, _, _), [u], v, e)
                                 => 
				 {   ct = ctyc (anormal_stuff::get_wrap_type_constructor po);
				     PURE (primwrap ct, [lpvar u], v, bogt, loop (e, c));
				 };

			     f::PRIMOP (po as (_, ap::UNWRAP, _, _), [u], v, e)
                                 =>
				 {   ct = ctyc (anormal_stuff::get_un_wrap_type_constructor po);
				     PURE (primunwrap ct, [lpvar u], v, ct, loop (e, c));
				 };

			     f::PRIMOP (po as (_, ap::MARKEXN, _, _), [x, m], v, e)
                                 =>
				 {   bty = lt::ltc_void;
				     ety = lt::ltc_tuple [bty, bty, bty];

				     my (xx, x0, x1, x2)
                                         =
                                         (make_var(), make_var(), make_var(), make_var());

				     my (y, z, z')
                                         =
                                         ( make_var (),
                                           make_var (),
                                           make_var ()
                                         );

				     PURE (p::UNWRAP,[lpvar x], xx, ctype (ety),
					 SELECT (0, VAR xx, x0, bogt,
					   SELECT (1, VAR xx, x1, bogt,
					     SELECT (2, VAR xx, x2, bogt,
					       RECORD (RK_RECORD,[(lpvar m, offp0),
								 (VAR x2, offp0)], z,
						      PURE (p::WRAP,[VAR z], z', bogt,
							RECORD (RK_RECORD,[(VAR x0, offp0),
									  (VAR x1, offp0),
									  (VAR z', offp0)],
							       y,
							   PURE (p::WRAP,[VAR y], v, bogt,
								loop (e, c)))))))));
				 };

			     f::PRIMOP ((_, ap::RAW_CCALL NULL, _, _), _ ! _ ! a ! _, v, e)
				 =>
				 # code generated here should never be executed anyway,
				 # so we just fake it...
				 {
#                                    print "*** pro-forma raw-ccall\n";
				     newname (v, lpvar a); loop (e, c);
				 };

			     f::PRIMOP ((_, ap::RAW_CCALL (THE i), lt, ts), f ! a ! _ ! _, v, e)
				 =>
				 {   i ->   { c_prototype => p,
                                              ml_argument_representations => lib7_args,
                                              ml_result_representation => ml_res_opt,
                                              is_reentrant=>reentrant
                                            };

				     fun cty ap::CCR64 => FLTT;
					 cty ap::CCI32 => INT32T;
					 cty ap::CCML  => bogt;
					 cty ap::CCI64 => bogt;
                                     end;

				     a' = lpvar a;

				     rcckind = if reentrant  REENTRANT_RCC; else FAST_RCC;fi;

				     fun rcc args
					 =
					 {   al = map VAR args;

					     my (al, linkage)
                                                 = 
						 case f
                                                    
						      f::STRING linkage =>  (al, linkage);
						      _                 =>  (lpvar f ! al, "");
                                                 esac;

					     case ml_res_opt
					       
						   NULL => RAW_C_CALL (rcckind, linkage, 
								p, al, [(v, INTT)], loop (e, c));
						   THE ap::CCI64
						       =>
						       {   my (v1, v2) = (make_var (), make_var ());

							   RAW_C_CALL
                                                             (  rcckind, linkage, p, al,
								[(v1, INT32T), (v2, INT32T)],
								record_nm([VAR v1, VAR v2],[INT32T, INT32T],
									 v, loop (e, c))
                                                             );
						       };

						   THE rt
                                                       =>
                                                       {
							   v' = make_var ();
							   res_cty = cty rt;

							   RAW_C_CALL (rcckind, linkage, p, al, [(v', res_cty)],
								PURE (primwrap res_cty, [VAR v'], v, bogt,
								     loop (e, c)));
						       };
					     esac;
					 };

				     sel =  if   (is_float_record  a   )   select_fl;
                                                                      else   select_nm;   fi;

				     fun build ([], rvl, _)
                                             =>
                                             rcc (reverse rvl);

					 build (ft ! ftl, rvl, i)
					     =>
					     {
						 t = cty ft;
						 v = make_var ();

						 sel (i, a', v, t, build (ftl, v ! rvl, i + 1));
					     };
                                     end;


				     case lib7_args
                                       
					  [ft] => {

					      # If there is precisely one arg,
					      # then it will not come packaged
                                              # into a record:
                                              #
					      t = cty ft;
					      v = make_var ();

					      PURE (primunwrap t, [a'], v, t, rcc [v]);
					  };

					  _ => build (lib7_args, [], 0);
                                     esac;
				 };

			     f::PRIMOP ((_, ap::RAW_CCALL _, _, _), _, _, _)
                                 =>
                                 bug "bad raw_ccall";

			     f::PRIMOP ((_, ap::RAW_RECORD _, _, _),[x as f::VAR _], v, e)
				 =>
				 # Code generated here should
                                 # never be executed anyway,
				 # so we just fake it:
				 {
#                                    print "*** pro-forma raw-record\n";
				     newname (v, lpvar x); loop (e, c);
				 };

			     f::PRIMOP (po as (_, p, lt, ts), ul, v, e)
                                 => 
				 {   ct = case (#3 (lt::ltd_arrow (lt::protected_instantiation_of_polymorphic_lambda_or_higher_order_constructor_type (lt, ts))))

					       [x] =>  ctype x;
					       _   =>  bug "unexpected case in f::PRIMOP";
					  esac;

				     vl = lpvars ul;

				     case (map_primop p)
				        PKS i => { newname (v, INT 0);
						    SETTER (i, vl, loop (e, c));
						  };
					PKA i => ARITH (i, vl, v, ct, loop (e, c));
					PKL i => LOOKER (i, vl, v, ct, loop (e, c));
					PKP i => PURE (i, vl, v, ct, loop (e, c));
                                     esac;
				 };

			     f::BRANCH (po as (_, p, _, _), ul, e1, e2)
                                 => 
				 {   my (header, fff) = prevent_eta c;

				     kont =  make_meta_fate   (fn vl = APPLY (fff, vl),   rttys c);

				     header (BRANCH (map_branch p, lpvars ul, make_var(),
					       loop (e1, kont), loop (e2, kont)));
				 };
                        esac;
		    };

		#  Process the top-level Function_Declaration: 

		fdec ->   (fk, f, vts, be);

		k = make_var();    #  top-level return fate 

		kont = make_meta_fate (fn vs = APPLY (VAR k, vs), res_ctys f);

		body = loop' m::empty (be, kont);

		vl = k ! (map #1 vts);
		cl = CNTT ! (map (ctype o #2) vts);

		(ESCAPE, f, vl, cl, bogus_header body)
                before
                    clean_up ();

	    };		#  fun translate_anormal_to_fps
    end;		#  toplevel stipulate 
};			#  generic package translate_anormal_to_fps_g 



## COPYRIGHT 1998 BY YALE FLINT PROJECT 
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
