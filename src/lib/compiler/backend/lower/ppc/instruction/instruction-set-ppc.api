## instruction-set-ppc.api
#
# WARNING: This file was automatically generated by mdl_g (v3.0)
# from the machine description file "ppc/ppc.mdl".
# DO NOT EDIT this file directly

# Compiled by:
#     src/lib/compiler/backend/lower/make7/ppc.make6


api Instruction_Set_Ppc {

    package cells: Ppccells;		# Ppccells	is from   src/lib/compiler/backend/lower/ppc/instruction/ppc-cells.pkg

    package cb:    Cells_Basis		# Cells_Basis	is from   src/lib/compiler/backend/lower/instruction/cells-basis.api
              =    cells_basis;

    package codetree:  Codetree;	# Codetree	is from   src/lib/compiler/backend/lower/codetree/codetree.api
    package constant:  Constant;	# Constant	is from   src/lib/compiler/backend/lower/instruction/constant.api
    package region:    Region;		# Region	is from   src/lib/compiler/backend/lower/instruction/region.api

    sharing constant == codetree::constant;
    sharing region   == codetree::region;

    Gpr = Int;
    Fpr = Int;
    Ccr = Int;
    Crf = Int;

    Spr
      = XER
      | LR
      | CTR;

    Operand
      = REG_OP  cells_basis::Cell
      | IMMED_OP  Int
      | LABEL_OP  codetree::Labexp;

    Addressing_Mode = (cells_basis::Cell, Operand);

    Ea
      = DIRECT  cells_basis::Cell
      | FDIRECT  cells_basis::Cell
      | DISPLACE  { base: cells_basis::Cell, disp: codetree::Labexp, mem: region::Region };

    Load
      = LBZ
      | LBZE
      | LHZ
      | LHZE
      | LHA
      | LHAE
      | LWZ
      | LWZE
      | LDE
      | LBZU
      | LHZU
      | LHAU
      | LWZU
      | LDZU;

    Store
      = STB
      | STBE
      | STH
      | STHE
      | STW
      | STWE
      | STDE
      | STBU
      | STHU
      | STWU
      | STDU;

    Fload
      = LFS
      | LFSE
      | LFD
      | LFDE
      | LFSU
      | LFDU;

    Fstore
      = STFS
      | STFSE
      | STFD
      | STFDE
      | STFSU
      | STFDU;

    Cmp
      = CMP
      | CMPL;

    Fcmp
      = FCMPO
      | FCMPU;

    Unary
      = NEG
      | EXTSB
      | EXTSH
      | EXTSW
      | CNTLZW
      | CNTLZD;
    Funary
      = FMR
      | FNEG
      | FABS
      | FNABS
      | FSQRT
      | FSQRTS
      | FRSP
      | FCTIW
      | FCTIWZ
      | FCTID
      | FCTIDZ
      | FCFID;

    Farith
      = FADD
      | FSUB
      | FMUL
      | FDIV
      | FADDS
      | FSUBS
      | FMULS
      | FDIVS;

    Farith3
      = FMADD
      | FMADDS
      | FMSUB
      | FMSUBS
      | FNMADD
      | FNMADDS
      | FNMSUB
      | FNMSUBS
      | FSEL;

    Bo
      = TRUE
      | FALSE
      | ALWAYS
      | COUNTER  { eq_zero: Bool, cond: Null_Or( Bool ) };

    Arith
      = ADD
      | SUBF
      | MULLW
      | MULLD
      | MULHW
      | MULHWU
      | DIVW
      | DIVD
      | DIVWU
      | DIVDU
      | AND
      | OR
      | XOR
      | NAND
      | NOR
      | EQV
      | ANDC
      | ORC
      | SLW
      | SLD
      | SRW
      | SRD
      | SRAW
      | SRAD;

    Arithi
      = ADDI
      | ADDIS
      | SUBFIC
      | MULLI
      | ANDI_RC
      | ANDIS_RC
      | ORI
      | ORIS
      | XORI
      | XORIS
      | SRAWI
      | SRADI;

    Rotate
      = RLWNM
      | RLDCL
      | RLDCR;

    Rotatei
      = RLWINM
      | RLWIMI
      | RLDICL
      | RLDICR
      | RLDIC
      | RLDIMI;

    Ccarith
      = CRAND
      | CROR
      | CRXOR
      | CRNAND
      | CRNOR
      | CREQV
      | CRANDC
      | CRORC;

    Bit
      = LT
      | GT
      | EQ
      | SO
      | FL
      | FG
      | FE
      | FU
      | FX
      | FEX
      | VX
      | OX;

    Xerbit
      = SO64
      | OV64
      | CA64
      | SO32
      | OV32
      | CA32;

    Cr_Bit = ((cells_basis::Cell), Bit);

    Base_Instruction
      = LL  { ld: Load, rt: cells_basis::Cell, ra: cells_basis::Cell, d: Operand, mem: region::Region }
      | LF  { ld: Fload, ft: cells_basis::Cell, ra: cells_basis::Cell, d: Operand, mem: region::Region }
      | ST  { st: Store, rs: cells_basis::Cell, ra: cells_basis::Cell, d: Operand, mem: region::Region }
      | STF  { st: Fstore, fs: cells_basis::Cell, ra: cells_basis::Cell, d: Operand, mem: region::Region }
      | UNARY  { oper: Unary, rt: cells_basis::Cell, ra: cells_basis::Cell, rc: Bool, oe: Bool }
      | ARITH  { oper: Arith, rt: cells_basis::Cell, ra: cells_basis::Cell, rb: cells_basis::Cell, rc: Bool, oe: Bool }
      | ARITHI  { oper: Arithi, rt: cells_basis::Cell, ra: cells_basis::Cell, im: Operand }
      | ROTATE  { oper: Rotate, ra: cells_basis::Cell, rs: cells_basis::Cell, sh: cells_basis::Cell, mb: Int, me: Null_Or( Int ) }
      | ROTATEI  { oper: Rotatei, ra: cells_basis::Cell, rs: cells_basis::Cell, sh: Operand, mb: Int, me: Null_Or( Int ) }
      | COMPARE  { cmp: Cmp, l: Bool, bf: cells_basis::Cell, ra: cells_basis::Cell, rb: Operand }
      | FCOMPARE  { cmp: Fcmp, bf: cells_basis::Cell, fa: cells_basis::Cell, fb: cells_basis::Cell }
      | FUNARY  { oper: Funary, ft: cells_basis::Cell, fb: cells_basis::Cell, rc: Bool }
      | FARITH  { oper: Farith, ft: cells_basis::Cell, fa: cells_basis::Cell, fb: cells_basis::Cell, rc: Bool }
      | FARITH3  { oper: Farith3, ft: cells_basis::Cell, fa: cells_basis::Cell, fb: cells_basis::Cell, fc: cells_basis::Cell, rc: Bool }
      | CCARITH  { oper: Ccarith, bt: Cr_Bit, ba: Cr_Bit, bb: Cr_Bit }
      | MCRF  { bf: cells_basis::Cell, bfa: cells_basis::Cell }
      | MTSPR  { rs: cells_basis::Cell, spr: cells_basis::Cell }
      | MFSPR  { rt: cells_basis::Cell, spr: cells_basis::Cell }
      | LWARX  { rt: cells_basis::Cell, ra: cells_basis::Cell, rb: cells_basis::Cell }
      | STWCX  { rs: cells_basis::Cell, ra: cells_basis::Cell, rb: cells_basis::Cell }
      | TW  { to: Int, ra: cells_basis::Cell, si: Operand }
      | TD  { to: Int, ra: cells_basis::Cell, si: Operand }
      | BC  { bo: Bo, bf: cells_basis::Cell, bit: Bit, address: Operand, lk: Bool, fall: Operand }
      | BCLR  { bo: Bo, bf: cells_basis::Cell, bit: Bit, lk: Bool, labels: List( label::Label ) }
      | BB  { address: Operand, lk: Bool }
      | CALL  { def: cells::Cellset, uses: cells::Cellset, cuts_to: List( label::Label ), mem: region::Region }
      | SOURCE  { }
      | SINK  { }
      | PHI  { }

    also
    Instruction
      = LIVE  { regs: cells::Cellset, spilled: cells::Cellset }
      | DEAD  { regs: cells::Cellset, spilled: cells::Cellset }
      | COPY  { kind: cells_basis::Cellkind, 
		size_in_bits: Int,          #  in bits 
		dst: List( cells_basis::Cell ),
		src: List( cells_basis::Cell ),
		tmp: Null_Or(  Ea ) /* NULL if |dst| == { src| == 1 */
	       }
      | NOTE  { instruction: Instruction,
		note:        note::Note
	      }
      | BASE_INSTRUCTION  Base_Instruction;

     ll:  { ld: Load, rt: cells_basis::Cell, ra: cells_basis::Cell, d: Operand, mem: region::Region } -> Instruction;
     lf:  { ld: Fload, ft: cells_basis::Cell, ra: cells_basis::Cell, d: Operand, mem: region::Region } -> Instruction;
     st:  { st: Store, rs: cells_basis::Cell, ra: cells_basis::Cell, d: Operand, mem: region::Region } -> Instruction;
     stf: { st: Fstore, fs: cells_basis::Cell, ra: cells_basis::Cell, d: Operand, mem: region::Region } -> Instruction;

     compare:  { cmp: Cmp, l: Bool, bf: cells_basis::Cell, ra: cells_basis::Cell, rb: Operand } -> Instruction;
     fcompare: { cmp: Fcmp, bf: cells_basis::Cell, fa: cells_basis::Cell, fb: cells_basis::Cell } -> Instruction;

     unary:    { oper: Unary, rt: cells_basis::Cell, ra: cells_basis::Cell, rc: Bool, oe: Bool } -> Instruction;
     arith:    { oper: Arith, rt: cells_basis::Cell, ra: cells_basis::Cell, rb: cells_basis::Cell, rc: Bool, oe: Bool } -> Instruction;
     arithi:   { oper: Arithi, rt: cells_basis::Cell, ra: cells_basis::Cell, im: Operand } -> Instruction;
     rotate:   { oper: Rotate, ra: cells_basis::Cell, rs: cells_basis::Cell, sh: cells_basis::Cell, mb: Int, me: Null_Or( Int ) } -> Instruction;
     rotatei:  { oper: Rotatei, ra: cells_basis::Cell, rs: cells_basis::Cell, sh: Operand, mb: Int, me: Null_Or( Int ) } -> Instruction;
     funary:   { oper: Funary, ft: cells_basis::Cell, fb: cells_basis::Cell, rc: Bool } -> Instruction;
     farith:   { oper: Farith, ft: cells_basis::Cell, fa: cells_basis::Cell, fb: cells_basis::Cell, rc: Bool } -> Instruction;
     farith3:  { oper: Farith3, ft: cells_basis::Cell, fa: cells_basis::Cell, fb: cells_basis::Cell, fc: cells_basis::Cell, rc: Bool } -> Instruction;
     ccarith:  { oper: Ccarith, bt: Cr_Bit, ba: Cr_Bit, bb: Cr_Bit } -> Instruction;

     mcrf:   { bf: cells_basis::Cell, bfa: cells_basis::Cell } -> Instruction;
     mtspr:  { rs: cells_basis::Cell, spr: cells_basis::Cell } -> Instruction;
     mfspr:  { rt: cells_basis::Cell, spr: cells_basis::Cell } -> Instruction;
     lwarx:  { rt: cells_basis::Cell, ra: cells_basis::Cell, rb: cells_basis::Cell } -> Instruction;
     stwcx:  { rs: cells_basis::Cell, ra: cells_basis::Cell, rb: cells_basis::Cell } -> Instruction;

     tw:    { to: Int, ra: cells_basis::Cell, si: Operand } -> Instruction;
     td:    { to: Int, ra: cells_basis::Cell, si: Operand } -> Instruction;

     bc:    { bo: Bo, bf: cells_basis::Cell, bit: Bit, address: Operand, lk: Bool, fall: Operand } -> Instruction;
     bclr:  { bo: Bo, bf: cells_basis::Cell, bit: Bit, lk: Bool, labels: List( label::Label ) } -> Instruction;

     bb:    { address: Operand, lk: Bool } -> Instruction;

     call:  { def: cells::Cellset, uses: cells::Cellset, cuts_to: List( label::Label ), mem: region::Region } -> Instruction;

     source: { } -> Instruction;
     sink:   { } -> Instruction;
     phi:    { } -> Instruction;
};

