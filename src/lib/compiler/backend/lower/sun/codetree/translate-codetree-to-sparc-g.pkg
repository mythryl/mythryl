## translate-codetree-to-sparc-g.pkg
#
# CONTEXT:
#
#     The Mythryl compiler code representations used are, in order:
#
#     1)  Raw Syntax is the initial front-end code representation.
#     2)  Deep Syntax is the second and final front-end code representation.
#     3)  Polylambda is the first backend code representation, used only transitionally.
#     4)  A-Normal  is the second backend code representation, and the first used for optimization.
#     5)  Fate-Passing-Style is the third and chief backend upper-half code representation.
#     6)  Codetree is the chief backend lower-half code representation.
#     7)  X86 instruction format (or equivalent for other target machines) -- an abstract tree format.
#     8)  X86 machine language   (or equivalent for other target machines) -- absolute binary code.
#
# For general context, see
#
#     src/lib/compiler/README
#
# This module implements conversion from Codetree to
# abstract Sparc machine instructions.  This is essentially
# an instruction selection task.
#
# Our runtime invocation is from
#
#     src/lib/compiler/codegen/main/translate-fate-passing-style-to-binary-g.pkg

# Compiled by:
#     src/lib/compiler/backend/lower/make7/sparc.make6



# This is a new instruction selection module for Sparc, 
# using the new instruction representation and the new
# Codetree representation. Support for V9 has been added.
#
# The cc bit in arithmetic op are now embedded within the arithmetic
# opcode.  This should save some space.
#
# -- Allen Leung



###                  "Though I had success in my research
###                   both when I was mad and when I was not,
###                   eventually I felt that my work would
###                   be better respected if I thought
###                   and acted like a 'normal' person."
###
###                                -- John Forbes Nash 



# We are invoked from:
#
#     src/lib/compiler/codegen/sun/sparc-codetree.pkg

generic package translate_codetree_to_sparc_g (

    package instruction_set:  Instruction_Set_Sparc;			# Instruction_Set_Sparc		is from   src/lib/compiler/backend/lower/sun/instruction/instruction-set-sparc.api

    package pseudo_instrs
	:
	Sparc_Pseudo_Instr						# Sparc_Pseudo_Instr		is from   src/lib/compiler/backend/lower/sun/codetree/sparc-pseudo-instruction.api
	where instruction_set == instruction_set;

    package extension_comp
	:
	Codetree_Extension_Default					# Codetree_Extension_Default	is from   src/lib/compiler/backend/lower/codetree/codetree-extension-default.api
	where instruction_set == instruction_set
	 also codetree == instruction_set::codetree;


    # The client should also specify these parameters.
    # These are the estimated cost of these instructions.
    # The code generator will use alternative sequences that are
    # cheaper when their costs are lower.
    #
    mulu_cost:  Ref( Int );  # Cost of unsigned multiplication in cycles 
    divu_cost:  Ref( Int );  # Cost of unsigned division in cycles 
    mult_cost:  Ref( Int );  # Cost of trapping/signed multiplication in cycles 
    divt_cost:  Ref( Int );  # Cost of trapping/signed division in cycles 

    # If you don't want to use register
    # windows at all, set this to FALSE:
    #
    registerwindow:  Ref( Bool );	# Should we use register windows? 

    v9:  Bool;				# Should we use v9 instruction set? 

    use_br:  Ref( Bool );		# Should we use the BR instruction (when in v9)?
					# (I think it is a good idea to use it.)
)

: (weak)  Translate_Codetree_To_Target_Machine					# Translate_Codetree_To_Target_Machine		is from   src/lib/compiler/backend/lower/codetree/translate-codetree-to-target-machine.api

{
    package instruction_set =  instruction_set;
    package cells           =  instruction_set::cells;
    package codetree        =  instruction_set::codetree;
    package codetree_stream =  extension_comp::codetree_stream;

    package i  = instruction_set;
    package t  = codetree;
    package ts = codetree_stream;
    package r  = t::region;
    package c  = cells;
    package cb = cells_basis;					# cells_basis			is from   src/lib/compiler/backend/lower/instruction/cells-basis.pkg
    package w  = unt32;						# unt32				is from   src/lib/std/unt32.pkg
    package p  = pseudo_instrs;
    package a  = lowcode_notes;					# lowcode_notes			is from   src/lib/compiler/backend/lower/instruction/lowcode-notes.pkg

    package control_flow_graph
        =
        extension_comp::control_flow_graph;

    Instruction_Stream = ts::Stream( i::Instruction, c::Cellset,	control_flow_graph::Control_Flow_Graph );
    Codetree_Stream    = ts::Stream( t::Statement,   List( t::Expression ),	control_flow_graph::Control_Flow_Graph );

    fun to_int n = t::machine_int::to_int (32, n);
    fun li i = t::LITERAL (t::machine_int::from_int (32, i));

    fun lt (n, m) =   t::machine_int::lt (32, n, m);
    fun le (n, m) =   t::machine_int::le (32, n, m);

    fun copy { dst, src, tmp }
        = 
	i::COPY { kind => cb::REGISTER, size_in_bits => 32, dst, src, tmp };

    fun fcopy { dst, src, tmp }
        = 
	i::COPY { kind => cb::FLOAT_REGISTER, size_in_bits => 64, dst, src, tmp };

    int_type = if v9  64; else 32;fi;

    package codetree_stuff
        =
        codetree_stuff_g (						# codetree_stuff_g		is from   src/lib/compiler/backend/lower/codetree/codetree-stuff-g.pkg
            package codetree = t;
	    package cells = c;
	    int_type = int_type;
	    natural_widths = if v9  [32, 64]; else [32];fi;
	     Rep = SE | ZE | NEITHER;
	    rep = NEITHER; 
	);

    generic package multiply32_g
        =
        codetree_mult_g (
	    package instruction_set = instruction_set;
	    package codetree = t;
	    package cb= cells_basis;	# cells_basis	is from   src/lib/compiler/backend/lower/instruction/cells-basis.pkg
	     Arg  = { r1: cb::Cell, r2: cb::Cell, d: cb::Cell };
	     Argi = { r: cb::Cell, i: Int, d: cb::Cell };

	    int_type = 32;    

	    fun mov { r, d }      = copy { dst => [d], src => [r], tmp=>NULL };

	    fun add { r1, r2, d } = i::arith { a=>i::ADD, r=>r1, i=>i::REG r2, d };

	    fun slli { r, i, d }  = [i::shift { s=>i::LEFTSHIFT, r, i=>i::IMMED i, d } ];
	    fun srli { r, i, d }  = [i::shift { s=>i::RIGHTSHIFTU, r, i=>i::IMMED i, d } ];
	    fun srai { r, i, d }  = [i::shift { s=>i::RIGHTSHIFT, r, i=>i::IMMED i, d } ];
        );

    generic package multiply64_g
        =
        codetree_mult_g (
	    package instruction_set = instruction_set;
	    package codetree = t;
	    package cb = cells_basis;
	     Arg  = { r1: cb::Cell, r2: cb::Cell, d: cb::Cell };
	     Argi = { r: cb::Cell, i: Int, d: cb::Cell };

	    int_type = 64;    

	    fun mov { r, d } = copy { dst => [d], src => [r], tmp=>NULL };

	    fun add { r1, r2, d } = i::arith { a=>i::ADD, r=>r1, i=>i::REG r2, d };
	    fun slli { r, i, d } = [i::shift { s=>i::SLLX, r, i=>i::IMMED i, d } ];
	    fun srli { r, i, d } = [i::shift { s=>i::SRLX, r, i=>i::IMMED i, d } ];
	    fun srai { r, i, d } = [i::shift { s=>i::SRAX, r, i=>i::IMMED i, d } ];
	);

    # Signed, trapping version of multiply and divide 
    #
    package mult32
	 =
	multiply32_g (
	    trapping = TRUE;
	    mult_cost = mult_cost; 

	    fun addv { r1, r2, d }
                = 
		i::arith { a=>i::ADDCC, r=>r1, i=>i::REG r2, d } ! pseudo_instrs::overflowtrap32; 

	    fun subv { r1, r2, d }
                = 
		i::arith { a=>i::SUBCC, r=>r1, i=>i::REG r2, d } ! pseudo_instrs::overflowtrap32; 

	    sh1addv = NULL; 
	    sh2addv = NULL; 
	    sh3addv = NULL; 
	)
	(
            signed = TRUE;
        );

    # Unsigned, non-trapping version of multiply and divide 
    #
    generic package mul32_g
        =
        multiply32_g (
	    trapping = FALSE;
	    mult_cost = mulu_cost;
	    fun addv { r1, r2, d } = [i::arith { a=>i::ADD, r=>r1, i=>i::REG r2, d } ];
	    fun subv { r1, r2, d } = [i::arith { a=>i::SUB, r=>r1, i=>i::REG r2, d } ];
	    sh1addv = NULL; 
	    sh2addv = NULL; 
	    sh3addv = NULL; 
	);

    package mulu32 = mul32_g (signed = FALSE;);

    package muls32 = mul32_g (signed = TRUE;);

    # Signed, trapping version of multiply and divide 
    #
    package mult64
        =
        multiply64_g (
	    trapping = TRUE;
	    mult_cost = mult_cost; 

	    fun addv { r1, r2, d }
                = 
		i::arith { a=>i::ADDCC, r=>r1, i=>i::REG r2, d } ! pseudo_instrs::overflowtrap64; 

	    fun subv { r1, r2, d }
                = 
		i::arith { a=>i::SUBCC, r=>r1, i=>i::REG r2, d } ! pseudo_instrs::overflowtrap64; 

	    sh1addv = NULL; 
	    sh2addv = NULL; 
	    sh3addv = NULL; 
	)
        (
            signed = TRUE;
        );

    # Unsigned, non-trapping version of multiply and divide 
    #
    generic package mul64_g
        =
        multiply64_g (
	    trapping = FALSE;
	    mult_cost = mulu_cost;
	    fun addv { r1, r2, d } = [i::arith { a=>i::ADD, r=>r1, i=>i::REG r2, d } ];
	    fun subv { r1, r2, d } = [i::arith { a=>i::SUB, r=>r1, i=>i::REG r2, d } ];
	    sh1addv = NULL; 
	    sh2addv = NULL; 
	    sh3addv = NULL; 
	);

    package mulu64 = mul64_g (signed = FALSE;);
    package muls64 = mul64_g (signed = TRUE;);

     Commutative = COMMUTE | NOCOMMUTE;

     Cc = REG    #  write to register 
	| CC     #  set condition code 
	| CC_REG #  Do both 
        ;

    fun error msg
        =
        lowcode_error_message::error("Sparc", msg);



    fun select_instructions
	 (instruction_stream
             as
	     ts::instruction_stream::STREAM { emit=>emit_instruction, define_local_label, define_global_label, emit_pseudo_op, add_note, get_notes,
		   begin_cluster, end_cluster, end_procedure, emit_comment, ... }
         )
	=
	{
	    emit		 = emit_instruction o i::BASE_INSTRUCTION;
	    #  Flags 
	    use_br          = *use_br;
	    registerwindow = *registerwindow;

	    trap32  = pseudo_instrs::overflowtrap32; 
	    trap64  = pseudo_instrs::overflowtrap64; 
	    zero_r   = c::r0;
	    new_reg  = c::new_reg;
	    new_freg = c::new_freg;

	    fun immed13 n
		=
		le (-4096, n)   and
		lt (n, 4096);

	    fun immed13w w
		=
		{ x = w::(>>>) (w, 0u12);

		    x == 0u0 or (w::bitwise_not x) == 0u0;
		};

	    fun splitw w
                =
                {   hi=>w::to_int (w::(>>) (w, 0u10)),
                    lo=>w::to_int (w::bitwise_and (w, 0ux3ff))
                };

	    fun split n
                =
                splitw (t::machine_int::to_word32 (32, n));


	    zero_opn = i::REG zero_r; #  zero value operand 

	    fun cond t::LT  => i::BL;
		cond t::LTU => i::BCS;
		cond t::LE  => i::BLE;
		cond t::LEU => i::BLEU;
		cond t::EQ  => i::BE;
		cond t::NE  => i::BNE;
		cond t::GE  => i::BGE;
		cond t::GEU => i::BCC;
		cond t::GT  => i::BG;
		cond t::GTU => i::BGU;
		cond _     => error "cond";
	    end;

	    fun rcond t::LT  => i::RLZ;
		rcond t::LE  => i::RLEZ;
		rcond t::EQ  => i::RZ;
		rcond t::NE  => i::RNZ;
		rcond t::GE  => i::RGEZ;
		rcond t::GT  => i::RGZ;
		rcond _ => error "rcond";
	    end;

	    fun signed_cmp (t::LT | t::LE | t::EQ | t::NE | t::GE | t::GT) => TRUE;
		signed_cmp _ => FALSE;
	    end;

	    fun fcond t::FEQ  => i::FBE;
		fcond t::FNEU => i::FBNE;
		fcond t::FUO  => i::FBU;
		fcond t::FGLE => i::FBO;
		fcond t::FGT  => i::FBG;
		fcond t::FGE  => i::FBGE;
		fcond t::FGTU => i::FBUG;
		fcond t::FGEU => i::FBUGE;
		fcond t::FLT  => i::FBL;
		fcond t::FLE  => i::FBLE;
		fcond t::FLTU => i::FBUL;
		fcond t::FLEU => i::FBULE;
		fcond t::FNE  => i::FBLG;
		fcond t::FEQU => i::FBUE;
		fcond fc => error("fcond " + t::basis::fcond_to_string fc);
	    end;

	    fun annotate (i,     []) =>   i;
		annotate (instruction, note ! notes) =>   annotate (i::NOTE { instruction, note }, notes);
	    end;

	    fun mark'(i, notes) =   emit_instruction (annotate (i, notes)); 
	    fun mark (i, notes) =   emit_instruction (annotate (i::BASE_INSTRUCTION i, notes)); 

	    # Convert an operand into a register:
	    #
	    fun reduce_opn (i::REG   r) =>  r;
		reduce_opn (i::IMMED 0) =>  zero_r;

		reduce_opn i
                    => 
		    {   d = new_reg(); 
		        emit (i::ARITH { a=>i::OR, r=>zero_r, i, d } );
                        d;
                    };
	    end;

	    # Emit parallel copies:
	    #
	    fun copy' (dst, src, notes)
		=
		mark'( copy { dst, src,
			      tmp => case dst    [_] => NULL;
				       _ => THE (i::DIRECT (new_reg()));
                                     esac
                           },
                       notes
                     );

	    fun fcopy' (dst, src, notes)
		=
		mark'
                  ( fcopy
                      { dst,
                        src,
			tmp => case dst
                                   [_] => NULL;
				    _  => THE (i::FDIRECT (new_freg()));
                               esac
                      },
                    notes
                  );

	    # Move register s to register d 
	    #
	    fun move (s, d, notes)
		=
		if (not (cb::same_color (s, d) or cb::register_id d == 0))
		    mark'(copy { dst => [d], src => [s], tmp=>NULL }, notes);
                fi;

	    # Move floating point register s to register d
	    #
	    fun fmoved (s, d, notes)
		=
		if (not (cb::same_color (s, d)))
		    mark'(fcopy { dst => [d], src => [s], tmp=>NULL }, notes);
                fi;

	    fun fmoves (s, d, notes) =   fmoved (s, d, notes); #  error "fmoves" for now!!! XXX BUGGO FIXME
	    fun fmoveq (s, d, notes) =   error "fmoveq"

	    # Load immediate 
	    # 
	    also
	    fun load_immed (n, d, cc, notes)
		=
		{   or_op = if (cc != REG ) i::ORCC; else i::OR;fi;

		    if (immed13 n)
                         mark (i::ARITH { a=>or_op, r=>zero_r, i=>i::IMMED (to_int n), d }, notes);
		    else
			 my { hi, lo } = split n;

			 if (lo == 0) 
			     mark (i::SETHI { i=>hi, d }, notes); gen_cmp0 (cc, d);
			 else
			     t = new_reg();
			     emit (i::SETHI { i=>hi, d=>t } );
			     mark (i::ARITH { a=>or_op, r=>t, i=>i::IMMED lo, d }, notes);
			 fi;
		    fi;
		}

	    # Load label expression 
	    # 
	    also
	    fun load_label (lab, d, cc, notes)
		= 
		{   or_op = if (cc != REG ) i::ORCC; else i::OR;fi; 
		    mark (i::ARITH { a=>or_op, r=>zero_r, i=>i::LAB lab, d }, notes);
                }

	    # Emit an arithmetic op:
	    # 
	    also
	    fun arith (a, acc, e1, e2, d, cc, comm, trap, notes)
		= 
		{   my (a, d)
                        =
                        case cc   
			    REG    => (a, d);
			    CC     => (acc, zero_r);
			    CC_REG => (acc, d);
                        esac;

		    case (opn e1, opn e2, comm)   
			(i, i::REG r, COMMUTE)=> mark (i::ARITH { a, r, i, d }, notes);
			(i::REG r, i, _)      => mark (i::ARITH { a, r, i, d }, notes);
			(r, i, _)             => mark (i::ARITH { a, r=>reduce_opn r, i, d }, notes);
		    esac;
		    
		    case trap
                        [] => ();
                        _  => apply emit_instruction trap;
                    esac; 
		}   

	    # Emit a shift op:
	    # 
	    also
	    fun shift (s, e1, e2, d, cc, notes)
                = 
	        {   mark (i::SHIFT { s, r=>expr e1, i=>opn e2, d }, notes);
		    gen_cmp0 (cc, d);
	        }

	    # Emit externally defined multiply
            # or division operation (V8): 
	    # 
	    also
	    fun extarith (gen, gen_const, e1, e2, d, cc, comm)
		=
		{   fun nonconst (e1, e2)
                        = 
			case (opn e1, opn e2, comm)   
			    (i, i::REG r, COMMUTE) => gen( { r, i, d }, reduce_opn);
			    (i::REG r, i, _)       => gen( { r, i, d }, reduce_opn);
			    (r, i, _)              => gen( { r=>reduce_opn r, i, d }, reduce_opn);
                        esac;

		    fun const (e, i)
                        = 
			{   r = expr e;
			    gen_const { r, i=>to_int i, d }
			    except
                                _ = gen( { r, i=>opn (t::LITERAL i), d }, reduce_opn);
		       };

		    instrs = case (comm, e1, e2)   
			         (_,       e1,           t::LITERAL i) => const (e1, i);
			         (COMMUTE, t::LITERAL i, e2          ) => const (e2, i);
			         _                                     => nonconst (e1, e2);
			     esac;

		    apply emit_instruction instrs; 

		    gen_cmp0 (cc, d);
		}

	    # Emit 64-bit multiply or
            # division operation (v9):
	    # 
	    also
	    fun muldiv64 (a, gen_const, e1, e2, d, cc, comm, notes)
                =
		{   fun nonconst (e1, e2)
                        = 
		        [ annotate
                            ( 
			      case (opn e1, opn e2, comm)   
			          (i,        i::REG r, COMMUTE) => i::arith { a, r, i, d };
			          (i::REG r, i,        _      ) => i::arith { a, r, i, d };
			          (r,        i,        _      ) => i::arith { a, r=>reduce_opn r, i, d };
                              esac,

                              notes
                            )
		       ];

		    fun const (e, i)
                        = 
			{   r = expr e;
			    gen_const { r, i=>to_int i, d }
			    except
                                _ = [annotate (i::arith { a, r, i=>opn (t::LITERAL i), d }, notes)];
			};

		    instrs
                       =
		       case (comm, e1, e2)   
			   (_,       e1,           t::LITERAL i) => const (e1, i);
			   (COMMUTE, t::LITERAL i, e2          ) => const (e2, i);
			   _                                     => nonconst (e1, e2);
                       esac;

		    apply emit_instruction instrs; 

		    gen_cmp0 (cc, d);
		}

	    # Divisions:
	    # 
	    also fun divu32 x = mulu32::divide { mode=>t::TO_ZERO, statement=>do_statement } x
	    also fun divs32 x = muls32::divide { mode=>t::TO_ZERO, statement=>do_statement } x
	    also fun divt32 x = mult32::divide { mode=>t::TO_ZERO, statement=>do_statement } x
	    also fun divu64 x = mulu64::divide { mode=>t::TO_ZERO, statement=>do_statement } x
	    also fun divs64 x = muls64::divide { mode=>t::TO_ZERO, statement=>do_statement } x
	    also fun divt64 x = mult64::divide { mode=>t::TO_ZERO, statement=>do_statement } x

	    # Emit a unary floating point op:
	    #
	    also
	    fun funary (a, e, d, notes)
		=
		mark (i::FPOP1 { a, r=>float_expression e, d }, notes)


	    # Emit a binary floating point op: 
	    # 
	    also
	    fun farith (a, e1, e2, d, notes)
		= 
		mark (i::FPOP2 { a, r1=>float_expression e1, r2=>float_expression e2, d }, notes)

	    # Convert an expression into an addressing mode 
	    # 
	    also
	    fun address ( t::ADD (type, (t::ADD (_, e, t::LITERAL n)
		     | t::ADD (_, t::LITERAL n, e)), t::LITERAL n')
		     )
		     =>
		     address (t::ADD (type, e, t::LITERAL (t::machine_int::add (type, n, n'))));

		 address (t::ADD (type, t::SUB (_, e, t::LITERAL n), t::LITERAL n'))
		     =>
		     address (t::ADD (type, e, t::LITERAL (t::machine_int::sub (type, n', n))));

		 address (t::ADD(_, e, t::LITERAL n))
		     => 
		     if (immed13 n)

			  (expr e, i::IMMED (to_int n));
		     else
			  d = new_reg();
			  load_immed (n, d, REG,[]);
			  (d, opn e);
		     fi;

		address (t::ADD(_, e, x as t::CONST c))    => (expr e, i::LAB x);
		address (t::ADD(_, e, x as t::LABEL l))    => (expr e, i::LAB x);
		address (t::ADD(_, e, t::LABEXP x))        => (expr e, i::LAB x);

		address (t::ADD (type, i as t::LITERAL _, e)) => address (t::ADD (type, e, i));

		address (t::ADD(_, x as t::CONST c, e))    => (expr e, i::LAB x);
		address (t::ADD(_, x as t::LABEL l, e))    => (expr e, i::LAB x);
		address (t::ADD(_, t::LABEXP x, e))        => (expr e, i::LAB x);

		address (t::ADD(_, e1, e2))                => (expr e1, i::REG (expr e2));
		address (t::SUB (type, e, t::LITERAL n))   => address (t::ADD (type, e, t::LITERAL (t::machine_int::neg (32, n))));

		address (x as t::LABEL l)                  => (zero_r, i::LAB x);
		address (t::LABEXP x)                      => (zero_r, i::LAB x);
		address a                                  => (expr a, zero_opn);
	    end 

	    # Emit an integer load:
	    # 
	    also
	    fun load (l, a, d, mem, cc, notes)
                = 
		{   my (r, i) = address a;
		    mark (i::LOAD { l, r, i, d, mem }, notes);
		    gen_cmp0 (cc, d);
		}

	    # Emit an integer store:
	    # 
	    also
	    fun store (s, a, d, mem, notes)
                =
		{   my (r, i) = address a;
		    mark (i::STORE { s, r, i, d=>expr d, mem }, notes);
                }

	    # Emit a floating point load:
	    # 
	    also
	    fun fload (l, a, d, mem, notes)
                =
		{   my (r, i) = address a;
		    mark (i::FLOAD { l, r, i, d, mem }, notes);
                }

	    # Emit a floating point store:
	    # 
	    also
	    fun fstore (s, a, d, mem, notes)
                =
		{   my (r, i) = address a;
		    mark (i::FSTORE { s, r, i, d=>float_expression d, mem }, notes);
                }

	    # Emit a jump:
	    # 
	    also
	    fun jmp (a, labs, notes)
                =
		{   my (r, i) = address a;
		    mark (i::JMP { r, i, labs, nop=>TRUE }, notes);
                }

	    # Convert lowcode to cellset:
	    # 
	    also
	    fun cellset lowcode
		=
		g (lowcode, c::empty)
                where
		    fun g ([], set) => set;
			g (t::INT_EXPRESSION (t::REG(_, r)) ! regs, set) => g (regs, cb::cell_set::add (r, set));
			g (t::FLOAT_EXPRESSION (t::FREG(_, f)) ! regs, set) => g (regs, cb::cell_set::add (f, set));
			g (t::BOOL_EXPRESSION (t::CC(_, cc)) ! regs, set) => g (regs, cb::cell_set::add (cc, set));
			g(_ ! regs, set) => g (regs, set);
                    end;
                end

	    # Emit a function call:
            #
	    also
	    fun call (a, flow, defs, uses, mem, cuts_to, notes, 0)
		    =>
		    {   my (r, i) = address a;
			defs=cellset (defs);
			uses=cellset (uses);

			case (cb::register_id r, i)   

			    (0, i::LAB (t::LABEL l))
				=>
				mark (i::CALL { label=>l, defs=>c::add_reg (c::link_reg, defs), uses,
					    cuts_to, mem, nop=>TRUE }, notes);

			   _ => mark (i::JMPL { r, i, d=>c::link_reg, defs, uses,
					     cuts_to, mem, nop=>TRUE }, notes);
			esac;
		    };

	        call _ => error "pops<>0 not implemented";
            end 

	    # Emit an integer branch instruction:
	    # 
	    also
	    fun branch (t::CMP (type, cond, a, b), lab, notes)
		    =>
		    {   my (cond, a, b)
			    =
			    case a

				(t::LITERAL _ | t::CONST _ | t::LABEL _)
				    => 
				    (t::basis::swap_cond cond, b, a);

				_   => (cond, a, b);
			    esac;

			if v9 
			     branch_v9 (cond, a, b, lab, notes);
			else 
			     do_expr (t::SUB (type, a, b), new_reg(), CC,[]);
			     br (cond, lab, notes);
			fi; 
		    };

		branch (t::CC (cond, r), lab, notes)
		    => 
		    if   (cb::same_color (r, c::psr))

			 br (cond, lab, notes);
		    else
			 gen_cmp0 (CC, r);
			 br (cond, lab, notes);
		    fi;

		branch (t::FCMP (fty, cond, a, b), lab, notes)
		    =>
		    {   cmp = case fty
				  32 => i::FCMPS;
				  64 => i::FCMPD;
				  _  => error "fbranch";
			     esac;

			emit (i::FCMP { cmp, r1=>float_expression a, r2=>float_expression b, nop=>TRUE } );
			mark (i::FBFCC { b=>fcond cond, a=>FALSE, label=>lab, nop=>TRUE }, notes);
		    };

	        branch _ => error "branch";
	    end 

	    also
	    fun branch_v9 (cond, a, b, lab, notes)
		=
		{   size = codetree_stuff::size::size a;

		    if (use_br and signed_cmp cond) 
		        r = new_reg();
			do_expr (t::SUB (size, a, b), r, REG,[]); 
			brcond (cond, r, lab, notes);
		    else
		        cc = case size
                                 32 => i::ICC; 
				 64 => i::XCC;
				 _  => error "branchV9";
                             esac;
			do_expr (t::SUB (size, a, b), new_reg(), CC,[]); 
			bp (cond, cc, lab, notes);
		    fi;
	        }

	    also
	    fun br (c, lab, notes)
                =
                mark (i::BICC { b=>cond c, a=>TRUE, label=>lab, nop=>TRUE }, notes)

	    also
	    fun brcond (c, r, lab, notes)
                = 
		mark (i::BR { rcond => rcond c, r, p=>i::PT, a=>TRUE, label=>lab, nop=>TRUE }, notes)

	    also
	    fun bp (c, cc, lab, notes)
                = 
		mark (i::BP { b=>cond c, cc, p=>i::PT, a=>TRUE, label=>lab, nop=>TRUE }, notes)

	    # Generate code for a statement:
	    # 
	    also
	    fun statement (t::MOVE_INT(_, d, e), notes) => do_expr (e, d, REG, notes);
		statement (t::MOVE_FLOAT(_, d, e), notes) => do_float_expression (e, d, notes);
		statement (t::MOVE_BOOL (d, e), notes) => do_bool_expression (e, d, notes);
		statement (t::COPY_INTS(_, dst, src), notes) => copy' (dst, src, notes);
		statement (t::COPY_FLOATS(_, dst, src), notes) => fcopy' (dst, src, notes);

		statement (t::JUMP (t::LABEL l, _), notes)
                    =>
		    mark (i::BICC { b=>i::BA, a=>TRUE, label=>l, nop=>FALSE }, notes);

		statement (t::JUMP (e, labs), notes) => jmp (e, labs, notes);

		statement (t::CALL { funct, targets, defs, uses, region, pops, ... }, notes)
                    => 
		    call (funct, targets, defs, uses, region,[], notes, pops);

		statement (t::FLOW_TO (t::CALL { funct, targets, defs, uses, region, pops, ... }, cuts_to), notes)
                    =>
		    call (funct, targets, defs, uses, region, cuts_to, notes, pops);

		statement (t::RET _, notes) => mark (i::RET { leaf=>not registerwindow, nop=>TRUE }, notes);
		statement (t::STORE (8, a, d, mem), notes)   => store (i::STB, a, d, mem, notes);
		statement (t::STORE (16, a, d, mem), notes)  => store (i::STH, a, d, mem, notes);
		statement (t::STORE (32, a, d, mem), notes)  => store (i::ST, a, d, mem, notes);

		statement (t::STORE (64, a, d, mem), notes)
                    => 
		    store (if v9  i::STX; else i::STD;fi, a, d, mem, notes);

		statement (t::FSTORE (32, a, d, mem), notes) => fstore (i::STF, a, d, mem, notes);
		statement (t::FSTORE (64, a, d, mem), notes) => fstore (i::STDF, a, d, mem, notes);

		statement (t::BCC (cc, lab), notes) => branch (cc, lab, notes);
		statement (t::DEFINE l, _) => define_local_label l;
		statement (t::NOTE (s, a), notes) => statement (s, a ! notes);
		statement (t::EXT s, notes) => extension_comp::compile_sext (reducer()) { statement=>s, notes };
		statement (s, notes) => do_stmts (codetree_stuff::compile_statement s);
	    end 

	    also
	    fun do_statement s
                =
                statement (s,[])

	    also
	    fun do_stmts ss
                =
                apply do_statement ss

	    # Convert an expression into a register:
	    # 
	    also
	    fun expr e
                =
		case e
		    t::REG(_, r) => r;
		    t::LITERAL z =>  (z == 0)
				       ?? zero_r
				       :: comp();
		    _            => comp();
		esac
                where
                    fun comp ()
                        =
                        {   d = new_reg();
	                    do_expr (e, d, REG, []); d; 
	                };
	        end

	    # Compute an integer expression and
            # put the result in register d. 
	    #
	    # If cc is set then set the
            # condition code with the result.
	    # 
	    also
	    fun do_expr (e, d, cc, notes)
                =
		case e   
		    t::REG(_, r) => { move (r, d, notes); gen_cmp0 (cc, r);};
		    t::LITERAL n => load_immed (n, d, cc, notes);
		    t::LABEL l   => load_label (e, d, cc, notes);
		    t::CONST c   => load_label (e, d, cc, notes);
		    t::LABEXP x  => load_label (x, d, cc, notes);

		    # Generic 32/64 bit support 
		    #
		    t::ADD(_, a, b)
                        =>
                        arith (i::ADD, i::ADDCC, a, b, d, cc, COMMUTE,[], notes);

		    t::SUB(_, a, b)
                        =>
			case b 
			    t::LITERAL z =>   (z == 0) ?? do_expr (a, d, cc, notes)
						       :: default ();
			    _            =>   default ();
			esac
			where
			    fun default ()
				=
				arith (i::SUB, i::SUBCC, a, b, d, cc, NOCOMMUTE,[], notes);
			end;


		    t::BITWISEAND(_, a, t::BITWISENOT(_, b))
                        => 
			arith (i::ANDN, i::ANDNCC, a, b, d, cc, NOCOMMUTE,[], notes);

		    t::BITWISEOR(_, a, t::BITWISENOT(_, b))
                        => 
			arith (i::ORN, i::ORNCC, a, b, d, cc, NOCOMMUTE,[], notes);

		    t::BITWISEXOR(_, a, t::BITWISENOT(_, b))
                        =>
			arith (i::XNOR, i::XNORCC, a, b, d, cc, COMMUTE,[], notes);

		    t::BITWISEAND(_, t::BITWISENOT(_, a), b)
                        => 
			arith (i::ANDN, i::ANDNCC, b, a, d, cc, NOCOMMUTE,[], notes);

		    t::BITWISEOR(_, t::BITWISENOT(_, a), b)
                        => 
			arith (i::ORN, i::ORNCC, b, a, d, cc, NOCOMMUTE,[], notes);

		    t::BITWISEXOR(_, t::BITWISENOT(_, a), b)
                        =>
			arith (i::XNOR, i::XNORCC, b, a, d, cc, COMMUTE,[], notes);

		    t::BITWISENOT(_, t::BITWISEXOR(_, a, b))
                        =>
			arith (i::XNOR, i::XNORCC, a, b, d, cc, COMMUTE,[], notes);

		    t::BITWISEAND(_, a, b) => arith (i::AND, i::ANDCC, a, b, d, cc, COMMUTE,[], notes);
		    t::BITWISEOR (_, a, b) => arith (i::OR, i::ORCC, a, b, d, cc, COMMUTE,[], notes);
		    t::BITWISEXOR(_, a, b) => arith (i::XOR, i::XORCC, a, b, d, cc, COMMUTE,[], notes);
		    t::BITWISENOT(_, a)    => arith (i::XNOR, i::XNORCC, a, li 0, d, cc, COMMUTE,[], notes);



		    # 32 bit support: 

		    t::RIGHTSHIFT (32, a, b) => shift (i::RIGHTSHIFT, a, b, d, cc, notes);
		    t::RIGHTSHIFTU (32, a, b) => shift (i::RIGHTSHIFTU, a, b, d, cc, notes);
		    t::LEFTSHIFT (32, a, b) => shift (i::LEFTSHIFT, a, b, d, cc, notes);

		    t::ADDT (32, a, b)
                        =>
			arith (i::ADDCC, i::ADDCC, a, b, d, CC_REG, COMMUTE, trap32, notes);

		    t::SUBT (32, a, b)
                        => 
			arith (i::SUBCC, i::SUBCC, a, b, d, CC_REG, NOCOMMUTE, trap32, notes);

		    t::MULU (32, a, b)
                        =>
                        extarith (p::umul32, mulu32::multiply, a, b, d, cc, COMMUTE);

		    t::MULS (32, a, b)
                        =>
                        extarith (p::smul32, muls32::multiply, a, b, d, cc, COMMUTE);

		    t::MULT (32, a, b)
                        =>
                        extarith (p::smul32trap, mult32::multiply, a, b, d, cc, COMMUTE);

		    t::DIVU (32, a, b)
                        =>
                        extarith (p::udiv32, divu32, a, b, d, cc, NOCOMMUTE);

		    t::DIVS (t::DIV_TO_ZERO, 32, a, b)
                        =>
			extarith (p::sdiv32, divs32, a, b, d, cc, NOCOMMUTE);

		    t::DIVT (t::DIV_TO_ZERO, 32, a, b)
                        =>
			extarith (p::sdiv32trap, divt32, a, b, d, cc, NOCOMMUTE);



		    # 64 bit support 
		    #
		    t::RIGHTSHIFT (64, a, b) => shift (i::SRAX, a, b, d, cc, notes);
		    t::RIGHTSHIFTU (64, a, b) => shift (i::SRLX, a, b, d, cc, notes);
		    t::LEFTSHIFT (64, a, b) => shift (i::SLLX, a, b, d, cc, notes);

		    t::ADDT (64, a, b)
                        =>
			arith (i::ADDCC, i::ADDCC, a, b, d, CC_REG, COMMUTE, trap64, notes);

		    t::SUBT (64, a, b)
                        =>
			arith (i::SUBCC, i::SUBCC, a, b, d, CC_REG, NOCOMMUTE, trap64, notes);

		    t::MULU (64, a, b)
                        => 
		        muldiv64 (i::MULX, mulu64::multiply, a, b, d, cc, COMMUTE, notes);

		    t::MULS (64, a, b)
                        => 
		        muldiv64 (i::MULX, muls64::multiply, a, b, d, cc, COMMUTE, notes);

		    t::MULT (64, a, b)
                        => 
		        {   muldiv64 (i::MULX, mult64::multiply, a, b, d, CC_REG, COMMUTE, notes);
			    apply emit_instruction trap64;
                        };

		    t::DIVU (64, a, b)
                        =>
                        muldiv64 (i::UDIVX, divu64, a, b, d, cc, NOCOMMUTE, notes);

		    t::DIVS (t::DIV_TO_ZERO, 64, a, b)
                        =>
			muldiv64 (i::SDIVX, divs64, a, b, d, cc, NOCOMMUTE, notes);

		    t::DIVT (t::DIV_TO_ZERO, 64, a, b)
                        =>
		        muldiv64 (i::SDIVX, divt64, a, b, d, cc, NOCOMMUTE, notes);



		    # Loads:
		    #
		    t::LOAD (8, a, mem) => load (i::LDUB, a, d, mem, cc, notes);
		    t::SIGNEXTEND(_, _, t::LOAD (8, a, mem)) => load (i::LDSB, a, d, mem, cc, notes);
		    t::LOAD (16, a, mem) => load (i::LDUH, a, d, mem, cc, notes);
		    t::SIGNEXTEND(_, _, t::LOAD (16, a, mem)) => load (i::LDSH, a, d, mem, cc, notes);
		    t::LOAD (32, a, mem) => load (i::LD, a, d, mem, cc, notes);
		    t::LOAD (64, a, mem) => load (if v9  i::LDX; else i::LDD;fi, a, d, mem, cc, notes);

		    # Conditional expression:
		    # 
		    t::COND expression => do_stmts (codetree_stuff::compile_cond { expression, rd=>d, notes } );

		    # Misc:
		    # 
		    t::LET (s, e) => { do_statement s; do_expr (e, d, cc, notes);};
		    t::MARK (e, a::MARKREG f) => { f d; do_expr (e, d, cc, notes);};
		    t::MARK (e, a) => do_expr (e, d, cc, a ! notes);
		    t::PRED (e, c) => do_expr (e, d, cc, a::CONTROL_DEP_USE c ! notes);
		    t::REXT e => extension_comp::compile_rext (reducer()) { e, rd=>d, notes };
		    e => do_expr (codetree_stuff::compile_int_expression e, d, cc, notes);
                esac

	    # Generate a comparison with zero:
	    # 
	    also
	    fun gen_cmp0 (REG, _) => ();
	        gen_cmp0 (_,   d) => emit (i::ARITH { a=>i::SUBCC, r=>d, i=>zero_opn, d=>zero_r } );
            end 

	    # Convert an expression into
            # a floating point register:
	    # 
	    also
	    fun float_expression (t::FREG(_, r)) => r;
	        float_expression e               => {  d = new_freg();  do_float_expression (e, d,[]);  d;  };
            end 

	    # Compute a floating point expression
            # and put the result in d 
	    # 
	    also
	    fun do_float_expression (e, d, notes)
		=
		case e

		    # Single precision:
		    #
		    t::FREG (32, r)     => fmoves (r, d, notes);
		    t::FLOAD (32, ea, mem)  => fload (i::LDF, ea, d, mem, notes);
		    t::FADD (32, a, b)  => farith (i::FADDS, a, b, d, notes);
		    t::FSUB (32, a, b)  => farith (i::FSUBS, a, b, d, notes);
		    t::FMUL (32, a, b)  => farith (i::FMULS, a, b, d, notes);
		    t::FDIV (32, a, b)  => farith (i::FDIVS, a, b, d, notes);
		    t::FABS (32, a)     => funary (i::FABSS, a, d, notes);
		    t::FNEG (32, a)     => funary (i::FNEGS, a, d, notes);
		    t::FSQRT (32, a)    => funary (i::FSQRTS, a, d, notes);

		    # Double precision:
		    #
		    t::FREG (64, r)     => fmoved (r, d, notes);
		    t::FLOAD (64, ea, mem)  => fload (i::LDDF, ea, d, mem, notes);
		    t::FADD (64, a, b)  => farith (i::FADDD, a, b, d, notes);
		    t::FSUB (64, a, b)  => farith (i::FSUBD, a, b, d, notes);
		    t::FMUL (64, a, b)  => farith (i::FMULD, a, b, d, notes);
		    t::FDIV (64, a, b)  => farith (i::FDIVD, a, b, d, notes);
		    t::FABS (64, a)     => funary (i::FABSD, a, d, notes);
		    t::FNEG (64, a)     => funary (i::FNEGD, a, d, notes);
		    t::FSQRT (64, a)    => funary (i::FSQRTD, a, d, notes);

		    # Quad precision:
		    #
		    t::FREG (128, r)    => fmoveq (r, d, notes);
		    t::FADD (128, a, b) => farith (i::FADDQ, a, b, d, notes);
		    t::FSUB (128, a, b) => farith (i::FSUBQ, a, b, d, notes);
		    t::FMUL (128, a, b) => farith (i::FMULQ, a, b, d, notes);
		    t::FDIV (128, a, b) => farith (i::FDIVQ, a, b, d, notes);
		    t::FABS (128, a)    => funary (i::FABSQ, a, d, notes);
		    t::FNEG (128, a)    => funary (i::FNEGQ, a, d, notes);
		    t::FSQRT (128, a)   => funary (i::FSQRTQ, a, d, notes);

		    # Floating point to floating point:
		    #
		    t::CVTF2F (type, type', e)
			=>
			case (type, type')

			    (32, 32)  => do_float_expression (e, d, notes);
			    (64, 32)  => funary (i::FS_TOD, e, d, notes);
			    (128, 32) => funary (i::FS_TOQ, e, d, notes);
			    (32, 64)  => funary (i::FD_TOS, e, d, notes);
			    (64, 64)  => do_float_expression (e, d, notes);
			    (128, 64) => funary (i::FD_TOQ, e, d, notes);
			    (32, 128) => funary (i::FQ_TOS, e, d, notes);
			    (64, 128) => funary (i::FQ_TOD, e, d, notes);
			    (128, 128) => do_float_expression (e, d, notes);
			    _ => error "CVTF2F";
			esac;

		    # Integer to floating point:
		    # 
		    t::CVTI2F ( 32, 32, e) =>   apply emit_instruction (p::cvti2s( { i=>opn e, d }, reduce_opn));
		    t::CVTI2F ( 64, 32, e) =>   apply emit_instruction (p::cvti2d( { i=>opn e, d }, reduce_opn));
		    t::CVTI2F (128, 32, e) =>   apply emit_instruction (p::cvti2q( { i=>opn e, d }, reduce_opn));

		    t::FMARK (e, a::MARKREG f) => { f d; do_float_expression (e, d, notes);};
		    t::FMARK (e, a)            => do_float_expression (e, d, a ! notes);
		    t::FPRED (e, c)            => do_float_expression (e, d, a::CONTROL_DEP_USE c ! notes);
		    t::FEXT e => extension_comp::compile_fext (reducer()) { e, fd=>d, notes };
		    e => do_float_expression (codetree_stuff::compile_float_expression e, d, notes);
		esac

	    also
	    fun do_bool_expression (t::CMP (type, cond, e1, e2), cc, notes)
		     =>
		     if   (cb::same_color (cc, c::psr))

			  do_expr (t::SUB (type, e1, e2), new_reg(), CC, notes);
		     else
			  error "do_bool_expression";
		     fi;

		 do_bool_expression (t::CC(_, r), d, notes)
		     => 
		     if   (cb::same_color (r, c::psr))

			  error "do_bool_expression";
		     else
			  move (r, d, notes);
		     fi;

		 do_bool_expression (t::CCMARK (e, a::MARKREG f), d, notes) => { f d; do_bool_expression (e, d, notes);};
		 do_bool_expression (t::CCMARK (e, a), d, notes) => do_bool_expression (e, d, a ! notes);

		 do_bool_expression (t::CCEXT e, d, notes)
		     =>
		     extension_comp::compile_ccext (reducer()) { e, ccd=>d, notes };

		 do_bool_expression e => error "do_bool_expression";
	     end 

	    also
	    fun cc_expr e
                =
                {   d = new_reg();
                    do_bool_expression (e, d,[]);
                    d;
                }

	    # Convert an expression into an operand:
	    # 
	    also
	    fun opn (x as t::CONST c) => i::LAB x;
		opn (x as t::LABEL l) => i::LAB x;
		opn (t::LABEXP x)     => i::LAB x;

		opn (e as t::LITERAL n)
		    => 
		    if (n == 0)

			zero_opn;

		    elif (immed13 n)

			i::IMMED (to_int n);
		    else
			i::REG (expr e);
		    fi;

		opn e
                    =>
                    i::REG (expr e);
	     end 

	    also
	    fun reducer ()
		=
		ts::REDUCER
                  { reduce_int_expression   => expr,
		    reduce_float_expression => float_expression,

		    reduce_bool_expression  => cc_expr,
		    reduce_statement        => statement,

		    operand        => opn,
		    reduce_operand => reduce_opn,

		    address_of     => address,
		    emit           => emit_instruction o annotate,

		    instruction_stream,
		    codetree_stream  => self()
		  }

	    also
	    fun self ()
		= 
		ts::instruction_stream::STREAM
                  {
		    begin_cluster,
		    end_cluster,
		    emit            => do_statement,
		    emit_pseudo_op,
		    define_local_label,
		    define_global_label,
		    emit_comment,
		    add_note,
		    get_notes,
		    end_procedure     => fn regs = end_procedure (cellset regs)
		  };

	    self();
	};

};


# Machine code generator for SPARC.
#
# The SPARC architecture has 32 general purpose registers (%g0 is always 0)
# and 32 single precision floating point registers.  
#
# Some Ugliness: double precision floating point registers are 
# register pairs.  There are no double precision moves, negation and absolute
# values.  These require two single precision operations.  I've created
# composite instructions FMOVd, FNEGd and FABSd to stand for these. 
#
# All integer arithmetic instructions can optionally set the condition 
# code register.  We use this to simplify certain comparisons with zero.
#
# Integer multiplication, division and conversion from integer to floating
# go thru the pseudo instruction interface, since older sparcs do not
# implement these instructions in hardware.
#
# In addition, the trap instruction for detecting overflow is a parameter.
# This allows different trap vectors to be used.
#
# -- Allen Leung



## COPYRIGHT (c) 2002 Bell Labs, Lucent Technologies
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
