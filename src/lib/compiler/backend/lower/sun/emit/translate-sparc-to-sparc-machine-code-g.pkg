## translate-sparc-to-sparc-machine-code-g.pkg
#
# WARNING: This file was automatically generated by mdl_g (v3.0)
# from the machine description file "sparc/sparc.mdl".
# DO NOT EDIT this file directly

# Compiled by:
#     src/lib/compiler/backend/lower/make7/sparc.make6


# We are invoked from:
#
#     src/lib/compiler/codegen/sun/sparc-codetree.pkg

generic package translate_sparc_to_sparc_machine_code_g (

    package instruction_set:  Instruction_Set_Sparc;				# Instruction_Set_Sparc	is from   src/lib/compiler/backend/lower/sun/instruction/instruction-set-sparc.api

    package codetree_eval
	:
	Codetree_Eval								# Codetree_Eval		is from   src/lib/compiler/backend/lower/codetree/codetree-eval.api
	where codetree == instruction_set::codetree;

    package instruction_stream
	:
        Instruction_Stream;				 			# Instruction_Stream	is from   src/lib/compiler/backend/lower/instruction/instruction-stream.api

    package code_string:  Code_String;						# Code_String		is from   src/lib/compiler/backend/lower/emit/code-string.api
)

: (weak)  Instruction_Emitter							# Instruction_Emitter	is from   src/lib/compiler/backend/lower/emit/instruction-emitter.api

{
    package instruction_stream =  instruction_stream;
    package instruction_set    =  instruction_set;
    package cells              =  instruction_set::cells;
    package codetree           =  instruction_set::codetree;
    package constant           =  instruction_set::constant;

    package i = instruction_set;
    package c = cells;
    package p = instruction_stream::pseudo_op;
    package s = instruction_stream;
    package t = codetree;
    package w = unt32;								# unt32			is from   src/lib/std/unt32.pkg

    #  Sparc is big endian 

    fun error msg
	=
	lowcode_error_message::error("SparcMC", msg);

    fun make_stream _
	=
	{   infix val  & | << >> >>> ;
	    #
	    (<<)  =  w::(<<);
	    (>>)  =  w::(>>);
	    (>>>) =  w::(>>>);
	    #
	    (|)   =  w::bitwise_or;
	    (&)   =  w::bitwise_and;

	    itow = w::from_int;

	    fun emit_bool FALSE => 0u0:  w::Unt;
		emit_bool TRUE  => 0u1:  w::Unt;
	    end;

	    emit_int = itow;

	    fun emit_word w = w;
	    fun emit_label l = itow (label::addr_of l);
	    fun emit_labexp le = itow (codetree_eval::value_of le);
	    fun emit_const c = itow (constant::value_of c);

	    loc = REF 0;

	    # Emit a byte:
	    # 
	    fun e_byte b =
	    { i = *loc;  loc := i + 1; code_string::update (i, b); };

	    #  emit the low order byte of a word 
	    #  note: fromLargeWord strips the high order bits! 
	    fun e_byte_w w =
	    { i = *loc;
	     loc := i + 1; code_string::update (i, unt8::from_large_unt w); };

	    fun do_nothing _ = ();
	    fun fail _ = raise exception FAIL "MCEmitter";
	    fun get_notes () = error "get_notes";

	    fun emit_pseudo_op  p_op
		=
		p::emit_value { p_op, loc => *loc, emit=>e_byte };

	    fun begin_cluster n = { code_string::init n; loc := 0;};


	fun e_word32 w = 
	    { b8 = w;
		w = w >> 0ux8;
		b16 = w;
		w = w >> 0ux8;
		b24 = w;
		w = w >> 0ux8;
		b32 = w;

	       { e_byte_w b32; 
		 e_byte_w b24; 
		 e_byte_w b16; 
		 e_byte_w b8 ;};
	    };
	fun emit_gp r = itow (cells_basis::physical_register_num r)
	also
	fun emit_fp r = itow (cells_basis::physical_register_num r)
	also
	fun emit_y r = itow (cells_basis::physical_register_num r)
	also
	fun emit_psr r = itow (cells_basis::physical_register_num r)
	also
	fun emit_fsr r = itow (cells_basis::physical_register_num r)
	also
	fun emit_cc r = itow (cells_basis::physical_register_num r)
	also
	fun emit_mem r = itow (cells_basis::physical_register_num r)
	also
	fun emit_ctrl r = itow (cells_basis::physical_register_num r)
	also
	fun emit_cellset r = itow (cells_basis::physical_register_num r);
	fun emit_load (i::LDSB) => (0ux9:  unt32::Unt);
	   emit_load (i::LDSH) => (0uxa:  unt32::Unt);
	   emit_load (i::LDUB) => (0ux1:  unt32::Unt);
	   emit_load (i::LDUH) => (0ux2:  unt32::Unt);
	   emit_load (i::LD) => (0ux0:  unt32::Unt);
	   emit_load (i::LDX) => (0uxb:  unt32::Unt);
	   emit_load (i::LDD) => (0ux3:  unt32::Unt); end 
	also
	fun emit_store (i::STB) => (0ux5:  unt32::Unt);
	   emit_store (i::STH) => (0ux6:  unt32::Unt);
	   emit_store (i::ST) => (0ux4:  unt32::Unt);
	   emit_store (i::STX) => (0uxe:  unt32::Unt);
	   emit_store (i::STD) => (0ux7:  unt32::Unt); end 
	also
	fun emit_fload (i::LDF) => (0ux20:  unt32::Unt);
	   emit_fload (i::LDDF) => (0ux23:  unt32::Unt);
	   emit_fload (i::LDQF) => (0ux22:  unt32::Unt);
	   emit_fload (i::LDFSR) => (0ux21:  unt32::Unt);
	   emit_fload (i::LDXFSR) => (0ux21:  unt32::Unt); end 
	also
	fun emit_fstore (i::STF) => (0ux24:  unt32::Unt);
	   emit_fstore (i::STDF) => (0ux27:  unt32::Unt);
	   emit_fstore (i::STFSR) => (0ux25:  unt32::Unt); end 
	also
	fun emit_arith (i::AND) => (0ux1:  unt32::Unt);
	   emit_arith (i::ANDCC) => (0ux11:  unt32::Unt);
	   emit_arith (i::ANDN) => (0ux5:  unt32::Unt);
	   emit_arith (i::ANDNCC) => (0ux15:  unt32::Unt);
	   emit_arith (i::OR) => (0ux2:  unt32::Unt);
	   emit_arith (i::ORCC) => (0ux12:  unt32::Unt);
	   emit_arith (i::ORN) => (0ux6:  unt32::Unt);
	   emit_arith (i::ORNCC) => (0ux16:  unt32::Unt);
	   emit_arith (i::XOR) => (0ux3:  unt32::Unt);
	   emit_arith (i::XORCC) => (0ux13:  unt32::Unt);
	   emit_arith (i::XNOR) => (0ux7:  unt32::Unt);
	   emit_arith (i::XNORCC) => (0ux17:  unt32::Unt);
	   emit_arith (i::ADD) => (0ux0:  unt32::Unt);
	   emit_arith (i::ADDCC) => (0ux10:  unt32::Unt);
	   emit_arith (i::TADD) => (0ux20:  unt32::Unt);
	   emit_arith (i::TADDCC) => (0ux30:  unt32::Unt);
	   emit_arith (i::TADDTV) => (0ux22:  unt32::Unt);
	   emit_arith (i::TADDTVCC) => (0ux32:  unt32::Unt);
	   emit_arith (i::SUB) => (0ux4:  unt32::Unt);
	   emit_arith (i::SUBCC) => (0ux14:  unt32::Unt);
	   emit_arith (i::TSUB) => (0ux21:  unt32::Unt);
	   emit_arith (i::TSUBCC) => (0ux31:  unt32::Unt);
	   emit_arith (i::TSUBTV) => (0ux23:  unt32::Unt);
	   emit_arith (i::TSUBTVCC) => (0ux33:  unt32::Unt);
	   emit_arith (i::UMUL) => (0uxa:  unt32::Unt);
	   emit_arith (i::UMULCC) => (0ux1a:  unt32::Unt);
	   emit_arith (i::SMUL) => (0uxb:  unt32::Unt);
	   emit_arith (i::SMULCC) => (0ux1b:  unt32::Unt);
	   emit_arith (i::UDIV) => (0uxe:  unt32::Unt);
	   emit_arith (i::UDIVCC) => (0ux1e:  unt32::Unt);
	   emit_arith (i::SDIV) => (0uxf:  unt32::Unt);
	   emit_arith (i::SDIVCC) => (0ux1f:  unt32::Unt);
	   emit_arith (i::MULX) => (0ux9:  unt32::Unt);
	   emit_arith (i::SDIVX) => (0ux2d:  unt32::Unt);
	   emit_arith (i::UDIVX) => (0uxd:  unt32::Unt); end 

	also
	fun emit_shift (i::LEFTSHIFT) => (0ux25, 0ux0);
	     emit_shift (i::RIGHTSHIFTU) => (0ux26, 0ux0);
	     emit_shift (i::RIGHTSHIFT) => (0ux27, 0ux0);
	     emit_shift (i::SLLX) => (0ux25, 0ux1);
	     emit_shift (i::SRLX) => (0ux26, 0ux1);
	     emit_shift (i::SRAX) => (0ux27, 0ux1); end 

	also
	fun emit_farith1 (i::FI_TOS) => (0uxc4:  unt32::Unt);
	     emit_farith1 (i::FI_TOD) => (0uxc8:  unt32::Unt);
	     emit_farith1 (i::FI_TOQ) => (0uxcc:  unt32::Unt);
	     emit_farith1 (i::FS_TOI) => (0uxd1:  unt32::Unt);
	     emit_farith1 (i::FD_TOI) => (0uxd2:  unt32::Unt);
	     emit_farith1 (i::FQ_TOI) => (0uxd3:  unt32::Unt);
	     emit_farith1 (i::FS_TOD) => (0uxc9:  unt32::Unt);
	     emit_farith1 (i::FS_TOQ) => (0uxd5:  unt32::Unt);
	     emit_farith1 (i::FD_TOS) => (0uxc6:  unt32::Unt);
	     emit_farith1 (i::FD_TOQ) => (0uxce:  unt32::Unt);
	     emit_farith1 (i::FQ_TOS) => (0uxc7:  unt32::Unt);
	     emit_farith1 (i::FQ_TOD) => (0uxcb:  unt32::Unt);
	     emit_farith1 (i::FMOVS) => (0ux1:  unt32::Unt);
	     emit_farith1 (i::FNEGS) => (0ux5:  unt32::Unt);
	     emit_farith1 (i::FABSS) => (0ux9:  unt32::Unt);
	     emit_farith1 (i::FMOVD) => error "FMOVd";
	     emit_farith1 (i::FNEGD) => error "FNEGd";
	     emit_farith1 (i::FABSD) => error "FABSd";
	     emit_farith1 (i::FMOVQ) => error "FMOVq";
	     emit_farith1 (i::FNEGQ) => error "FNEGq";
	     emit_farith1 (i::FABSQ) => error "FABSq";
	     emit_farith1 (i::FSQRTS) => (0ux29:  unt32::Unt);
	     emit_farith1 (i::FSQRTD) => (0ux2a:  unt32::Unt);
	     emit_farith1 (i::FSQRTQ) => (0ux2b:  unt32::Unt);
	 end 
	also
	fun emit_farith2 (i::FADDS) => (0ux41:  unt32::Unt);
	     emit_farith2 (i::FADDD) => (0ux42:  unt32::Unt);
	     emit_farith2 (i::FADDQ) => (0ux43:  unt32::Unt);
	     emit_farith2 (i::FSUBS) => (0ux45:  unt32::Unt);
	     emit_farith2 (i::FSUBD) => (0ux46:  unt32::Unt);
	     emit_farith2 (i::FSUBQ) => (0ux47:  unt32::Unt);
	     emit_farith2 (i::FMULS) => (0ux49:  unt32::Unt);
	     emit_farith2 (i::FMULD) => (0ux4a:  unt32::Unt);
	     emit_farith2 (i::FMULQ) => (0ux4b:  unt32::Unt);
	     emit_farith2 (i::FS_MULD) => (0ux69:  unt32::Unt);
	     emit_farith2 (i::FD_MULQ) => (0ux6e:  unt32::Unt);
	     emit_farith2 (i::FDIVS) => (0ux4d:  unt32::Unt);
	     emit_farith2 (i::FDIVD) => (0ux4e:  unt32::Unt);
	     emit_farith2 (i::FDIVQ) => (0ux4f:  unt32::Unt); end 
	also
	fun emit_fcmp (i::FCMPS) => (0ux51:  unt32::Unt);
	     emit_fcmp (i::FCMPD) => (0ux52:  unt32::Unt);
	     emit_fcmp (i::FCMPQ) => (0ux53:  unt32::Unt);
	     emit_fcmp (i::FCMPES) => (0ux55:  unt32::Unt);
	     emit_fcmp (i::FCMPED) => (0ux56:  unt32::Unt);
	     emit_fcmp (i::FCMPEQ) => (0ux57:  unt32::Unt);
	end 
	also
	fun emit_branch (i::BN) => (0ux0:  unt32::Unt);
	     emit_branch (i::BE) => (0ux1:  unt32::Unt);
	     emit_branch (i::BLE) => (0ux2:  unt32::Unt);
	     emit_branch (i::BL) => (0ux3:  unt32::Unt);
	     emit_branch (i::BLEU) => (0ux4:  unt32::Unt);
	     emit_branch (i::BCS) => (0ux5:  unt32::Unt);
	     emit_branch (i::BNEG) => (0ux6:  unt32::Unt);
	     emit_branch (i::BVS) => (0ux7:  unt32::Unt);
	     emit_branch (i::BA) => (0ux8:  unt32::Unt);
	     emit_branch (i::BNE) => (0ux9:  unt32::Unt);
	     emit_branch (i::BG) => (0uxa:  unt32::Unt);
	     emit_branch (i::BGE) => (0uxb:  unt32::Unt);
	     emit_branch (i::BGU) => (0uxc:  unt32::Unt);
	     emit_branch (i::BCC) => (0uxd:  unt32::Unt);
	     emit_branch (i::BPOS) => (0uxe:  unt32::Unt);
	     emit_branch (i::BVC) => (0uxf:  unt32::Unt); end 

	also
	fun emit_rcond (i::RZ) => (0ux1:  unt32::Unt);
	     emit_rcond (i::RLEZ) => (0ux2:  unt32::Unt);
	     emit_rcond (i::RLZ) => (0ux3:  unt32::Unt);
	     emit_rcond (i::RNZ) => (0ux5:  unt32::Unt);
	     emit_rcond (i::RGZ) => (0ux6:  unt32::Unt);
	     emit_rcond (i::RGEZ) => (0ux7:  unt32::Unt); end 
	also
	fun emit_cc (i::ICC) => (0ux0:  unt32::Unt);
	     emit_cc (i::XCC) => (0ux2:  unt32::Unt); end 

	also
	fun emit_fbranch (i::FBN) => (0ux0:  unt32::Unt);
	     emit_fbranch (i::FBNE) => (0ux1:  unt32::Unt);
	     emit_fbranch (i::FBLG) => (0ux2:  unt32::Unt);
	     emit_fbranch (i::FBUL) => (0ux3:  unt32::Unt);
	     emit_fbranch (i::FBL) => (0ux4:  unt32::Unt);
	     emit_fbranch (i::FBUG) => (0ux5:  unt32::Unt);
	     emit_fbranch (i::FBG) => (0ux6:  unt32::Unt);
	     emit_fbranch (i::FBU) => (0ux7:  unt32::Unt);
	     emit_fbranch (i::FBA) => (0ux8:  unt32::Unt);
	     emit_fbranch (i::FBE) => (0ux9:  unt32::Unt);
	     emit_fbranch (i::FBUE) => (0uxa:  unt32::Unt);
	     emit_fbranch (i::FBGE) => (0uxb:  unt32::Unt);
	     emit_fbranch (i::FBUGE) => (0uxc:  unt32::Unt);
	     emit_fbranch (i::FBLE) => (0uxd:  unt32::Unt);
	     emit_fbranch (i::FBULE) => (0uxe:  unt32::Unt);
	     emit_fbranch (i::FBO) => (0uxf:  unt32::Unt); end 

	also
	fun emit_fsize (i::SS) => (0ux4:  unt32::Unt);
	    emit_fsize (i::DD) => (0ux6:  unt32::Unt);
	    emit_fsize (i::QQ) => (0ux7:  unt32::Unt);
	end;

	fun opn { i } = 
	    { 
     ###line 478.11 "sparc/sparc.mdl"
		fun hi22 w = (itow w) >>> 0uxa;

     ###line 479.11 "sparc/sparc.mdl"
		fun lo10 w = ((itow w) & 0ux3ff);

	       (case i   
		 i::REG rs2 => error "opn";
		i::IMMED i => itow i;
		i::LAB l => itow (codetree_eval::value_of l);
		i::LO l => lo10 (codetree_eval::value_of l);
		i::HI l => hi22 (codetree_eval::value_of l); esac
	       );
	    }
	also
	fun rr { op1, rd, op3, rs1, rs2 } = 
	    { rs1 = emit_gp rs1;
		rs2 = emit_gp rs2;
	     e_word32 ((op1 << 0ux1e) + ((rd << 0ux19) + ((op3 << 0ux13) + ((rs1 << 0uxe) + rs2))));
	    }
	also
	fun ri { op1, rd, op3, rs1, simm13 } = 
	    { rs1 = emit_gp rs1;
	     e_word32 ((op1 << 0ux1e) + ((rd << 0ux19) + ((op3 << 0ux13) + ((rs1 << 0uxe) + ((simm13 & 0ux1fff) + 0ux2000)))));
	    }
	also
	fun rix { op1, op3, r, i, d } = 
	    (case i   
	      i::REG rs2 => rr { op1, op3, rs1=>r, rs2, rd=>d };
	     _ => ri { op1, op3, rs1=>r, rd=>d, simm13=>opn { i }}; esac
	    )
	also
	fun rir { op1, op3, r, i, d } = 
	    { d = emit_gp d;
	     rix { op1, op3, r, i, d };
	    }
	also
	fun rif { op1, op3, r, i, d } = 
	    { d = emit_fp d;
	     rix { op1, op3, r, i, d };
	    }
	also
	fun load { l, r, i, d } = 
	    { l = emit_load l;
	     rir { op1=>0ux3, op3=>l, r, i, d };
	    }
	also
	fun store { s, r, i, d } = 
	    { s = emit_store s;
	     rir { op1=>0ux3, op3=>s, r, i, d };
	    }
	also
	fun fload { l, r, i, d } = 
	    { l = emit_fload l;
	     rif { op1=>0ux3, op3=>l, r, i, d };
	    }
	also
	fun fstore { s, r, i, d } = 
	    { s = emit_fstore s;
	     rif { op1=>0ux3, op3=>s, r, i, d };
	    }
	also
	fun sethi { rd, imm22 } = 
	    { rd = emit_gp rd;
		imm22 = emit_int imm22;
	     e_word32 ((rd << 0ux19) + ((imm22 & 0ux3fffff) + 0ux1000000));
	    }
	also
	fun NOP { } = e_word32 0ux1000000
	also
	fun unimp { const22 } = 
	    { const22 = emit_int const22;
	     e_word32 const22;
	    }
	also
	fun delay { nop } = (if (nop)
		    (NOP { } );
	       fi)
	also
	fun arith { a, r, i, d } = 
	    { a = emit_arith a;
	     rir { op1=>0ux2, op3=>a, r, i, d };
	    }
	also
	fun shiftr { rd, op3, rs1, x, rs2 } = 
	    { rs2 = emit_gp rs2;
	     e_word32 ((rd << 0ux19) + ((op3 << 0ux13) + ((rs1 << 0uxe) + ((x << 0uxc) + (rs2 + 0ux80000000)))));
	    }
	also
	fun shifti { rd, op3, rs1, x, count } = e_word32 ((rd << 0ux19) + ((op3 << 0ux13) + ((rs1 << 0uxe) + ((x << 0uxc) + ((count & 0ux3f) + 0ux80002000)))))
	also
	fun shift { s, r, i, d } = 
	    { s = emit_shift s;
		r = emit_gp r;
		d = emit_gp d;

	       { 
     ###line 517.13 "sparc/sparc::mdl"
		   my (op3, x) = s;

		  (case i   
		    i::REG rs2 => shiftr { op3, rs1=>r, rs2, rd=>d, x };
		   _ => shifti { op3, rs1=>r, count=>opn { i }, rd=>d, x }; esac
		  );
	       };
	    }
	also
	fun save { r, i, d } = rir { op1=>0ux2, op3=>0ux3c, r, i, d }
	also
	fun restore { r, i, d } = rir { op1=>0ux2, op3=>0ux3d, r, i, d }
	also
	fun bicc { a, b, disp22 } = 
	    { a = emit_bool a;
		b = emit_branch b;
	     e_word32 ((a << 0ux1d) + ((b << 0ux19) + ((disp22 & 0ux3fffff) + 0ux800000)));
	    }
	also
	fun fbfcc { a, b, disp22 } = 
	    { a = emit_bool a;
		b = emit_fbranch b;
	     e_word32 ((a << 0ux1d) + ((b << 0ux19) + ((disp22 & 0ux3fffff) + 0ux1800000)));
	    }
	also
	fun call { disp30 } = e_word32 ((disp30 & 0ux3fffffff) + 0ux40000000)
	also
	fun jmpl { r, i, d } = rir { op1=>0ux2, op3=>0ux38, r, i, d }
	also
	fun jmp { r, i } = rix { op1=>0ux2, op3=>0ux38, r, i, d=>0ux0 }
	also
	fun ticcr { op1, rd, op3, rs1, cc, rs2 } = 
	    { rs1 = emit_gp rs1;
		cc = emit_cc cc;
		rs2 = emit_gp rs2;
	     e_word32 ((op1 << 0ux1e) + ((rd << 0ux19) + ((op3 << 0ux13) + ((rs1 << 0uxe) + ((cc << 0uxb) + rs2)))));
	    }
	also
	fun ticci { op1, rd, op3, rs1, cc, sw_trap } = 
	    { rs1 = emit_gp rs1;
		cc = emit_cc cc;
	     e_word32 ((op1 << 0ux1e) + ((rd << 0ux19) + ((op3 << 0ux13) + ((rs1 << 0uxe) + ((cc << 0uxb) + ((sw_trap & 0ux7f) + 0ux2000))))));
	    }
	also
	fun ticcx { op1, op3, cc, r, i, d } = 
	    (case i   
	      i::REG rs2 => ticcr { op1, op3, cc, rs1=>r, rs2, rd=>d };
	     _ => ticci { op1, op3, cc, rs1=>r, rd=>d, sw_trap=>opn { i }}; esac
	    )
	also
	fun ticc { t, cc, r, i } = 
	    { t = emit_branch t;
	     ticcx { op1=>0ux2, d=>t, op3=>0ux3a, cc, r, i };
	    }
	also
	fun rdy { d } = 
	    { d = emit_gp d;
	     e_word32 ((d << 0ux19) + 0ux81400000);
	    }
	also
	fun wdy { r, i } = rix { op1=>0ux2, op3=>0ux30, r, i, d=>0ux0 }
	also
	fun fop_1 { d, a, r } = e_word32 ((d << 0ux19) + ((a << 0ux5) + (r + 0ux81a00000)))
	also
	fun fop1 { a, r, d } = 
	    { a = emit_farith1 a;
		r = emit_fp r;
		d = emit_fp d;
	     fop_1 { a, r, d };
	    }

	also
	fun fdouble { a, r, d }
            = 
	    {   a = emit_farith1 a;
		r = emit_fp r;
		d = emit_fp d;

	        fop_1 { a, r, d }; 
	        fop_1 { a=>0ux1, r=>r + 0ux1, d=>d + 0ux1 };
	    }

	also
	fun fquad { a, r, d } = 
	    { a = emit_farith1 a;
		r = emit_fp r;
		d = emit_fp d;

	       { fop_1 { a, r, d }; 
		 fop_1 { a=>0ux1, r=>r + 0ux1, d=>d + 0ux1 }; 
		 fop_1 { a=>0ux1, r=>r + 0ux2, d=>d + 0ux2 }; 
		 fop_1 { a=>0ux1, r=>r + 0ux3, d=>d + 0ux3 } ;};
	    }
	also
	fun fop2 { d, r1, a, r2 } = 
	    { d = emit_fp d;
		r1 = emit_fp r1;
		a = emit_farith2 a;
		r2 = emit_fp r2;
	     e_word32 ((d << 0ux19) + ((r1 << 0uxe) + ((a << 0ux5) + (r2 + 0ux81a00000))));
	    }
	also
	fun fcmp { rs1, opf, rs2 } = 
	    { rs1 = emit_fp rs1;
		opf = emit_fcmp opf;
		rs2 = emit_fp rs2;
	     e_word32 ((rs1 << 0uxe) + ((opf << 0ux5) + (rs2 + 0ux81a80000)));
	    }
	also
	fun cmovr { op3, rd, cc2, cond, cc1, cc0, rs2 } = e_word32 ((op3 << 0ux18) + ((rd << 0ux13) + ((cc2 << 0ux12) + ((cond << 0uxe) + ((cc1 << 0uxc) + ((cc0 << 0uxb) + (rs2 + 0ux80000000)))))))
	also
	fun cmovi { op3, rd, cc2, cond, cc1, cc0, simm11 } = e_word32 ((op3 << 0ux18) + ((rd << 0ux13) + ((cc2 << 0ux12) + ((cond << 0uxe) + ((cc1 << 0uxc) + ((cc0 << 0uxb) + ((simm11 & 0ux7ff) + 0ux80002000)))))))
	also
	fun cmov { op3, cond, cc2, cc1, cc0, i, rd } = 
	    (case i   
	      i::REG rs2 => cmovr { op3, cond, rs2=>emit_gp rs2, rd, cc0, 
		 cc1, cc2 };
	     _ => cmovi { op3, cond, rd, cc0, cc1, cc2, 
		 simm11=>opn { i }}; esac
	    )
	also
	fun movicc { b, i, d } = 
	    { b = emit_branch b;
		d = emit_gp d;
	     cmov { op3=>0ux2c, cond=>b, i, rd=>d, cc2=>0ux1, cc1=>0ux0, cc0=>0ux0 };
	    }
	also
	fun movfcc { b, i, d } = 
	    { b = emit_fbranch b;
		d = emit_gp d;
	     cmov { op3=>0ux2c, cond=>b, i, rd=>d, cc2=>0ux0, cc1=>0ux0, cc0=>0ux0 };
	    }
	also
	fun fmovicc { size, b, r, d } = 
	    { size = emit_fsize size;
		b = emit_branch b;
		r = emit_fp r;
		d = emit_fp d;
	     cmovr { op3=>0ux2c, cond=>b, rs2=>r, rd=>d, cc2=>0ux1, cc1=>0ux0, cc0=>0ux0 };
	    }
	also
	fun fmovfcc { size, b, r, d } = 
	    { size = emit_fsize size;
		b = emit_fbranch b;
		r = emit_fp r;
		d = emit_fp d;
	     cmovr { op3=>0ux2c, cond=>b, rs2=>r, rd=>d, cc2=>0ux0, cc1=>0ux0, cc0=>0ux0 };
	    }
	also
	fun movrr { rd, rs1, rcond, rs2 } = 
	    { rd = emit_gp rd;
		rs1 = emit_gp rs1;
		rs2 = emit_gp rs2;
	     e_word32 ((rd << 0ux19) + ((rs1 << 0uxe) + ((rcond << 0uxa) + (rs2 + 0ux81780000))));
	    }
	also
	fun movri { rd, rs1, rcond, simm10 } = 
	    { rd = emit_gp rd;
		rs1 = emit_gp rs1;
	     e_word32 ((rd << 0ux19) + ((rs1 << 0uxe) + ((rcond << 0uxa) + ((simm10 & 0ux3ff) + 0ux81782000))));
	    }
	also
	fun movr { rcond, r, i, d } = 
	    { rcond = emit_rcond rcond;

	       (case i   
		 i::REG rs2 => movrr { rcond, rs1=>r, rs2, rd=>d };
		_ => movri { rcond, rs1=>r, rd=>d, simm10=>opn { i }}; esac
	       );
	    };

     ###line 596.7 "sparc/sparc::mdl"
	fun disp label = (itow ((label::addr_of label) - *loc)) >>> 0ux2;

     ###line 597.7 "sparc/sparc::mdl"
	r15 = c::reg cells_basis::REGISTER 15;
	r31 = c::reg cells_basis::REGISTER 31;
	    fun emitter instruction
		=
		emit_instruction instruction
		where 

		    fun emit_instruction (i::LOAD { l, d, r, i, mem } ) => load { l, r, i, d };
			emit_instruction (i::STORE { s, d, r, i, mem } ) => store { s, r, i, d };
			emit_instruction (i::FLOAD { l, r, i, d, mem } ) => fload { l, r, i, d };
			emit_instruction (i::FSTORE { s, d, r, i, mem } ) => fstore { s, r, i, d };
			emit_instruction (i::UNIMP { const22 } ) => unimp { const22 };
			emit_instruction (i::SETHI { i, d } ) => sethi { imm22=>i, rd=>d };
			emit_instruction (i::ARITH { a, r, i, d } ) => arith { a, r, i, d };
			emit_instruction (i::SHIFT { s, r, i, d } ) => shift { s, r, i, d };
			emit_instruction (i::MOVICC { b, i, d } ) => movicc { b, i, d };
			emit_instruction (i::MOVFCC { b, i, d } ) => movfcc { b, i, d };
			emit_instruction (i::MOVR { rcond, r, i, d } ) => movr { rcond, r, i, d };
			emit_instruction (i::FMOVICC { size, b, r, d } ) => fmovicc { size, b, r, d };
			emit_instruction (i::FMOVFCC { size, b, r, d } ) => fmovfcc { size, b, r, d };
			emit_instruction (i::BICC { b, a, label, nop } ) => 
			 { bicc { b, a, disp22=>disp label }; 
			   delay { nop } ;};
			emit_instruction (i::FBFCC { b, a, label, nop } ) => 
			 { fbfcc { b, a, disp22=>disp label }; 
			   delay { nop } ;};
			emit_instruction (i::BR { rcond, p, r, a, label, nop } ) => error "BR";
			emit_instruction (i::BP { b, p, cc, a, label, nop } ) => error "BP";
			emit_instruction (i::JMP { r, i, labs, nop } ) => 
			 { jmp { r, i }; 
			   delay { nop } ;};
			emit_instruction (i::JMPL { r, i, d, defs, uses, cuts_to, nop, mem } ) => 
			 { jmpl { r, i, d }; 
			   delay { nop } ;};
			emit_instruction (i::CALL { defs, uses, label, cuts_to, nop, mem } ) => 
			 { call { disp30=>disp label }; 
			   delay { nop } ;};
			emit_instruction (i::TICC { t, cc, r, i } ) => ticc { t, r, cc, i };
			emit_instruction (i::FPOP1 { a, r, d } )
			    => 
			    case a

				i::FMOVD => fdouble { a=>i::FMOVS, r, d };
				i::FNEGD => fdouble { a=>i::FNEGS, r, d };
				i::FABSD => fdouble { a=>i::FABSS, r, d };
				i::FMOVQ => fquad   { a=>i::FMOVS, r, d };
				i::FNEGQ => fquad   { a=>i::FNEGS, r, d };
				i::FABSQ => fquad   { a=>i::FABSS, r, d };
				_ => fop1 { a, r, d };
			     esac;

			emit_instruction (i::FPOP2 { a, r1, r2, d } ) => fop2 { a, r1, r2, d };
			emit_instruction (i::FCMP { cmp, r1, r2, nop } ) => 
			 { fcmp { opf=>cmp, rs1=>r1, rs2=>r2 }; 
			   delay { nop } ;};
			emit_instruction (i::SAVE { r, i, d } ) => save { r, i, d };
			emit_instruction (i::RESTORE { r, i, d } ) => restore { r, i, d };
			emit_instruction (i::RDY { d } ) => rdy { d };
			emit_instruction (i::WRY { r, i } ) => wdy { r, i };
			emit_instruction (i::RET { leaf, nop } ) => 
			 { jmp { r=>(if (leaf)
				   r31;
			      else r15;fi), i=>i::IMMED 8 }; 
			   delay { nop } ;};
			emit_instruction (i::SOURCE { } ) => ();
			emit_instruction (i::SINK { } ) => ();
			emit_instruction (i::PHI { } ) => ();
		    end;

		end;

	fun emit_instruction (i::NOTE { instruction, ... } ) => emit_instruction instruction;
	    emit_instruction (i::BASE_INSTRUCTION i) => emitter i;
	    emit_instruction (i::LIVE _)  => ();
	    emit_instruction (i::DEAD _)  => ();
	    emit_instruction _ => error "emit_instruction";
	end;

	  s::STREAM { begin_cluster,
		      emit_pseudo_op,
		      emit => emit_instruction,
		      end_cluster  => fail,
		      define_local_label => do_nothing,
		      define_global_label  => do_nothing,
		      emit_comment => do_nothing,
		      end_procedure  => do_nothing,
		      add_note     => do_nothing,
		      get_notes
		    };
	};
};

