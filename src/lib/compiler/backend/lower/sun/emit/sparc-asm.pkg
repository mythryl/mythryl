#
# WARNING: This file was automatically generated by mdl_g (v3.0)
# from the machine description file "sparc/sparc.mdl".
# DO NOT EDIT this file directly

# Compiled by:
#     src/lib/compiler/backend/lower/make7/sparc.make6


# We are invoked from:
#
#     src/lib/compiler/codegen/sun/sparc-codetree.pkg

generic package sparc_asm_emitter_g (

    package instruction_stream
	:
	Instruction_Stream;						# Instruction_Stream	is from   src/lib/compiler/backend/lower/instruction/instruction-stream.api

    package instruction_set
	:
	Instruction_Set_Sparc						# Instruction_Set_Sparc	is from   src/lib/compiler/backend/lower/sun/instruction/instruction-set-sparc.api
	where
            codetree
            ==
            instruction_stream::pseudo_op::codetree;

    package shuffle
	:
	Sparcshuffle							# Sparcshuffle		is from   src/lib/compiler/backend/lower/sun/instruction/sparc-shuffle.api
	where instruction_set == instruction_set;

    package codetree_eval
	:
	Codetree_Eval							# Codetree_Eval		is from   src/lib/compiler/backend/lower/codetree/codetree-eval.api
	where codetree == instruction_set::codetree;

###line 466.21 "sparc/sparc::mdl"
    v9:  Bool;
)

: (weak) Instruction_Emitter						# Instruction_Emitter	is from   src/lib/compiler/backend/lower/emit/instruction-emitter.api

{
   package instruction_stream =  instruction_stream;
   package instruction_set    =  instruction_set;
   package cells              =  instruction_set::cells;
   package codetree           =  instruction_set::codetree;
   package constant           =  instruction_set::constant;

   package i  = instruction_set;
   package c  = cells;
   package t  = codetree;
   package s  = instruction_stream;
   package p  = s::pseudo_op;
   
   include asm_flags;
   
   fun error msg
       =
       lowcode_error_message::error("sparc_asm_emitter_g", msg);
   
   fun make_stream format_annotations
       =
       {   stream =   *asm_stream::asm_out_stream;

	   fun emit' s
               =
               file::write (stream, s);

	   newline =   REF TRUE;

	   tabs    =   REF 0;

	   fun tabbing 0 => ();
	       tabbing n => { emit' "\t"; tabbing (n - 1);};
           end;

	   fun emit s = { tabbing *tabs; tabs := 0; newline := FALSE; emit' s;};
	   fun nl () = { tabs := 0; if *newline  (); else { newline := TRUE; emit' "\n";};fi;};
	   fun comma () = emit ", ";
	   fun tab () = tabs := 1;
	   fun indent () = tabs := 2;

	   fun ms n
               =
               {   s = int::to_string n;

		  if (n<0 ) "-" + string::substring (s, 1, size s - 1);
		  else s;fi;
	       };

	   fun emit_label lab = emit (p::client::asm_pseudo_ops::lexp_to_string (t::LABEL lab));
	   fun emit_labexp le = emit (p::client::asm_pseudo_ops::lexp_to_string (t::LABEXP le));
	   fun emit_const c = emit (constant::to_string c);
	   fun emit_int i = emit (ms i);
	   fun paren f = { emit "("; f(); emit ")";};
	   fun define_local_label lab = emit (p::client::asm_pseudo_ops::define_local_label lab + "\n");
	   fun define_global_label lab = define_local_label lab;
	   fun emit_comment msg = { tab(); emit("/* " + msg + " */"); nl();};
	   fun add_note a = emit_comment (note::to_string a);
	   fun get_notes () = error "get_notes";
	   fun do_nothing _ = ();
	   fun fail _ = raise exception FAIL "AsmEmitter";
	   fun emit_region mem = emit_comment (i::region::to_string mem);
	   emit_region = 
	      if *show_region  emit_region; else do_nothing;fi;
	   fun emit_pseudo_op p_op = { emit (p::to_string p_op); emit "\n";};
	   fun begin_cluster size = { emit_comment("Code Size = " + ms size); nl();};
	   emit_cell_info = asm_formatting_utilities::reginfo
				    (emit, format_annotations);
	   fun emit_cell r = { emit (cells_basis::to_string r); emit_cell_info r;};
	   fun emit_cellset (title, cellset)
               =
	       { nl(); emit_comment (title + cells_basis::cell_set::to_string cellset);};

	   emit_cellset = 
	     if *show_cellset  emit_cellset; else do_nothing;fi;

	   fun emit_defs cellset = emit_cellset("defs: ", cellset);
	   fun emit_uses cellset = emit_cellset("uses: ", cellset);
	   emit_cuts_to = 
	     if *show_cuts_to  asm_formatting_utilities::emit_cuts_to emit;
	     else do_nothing;fi;
	   fun emitter instruction =
	   {
       fun asm_load (i::LDSB) => "ldsb";
	  asm_load (i::LDSH) => "ldsh";
	  asm_load (i::LDUB) => "ldub";
	  asm_load (i::LDUH) => "lduh";
	  asm_load (i::LD) => "ld";
	  asm_load (i::LDX) => "ldx";
	  asm_load (i::LDD) => "ldd"; end 
       also fun emit_load x = emit (asm_load x)
       also fun asm_store (i::STB) => "stb";
	  asm_store (i::STH) => "sth";
	  asm_store (i::ST) => "st";
	  asm_store (i::STX) => "stx";
	  asm_store (i::STD) => "std"; end 
       also fun emit_store x = emit (asm_store x)
       also fun asm_fload (i::LDF) => "ldf";
	  asm_fload (i::LDDF) => "lddf";
	  asm_fload (i::LDQF) => "ldqf";
	  asm_fload (i::LDFSR) => "ldfsr";
	  asm_fload (i::LDXFSR) => "ldxfsr"; end 
       also fun emit_fload x = emit (asm_fload x)
       also fun asm_fstore (i::STF) => "stf";
	  asm_fstore (i::STDF) => "stdf";
	  asm_fstore (i::STFSR) => "stfsr"; end 
       also fun emit_fstore x = emit (asm_fstore x)
       also fun asm_arith (i::AND) => "and";
	  asm_arith (i::ANDCC) => "andcc";
	  asm_arith (i::ANDN) => "andn";
	  asm_arith (i::ANDNCC) => "andncc";
	  asm_arith (i::OR) => "or";
	  asm_arith (i::ORCC) => "orcc";
	  asm_arith (i::ORN) => "orn";
	  asm_arith (i::ORNCC) => "orncc";
	  asm_arith (i::XOR) => "xor";
	  asm_arith (i::XORCC) => "xorcc";
	  asm_arith (i::XNOR) => "xnor";
	  asm_arith (i::XNORCC) => "xnorcc";
	  asm_arith (i::ADD) => "add";
	  asm_arith (i::ADDCC) => "addcc";
	  asm_arith (i::TADD) => "tadd";
	  asm_arith (i::TADDCC) => "taddcc";
	  asm_arith (i::TADDTV) => "taddtv";
	  asm_arith (i::TADDTVCC) => "taddtvcc";
	  asm_arith (i::SUB) => "sub";
	  asm_arith (i::SUBCC) => "subcc";
	  asm_arith (i::TSUB) => "tsub";
	  asm_arith (i::TSUBCC) => "tsubcc";
	  asm_arith (i::TSUBTV) => "tsubtv";
	  asm_arith (i::TSUBTVCC) => "tsubtvcc";
	  asm_arith (i::UMUL) => "umul";
	  asm_arith (i::UMULCC) => "umulcc";
	  asm_arith (i::SMUL) => "smul";
	  asm_arith (i::SMULCC) => "smulcc";
	  asm_arith (i::UDIV) => "udiv";
	  asm_arith (i::UDIVCC) => "udivcc";
	  asm_arith (i::SDIV) => "sdiv";
	  asm_arith (i::SDIVCC) => "sdivcc";
	  asm_arith (i::MULX) => "mulx";
	  asm_arith (i::SDIVX) => "sdivx";
	  asm_arith (i::UDIVX) => "udivx"; end 
       also fun emit_arith x = emit (asm_arith x)
       also fun asm_shift (i::LEFTSHIFT) => "sll";
	  asm_shift (i::RIGHTSHIFTU) => "srl";
	  asm_shift (i::RIGHTSHIFT) => "sra";
	  asm_shift (i::SLLX) => "sllx";
	  asm_shift (i::SRLX) => "srlx";
	  asm_shift (i::SRAX) => "srax"; end 
       also fun emit_shift x = emit (asm_shift x)

       also fun asm_farith1 (i::FI_TOS) => "fitos";
	    asm_farith1 (i::FI_TOD) => "fitod";
	    asm_farith1 (i::FI_TOQ) => "fitoq";
	    asm_farith1 (i::FS_TOI) => "fstoi";
	    asm_farith1 (i::FD_TOI) => "fdtoi";
	    asm_farith1 (i::FQ_TOI) => "fqtoi";
	    asm_farith1 (i::FS_TOD) => "fstod";
	    asm_farith1 (i::FS_TOQ) => "fstoq";
	    asm_farith1 (i::FD_TOS) => "fdtos";
	    asm_farith1 (i::FD_TOQ) => "fdtoq";
	    asm_farith1 (i::FQ_TOS) => "fqtos";
	    asm_farith1 (i::FQ_TOD) => "fqtod";
	    asm_farith1 (i::FMOVS) => "fmovs";
	    asm_farith1 (i::FNEGS) => "fnegs";
	    asm_farith1 (i::FABSS) => "fabss";
	    asm_farith1 (i::FMOVD) => "fmovd";
	    asm_farith1 (i::FNEGD) => "fnegd";
	    asm_farith1 (i::FABSD) => "fabsd";
	    asm_farith1 (i::FMOVQ) => "fmovq";
	    asm_farith1 (i::FNEGQ) => "fnegq";
	    asm_farith1 (i::FABSQ) => "fabsq";
	    asm_farith1 (i::FSQRTS) => "fsqrts";
	    asm_farith1 (i::FSQRTD) => "fsqrtd";
	    asm_farith1 (i::FSQRTQ) => "fsqrtq";
       end 

       also fun emit_farith1 x = emit (asm_farith1 x)

       also fun asm_farith2 (i::FADDS) => "fadds";
	    asm_farith2 (i::FADDD) => "faddd";
	    asm_farith2 (i::FADDQ) => "faddq";
	    asm_farith2 (i::FSUBS) => "fsubs";
	    asm_farith2 (i::FSUBD) => "fsubd";
	    asm_farith2 (i::FSUBQ) => "fsubq";
	    asm_farith2 (i::FMULS) => "fmuls";
	    asm_farith2 (i::FMULD) => "fmuld";
	    asm_farith2 (i::FMULQ) => "fmulq";
	    asm_farith2 (i::FS_MULD) => "fsmuld";
	    asm_farith2 (i::FD_MULQ) => "fdmulq";
	    asm_farith2 (i::FDIVS) => "fdivs";
	    asm_farith2 (i::FDIVD) => "fdivd";
	    asm_farith2 (i::FDIVQ) => "fdivq";
	end 
       also fun emit_farith2 x = emit (asm_farith2 x)

       also fun asm_fcmp (i::FCMPS) => "fcmps";
	    asm_fcmp (i::FCMPD) => "fcmpd";
	    asm_fcmp (i::FCMPQ) => "fcmpq";
	    asm_fcmp (i::FCMPES) => "fcmpes";
	    asm_fcmp (i::FCMPED) => "fcmped";
	    asm_fcmp (i::FCMPEQ) => "fcmpeq";
	end 

       also fun emit_fcmp x = emit (asm_fcmp x)

       also fun asm_branch (i::BN) => "n";
	    asm_branch (i::BE) => "e";
	    asm_branch (i::BLE) => "le";
	    asm_branch (i::BL) => "l";
	    asm_branch (i::BLEU) => "leu";
	    asm_branch (i::BCS) => "cs";
	    asm_branch (i::BNEG) => "neg";
	    asm_branch (i::BVS) => "vs";
	    asm_branch (i::BA) => "";
	    asm_branch (i::BNE) => "ne";
	    asm_branch (i::BG) => "g";
	    asm_branch (i::BGE) => "ge";
	    asm_branch (i::BGU) => "gu";
	    asm_branch (i::BCC) => "cc";
	    asm_branch (i::BPOS) => "pos";
	    asm_branch (i::BVC) => "vs";
	end 
       also fun emit_branch x = emit (asm_branch x)

       also fun asm_rcond (i::RZ) => "rz";
	    asm_rcond (i::RLEZ) => "rlez";
	    asm_rcond (i::RLZ) => "rlz";
	    asm_rcond (i::RNZ) => "rnz";
	    asm_rcond (i::RGZ) => "rgz";
	    asm_rcond (i::RGEZ) => "rgez";
	end 

       also fun emit_rcond x = emit (asm_rcond x)

       also fun asm_prediction (i::PT) => "pt";
	    asm_prediction (i::PN) => "pn";
	end 

       also fun emit_prediction x = emit (asm_prediction x)

       also fun asm_fbranch (i::FBN) => "fbn";
	    asm_fbranch (i::FBNE) => "fbne";
	    asm_fbranch (i::FBLG) => "fblg";
	    asm_fbranch (i::FBUL) => "fbul";
	    asm_fbranch (i::FBL) => "fbl";
	    asm_fbranch (i::FBUG) => "fbug";
	    asm_fbranch (i::FBG) => "fbg";
	    asm_fbranch (i::FBU) => "fbu";
	    asm_fbranch (i::FBA) => "fb";
	    asm_fbranch (i::FBE) => "fbe";
	    asm_fbranch (i::FBUE) => "fbue";
	    asm_fbranch (i::FBGE) => "fbge";
	    asm_fbranch (i::FBUGE) => "fbuge";
	    asm_fbranch (i::FBLE) => "fble";
	    asm_fbranch (i::FBULE) => "fbule";
	    asm_fbranch (i::FBO) => "fbo";
	end 
       also
       fun emit_fbranch x
           =
           emit (asm_fbranch x)
       also
       fun asm_fsize (i::SS) => "s";
	   asm_fsize (i::DD) => "d";
	   asm_fsize (i::QQ) => "q";
       end 
       also
       fun emit_fsize x = emit (asm_fsize x)

       also
       fun emit_operand (i::REG gp) => emit_cell gp;
	   emit_operand (i::IMMED int) => emit_int int;
	   emit_operand (i::LAB labexp) => emit_labexp labexp;
	   emit_operand (i::LO labexp) => 
	    { emit "%lo("; 
	      emit_labexp labexp; 
	      emit ")" ;};
	   emit_operand (i::HI labexp) => 
	    { emit "%hi("; 
	      emit_labexp labexp; 
	      emit ")" ;};
	end;

    # #line 469.7 "sparc/sparc::mdl"
       fun emit_leaf FALSE => ();
	   emit_leaf TRUE => emit "l";
       end;

    # #line 470.7 "sparc/sparc::mdl"
       fun emit_nop FALSE => ();
	   emit_nop TRUE => emit "\n\tnop";
       end;

    # #line 471.7 "sparc/sparc::mdl"
       fun emit_a FALSE => ();
	   emit_a TRUE => emit ", a";
       end;

    # #line 472.7 "sparc/sparc::mdl"
       fun emit_cc FALSE => ();
	   emit_cc TRUE => emit "cc";
       end;
       fun emit_instruction' instruction
           = 
	   case instruction
             
	     i::LOAD { l, d, r, i, mem } => 
	     { emit_load l; 
	       emit "\t["; 
	       emit_cell r; 
	       emit "+"; 
	       emit_operand i; 
	       emit "], "; 
	       emit_cell d; 
	       emit_region mem ;};
	    i::STORE { s, d, r, i, mem } => 
	     { emit_store s; 
	       emit "\t"; 
	       emit_cell d; 
	       emit ", ["; 
	       emit_cell r; 
	       emit "+"; 
	       emit_operand i; 
	       emit "]"; 
	       emit_region mem ;};
	    i::FLOAD { l, r, i, d, mem } => 
	     { emit_fload l; 
	       emit "\t["; 
	       emit_cell r; 
	       emit "+"; 
	       emit_operand i; 
	       emit "], "; 
	       emit_cell d; 
	       emit_region mem ;};
	    i::FSTORE { s, d, r, i, mem } => 
	     { emit_fstore s; 
	       emit "\t["; 
	       emit_cell r; 
	       emit "+"; 
	       emit_operand i; 
	       emit "], "; 
	       emit_cell d; 
	       emit_region mem ;};
	    i::UNIMP { const22 } => 
	     { emit "unimp "; 
	       emit_int const22 ;};
	    i::SETHI { i, d } => 
	     { 
    # #line 656.18 "sparc/sparc::mdl"
		 i = unt32::to_string (unt32::(<<) (unt32::from_int i, 0uxa));

		{ emit "sethi\t%hi (0x"; 
		  emit i; 
		  emit "), "; 
		  emit_cell d ;};
	     };
	    i::ARITH { a, r, i, d } => 
	     (case (a, cells_basis::register_id r, cells_basis::register_id d, i)   
	       (i::OR, 0, _, i::REG _) => 
	       { emit "mov\t"; 
		 emit_operand i; 
		 emit ", "; 
		 emit_cell d ;};
	      (i::OR, 0, _, _) => 
	       { emit "set\t"; 
		 emit_operand i; 
		 emit ", "; 
		 emit_cell d ;};
	      (i::SUBCC, _, 0, _) => 
	       { emit "cmp\t"; 
		 emit_cell r; 
		 emit ", "; 
		 emit_operand i ;};
	      _ => 
	       { emit_arith a; 
		 emit "\t"; 
		 emit_cell r; 
		 emit ", "; 
		 emit_operand i; 
		 emit ", "; 
		 emit_cell d ;}; esac
	     );
	    i::SHIFT { s, r, i, d } => 
	     { emit_shift s; 
	       emit "\t"; 
	       emit_cell r; 
	       emit ", "; 
	       emit_operand i; 
	       emit ", "; 
	       emit_cell d ;};
	    i::MOVICC { b, i, d } => 
	     { emit "mov"; 
	       emit_branch b; 
	       emit "\t"; 
	       emit_operand i; 
	       emit ", "; 
	       emit_cell d ;};

	    i::MOVFCC { b, i, d } => 
	     { emit "mov"; 
	       emit_fbranch b; 
	       emit "\t"; 
	       emit_operand i; 
	       emit ", "; 
	       emit_cell d ;};

	    i::MOVR { rcond, r, i, d } => 
	     { emit "movr"; 
	       emit_rcond rcond; 
	       emit "\t"; 
	       emit_cell r; 
	       emit ", "; 
	       emit_operand i; 
	       emit ", "; 
	       emit_cell d ;};

	    i::FMOVICC { size, b, r, d } => 
	     { emit "fmov"; 
	       emit_fsize size; 
	       emit_branch b; 
	       emit "\t"; 
	       emit_cell r; 
	       emit ", "; 
	       emit_cell d ;};

	    i::FMOVFCC { size, b, r, d } => 
	     { emit "fmov"; 
	       emit_fsize size; 
	       emit_fbranch b; 
	       emit "\t"; 
	       emit_cell r; 
	       emit ", "; 
	       emit_cell d ;};

	    i::BICC { b, a, label, nop } => 
	     { emit "b"; 
	       emit_branch b; 
	       emit_a a; 
	       emit "\t"; 
	       emit_label label; 
	       emit_nop nop ;};

	    i::FBFCC { b, a, label, nop } => 
	     { emit_fbranch b; 
	       emit_a a; 
	       emit "\t"; 
	       emit_label label; 
	       emit_nop nop ;};

	    i::BR { rcond, p, r, a, label, nop } => 
	     { emit "b"; 
	       emit_rcond rcond; 
	       emit_a a; 
	       emit_prediction p; 
	       emit "\t"; 
	       emit_cell r; 
	       emit ", "; 
	       emit_label label; 
	       emit_nop nop ;};

	    i::BP { b, p, cc, a, label, nop } => 
	     { emit "bp"; 
	       emit_branch b; 
	       emit_a a; 
	       emit_prediction p; 
	       emit "\t%"; 
	       emit (if ((cc == i::ICC))
		       "i";
		  else "x";fi); 
	       emit "cc, "; 
	       emit_label label; 
	       emit_nop nop ;};

	    i::JMP { r, i, labs, nop } => 
	     { emit "jmp\t["; 
	       emit_cell r; 
	       emit "+"; 
	       emit_operand i; 
	       emit "]"; 
	       emit_nop nop ;};

	    i::JMPL { r, i, d, defs, uses, cuts_to, nop, mem } => 
	     { emit "jmpl\t["; 
	       emit_cell r; 
	       emit "+"; 
	       emit_operand i; 
	       emit "], "; 
	       emit_cell d; 
	       emit_region mem; 
	       emit_defs defs; 
	       emit_uses uses; 
	       emit_cuts_to cuts_to; 
	       emit_nop nop ;};

	    i::CALL { defs, uses, label, cuts_to, nop, mem } => 
	     { emit "call\t"; 
	       emit_label label; 
	       emit_region mem; 
	       emit_defs defs; 
	       emit_uses uses; 
	       emit_cuts_to cuts_to; 
	       emit_nop nop ;};

	    i::TICC { t, cc, r, i } => 
	     { emit "t"; 
	       emit_branch t; 
	       emit "\t"; 
	       (if ((cc == i::ICC))
		       ();
		  else (emit "%xcc, ");fi); 
	       emit_cell r; 
	       emit "+"; 
	       emit_operand i ;};

	    i::FPOP1 { a, r, d } => 
	     { 
    # #line 764.18 "sparc/sparc::mdl"
		 fun f (a, r, d) = 
		     { emit a; 
		       emit "\t"; 
		       emit (c::show_fp r); 
		       emit ", "; 
		       emit (c::show_fp d);};

    # #line 769.18 "sparc/sparc::mdl"
		 fun g (a, r, d) = 
		     { 
    # #line 770.22 "sparc/sparc::mdl"
			 r = cells_basis::register_num r;
			 d = cells_basis::register_num d;

		      f (a, r, d); 
			emit "\n\t"; 
			f ("fmovs", r + 1, d + 1);
		     };

    # #line 774.18 "sparc/sparc::mdl"
		 fun h (a, r, d) = 
		     { 
    # #line 775.22 "sparc/sparc::mdl"
			 r = cells_basis::register_num r;
			 d = cells_basis::register_num d;
		      f (a, r, d); 
			emit "\n\t"; 
			f ("fmovs", r + 1, d + 1); 
			emit "\n\t"; 
			f ("fmovs", r + 2, d + 2); 
			emit "\n\t"; 
			f ("fmovs", r + 3, d + 3);
		     };
	      (if (v9)
		        
		   { emit_farith1 a; 
		     emit "\t"; 
		     emit_cell r; 
		     emit ", "; 
		     emit_cell d ;};
		   else 
		   (case a
		      
			i::FMOVD => g ("fmovs", r, d);
			i::FNEGD => g ("fnegs", r, d);
			i::FABSD => g ("fabss", r, d);
			i::FMOVQ => h ("fmovs", r, d);
			i::FNEGQ => h ("fnegs", r, d);
			i::FABSQ => h ("fabss", r, d);
			_ => 
			 { emit_farith1 a; 
			   emit "\t"; 
			   emit_cell r; 
			   emit ", "; 
			   emit_cell d ;}; esac
		       );fi);
	     };

	    i::FPOP2 { a, r1, r2, d } => 
	     { emit_farith2 a; 
	       emit "\t"; 
	       emit_cell r1; 
	       emit ", "; 
	       emit_cell r2; 
	       emit ", "; 
	       emit_cell d ;};

	    i::FCMP { cmp, r1, r2, nop } => 
	     { emit_fcmp cmp; 
	       emit "\t"; 
	       emit_cell r1; 
	       emit ", "; 
	       emit_cell r2; 
	       emit_nop nop ;};

	    i::SAVE { r, i, d } => 
	     { emit "save\t"; 
	       emit_cell r; 
	       emit ", "; 
	       emit_operand i; 
	       emit ", "; 
	       emit_cell d ;};

	    i::RESTORE { r, i, d } => 
	     { emit "restore\t"; 
	       emit_cell r; 
	       emit ", "; 
	       emit_operand i; 
	       emit ", "; 
	       emit_cell d ;};

	    i::RDY { d } => 
	     { emit "rd\t%y, "; 
	       emit_cell d ;};

	    i::WRY { r, i } => 
	     { emit "wr\t"; 
	       emit_cell r; 
	       emit ", "; 
	       emit_operand i; 
	       emit ", %y" ;};

	    i::RET { leaf, nop } => 
	     { emit "ret"; 
	       emit_leaf leaf; 
	       emit_nop nop ;};
	    i::SOURCE { } => emit "source";
	    i::SINK { } => emit "sink";
	    i::PHI { } => emit "phi";
           esac;

	    tab(); emit_instruction' instruction; nl();
	  } #  emitter 
	  also fun emit_instr_indented i = { indent(); emit_instruction i; nl();}
	  also fun emit_instrs instrs =
	       apply (if *indent_copies  emit_instr_indented;
		    else emit_instruction;fi) instrs

	  also
          fun emit_instruction (i::NOTE { instruction, note } )
                  =>
	          {   emit_comment (note::to_string note);
		      nl();
		      emit_instruction instruction;
                  };

	     emit_instruction (i::LIVE { regs, spilled } )
                 => 
		emit_comment("live= " + cells_basis::cell_set::to_string regs +
			"spilled= " + cells_basis::cell_set::to_string spilled);

	     emit_instruction (i::DEAD { regs, spilled } )
                 => 
		 emit_comment("killed . " + cells_basis::cell_set::to_string regs +
			"spilled . " + cells_basis::cell_set::to_string spilled);

	     emit_instruction (i::BASE_INSTRUCTION i)
                 =>
                 emitter i;

	     emit_instruction (i::COPY { kind => cells_basis::REGISTER, size_in_bits, src, dst, tmp } )
                 =>
	         emit_instrs (shuffle::shuffle { tmp, src, dst } );

	     emit_instruction (i::COPY { kind => cells_basis::FLOAT_REGISTER, size_in_bits, src, dst, tmp } )
                 =>
	         emit_instrs (shuffle::shufflefp { tmp, src, dst } );

	     emit_instruction _ => error "emitInstr";
         end;

	 s::STREAM { begin_cluster,
		     emit_pseudo_op,
		     emit           => emit_instruction,
		     end_cluster    => fail,
		     define_local_label,
		     define_global_label,
		     emit_comment,
		     end_procedure    => do_nothing,
		     add_note,
		     get_notes
		   };
       };
};

