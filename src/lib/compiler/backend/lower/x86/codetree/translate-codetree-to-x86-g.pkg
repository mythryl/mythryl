## translate-codetree-to-x86-g.pkg
#
# CONTEXT:
#
#     The Mythryl compiler code representations used are, in order:
#
#     1)  Raw Syntax is the initial front-end code representation.
#     2)  Deep Syntax is the second and final front-end code representation.
#     3)  Polylambda is the first backend code representation, used only transitionally.
#     4)  A-Normal  is the second backend code representation, and the first used for optimization.
#     5)  Fate-Passing-Style is the third and chief backend upper-half code representation.
#     6)  Codetree is the chief backend lower-half code representation.
#     7)  X86 instruction format (or equivalent for other target machines) -- an abstract tree format.
#     8)  X86 machine language   (or equivalent for other target machines) -- absolute binary code.
#
# For general context, see
#
#     src/lib/compiler/README
#
# This module implements conversion from Codetree
# to abstract x86 machine instructions.  This is
# primarily an instruction selection task.
#
# Our runtime invocation is from
#
#     src/lib/compiler/codegen/main/translate-fate-passing-style-to-binary-g.pkg

# Compiled by:
#     src/lib/compiler/backend/lower/make7/ia32.make6




# This is a revised version that takes into account of
# the extended x86 instruction set, and has better handling of
# non-standard types.  I've factored out the integer/floating point 
# comparison code, added optimizations for conditional moves. 
# The latter generates SETcc and CMOVcc (Pentium Pro only) instructions. 
#
# To avoid problems, I have tried to incorporate as many
# of  Lal's original magic incantations as possible.
#
# Changes include:
#
#  1.  REMU/REMS are now supported 
#
#  2.  COND is supported by generating SETcc and/or CMOVcc; this
#      may require at least a Pentium II to work.
#
#  3.  Division by a constant has been optimized.
#      Division by a power of 2 generates SHRL or SARL.
#
#  4.  Better addressing mode selection has been implemented.
#      This should improve array indexing on lib7.
#
#  5.  Generate testl/testb instead of andl whenever appropriate.
#      This is recommended by the Intel Optimization Guide and seems to improve
#      boxity tests on lib7.
#
# More changes for floating point: 
#  A new mode is implemented which generates pseudo 3-address instructions
# for floating point.  These instructions are register allocated the
# normal way, with the virtual registers mapped onto a set of pseudo
# %fp registers.  These registers are then mapped onto the %st registers
# with a new postprocessing phase.
#
# -- Allen Leung


stipulate

    rewrite_mem_reg    = TRUE;   #  should we rewrite memRegs 
    enable_fast_fpmode = TRUE;   #  set this to FALSE to disable the mode 

herein

    # We are invoked from:
    #
    #     src/lib/compiler/codegen/x86/x86-codegen-g.pkg

    generic package translate_codetree_to_x86_g (

	package instruction_set_x86
            :
            Instruction_Set_X86;					# Instruction_Set_X86		is from   src/lib/compiler/backend/lower/x86/instruction/instruction-set-x86.api

	package codetree_utils
            :
            Codetree_Utilities						# Codetree_Utilities		is from   src/lib/compiler/backend/lower/codetree/codetree-utils.api
	    where codetree == instruction_set_x86::codetree;

	package extension_comp
            :
            Codetree_Extension_Default					# Codetree_Extension_Default	is from   src/lib/compiler/backend/lower/codetree/codetree-extension-default.api
	    where instruction_set == instruction_set_x86
	    also  codetree == instruction_set_x86::codetree;

	package codetree_stream
            :
            Codetree_Stream						# Codetree_Stream		is from   src/lib/compiler/backend/lower/codetree/codetree-stream.api
	    where
                codetree == extension_comp::codetree;

	Architecture = PENTIUM | PENTIUM_PRO | PENTIUM_II | PENTIUM_III;

	architecture:  Ref( Architecture );

	cvti2f:  
	      {   type: instruction_set_x86::codetree::Some_Type, 
		  src:    instruction_set_x86::Operand, 

		  #  source operand, guaranteed to be non-memory! 
		  ref_notes:     Ref( note::Notes )				# Cluster annotations 
	      }
	      -> 
	      {   instrs:  List( instruction_set_x86::Instruction ),	#  the instructions 
		  temp_mem: instruction_set_x86::Operand, 			        #  temporary for CVTI2F 
		  cleanup: List( instruction_set_x86::Instruction )	#  Cleanup code 
	      };

	    # When the following flag is set,
            # we allocate floating point registers
	    # directly on the floating point stack
	    #	
	    fast_floating_point:  Ref( Bool ); 
    )

    : (weak)
    api {
        include Translate_Codetree_To_Target_Machine; 					# Translate_Codetree_To_Target_Machine		is from   src/lib/compiler/backend/lower/codetree/translate-codetree-to-target-machine.api
        rewrite_mem_reg:  Bool;
    }

    {
	package codetree_stream = extension_comp::codetree_stream;
	package instruction_set = instruction_set_x86;
	package cells           = instruction_set::cells;

	package shuffle
            =
            shuffle_g (							# shuffle_g		is from   src/lib/compiler/backend/lower/instruction/shuffle-g.pkg
                instruction_set_x86
	    );

	package i  = instruction_set_x86;
	package t  = i::codetree;
	package ts = codetree_stream;
	package c  = cells;
	package w32= unt32;						# unt32			is from   src/lib/std/unt32.pkg
	package a= lowcode_notes;					# lowcode_notes		is from   src/lib/compiler/backend/lower/instruction/lowcode-notes.pkg
	package cb= cells_basis;					# cells_basis		is from   src/lib/compiler/backend/lower/instruction/cells-basis.pkg

	package control_flow_graph
            =
            extension_comp::control_flow_graph;

	Instruction_Stream
            =
            ts::Stream
              (
                i::Instruction,
                c::Cellset,
                control_flow_graph::Control_Flow_Graph
              ); 

	Codetree_Stream
            =
            ts::Stream
              (
                t::Statement,
                List( t::Expression ),
                control_flow_graph::Control_Flow_Graph
              );

	Kind = REAL | INTEGER;

	package codetree_stuff
	    =
	    codetree_stuff_g (						# codetree_stuff_g		is from   src/lib/compiler/backend/lower/codetree/codetree-stuff-g.pkg
		package codetree = t;
		package cells = c;
		int_type = 32;
		natural_widths = [32];
		Rep = SE | ZE | NEITHER;
		rep = NEITHER;
	    );

	fun error msg
	    =
	    lowcode_error_message::error("translate_codetree_to_x86_g", msg);


	# Should we perform automatic MemReg translation?  
	# If this is on, we can avoid doing RewritePseudo phase entirely.
	#
	rewrite_mem_reg = rewrite_mem_reg;

	#  The following hardcoded 
	#
	fun is_mem_reg r
            =
            rewrite_mem_reg and 
			 { r = cb::register_num r;
			   r >= 8 and r < 32; 
			 };

	fun is_fmem_reg r
            =
            if (enable_fast_fpmode and *fast_floating_point)

	        r = cb::register_num r;
		r >= 8 and r < 32;
	    else
                TRUE;
            fi;

	is_any_fmem_reg
            =
            list::exists
                (fn r = {   r = cb::register_num r;  
			   r >= 8 and r < 32;
                        }
                );


	st0 = c::st 0;
	st7 = c::st 7;

	opcodes8 = { inc=>i::INCB, dec=>i::DECB, add=>i::ADDB, sub=>i::SUBB,
			notx=>i::NOTB, neg=>i::NEGB,
			shl=>i::SHLB, shr=>i::SHRB, sar=>i::SARB,
			orx=>i::BITWISEOR, andx=>i::BITWISEAND, xor=>i::BITWISEXOR
                   };

	opcodes16 = { inc=>i::INCW, dec=>i::DECW, add=>i::ADDW, sub=>i::SUBW,
			 notx=>i::NOTW, neg=>i::NEGW,
			 shl=>i::SHLW, shr=>i::SHRW, sar=>i::SARW,
			 orx=>i::ORW, andx=>i::ANDW, xor=>i::XORW
                    };

	opcodes32 = { inc=>i::INCL, dec=>i::DECL, add=>i::ADDL, sub=>i::SUBL,
			 notx=>i::NOTL, neg=>i::NEGL,
			 shl=>i::SHLL, shr=>i::SHRL, sar=>i::SARL,
			 orx=>i::ORL, andx=>i::ANDL, xor=>i::XORL
                    };


	# The code generator 
	#
	fun select_instructions
            (
		instruction_stream
		    as
		    ts::instruction_stream::STREAM {

			emit => emit_instruction,
			define_local_label,
			define_global_label,
			emit_pseudo_op,
			add_note,
			get_notes,
			begin_cluster,
			end_cluster,
			end_procedure,
			emit_comment,
			...
		    }
	    )
	    : Codetree_Stream
	    =
	    { 
		emit = emit_instruction o i::BASE_INSTRUCTION;

		exception EA;

		# label where a trap is generated -- one per cluster 
		#
		trap_label = REF (NULL:  Null_Or ((i::Instruction, label::Label)) );

		# flag floating point generation 
		#
		floating_point_used = REF FALSE;

		# Effective address of an integer register 
		#
		fun int_reg  r = if (is_mem_reg  r) i::MEM_REG r;  else i::DIRECT r; fi;
		fun real_reg r = if (is_fmem_reg r) i::FDIRECT r;  else i::FPR    r; fi;

		#  Add an overflow trap 
		fun trap ()
		    =
		    emit_instruction jmp
                    where
		        jmp = case *trap_label
				   NULL
				       =>
				       {   label = label::make_label_generator "trap" ();

					   jmp   = i::NOTE { instruction => i::jcc { cond => i::OO, 
								           operand => i::IMMED_LABEL (t::LABEL label)
                                                                         },
							     note => lowcode_notes::BRANCHPROB  probability::unlikely
                                                           };

					   trap_label := THE (jmp, label);
					   jmp;
				       };

				  THE (jmp, _)
				       =>
				       jmp;
                              esac;
		    end;

		new_reg  = c::new_reg;
		new_freg = c::new_freg;

		fun fsize 32 => i::FP32;
		    fsize 64 => i::FP64;
		    fsize 80 => i::FP80;
		    fsize _  => error "fsize";
                end;

		# Mark an expression with a list of annotations:
		#
		fun mark' (instruction, [])           =>  emit_instruction  instruction;
		    mark' (instruction, note ! notes) =>  mark'(i::NOTE { instruction, note }, notes);
                end; 

		# Annotate an expression and emit it 
		#
		fun mark (i, notes)
                    =
                    mark'(i::BASE_INSTRUCTION i, notes);

		emits = apply emit_instruction;

		# Emit parallel copies for integers .
		# Translates parallel copies that involve memregs into 
		# individual copies.
		#
		fun copy_ints ([], [], notes)
			=>
			();

		    copy_ints (dst, src, notes)
			=> 
		       emits
			   (shuffle::shuffle
			       { mv_instr, ea => int_reg }
			       { tmp => THE (i::DIRECT (new_reg())),
				 dst,
				 src
			       }
			   )
                        where
			    fun mv_instr { dst as i::MEM_REG rd, src as i::MEM_REG rs }
				    => 
				    if (cb::same_color (rd, rs))
                                        [];
                                    else
					tmp_r = i::DIRECT (new_reg());
					 [i::move { mv_op=>i::MOVL, src, dst=>tmp_r },
					    i::move { mv_op=>i::MOVL, src=>tmp_r, dst } ];
				    fi;

			        mv_instr { dst=>i::DIRECT rd, src=>i::DIRECT rs }
				    => 
				    if (cb::same_color (rd, rs))
					 []; 
				    else [i::COPY { kind =>cb::REGISTER, size_in_bits=>32, dst => [rd], src => [rs], tmp => NULL } ];
                                    fi;

			        mv_instr { dst, src }
				    =>
				    [i::move { mv_op=>i::MOVL, src, dst } ];
                            end;
			end;
                end;

		# Conversions 
		#
		itow = unt::from_int;
		wtoi = unt::to_int;

		fun to_int32 i = t::machine_int::to_int32 (32, i);

		w32toi32 = unt32::to_large_int_x; 
		i32tow32 = unt32::from_large_int;

		# One day, this is going to bite us
                # when precision (large_int)>32 					# XXX BUGGO FIXME
		#
		fun w_to_int32 w
                    =
                    int32::from_large (unt32::to_large_int_x w);

		# Some useful registers 
		#
		eax = i::DIRECT (c::eax);
		ecx = i::DIRECT (c::ecx);
		edx = i::DIRECT (c::edx);

		fun immed_label lab
                    =
                    i::IMMED_LABEL (t::LABEL lab);

		# Is the expression zero? 
		#
		fun is_zero (t::LITERAL z)       =>   z == 0;
		    is_zero (t::MARK (e, a))  =>   is_zero e;
		    is_zero _ => FALSE;
                end;

		# Does the expression set the zero bit? 
		# WARNING: we assume these things are not optimized out!

		fun set_zero_bit (t::BITWISEAND _)     => TRUE;
		    set_zero_bit (t::BITWISEOR _)      => TRUE;
		    set_zero_bit (t::BITWISEXOR _)     => TRUE;
		    set_zero_bit (t::RIGHTSHIFT _)      => TRUE;
		    set_zero_bit (t::RIGHTSHIFTU _)      => TRUE;
		    set_zero_bit (t::LEFTSHIFT _)      => TRUE;
		    set_zero_bit (t::SUB _)      => TRUE;
		    set_zero_bit (t::ADDT _)     => TRUE;
		    set_zero_bit (t::SUBT _)     => TRUE;
		    set_zero_bit (t::MARK (e, _)) => set_zero_bit e;
		    set_zero_bit _             => FALSE;
                end;

		fun set_zero_bit2 (t::BITWISEAND _)     => TRUE;
		    set_zero_bit2 (t::BITWISEOR _)      => TRUE;
		    set_zero_bit2 (t::BITWISEXOR _)     => TRUE;
		    set_zero_bit2 (t::RIGHTSHIFT _)      => TRUE;
		    set_zero_bit2 (t::RIGHTSHIFTU _)      => TRUE;
		    set_zero_bit2 (t::LEFTSHIFT _)      => TRUE;
		    set_zero_bit2 (t::ADD (32, _, _)) => TRUE; #  Can't use leal! 
		    set_zero_bit2 (t::SUB _)      => TRUE;
		    set_zero_bit2 (t::ADDT _)     => TRUE;
		    set_zero_bit2 (t::SUBT _)     => TRUE;
		    set_zero_bit2 (t::MARK (e, _)) => set_zero_bit2 e;
		    set_zero_bit2 _             => FALSE;
                end;

		# Emit parallel copies for floating point. 
		# Normal version:
		#
		fun copy_floats'(fty, [], [], _) => ();

		    copy_floats'(fty, dst as [_], src as [_], notes)
                        => 
		        mark'(i::COPY { kind => cb::FLOAT_REGISTER, size_in_bits=>fty, dst, src, tmp=>NULL }, notes);

		    copy_floats'(fty, dst, src, notes)
                        => 
		        mark'(i::COPY { kind => cb::FLOAT_REGISTER, size_in_bits=>fty, dst, src, tmp=>THE (i::FDIRECT (new_freg())) }, notes);
                end;

		# Emit parallel copies for floating point.
		# Fast version.
		# Translates parallel copies that involve memregs into 
		# individual copies.
		#
		fun copy_floats''(fty, [], [], _)
			=>
			();

		   copy_floats''(fty, dst, src, notes)
			=> 
			if (TRUE or is_any_fmem_reg dst or is_any_fmem_reg src)

				 fsize = fsize fty;

				 fun mv_instr { dst, src }
                                     =
                                     [i::fmove { fsize, src, dst } ];

				 emits (
                                     shuffle::shuffle
                                         { mv_instr, ea=>real_reg }
					 { tmp=>case dst   
						[_] => NULL;
						_  => THE (i::FPR (new_reg()));
						esac,
					   dst, src
					 }
                                 );

			else
			  mark'(i::COPY { kind => cb::FLOAT_REGISTER,
                                          size_in_bits=>fty, dst,
					  src,
                                          tmp=>case dst   
						 [_] => NULL;
						_   => THE (i::FPR (new_freg()));
					       esac
                                        },
                                 notes
                                );
			fi;
		end;

		fun copy_floats x
		    =
		    if (enable_fast_fpmode and *fast_floating_point)
			 copy_floats'' x;
		    else copy_floats' x;
                    fi;

		# Translate Codetree condition code
                # to x86 condition code:
		#
		fun cond t::LT => i::LT;  cond t::LTU => i::BB;
		    cond t::LE => i::LE;  cond t::LEU => i::BE;
		    cond t::EQ => i::EQ;  cond t::NE  => i::NE;
		    cond t::GE => i::GE;  cond t::GEU => i::AE;
		    cond t::GT => i::GT;  cond t::GTU => i::AA;
		    cond cc => error (cat ["cond(", t::basis::cond_to_string cc, ")"]);
		end;

		fun zero dst
		    =
		    emit (i::BINARY { bin_op=>i::XORL, src=>dst, dst } );

		# Move and annotate:
		#
		fun move'(src as i::DIRECT s, dst as i::DIRECT d, notes)
			=>
			if   (not (cb::same_color (s, d)))

			     mark'(i::COPY { kind => cb::REGISTER, size_in_bits=>32, dst => [d], src => [s], tmp => NULL }, notes);
			fi;

		   move'(i::IMMED 0, dst as i::DIRECT d, notes)
			=> 
			mark (i::BINARY { bin_op=>i::XORL, src=>dst, dst }, notes);	# XOR register with itself to clear it.

		   move'(src, dst, notes)
			=>
			mark (i::MOVE { mv_op=>i::MOVL, src, dst }, notes);
                end;


		# Move only!
		#
		fun move (src, dst)
		    =
		    move'(src, dst, []);

		readonly = i::region::readonly;


		# Compute an effective address.  
		#
		fun address (ea, mem)
		    =
		    { 
			# Keep building a bigger and bigger effective address expressions 
			# The input is a list of trees
			# b -- base
			# i -- index
			# s -- scale
			# d -- immed displacement
			#
			fun do_ea ([], b, i, s, d)
                                =>
                                make_addressing_mode (b, i, s, d);

			    do_ea (t ! trees, b, i, s, d)
				=>
				case t    
				    t::LITERAL n =>  do_eaimmed (trees, to_int32 n, b, i, s, d);
				    t::CONST   _ =>  do_ealabel (trees, t, b, i, s, d);
				    t::LABEL   _ =>  do_ealabel (trees, t, b, i, s, d);
				    t::LABEXP le =>  do_ealabel (trees, le, b, i, s, d);

				    t::ADD (32, t1, t2 as t::REG(_, r))
                                        => 
					if (is_mem_reg r) do_ea (t2 ! t1 ! trees, b, i, s, d);
					else              do_ea (t1 ! t2 ! trees, b, i, s, d);
                                        fi;

				    t::ADD (32, t1, t2)
					=>
					do_ea (t1 ! t2 ! trees, b, i, s, d);

				    t::SUB (32, t1, t::LITERAL n)
                                        => 
					do_ea (t1 ! t::LITERAL (t::machine_int::neg (32, n)) ! trees, b, i, s, d);

				    t::LEFTSHIFT (32, t1, t::LITERAL n)
                                        =>
                                        {   n = t::machine_int::to_int (32, n);

					    case n
						0 => displace (trees, t1, b, i, s, d);
						1 => indexed (trees, t1, t, 1, b, i, s, d);
						2 => indexed (trees, t1, t, 2, b, i, s, d);
						3 => indexed (trees, t1, t, 3, b, i, s, d);
						_ => displace (trees, t, b, i, s, d);
					    esac;
				        };

				    t => displace (trees, t, b, i, s, d);
				esac;
			end  

			# Add an immediate constant:
			# 
			also
			fun do_eaimmed (trees, 0, b, i, s, d)
                                =>
                                do_ea (trees, b, i, s, d);

			    do_eaimmed (trees, n, b, i, s, i::IMMED m)
                                => 
				do_ea (trees, b, i, s, i::IMMED (n+m));

			    do_eaimmed (trees, n, b, i, s, i::IMMED_LABEL le)
                                => 
				do_ea (trees, b, i, s, 
				     i::IMMED_LABEL (t::ADD (32, le, t::LITERAL (t::machine_int::from_int32 (32, n)))));

			    do_eaimmed (trees, n, b, i, s, _)
                                =>
                                error "do_eaimmed";
			end 

			# Add a label expression:
			#
			also
			fun do_ealabel (trees, le, b, i, s, i::IMMED 0)
				=> 
				do_ea (trees, b, i, s, i::IMMED_LABEL le);

			    do_ealabel (trees, le, b, i, s, i::IMMED m)
				=> 
				do_ea (
				    trees,
				    b,
				    i,
				    s, 
				    i::IMMED_LABEL (t::ADD (32, le, t::LITERAL (t::machine_int::from_int32 (32, m))))
				    except
					OVERFLOW =  error "do_ealabel: constant too large"
				);

			    do_ealabel (trees, le, b, i, s, i::IMMED_LABEL le')
				=> 
				do_ea (trees, b, i, s, i::IMMED_LABEL (t::ADD (32, le, le')));

			    do_ealabel (trees, le, b, i, s, _)
				=>
				error "doEALabel";
			end 

			also
			fun make_addressing_mode (NULL, NULL, _, disp)
				=>
				disp;

			    make_addressing_mode (THE base, NULL, _, disp)
				=> 
				i::DISPLACE { base, disp, mem };

			    make_addressing_mode (base, THE index, scale, disp)
				=> 
				i::INDEXED { base, index, scale, disp, mem };
			end 

			# Generate code for tree and
			# ensure that it is not in %esp 
			also
			fun expr_not_esp tree
			    =
			    {   r = expr tree;

				if   (cb::same_color (r, c::esp))

				     tmp = new_reg();
				     move (i::DIRECT r, i::DIRECT tmp);
				     tmp;
				else
				     r;
				fi;
			    }

			#  Add a base register 
			also
			fun displace (trees, t, NULL, i, s, d)   #  no base yet 
				=>
				do_ea (trees, THE (expr t), i, s, d);

			    displace (trees, t, b as THE base, NULL, _, d) 	 #  no index 
				=>
				#   Make t the index, but make sure that it is not %esp! 
				{   i = expr t;

				    if (cb::same_color (i, c::esp) )

				        # Swap base and index 
					if (cb::same_color (base, c::esp) )
					     do_ea (trees, THE i, b, 0, d);
					else
                                             # Base and index = %esp! 
					     index = new_reg();
					     move (i::DIRECT i, i::DIRECT index);
					     do_ea (trees, b, THE index, 0, d);
					fi;
				    else
				        do_ea (trees, b, THE i, 0, d);
                                    fi;
				};

			    displace (trees, t, THE base, i, s, d)  /* base and index */ 
			        =>
			        {   b = expr (t::ADD (32, t::REG (32, base), t));
				    do_ea (trees, THE b, i, s, d);
                                };
			end 

			#  Add an indexed register 
			also
			fun indexed (trees, t, t0, scale, b, NULL, _, d) #  no index yet 
				=>
				do_ea (trees, b, THE (expr_not_esp t), scale, d);

			    indexed (trees, _, t0, _, NULL, i, s, d) 	 #  no base 
				=>
				do_ea (trees, THE (expr t0), i, s, d);

			    indexed (trees, _, t0, _, THE base, i, s, d)    # Base and index
				=>
				{   b = expr (t::ADD (32, t0, t::REG (32, base)));
				    do_ea (trees, THE b, i, s, d);
				};
			end;

			case (do_ea([ea], NULL, NULL, 0, i::IMMED 0))

			     i::IMMED _ => raise exception EA;
			     i::IMMED_LABEL le => i::LABEL_EA le;
			     ea => ea;
			esac;
		    }				# fun address 

		# Reduce an expression
                # into an operand:
                #
		also
		fun operand (t::LITERAL i) => i::IMMED (to_int32 (i)); 
		    operand (x as (t::CONST _ | t::LABEL _)) => i::IMMED_LABEL x;
		    operand (t::LABEXP le) => i::IMMED_LABEL le;
		    operand (t::REG(_, r)) => int_reg r;
		    operand (t::LOAD (32, ea, mem)) => address (ea, mem);
		    operand (t) => i::DIRECT (expr t);
		end 

		also
		fun move_to_reg (operand)
		    =
		    {   dst = i::DIRECT (new_reg());
			move (operand, dst); dst;
		    }

		also
		fun reduce_operand (i::DIRECT r)
			=>
			r;

		    reduce_operand operand
			=>
			{   dst = new_reg();
			    move (operand, i::DIRECT dst);
			    dst;
			};
		end 

		# Ensure that the operand is
                # either an immed or register:
                #
		also
		fun immed_or_reg (operand as i::DISPLACE _) =>  move_to_reg  operand;
		    immed_or_reg (operand as i::INDEXED  _) =>  move_to_reg  operand;
		    immed_or_reg (operand as i::MEM_REG  _) =>  move_to_reg  operand;
		    immed_or_reg (operand as i::LABEL_EA _) =>  move_to_reg  operand;
		    immed_or_reg operand  => operand;
		end 

		also
		fun is_immediate (i::IMMED       _) =>  TRUE;
		    is_immediate (i::IMMED_LABEL _) =>  TRUE;
		    is_immediate _                  =>  FALSE;
		end 

		also
		fun reg_or_mem operand
		    =
		    if (is_immediate operand)   move_to_reg operand;
                    else                        operand;
                    fi

		also
		fun is_mem_operand operand
		    = 
		    case operand

			 i::DISPLACE _ =>  TRUE;
			 i::INDEXED _  =>  TRUE; 
			 i::MEM_REG _  =>  TRUE; 
			 i::LABEL_EA _ =>  TRUE; 
			 i::FDIRECT f  =>  TRUE;
			 _             =>  FALSE;
		    esac


		    # Compute an integer expression and put the result in 
		    # the destination register rd.  

		also
		fun do_expression (expression, rd:  cb::Cell, notes)
		    = 
		    {   rd_operand = int_reg rd;

			fun equal_rd (i::DIRECT  r) =>  cb::same_color (r, rd);
			    equal_rd (i::MEM_REG r) =>  cb::same_color (r, rd);
			    equal_rd _ => FALSE;
			end;

			# Emit a binary operator.  If the destination is
			# a memReg, do something smarter.
			#
			fun gen_binary (bin_op, operand1, operand2)
			    =
			    if (   is_mem_reg rd
			       and (is_mem_operand operand1 or is_mem_operand operand2)
			       or  equal_rd (operand2)
			       )

				 tmp_r = new_reg();
				 tmp  = i::DIRECT tmp_r;
				 move (operand1, tmp);
				 mark (i::BINARY { bin_op, src=>operand2, dst=>tmp }, notes);
				 move (tmp, rd_operand);
			    else
				 move (operand1, rd_operand);
				 mark (i::BINARY { bin_op, src=>operand2, dst=>rd_operand }, notes);
			    fi;


			#  Generate a binary operator; it may commute:
			# 
			fun binary_comm (bin_op, e1, e2)
			    = 
			    {   my (operand1, operand2)
				    = 
				    case (operand e1, operand e2)

					 (x as i::IMMED _, y)      => (y, x);
					 (x as i::IMMED_LABEL _, y) => (y, x);
					 (x, y as i::DIRECT _)     => (y, x);
					 (x, y)                   => (x, y);
				    esac;

				gen_binary (bin_op, operand1, operand2);
			    };


			# Generate a binary operator; non-commutative:
			# 
			fun binary (bin_op, e1, e2)
			    =
			    gen_binary (bin_op, operand e1, operand e2);


			# Generate a unary operator:
			#
			fun unary (un_op, e)
			    = 
			    {   operand = operand e;
				if (is_mem_reg rd and is_mem_operand operand)

				     tmp = i::DIRECT (new_reg());
				     move (operand, tmp); move (tmp, rd_operand);
				else
				     move (operand, rd_operand);
				fi;
				mark (i::UNARY { un_op, operand=>rd_operand }, notes);
			    };


			# Generate shifts; the shift 
			# amount must be a constant or in %ecx
			#
			fun shift (opcode, e1, e2)
			    =
			    {   my (operand1, operand2)
                                    =
                                    ( operand e1,
                                      operand e2
                                    );

				case operand2    

				    i::IMMED _
                                        =>
                                        gen_binary (opcode, operand1, operand2);

				    _ => 
					if (equal_rd (operand2)) 

					    tmp_r = new_reg();
					    tmp  = i::DIRECT tmp_r;
					    move (operand1, tmp);
					    move (operand2, ecx);
					    mark (i::BINARY { bin_op=>opcode, src=>ecx, dst=>tmp }, notes);
					    move (tmp, rd_operand);
					else
					     move (operand1, rd_operand);
					     move (operand2, ecx);
					     mark (i::BINARY { bin_op=>opcode, src=>ecx, dst=>rd_operand }, notes);
					fi;
			       esac;
			    };

			# Division or remainder:
                        # divisor must be in %edx:%eax pair 
			#
			fun divrem (signed, overflow, e1, e2, result_reg)
			    =
			    {   my (operand1, operand2)
                                    =
                                    (operand e1, operand e2);

				move (operand1, eax);

				oper = if signed
                                           emit (i::CDQ);
                                           i::IDIVL1;
				       else
                                           zero edx;
                                           i::DIVL1;
                                       fi;

			        mark (i::MULTDIV { mult_div_op=>oper, src=>reg_or_mem operand2 }, notes);

				move (result_reg, rd_operand);

				if overflow  trap(); fi;
			    };

			# Division with rounding towards negative infinity 
			#
			fun divinf0 (overflow, e1, e2)
			    =
			    {
				o1 = operand e1;
				o2 = operand e2;
				l = label::make_anonymous_label ();

				move (o1, eax);
				emit i::CDQ;

				mark (i::MULTDIV { mult_div_op => i::IDIVL1, src => reg_or_mem o2 },
				      notes);

				if overflow  trap(); fi;

				apply emit [i::CMPL { lsrc => edx, rsrc => i::IMMED 0 },
					  i::JCC { cond => i::EQ, operand => immed_label l },
					  i::BINARY { bin_op => i::XORL,
						     src => reg_or_mem o2,
						     dst => edx },
					  i::JCC { cond => i::GE, operand => immed_label l },
					  i::UNARY { un_op => i::DECL, operand => eax } ];

				define_local_label l;
				move (eax, rd_operand);
			    };

			# Analyze for power-of-two-ness 
			#
			fun analyze i'
			    =
			    {
				i = to_int32 i';

				{   my  (isneg, a, w)
					=
					if (i >= 0)
					     (FALSE, i, t::machine_int::to_word32 (32, i'));
					else (TRUE, -i, t::machine_int::to_word32 (32, t::machine_int::neg (32,  i')));
                                        fi;

				    fun log2 (0u1, p) => p;
				        log2 (  w, p) => log2 (w32::(>>) (w, 0u1), p + 1);
                                    end;

				    if (w > 0u1 and w32::bitwise_and (w - 0u1, w) == 0u0)

					(i, THE (isneg, a,
						  t::LITERAL (t::machine_int::from_int32 (32, log2 (w, 0)))));
				    else
                                        (i, NULL);
                                    fi;
				}
				except
                                    _ = (i, NULL);
			    };

			# Division by a power of two when rounding to neginf is the
			# same as an arithmetic right shift:
			#
			fun divinf (overflow, e1, e2 as t::LITERAL n')
				=>
				case (analyze n')

				    (_, NULL)
                                        =>
                                        divinf0 (overflow, e1, e2);

				    (_, THE (FALSE, _, p))
                                        =>
				        shift (i::SARL, t::REG (32, expr e1), p);

				    (_, THE (TRUE, _, p))
                                        =>
                                        {   reg = expr e1;

					    emit (i::UNARY { un_op => i::NEGL, operand => i::DIRECT reg } );
					    shift (i::SARL, t::REG (32, reg), p);
				        };
				esac;

			    divinf (overflow, e1, e2)
				=>
				divinf0 (overflow, e1, e2);
			end;

			fun reminf0 (e1, e2)
			    =
			    {   o1 = operand e1;
				o2 = operand e2;
				l = label::make_anonymous_label ();

				move (o1, eax);
				emit i::CDQ;

				mark (i::MULTDIV { mult_div_op => i::IDIVL1, src => reg_or_mem o2 },
				      notes);

				apply emit [i::CMPL { lsrc => edx, rsrc => i::IMMED 0 },
					  i::JCC { cond => i::EQ, operand => immed_label l } ];

				move (edx, eax);

				apply emit [i::BINARY { bin_op => i::XORL,
						     src => reg_or_mem o2, dst => eax },
					  i::JCC { cond => i::GE, operand => immed_label l },
					  i::BINARY { bin_op => i::ADDL,
						     src => reg_or_mem o2, dst => edx } ];
				define_local_label l;
				move (edx, rd_operand);
			    };

			# n mod (power-of-2) corresponds to a bitmask (AND). 
			# If the power is negative, then we must first negate
			# the argument and then again negate the result.
			#
			fun reminf (e1, e2 as t::LITERAL n')
				=>
				case (analyze n')

				     (_, NULL)
					 =>
					 reminf0 (e1, e2);

				     (_, THE (FALSE, a, _))
					 =>
					 binary_comm (i::ANDL, e1,
							     t::LITERAL (t::machine_int::from_int32 (32, a - 1)));

				     (_, THE (TRUE, a, _))
					 =>
					 {   r1 = expr e1;
					     o1 = i::DIRECT r1;

					     emit (i::UNARY { un_op => i::NEGL, operand => o1 } );

					     emit (i::BINARY { bin_op => i::ANDL,
							      src => i::IMMED (a - 1),
							      dst => o1 }
                                                  );

					     unary (i::NEGL, t::REG (32, r1));
					 };
				esac;

			   reminf (e1, e2)
				=>
				reminf0 (e1, e2);
			end;

			# Optimize the special case for division:
			#
			fun divide (signed, overflow, e1, e2 as t::LITERAL n')
				=>
				case (analyze n')   

				     (n, THE (isneg, a, p))
					 =>
					 if signed 

					      label = label::make_anonymous_label ();
					      reg1 = expr e1;
					      operand1 = i::DIRECT reg1;

					      if isneg 
						  emit (i::UNARY { un_op => i::NEGL,
								  operand => operand1 }
                                                       );

					      elif (set_zero_bit e1 ) ();

					      else emit (i::CMPL { lsrc => operand1,
								  rsrc => i::IMMED 0 }
                                                        );
					      fi;

					      emit (i::JCC { cond => i::GE,
							    operand => immed_label label } );
					      emit  if (a == 2)
							i::UNARY { un_op => i::INCL,
								  operand => operand1 };
						    else
							i::BINARY { bin_op => i::ADDL,
								   src => i::IMMED (a - 1),
								   dst => operand1 };
                                                    fi;
					      define_local_label label;
					      shift (i::SARL, t::REG (32, reg1), p);

					 else
					      shift (i::SHRL, e1, p);
					fi;

				    (n, NULL)
					=>
					divrem (signed, overflow and (n == -1 or n == 0),
					    e1, e2, eax);
			       esac;

			   divide (signed, overflow, e1, e2)
			       =>
			       divrem (signed, overflow, e1, e2, eax);
			end;

			# rem never causes overflow 
			#
			fun rem (signed, e1, e2 as t::LITERAL n')
				=>
				case (analyze n')   

				     (n, THE (isneg, a, _))
					 =>
					 if signed 

					     # The following logic should work uniformely
					     # for both isneg and not isneg.  It only uses
					     # the absolute value (a) of the divisor.
					     # Here is the formula:
					     #    let p be a power of two and a = abs (p):
					     #
					     #    x % p = x - ((x < 0 ? x + a - 1:  x) & (-a))
					     #
					     # (That's what GCC seems to do.)
					     #
					     r1 = expr e1;
					     o1 = i::DIRECT r1;
					     rt = new_reg ();
					     tmp = i::DIRECT rt;
					     l = label::make_anonymous_label ();

					     move (o1, tmp);

					     if (not (set_zero_bit e1))

					         emit (i::CMPL { lsrc => o1,
								 rsrc => i::IMMED 0
                                                               }
                                                      );
                                             fi;

					     emit (i::JCC { cond => i::GE,
							   operand => immed_label l } );

					     emit (i::BINARY { bin_op => i::ADDL,
							      src => i::IMMED (a - 1),
							      dst => tmp } );

					     define_local_label l;

					     emit (i::BINARY { bin_op => i::ANDL,
							      src => i::IMMED (-a),
							      dst => tmp } );

					     binary (i::SUBL, t::REG (32, r1), t::REG (32, rt));

					 elif isneg 

					      #  this is really strange... 
					      divrem (FALSE, FALSE, e1, e2, edx);
					 else
					      binary_comm (i::ANDL, e1,
							  t::LITERAL (t::machine_int::from_int32 (32, n - 1)));
					 fi;

				     (_, NULL)
                                         =>
                                         divrem (signed, FALSE, e1, e2, edx);
			       esac;

			   rem (signed, e1, e2)
			       =>
			       divrem (signed, FALSE, e1, e2, edx);
			end;


			# Makes sure the destination must be a register 
			#	
			fun dst_must_be_reg f
			    = 
			    if (is_mem_reg rd)
				 tmp_r = new_reg();
				 tmp  = i::DIRECT (tmp_r);
				 f (tmp_r, tmp); move (tmp, rd_operand);
			    else
				 f (rd, rd_operand);
			    fi;


			# unsigned integer multiplication
			# 
			fun u_multiply0 (e1, e2)
			    = 
			    #  note e2 can never be (i::DIRECT edx) 
			    {   move (operand e1, eax);
				mark (i::MULTDIV { mult_div_op=>i::MULL1, 
					    src=>reg_or_mem (operand e2) }, notes);
				move (eax, rd_operand);
			    };


			fun u_multiply (e1, e2 as t::LITERAL n')
				=>
				case (analyze n')   

				    (_, THE (FALSE, _, p))
                                        =>
                                        shift (i::SHLL, e1, p);

				    _   =>
                                        u_multiply0 (e1, e2);
				esac;

			    u_multiply (e1 as t::LITERAL _, e2) =>  u_multiply  (e2, e1);
			    u_multiply (e1, e2)                 =>  u_multiply0 (e1, e2);
			end;


			# signed integer multiplication: 
			# The only forms that are allowed that also sets the 
			# OF and CF flags are:
			#
			#          (dst)  (src1)  (src2)
			#      imul r32, r32/m32, imm8
			#          (dst)  (src) 
			#      imul r32, imm8
			#      imul r32, imm32
			#      imul r32, r32/m32
			# Note: destination must be a register!
			#
			fun multiply (e1, e2)
			    = 
			    dst_must_be_reg
				(fn (rd, rd_operand)
				    =
				    do_it (operand e1, operand e2)
				    where
					fun do_it (i1 as i::IMMED _, i2 as i::IMMED _)
						=>
						{   move (i1, rd_operand);
						    mark (i::BINARY { bin_op=>i::IMULL, dst=>rd_operand, src=>i2 }, notes);
						};

					    do_it (rm, i2 as i::IMMED _)
						=>
						do_it (i2, rm);

					    do_it (imm as i::IMMED (i), rm)
						=>
						mark (i::MUL3 { dst=>rd, src1=>rm, src2=>i }, notes);

					    do_it (r1 as i::DIRECT _, r2 as i::DIRECT _)
						=>
						{   move (r1, rd_operand);
						    mark (i::BINARY { bin_op=>i::IMULL, dst=>rd_operand, src=>r2 }, notes);
						};

					    do_it (r1 as i::DIRECT _, rm)
						=>
						{ 
						    move (r1, rd_operand);
						    mark (i::BINARY { bin_op=>i::IMULL, dst=>rd_operand, src=>rm }, notes);
						};

					    do_it (rm, r as i::DIRECT _)
						=>
						do_it (r, rm);

					    do_it (rm1, rm2)
						 =>
						 if (equal_rd rm2)
						      tmp_r = new_reg();
						      tmp   = i::DIRECT tmp_r;
						      move (rm1, tmp);
						      mark (i::BINARY { bin_op=>i::IMULL, dst=>tmp, src=>rm2 }, notes);
						      move (tmp, rd_operand);
						 else
						      move (rm1, rd_operand);
						      mark (i::BINARY { bin_op=>i::IMULL, dst=>rd_operand, src=>rm2 }, notes);
						 fi;
					end;
				    end
			    );			# fn

			fun multiply_notrap (e1, e2 as t::LITERAL n')
				=>
				case (analyze n')   

				     (_, THE (isneg, _, p))
                                         =>
                                         {
					     r1 = expr e1;
					     o1 = i::DIRECT r1;

					     if isneg 
						 emit (i::UNARY { un_op => i::NEGL, operand => o1 } );
					     fi;
					     shift (i::SHLL, t::REG (32, r1), p);
					 };

				     _   => multiply (e1, e2);
				esac;

			    multiply_notrap (e1 as t::LITERAL _, e2) =>  multiply_notrap (e2, e1);
			    multiply_notrap (e1,                 e2) =>  multiply (e1, e2);
			end;

			# Emit a load instruction; makes sure
			# that the destination is a register:
			#
			fun gen_load (mv_op, ea, mem)
			    = 
			    dst_must_be_reg (fn (_, dst)
				=
				mark (i::MOVE { mv_op, src=>address (ea, mem), dst }, notes));

			# Generate zero extended loads:
                        #
			fun load8   (ea, mem) = gen_load (i::MOVZBL, ea, mem);
			fun load16  (ea, mem) = gen_load (i::MOVZWL, ea, mem);
			fun load8s  (ea, mem) = gen_load (i::MOVSBL, ea, mem);
			fun load16s (ea, mem) = gen_load (i::MOVSWL, ea, mem);
			fun load32  (ea, mem) = gen_load (i::MOVL,   ea, mem);

			# Generate sign-extended loads.

			# Generate setcc instruction:
			#  semantics:  MOVE_INT (rd, COND(_, t::CMP (type, cc, t1, t2), yes, no))
			# Bug, if eax is either t1 or t2 then problem will occur!!!
			# Note that we have to use eax as the destination of the
			# setcc because it only works on the registers
			# %al, %bl, %cl, %dl and %[abcd]h.  The last four registers
			# are inaccessible in 32 bit mode.

			fun setcc (type, cc, t1, t2, yes, no)
			    = 
			    {   my (cc, yes, no)
                                    = 
				    if (yes > no)  (cc, yes, no);
				    else           (t::basis::negate_cond cc, no, yes);
                                    fi;

			        # Clear the destination first.
				# This this because stupid SETcc 
				# only writes to the low order
				# byte.  That's Intel architecture, folks.
				#
				case (yes, no, cc)   

				    (1, 0, t::LT)
                                        =>
					{   tmp = i::DIRECT (expr (t::SUB (32, t1, t2)));
					    move (tmp, rd_operand);
					    emit (i::BINARY { bin_op=>i::SHRL, src=>i::IMMED 31, dst=>rd_operand } );
					};

				    (1, 0, t::GT)
                                        =>
					{   tmp = i::DIRECT (expr (t::SUB (32, t1, t2)));
					    emit (i::UNARY { un_op=>i::NOTL, operand=>tmp } );
					    move (tmp, rd_operand);
					    emit (i::BINARY { bin_op=>i::SHRL, src=>i::IMMED 31, dst=>rd_operand } );
					};

				    (1, 0, _) 	 #  normal case
                                        => 
				        {   cc = cmp (TRUE, type, cc, t1, t2, []); 
				            mark (i::SET { cond => cond cc, operand=>eax }, notes);
					    emit (i::BINARY { bin_op=>i::ANDL, src=>i::IMMED 255, dst=>eax } );
					    move (eax, rd_operand);
				        };

				    (c1, c2, _)
                                        => 
				        # general case; 
				        # from the Intel optimization guide p3-5 
				        #
					{   zero eax;
					    cc = cmp (TRUE, type, cc, t1, t2, []); 

					    fun c19 (base, scale)
                                                =
                                                {
						    address = i::INDEXED { base,
									 index=>c::eax,
									 scale,
									 disp=>i::IMMED c2,
									 mem=>readonly };
						    tmp_r = new_reg();
						    tmp  = i::DIRECT tmp_r;
						    emit (i::SET { cond=>cond cc, operand=>eax } ); 
						    mark (i::LEA { r32=>tmp_r, address }, notes);
						    move (tmp, rd_operand);
					        };

					    case (c1-c2)   

						1 => c19 (NULL, 0);
						2 => c19 (NULL, 1);
						3 => c19 (THE c::eax, 1);
						4 => c19 (NULL, 2);
						5 => c19 (THE c::eax, 2);
						8 => c19 (NULL, 3);
						9 => c19 (THE c::eax, 3);

						dd =>
						    {   emit (i::SET { cond=>cond (t::basis::negate_cond cc), 
								operand=>eax } ); 

							emit (i::UNARY { un_op=>i::DECL, operand=>eax } );

							emit (i::BINARY { bin_op=>i::ANDL,
								      src=>i::IMMED dd, dst=>eax } );

							if (c2 == 0) 
							     move (eax, rd_operand);
							else
							     tmp_r = new_reg();
							     tmp  = i::DIRECT tmp_r;

							     mark (i::LEA { address=>
									   i::DISPLACE {
										      base=>c::eax,
										      disp=>i::IMMED c2,
										      mem=>readonly },
									   r32=>tmp_r }, notes);

							     move (tmp, rd_operand);
							fi;
                                                    };
                                            esac;
					};
                            	esac;
			    };			# fun setcc 

			# Generate cmovcc instruction.
			# on Pentium Pro and Pentium II only
			#
			fun cmovcc (type, cc, t1, t2, yes, no)
			    = 
			    dst_must_be_reg  gen_cmov
                            where
			        fun gen_cmov (dst_r, _)
				    = 
				    {   do_expression (no, dst_r, []);			# FALSE branch 
					cc = cmp (TRUE, type, cc, t1, t2, []);	# Compare 

				        mark (i::CMOV { cond=>cond cc, src=>reg_or_mem (operand yes), 
						    dst=>dst_r }, notes); 
				    };
			    end;

			fun unknown_expression expression
			    =
			    do_expression (codetree_stuff::compile_int_expression expression, rd, notes); 


			# Add n to rd:
                        #
			fun add_n n
			    =
			    {   n = operand n;

				src = if (is_mem_reg rd)   immed_or_reg n;
                                      else                 n;
                                      fi;

			        mark (i::BINARY { bin_op=>i::ADDL, src, dst=>rd_operand }, notes);
			    };


			# Generate addition:
                        #
			fun addition (e1, e2)
			    =
			    case e1   
				t::REG(_, rs) => if (cb::same_color (rs, rd))  add_n e2; 
						 else                          addition1 (e1, e2);
						 fi;

			       _ => addition1 (e1, e2);
                            esac

		       also
		       fun addition1 (e1, e2)
			    =
			    case e2   
				t::REG(_, rs) => if (cb::same_color (rs, rd))  add_n e1; 
						 else                          addition2 (e1, e2);
						 fi;
				_ => addition2 (e1, e2);
                            esac 

			also
			fun addition2 (e1, e2)
                            =
			    dst_must_be_reg
				(fn (dst_r, _)
                                    =
				    mark (i::LEA { r32=>dst_r, address=>address (expression, readonly) }, notes)
				)
			    except
                                EA = binary_comm (i::ADDL, e1, e2);


		        case expression

			     t::REG(_, rs)
				 => 
				 if (is_mem_reg rs and is_mem_reg rd)

				     tmp = i::DIRECT (new_reg());
				     move'(i::MEM_REG rs, tmp, notes);
				     move'(tmp, rd_operand, []);
				 else
				     move'(int_reg rs, rd_operand, notes);
				 fi;

			     t::LITERAL z
                                 =>
                                 {
				     n = to_int32 z;

				     if (n==0) 
					 # As per Fermin's request, special optimization for rd := 0. 
					 # Currently we don't bother with the size.
					 #
					 if (is_mem_reg rd)  move'(i::IMMED 0, rd_operand, notes);
					 else mark (i::BINARY { bin_op=>i::XORL, src=>rd_operand, dst=>rd_operand }, notes);
					 fi;
				     else
					 move'(i::IMMED (n), rd_operand, notes);
				     fi;
				 };

			     (t::CONST _ | t::LABEL _)
                                 => 
			         move'(i::IMMED_LABEL expression, rd_operand, notes);

			     t::LABEXP le
                                 =>
                                 move'(i::IMMED_LABEL le, rd_operand, notes);

			     # 32-bit addition 
			     #
			     t::ADD (32, e1, e2 as t::LITERAL n)
                                 =>
                                 {
				     n = to_int32 n;

				     case n 
					 1 =>  unary (i::INCL, e1);
				        -1 =>  unary (i::DECL, e1);
				         _ =>  addition (e1, e2);
                                     esac;
				 };

			     t::ADD (32, e1 as t::LITERAL n, e2)
                                 =>
                                 {
				     n = to_int32 n;

				     case n 
					 1 =>  unary (i::INCL, e2);
				        -1 =>  unary (i::DECL, e2);
				         _ =>  addition (e1, e2);
                                     esac;
				 };

			     t::ADD (32, e1, e2)
				 =>
				 addition (e1, e2);

			     # 32-bit addition but set the flag!
			     # This is a stupid hack for now.     XXX BUGGO FIXME
			     #
			     t::ADD (0, e, e1 as t::LITERAL n)
				 =>
				 {
				     n = t::machine_int::to_int (32, n);

				     if   (n ==  1)  unary       (i::INCL, e);
				     elif (n == -1)  unary       (i::DECL, e);
				     else            binary_comm (i::ADDL, e, e1);
				     fi;
				 };

			     t::ADD (0, e1 as t::LITERAL n, e)
                                 =>
                                 {
				     n = t::machine_int::to_int (32, n);

				     if   (n ==  1)  unary       (i::INCL, e);
				     elif (n == -1)  unary       (i::DECL, e);
				     else            binary_comm (i::ADDL, e1, e);
				     fi;
				 };

			     t::ADD (0, e1, e2)
                                 =>
                                 binary_comm (i::ADDL, e1, e2);

			     # 32-bit subtraction:
			     #
			     t::SUB (32, e1, e2 as t::LITERAL n)
				 =>
				 {   n = to_int32 n;

				     case n
					 0 => do_expression (e1, rd, notes);
					 1 => unary (i::DECL, e1);
					-1 => unary (i::INCL, e1);
					 _ => binary (i::SUBL, e1, e2);
				     esac;
				 };

			     t::SUB (32, e1 as t::LITERAL n, e2)
				 => 
				 if (n == 0) unary  (i::NEGL, e2);
				 else        binary (i::SUBL, e1, e2);
				 fi;

			     t::SUB (32, e1, e2) => binary (i::SUBL, e1, e2);

			     t::MULU (32, x, y) => u_multiply (x, y);
			     t::DIVU (32, x, y) => divide (FALSE, FALSE, x, y);
			     t::REMU (32, x, y) => rem (FALSE, x, y);

			     t::MULS (32, x, y) => multiply_notrap (x, y);
			     t::DIVS (t::DIV_TO_ZERO, 32, x, y) => divide (TRUE, FALSE, x, y);
			     t::DIVS (t::DIV_TO_NEGINF, 32, x, y) => divinf (FALSE, x, y);
			     t::REMS (t::DIV_TO_ZERO, 32, x, y) => rem (TRUE, x, y);
			     t::REMS (t::DIV_TO_NEGINF, 32, x, y) => reminf (x, y);

			     t::ADDT (32, x, y) => { binary_comm (i::ADDL, x, y); trap();};
			     t::SUBT (32, x, y) => { binary (i::SUBL, x, y); trap();};
			     t::MULT (32, x, y) => { multiply (x, y); trap ();};
			     t::DIVT (t::DIV_TO_ZERO, 32, x, y) => divide (TRUE, TRUE, x, y);
			     t::DIVT (t::DIV_TO_NEGINF, 32, x, y) => divinf (TRUE, x, y);

			     t::BITWISEAND (32, x, y) => binary_comm (i::ANDL, x, y);
			     t::BITWISEOR (32, x, y)  => binary_comm (i::ORL, x, y);
			     t::BITWISEXOR (32, x, y) => binary_comm (i::XORL, x, y);
			     t::BITWISENOT (32, x)    => unary (i::NOTL, x);

			     t::RIGHTSHIFT (32, x, y)  => shift (i::SARL, x, y);
			     t::RIGHTSHIFTU (32, x, y)  => shift (i::SHRL, x, y);
			     t::LEFTSHIFT (32, x, y)  => shift (i::SHLL, x, y);

			     t::LOAD (8, ea, mem) => load8 (ea, mem);
			     t::LOAD (16, ea, mem) => load16 (ea, mem);
			     t::LOAD (32, ea, mem) => load32 (ea, mem);

			     t::SIGNEXTEND (32, 8, t::LOAD (8, ea, mem)) => load8s (ea, mem);
			     t::SIGNEXTEND (32, 16, t::LOAD (16, ea, mem)) => load16s (ea, mem);
			     t::ZEROEXTEND (32, 8, t::LOAD (8, ea, mem)) => load8 (ea, mem);
			     t::ZEROEXTEND (32, 16, t::LOAD (16, ea, mem)) => load16 (ea, mem);

			     t::COND (32, t::CMP (type, cc, t1, t2), y as t::LITERAL yes, n as t::LITERAL no)
				 =>
				 case *architecture		#  PentiumPro and higher has CMOVcc 

				     PENTIUM =>   setcc (type, cc, t1, t2, to_int32 yes, to_int32 no);
				     _       =>   cmovcc (type, cc, t1, t2, y, n);
				 esac;

			     t::COND (32, t::CMP (type, cc, t1, t2), yes, no)
				 => 
				 case *architecture		#  PentiumPro and higher has CMOVcc 

				     PENTIUM =>   unknown_expression expression;
				     _       =>   cmovcc (type, cc, t1, t2, yes, no);
				 esac;

			     t::LET (s, e) => { do_statement s; do_expression (e, rd, notes);};
			     t::MARK (e, a::MARKREG f) => { f rd; do_expression (e, rd, notes);};
			     t::MARK (e, a) => do_expression (e, rd, a ! notes);
			     t::PRED (e, c) => do_expression (e, rd, a::CONTROL_DEP_USE c ! notes);

			     t::REXT e => 
				extension_comp::compile_rext (reducer()) { e, rd, notes }; 

			     # Simplify and try again:
			     #
			     expression => unknown_expression expression;
			esac;
		    }								# fun do_expression 



		# Generate an expression and return its result register 
		# If rewritePseudo is on, the result is guaranteed to be in a 
		# non memReg register
		#
		also
		fun expr (expression as t::REG(_, rd))
			=> 
			if (is_mem_reg rd)  gen_expr expression;
                        else                rd;
                        fi;

		    expr expression
			=>
			gen_expr expression;
		end 

		also
		fun gen_expr expression
		    = 
		    {   rd = new_reg();
			do_expression (expression, rd, []);
			rd;
		    }

		# Compare an expression with zero.
		# On the x86, TEST is superior to AND for doing the same thing,
		# since it doesn't need to write out the result in a register.
		#
		also
		fun cmp_with_zero (cc as (t::EQ | t::NE), e as t::BITWISEAND (type, a, b), notes)
			=> 
			{   case type

				  8 =>  test (i::TESTB, a, b,  notes);
				 16 =>  test (i::TESTW, a, b,  notes);
				 32 =>  test (i::TESTL, a, b,  notes);
				  _ =>  do_expression (e, new_reg(), notes);
			    esac; 

			    cc;
			};  

		   cmp_with_zero (cc, e, notes)
			=> 
			{   e = 
				case e						#  hack to disable the lea optimization XXX 

				     t::ADD(_, a, b) => t::ADD (0, a, b);
				     e => e;
				esac;

			    do_expression (e, new_reg(), notes);
			    cc;
			};
		end 

		# Emit a test.
		#   The available modes are
		#      r/m, r
		#      r/m, imm
		# On selecting the right instruction: TESTL/TESTW/TESTB.   
		# When anding an operand with a constant
		# that fits within 8 (or 16) bits, it is possible to use TESTB,
		# (or TESTW) instead of TESTL.   Because x86 is little endian, 
		# this works for memory operands too.  However, with TESTB, it is
		# not possible to use registers other than 
		# AL, CL, BL, DL, and AH, CH, BH, DH.  So, the best way is to
		# perform register allocation first, and if the operand registers
		# are one of EAX, ECX, EBX, or EDX, replace the TESTL instruction 
		# by TESTB.
		#
		also
		fun test (testopcode, a, b, notes)
		    = 
		    {   my (_, operand1, operand2)
			    =
			    commute_comparison (t::EQ, TRUE, a, b);

			#  translate r, r/m => r/m, r 
			my (operand1, operand2)
			    = 
			    if (is_mem_operand operand2)  (operand2, operand1);
                            else                          (operand1, operand2);
                            fi;

			mark (testopcode { lsrc=>operand1, rsrc=>operand2 }, notes);
		    }

		    #  %eflags <- src 

		also
		fun move_to_eflags src
		    =
		    if   (not (cb::same_color (src, c::eflags)))

			 move (i::DIRECT src, eax);
			 emit (i::LAHF);
		    fi

		    # dst <- %eflags

		also
		fun move_from_eflags dst
		    =
		    if   (not (cb::same_color (dst, c::eflags)))

			 emit (i::SAHF);
			 move (eax, i::DIRECT dst);
		    fi

		   # Generate a condition code expression.
		   # The zero is for setting the condition code!  
		   # I have no idea why this is used.

		also
		fun do_bool_expression (t::CMP (type, cc, t1, t2), rd, notes)
			=> 
			{   cmp (FALSE, type, cc, t1, t2, notes); 
			    move_from_eflags rd;
			}; 

		    do_bool_expression (t::CC (cond, rs), rd, notes)
			=> 
			if   (cb::same_color (rs, c::eflags) or cb::same_color (rd, c::eflags))

			     move_to_eflags rs;
			     move_from_eflags rd;
			else
			     move'(i::DIRECT rs, i::DIRECT rd, notes);
			fi;

		    do_bool_expression (t::CCMARK (e, a::MARKREG f), rd, notes)
			=>
			{   f rd;
			    do_bool_expression (e, rd, notes);
			};

		    do_bool_expression (t::CCMARK (e, a), rd, notes)
			=>
			do_bool_expression (e, rd, a ! notes);

		    do_bool_expression (t::CCEXT e, cd, notes)
			=> 
			extension_comp::compile_ccext (reducer()) { e, ccd=>cd, notes }; 

		    do_bool_expression _
			=>
			error "do_bool_expression";
		end 

		also
		fun cc_expr e = error "cbool_expression"


		# Generate a comparison and set the condition code;
		# Return the actual cc used.  If the flag swapable is TRUE,
		# we can also reorder the operands. 
		#
		also
		fun cmp (swapable, type, cc, t1, t2, notes)
		     = 
		     #  == and != can be always be reordered 
		     {   swapable = swapable or cc == t::EQ or cc == t::NE;

			 # Sometimes the comparison
                         # is not necessary because
			 # the bits are already set.

			 if (is_zero t1 and set_zero_bit2 t2)

			     if swapable 
				  cmp_with_zero (t::basis::swap_cond cc, t2, notes);
			     else # Can't reorder the comparison.
				  gen_cmp (type, FALSE, cc, t1, t2, notes);
			     fi;

			 elif (is_zero t2 and set_zero_bit2 t1) 

			      cmp_with_zero (cc, t1, notes);

			 else
                              gen_cmp (type, swapable, cc, t1, t2, notes);
                         fi;
		     }

		# Give a and b which are the operands to a comparison (or test)
		# Return the appropriate condition code and operands.
		#   The available modes are:
		#        r/m, imm
		#        r/m, r
		#        r,   r/m
		#
		also
		fun commute_comparison (cc, swapable, a, b)
		    = 
		    {   my (operand1, operand2) = (operand a, operand b);

			# Try to fold in the operands whenever possible:

			case (is_immediate operand1, is_immediate operand2)

			     (TRUE, TRUE)
				 =>
				 (cc, move_to_reg operand1, operand2);

			     (TRUE, FALSE)
				 => 
				 if swapable  (t::basis::swap_cond cc, operand2, operand1);
				 else         (cc, move_to_reg operand1, operand2);
                                 fi;

			     (FALSE, TRUE)
				 =>
				 (cc, operand1, operand2);

			     (FALSE, FALSE)
				 => 
				 case (operand1, operand2)

				      (_, i::DIRECT _) =>  (cc, operand1, operand2);
				      (i::DIRECT _, _) =>  (cc, operand1, operand2);
				      (_, _)           =>  (cc, move_to_reg operand1, operand2);
				 esac;
			esac;
		    } 

		# Generate a real comparison;
                # return the real cc used: 
		#
		also
		fun gen_cmp (type, swapable, cc, a, b, notes)
		    = 
		    {   my (cc, operand1, operand2)
			    =
			    commute_comparison (cc, swapable, a, b);

			mark (i::CMPL { lsrc=>operand1, rsrc=>operand2 }, notes);
			cc; 
		    }

		# Generate code for jumps:
		#
		also
		fun jmp (lambda_expression as t::LABEL lab, labs, notes)
			=> 
			mark (i::JMP (i::IMMED_LABEL lambda_expression, [lab]), notes);

		    jmp (t::LABEXP le, labs, notes)
			=>
			mark (i::JMP (i::IMMED_LABEL le, labs), notes);

		    jmp (ea, labs, notes)
			=>
			mark (i::JMP (operand ea, labs), notes);
		end 

		# Convert lowcode to cellset:
		#
		also
		fun cellset lowcode
		    =
		    g (lowcode, c::empty)
                    where
		        add_ccreg = cb::cell_set::add; 

			fun g ([], acc) => acc;
			    g (t::INT_EXPRESSION (t::REG(_, r)) ! regs, acc)  => g (regs, c::add_reg (r, acc));
			    g (t::FLOAT_EXPRESSION (t::FREG(_, f)) ! regs, acc) => g (regs, c::add_freg (f, acc));
			    g (t::BOOL_EXPRESSION (t::CC(_, cc)) ! regs, acc)  => g (regs, add_ccreg (cc, acc));
			    g (t::BOOL_EXPRESSION (t::FCC(_, cc)) ! regs, acc)  => g (regs, add_ccreg (cc, acc));
			    g(_ ! regs, acc) => g (regs, acc);
			end;
		    end

		# Generate code for calls:
		# 
		also
		fun call (ea, flow, def, uses, mem, cuts_to, notes, pops)
		    = 
		    {   fun return (set, [])
				=>
				set;

			    return (set, a ! notes)
				=>
				case (a::return_arg.peek a)

				     THE r =>   return (cb::cell_set::add (r, set), notes);
				     NULL  =>   return (set, notes);
                                esac;
			end;

			mark (i::CALL { operand=>operand ea, defs=>cellset (def), uses=>cellset (uses),
				    return=>return (c::empty, notes), cuts_to, mem,
				    pops }, notes);
		    }

		# Generate code for integer stores; first move data to %eax 
		# This is mainly because we can't allocate to registers like
		# ah, dl, dx etc.
		#
		also
		fun gen_store (mv_op, ea, d, mem, notes)
		    =
		    {   src = 
			   case (immed_or_reg (operand d))

				src as i::DIRECT r
				    =>
				    if (cb::same_color (r, c::eax))
                                         src;
                                    else
                                         move (src, eax);
                                         eax;
                                    fi;

				src => src;
			   esac;

			mark (i::MOVE { mv_op, src, dst=>address (ea, mem) }, notes);
		    }

		#  generate code for 8-bit integer stores 
		#  movb has to use %eax as source. Stupid x86! 
		#
		also
		fun store8 (ea, d, mem, notes)
		    =
		    gen_store (i::MOVB, ea, d, mem, notes)


		also
		fun store16 (ea, d, mem, notes)
		    = 
		    mark (i::MOVE { mv_op=>i::MOVW, src=>immed_or_reg (operand d), dst=>address (ea, mem) }, notes)


		also
		fun store32 (ea, d, mem, notes)
		    = 
		    move'(immed_or_reg (operand d), address (ea, mem), notes)

		# Generate code for branching:
		#
		also
		fun branch (t::CMP (type, cc, t1, t2), lab, notes)
			=>
			#  Allow reordering of operands 
			{   cc = cmp (TRUE, type, cc, t1, t2, []); 
			    mark (i::JCC { cond=>cond cc, operand=>immed_label lab }, notes);
			};

		    branch (t::FCMP (fty, fcc, t1, t2), lab, notes)
			=> 
			fbranch (fty, fcc, t1, t2, lab, notes);

		    branch (bool_expression, lab, notes)
			=>
			{   do_bool_expression (bool_expression, c::eflags, []);
			    mark (i::JCC { cond=>cond (codetree_stuff::cond_of bool_expression), operand=>immed_label lab }, notes);
			};
		end 


		# Generate code for floating point
                # compare and branch:
		# 
		also
		fun fbranch (fty, fcc, t1, t2, lab, notes)
		    = 
		    {   fun j cc = mark (i::JCC { cond=>cc, operand=>immed_label lab }, notes);
			fbranching (fty, fcc, t1, t2, j);
		    }

		also
		fun fbranching (fty, fcc, t1, t2, j)
		    = 
		    {   fun ignore_order (t::FREG _) => TRUE;
			    ignore_order (t::FLOAD _) => TRUE;
			    ignore_order (t::FMARK (e, _)) => ignore_order e;
			    ignore_order _ => FALSE;
			end;

			fun compare'()		#  Sethi-Ullman style
			    = 
			    {   if (   ignore_order t1
				   or  ignore_order t2
				   )

				     reduce_float_expression (fty, t2, []);
				     reduce_float_expression (fty, t1, []);
				else
				     reduce_float_expression (fty, t1, []);
				     reduce_float_expression (fty, t2, []); 
				     emit (i::FXCH { operand=>c::st (1) });
				fi;

				emit (i::FUCOMPP);
				fcc;
			    };

			fun compare''()
			    = 
			    # Direct style 
			    # Try to make lsrc the memory operand
                            #
			    {   lsrc = foperand (fty, t1);
				rsrc = foperand (fty, t2);
				fsize = fsize fty;

				fun cmp (lsrc, rsrc, fcc)
				    =
				    {   i = *architecture != PENTIUM;    
					emit (i::FCMP { i, fsize, lsrc, rsrc } );
					fcc;
				    };

				case (lsrc, rsrc)

				     (i::FPR _, i::FPR _)
					 =>
					 cmp (lsrc, rsrc, fcc);

				     (i::FPR _, mem)
					 =>
					 cmp (mem, lsrc, t::basis::swap_fcond fcc);

				     (mem, i::FPR _)
					 =>
					 cmp (lsrc, rsrc, fcc);

				     (lsrc, rsrc) 		#  Can't be both memory! 
					 =>
					 {   ftmp_r = new_freg();
					     ftmp  = i::FPR ftmp_r;
					     emit (i::FMOVE { fsize, src=>rsrc, dst=>ftmp } );
					     cmp (lsrc, ftmp, fcc);
					 };
				esac;
			    };

			fun compare ()
			    = 
			    if   (enable_fast_fpmode and *fast_floating_point)
				 compare''();
			    else compare' ();
                            fi;

			fun andil i = emit (i::BINARY { bin_op=>i::ANDL, src=>i::IMMED (i), dst=>eax } );
			fun testil i = emit (i::TESTL { lsrc=>eax, rsrc=>i::IMMED (i) } );
			fun xoril i = emit (i::BINARY { bin_op=>i::XORL, src=>i::IMMED (i), dst=>eax } );
			fun cmpil i = emit (i::CMPL { rsrc=>i::IMMED (i), lsrc=>eax } );
			fun sahf () = emit (i::SAHF);

			fun branch fcc
			    =
			    case fcc

				 t::FEQ   => { andil 0x4400; xoril 0x4000; j (i::EQ);};
				 t::FNEU  => { andil 0x4400; xoril 0x4000; j (i::NE);};
				 t::FUO   => { sahf(); j (i::PP);};
				 t::FGLE  => { sahf(); j (i::NP);};
				 t::FGT   => { testil 0x4500;  j (i::EQ);};
				 t::FLEU  => { testil 0x4500;  j (i::NE);};
				 t::FGE   => { testil 0x500; j (i::EQ);};
				 t::FLTU  => { testil 0x500; j (i::NE);};
				 t::FLT   => { andil 0x4500; cmpil 0x100; j (i::EQ);};
				 t::FGEU  => { andil 0x4500; cmpil 0x100; j (i::NE);};
				 t::FLE   => { andil 0x4100; cmpil 0x100; j (i::EQ);
					     cmpil 0x4000; j (i::EQ);};
				 t::FGTU  => { sahf(); j (i::PP); testil 0x4100; j (i::EQ);};
				 t::FNE   => { testil 0x4400; j (i::EQ);};
				 t::FEQU  => { testil 0x4400; j (i::NE);};
				 _      => error (cat [
					       "fbranch(", t::basis::fcond_to_string fcc, ")"
					     ]);
			    esac;



			#             P  Z  C
			# x < y       0  0  1
			# x > y       0  0  0
			# x = y       0  1  0
			# unordered   1  1  1
			# When it's unordered, all three flags, P, Z, C are set.
			#
			fun fast_branch (fcc)
			    =
			    case fcc
				 t::FEQ  =>  ordered_only (i::EQ);
				 t::FNEU =>  { j (i::PP); j (i::NE);};
				 t::FUO  =>  j (i::PP);
				 t::FGLE =>  j (i::NP);
				 t::FGT  =>  ordered_only (i::AA);
				 t::FLEU =>  j (i::BE);
				 t::FGE  =>  ordered_only (i::AE);
				 t::FLTU =>  j (i::BB);
				 t::FLT  =>  ordered_only (i::BB);
				 t::FGEU =>  { j (i::PP); j (i::AE);};
				 t::FLE  =>  ordered_only (i::BE);
				 t::FGTU =>  { j (i::PP); j (i::AA);};
				 t::FNE  =>  ordered_only (i::NE);
				 t::FEQU =>  j (i::EQ);
				 _       =>  error (cat [
					       "fbranch(", t::basis::fcond_to_string fcc, ")"
					     ]);
			    esac

			also
			fun ordered_only fcc
			    =
			    {   label = label::make_anonymous_label();
				emit (i::JCC { cond=>i::PP, operand=>immed_label label } );
				j fcc;
				define_local_label label;
			    };

			fcc = compare(); 

			if (   *architecture != PENTIUM
			   and (enable_fast_fpmode and *fast_floating_point)
			   )

			     fast_branch  fcc;
			else
			     emit i::FNSTSW;   
			     branch  fcc;
			fi;
		    }

		# ========================================================
		# Floating point code generation starts here.
		# Some generic fp routines first.
		# ========================================================

		# Can this tree be folded into the src operand of a floating point
		# operations?
		#
		also
		fun foldable_float_expression (t::FREG _) => TRUE;
		    foldable_float_expression (t::FLOAD _) => TRUE;
		    foldable_float_expression (t::CVTI2F(_, (16 | 32), _)) => TRUE;
		    foldable_float_expression (t::CVTF2F(_, _, t)) => foldable_float_expression t;
		    foldable_float_expression (t::FMARK (t, _)) => foldable_float_expression t;
		    foldable_float_expression _ => FALSE;
		end 

		# Move integer e of size type into a memory location.
		# Returns a quadruple: 
		# (INTEGER, return type, effect address of memory location, cleanup code) 
		#
		also
		fun convert_int_to_float (type, e)
		    = 
		    {   operand = operand e; 

			if   (is_mem_operand operand and (type == 16 or type == 32))

			     (INTEGER, type, operand, []);
			else 
			     my { instrs, temp_mem, cleanup }
				 = 
				 cvti2f { type, src=>operand, ref_notes => get_notes() };

			     emits instrs;

			     (INTEGER, 32, temp_mem, cleanup);
			fi;
		    }

		# ========================================================
		# Sethi-Ullman based floating point code generation as 
		# implemented by Lal 
		# ========================================================

		also
		fun fld (32, operand) => i::FLDS operand;
		    fld (64, operand) => i::FLDL operand;
		    fld (80, operand) => i::FLDT operand;
		    fld _         => error "fld";
		end 

		also
		fun fild (16, operand) => i::FILD operand;
		    fild (32, operand) => i::FILDL operand;
		    fild (64, operand) => i::FILDLL operand;
		    fild _         => error "fild";
		end 

		also
		fun fxld (INTEGER, type, operand) => fild (type, operand);
		    fxld (REAL, fty, operand) => fld (fty, operand);
		end 

		also
		fun fstp (32, operand) => i::FSTPS operand;
		    fstp (64, operand) => i::FSTPL operand;
		    fstp (80, operand) => i::FSTPT operand;
		    fstp _          => error "fstp";
		end 

		# Generate code for floating point stores:
		#
		also
		fun fstore'(fty, ea, d, mem, notes)
		    = 
		    {   case d

			     t::FREG (fty, fs) =>   emit (fld (fty, i::FDIRECT fs));
			     _                 =>   reduce_float_expression (fty, d, []);
			esac;

			mark (fstp (fty, address (ea, mem)), notes);
		    }

		# Generate code for floating point loads:
		#
		also
		fun fload'(fty, ea, mem, fd, notes)
		    = 
		    {   ea = address (ea, mem);
			mark (fld (fty, ea), notes); 

			if   (cb::same_color (fd, st0))

			     emit (fstp (fty, i::FDIRECT fd));
			fi;
		    }

		also
		fun float_expression' e
		    =
		    {   reduce_float_expression (64, e, []);
			c::st (0);
		    }

		# Generate floating point expression
                # and put the result in fd:
		#
		also
		fun do_float_expression'(fty, t::FREG(_, fs), fd, notes)
			=> 
			if   (cb::same_color (fs, fd))

			     mark'(i::COPY { kind => cb::FLOAT_REGISTER, size_in_bits=>64, dst => [fd], src => [fs], tmp=>NULL }, notes);
			fi;

		    do_float_expression'(_, t::FLOAD (fty, ea, mem), fd, notes)
			=> 
			fload'(fty, ea, mem, fd, notes);

		    do_float_expression'(fty, t::FEXT float_expression, fd, notes)
			=> 
			{   extension_comp::compile_fext (reducer()) { e=>float_expression, fd, notes };

			    if (not (cb::same_color (fd, st0)))
                                emit (fstp (fty, i::FDIRECT fd));
                            fi;
			};

		    do_float_expression'(fty, e, fd, notes)
			=>
			{   reduce_float_expression (fty, e, []);

			    if   (cb::same_color (fd, st0))

				 mark (fstp (fty, i::FDIRECT fd), notes);
			    fi;
			};
		end 


		# Generate floating point expression using Sethi-Ullman's scheme:
		# This function evaluates a floating point expression, 
		# and put result in %ST (0).
		#
		also
		fun reduce_float_expression (fty, float_expression, notes) 
		    = 
		    {   st = i::ST (c::st 0);
			st1 = i::ST (c::st 1);
			cleanup_code = REF [] : Ref(  List(  i::Instruction ) );

			Su_Tree
			    = LEAF  (Int, t::Float_Expression, Ans)
			    | BINARY  (Int, t::Fty, Fbinop, Su_Tree, Su_Tree, Ans)
			    | UNARY  (Int, t::Fty, i::Fun_Op, Su_Tree, Ans)

			also
			Fbinop
			    =
			    FADD | FSUB | FMUL | FDIV | FIADD | FISUB | FIMUL | FIDIV
			withtype Ans = note::Notes;

			fun label (LEAF (n, _, _)) => n;
			    label (BINARY (n, _, _, _, _, _)) => n;
			    label (UNARY (n, _, _, _, _)) => n;
			end;

			fun annotate (LEAF (n, x, notes), a)  => LEAF (n, x, a ! notes);
			    annotate (BINARY (n, t, b, x, y, notes), a) => BINARY (n, t, b, x, y, a ! notes);
			    annotate (UNARY (n, t, u, x, notes), a) => UNARY (n, t, u, x, a ! notes);
			end;

			# Generate expression tree with sethi-ullman numbers:
			# 
			fun su (e as t::FREG _)        => LEAF (1, e, []);
			    su (e as t::FLOAD _)       => LEAF (1, e, []);
			    su (e as t::CVTI2F _)      => LEAF (1, e, []);

			    su (t::CVTF2F(_, _, t))    => su t;
			    su (t::FMARK (t, a))       => annotate (su t, a);

			    su (t::FABS (fty, t))      => su_unary (fty, i::FABS, t);
			    su (t::FNEG (fty, t))      => su_unary (fty, i::FCHS, t);
			    su (t::FSQRT (fty, t))     => su_unary (fty, i::FSQRT, t);

			    su (t::FADD (fty, t1, t2)) => su_com_binary (fty, FADD, FIADD, t1, t2);
			    su (t::FMUL (fty, t1, t2)) => su_com_binary (fty, FMUL, FIMUL, t1, t2);

			    su (t::FSUB (fty, t1, t2)) => su_binary (fty, FSUB, FISUB, t1, t2);
			    su (t::FDIV (fty, t1, t2)) => su_binary (fty, FDIV, FIDIV, t1, t2);
			    su _ => error "su";
			end 

			# Try to fold the the memory operand
                        # or integer conversion:
			#
			also
			fun su_fold (e as t::FREG _) => (LEAF (0, e, []), FALSE);
			    su_fold (e as t::FLOAD _) => (LEAF (0, e, []), FALSE);

			    su_fold (e as t::CVTI2F(_, (16 | 32), _)) => (LEAF (0, e, []), TRUE);
			    su_fold (t::CVTF2F(_, _, t)) => su_fold t;

			    su_fold (t::FMARK (t, a))
                                => 
			        {   my (t, integer) = su_fold t; 
			            (annotate (t, a), integer);
                                };

			    su_fold e
                                =>
                                (su e, FALSE);
			end 

			# Form unary tree:
			#
			also
			fun su_unary (fty, funary, t)
			    = 
			    {   t = su t;
				UNARY (label t, fty, funary, t, []);
			    }

			# Form binary tree:
			#
			also
			fun su_binary (fty, binop, ibinop, t1, t2)
			    =
			    {   t1 = su t1;
				my (t2, integer) = su_fold t2;

				n1 = label t1;
				n2 = label t2;

				n  = if (n1==n2)  n1+1;
                                     else         int::max (n1, n2);
                                     fi;

				my_op =    integer ?? ibinop
                                                   ::  binop;

				BINARY (n, fty, my_op, t1, t2, []); 
			    }

			# Try to fold in the operand if possible. 
			# This only applies to commutative operations.
			#
			also
			fun su_com_binary (fty, binop, ibinop, t1, t2)
			    =
			    {   my (t1, t2)
				    =
				    if (foldable_float_expression t2)
					 (t1, t2);
				    else (t2, t1);
                                    fi;

				su_binary (fty, binop, ibinop, t1, t2);
			    }

			also
			fun same_tree (LEAF(_, t::FREG (t1, f1), []), 
				     LEAF(_, t::FREG (t2, f2), []))
				=> 
				t1 == t2 and cb::same_color (f1, f2);

			    same_tree _
				=>
				FALSE;
			end;



			# Traverse tree and generate code 
			#
			fun gencode (LEAF(_, t, notes))
				=>
				mark (fxld (leaf_ea t), notes);

			    gencode (BINARY(_, _, binop, x, t2 as LEAF (0, y, a1), a2))
				=> 
				{   gencode x;

				    my (_, fty, src) = leaf_ea y;

				    fun gen (code)
					=
					mark (code, a1 @ a2);

				    fun binary (oper32, oper64)
					=
					if   (same_tree (x, t2))

					     gen (i::FBINARY { bin_op=>oper64, src=>st, dst=>st } );
					else
					     oper
						 = 
						 if   (is_mem_operand  src)

						      case fty

							   32 =>  oper32;
							   64 =>  oper64;
							   _  =>  error "gencode: BINARY";
						      esac;
						 else
						      oper64;
						 fi;

					     gen (i::FBINARY { bin_op=>oper, src, dst=>st } );
					fi;

				    fun ibinary (oper16, oper32)
					=
					gen (i::FIBINARY { bin_op, src } )
                                        where
					    bin_op
						=
						case fty

						     16 => oper16; 
						     32 => oper32; 
						      _ => error "gencode: IBINARY";
						esac;
					end;

				    case binop

					 FADD  =>   binary (i::FADDS,  i::FADDL); 
					 FSUB  =>   binary (i::FDIVS,  i::FSUBL); 
					 FMUL  =>   binary (i::FMULS,  i::FMULL); 
					 FDIV  =>   binary (i::FDIVS,  i::FDIVL); 
					 FIADD =>  ibinary (i::FIADDS, i::FIADDL); 
					 FISUB =>  ibinary (i::FIDIVS, i::FISUBL); 
					 FIMUL =>  ibinary (i::FIMULS, i::FIMULL); 
					 FIDIV =>  ibinary (i::FIDIVS, i::FIDIVL);
				    esac; 
				};  

			    gencode (BINARY(_, fty, binop, t1, t2, notes))
				=> 
				{   fun do_it (t1, t2, oper, oper_p, oper_rp)
					= 
					{   # oper[P] =>  st (1) := st oper st (1); [pop] 
					    # operR[P] => st (1) := st (1) oper st; [pop]

					    n1 = label t1;
					    n2 = label t2;

					    if   (n1 < n2 and n1 <= 7)

						 gencode t2;
						 gencode t1;
						 mark (i::FBINARY { bin_op=>oper_p, src=>st, dst=>st1 }, notes);
					    else
						 if   (n2 <= n1 and n2 <= 7)

						      gencode t1;
						      gencode t2;
						      mark (i::FBINARY { bin_op=>oper_rp, src=>st, dst=>st1 }, notes);
						 else 
						      #  Both labels > 7 
						      fs = i::FDIRECT (new_freg());
						      gencode t2;
						      emit (fstp (fty, fs));
						      gencode t1;
						      mark (i::FBINARY { bin_op=>oper, src=>fs, dst=>st }, notes);
						 fi;
					    fi;
				       };

				    case  binop

					FADD => do_it (t1, t2, i::FADDL, i::FADDP, i::FADDP);
					FMUL => do_it (t1, t2, i::FMULL, i::FMULP, i::FMULP);
					FSUB => do_it (t1, t2, i::FSUBL, i::FSUBP, i::FSUBRP);
					FDIV => do_it (t1, t2, i::FDIVL, i::FDIVP, i::FDIVRP);
					_ => error "gencode::BINARY";
				    esac;
				};

			    gencode (UNARY(_, _, unary_op, su, notes))
				=> 
				{   gencode (su);
				    mark (i::FUNARY (unary_op), notes);
				};
			end 

			# Generate code for a leaf.
			# Returns the type and an effective address
			#
			also
			fun leaf_ea (t::FREG (fty, f))        => (REAL, fty, i::FDIRECT f);
			    leaf_ea (t::FLOAD (fty, ea, mem)) => (REAL, fty, address (ea, mem));

			    leaf_ea (t::CVTI2F(_, 32, t)) => int2real (32, t);
			    leaf_ea (t::CVTI2F(_, 16, t)) => int2real (16, t);
			    leaf_ea (t::CVTI2F(_, 8, t))  => int2real (8, t);

			    leaf_ea _ => error "leafEA";
			end 

			also
			fun int2real (type, e)
			    = 
			    {   my (_, type, ea, cleanup)
				    =
				    convert_int_to_float (type, e);

				cleanup_code := *cleanup_code @ cleanup;

				(INTEGER, type, ea);
			    };

			gencode (su float_expression);
			emits *cleanup_code;
		    }				# reduceFexp

		# ========================================================
		# This section generates 3-address style floating 
		# point code.  
		# ========================================================

		also
		fun isize 16 => i::INT16;
		    isize 32 => i::INT32;
		    isize _  => error "isize";
		end 

		also
		fun fstore''(fty, ea, d, mem, notes)
		    = 
		    {   floating_point_used := TRUE;

			mark (i::FMOVE { fsize=>fsize fty, dst=>address (ea, mem), 
				  src=>foperand (fty, d) }, notes);
		    }

		also
		fun fload''(fty, ea, mem, d, notes)
		    = 
		    {   floating_point_used := TRUE;

			mark (i::FMOVE { fsize=>fsize fty, src=>address (ea, mem), 
				  dst=>real_reg d }, notes);
		    }

		also
		fun fiload''(ity, ea, d, notes)
		    = 
		    {   floating_point_used := TRUE;

			mark (i::FILOAD { isize=>isize ity, ea, dst=>real_reg d }, notes);
		    }

		also
		fun float_expression''(e as t::FREG(_, f))
			=> 
			if (is_fmem_reg f)  trans_float_expression e;
                        else                f;
                        fi;

		    float_expression'' e
			=>
			trans_float_expression e;
		end 

		also
		fun trans_float_expression e
		    = 
		    {   fd = new_freg();
			do_float_expression''(64, e, fd, []);
			fd;
		    }


		# Process a floating point operand.
		# Put operand in register when possible.
		# The operand should match the given fty.
		#
		also
		fun foperand (fty, e as t::FREG (fty', f))
			=> 
			if (fty == fty')   real_reg f;
                        else               i::FPR (float_expression'' e);
                        fi;

		    foperand (fty, t::CVTF2F(_, _, e))
			=>
			foperand (fty, e); #  nop on the x86 

		    foperand (fty, e as t::FLOAD (fty', ea, mem))
			=> 
			# Fold operand when
                        # the precison matches:
			#
			if (fty == fty')   address (ea, mem);
                        else               i::FPR (float_expression'' e);
                        fi;

		    foperand (fty, e)
			=>
			i::FPR (float_expression'' e);
		end 


		# Process a floating point operand. 
		# Try to fold in a memory operand or
                # conversion from an integer:
		#
		also
		fun fioperand (t::FREG (fty, f)) => (REAL, fty, real_reg f, []);
		    fioperand (t::FLOAD (fty, ea, mem)) => (REAL, fty, address (ea, mem), []);
		    fioperand (t::CVTF2F(_, _, e)) => fioperand (e); #  nop on the x86 
		    fioperand (t::CVTI2F(_, type, e)) => convert_int_to_float (type, e);
		    fioperand (t::FMARK (e, notes)) => fioperand (e); #  XXX 
		    fioperand (e) => (REAL, 64, i::FPR (float_expression'' e), []);
		end 

		# Generate binary operator.
		#
                # Since the real binary operators
		# do not take memory as destination,
                # we must ensure this does not happen:
		#
		also
		fun fbinop (target_fty, bin_op, bin_op_r, ibin_op, ibin_op_r, lsrc, rsrc, fd, notes)
		    = 
		    #  Put the mem operand in rsrc 
		    { 
			fun is_mem_operand (t::FREG(_, f)) =>  is_fmem_reg f;

			    is_mem_operand (t::FLOAD _                ) => TRUE;
			    is_mem_operand (t::CVTI2F(_, (16 | 32), _)) => TRUE;

			    is_mem_operand (t::CVTF2F(_, _, t)) => is_mem_operand t;
			    is_mem_operand (t::FMARK (t, _)   ) => is_mem_operand t;

			    is_mem_operand _ => FALSE;
			end;

			my (bin_op, ibin_op, lsrc, rsrc)
			    = 
			    if (is_mem_operand lsrc)
				 (bin_op_r, ibin_op_r, rsrc, lsrc);
			    else (bin_op, ibin_op, lsrc, rsrc);
                            fi;

			lsrc = foperand (target_fty, lsrc);

			my (kind, fty, rsrc, code)
			    =
			    fioperand  rsrc;

			fun dst_must_be_freg f
			    =
			    if (target_fty != 64)

				 tmp_r = new_freg(); 
				 tmp  = i::FPR tmp_r;

				 mark (f tmp, notes); 

				 emit (i::FMOVE { fsize => fsize target_fty, 
						  src   => tmp,
                                                  dst   => real_reg fd
                                                }
                                      );

			    else
				 mark (f(real_reg fd), notes);
			    fi;

			case kind

			     REAL
				 => 
				 dst_must_be_freg (fn dst
                                                      =
					              i::FBINOP { fsize  => fsize fty,
                                                                  bin_op, lsrc, rsrc, dst
                                                                }
                                                  ); 
			     INTEGER
				 => 
				 {   dst_must_be_freg
					 (fn dst =
					      i::FIBINOP { isize=>isize fty, bin_op=>ibin_op, 
							   lsrc, rsrc, dst
                                                         }
					 );
				     emits code;
				 };
			esac;
		    }

		also
		fun funop (fty, un_op, src, fd, notes)
		    = 
		    {   src = foperand (fty, src);

			mark (i::FUNOP { fsize=>fsize fty,
				     un_op, src, dst=>real_reg fd }, notes);
		    }

		also
		fun do_float_expression''(fty, e, fd, notes)
		    = 
		    {   floating_point_used := TRUE;

			case e

			     t::FREG(_, fs)
                                 =>
                                 if (not (cb::same_color (fs, fd) ))
				     copy_floats''(fty, [fd], [fs], notes);
                                 fi;

			     # X86 does everything as 80-bits internally. 

			     # Binary operators 
			     #
			     t::FADD(_, a, b) => fbinop (fty, 
						       i::FADDL, i::FADDL, i::FIADDL, i::FIADDL, 
						       a, b, fd, notes);
			     t::FSUB(_, a, b) => fbinop (fty,
						       i::FSUBL, i::FSUBRL, i::FISUBL, i::FISUBRL,
						       a, b, fd, notes);
			     t::FMUL(_, a, b) => fbinop (fty,
						       i::FMULL, i::FMULL, i::FIMULL, i::FIMULL,
						       a, b, fd, notes);
			     t::FDIV(_, a, b) => fbinop (fty,
						       i::FDIVL, i::FDIVRL, i::FIDIVL, i::FIDIVRL,
						       a, b, fd, notes);

			     #  Unary operators 
			     t::FNEG(_, a) => funop (fty, i::FCHS, a, fd, notes);
			     t::FABS(_, a) => funop (fty, i::FABS, a, fd, notes);
			     t::FSQRT(_, a) => funop (fty, i::FSQRT, a, fd, notes);

			     #  Load 
			     t::FLOAD (fty, ea, mem) => fload''(fty, ea, mem, fd, notes);

			     #  Type conversions 
			     t::CVTF2F(_, _, e) => do_float_expression''(fty, e, fd, notes);
			     t::CVTI2F(_, type, e) => 
			     { my (_, type, ea, cleanup) = convert_int_to_float (type, e);
			       fiload''(type, ea, fd, notes); 
				 emits cleanup;
			     };

			     t::FMARK (e, a::MARKREG f) => { f fd; do_float_expression''(fty, e, fd, notes);};
			     t::FMARK (e, a) => do_float_expression''(fty, e, fd, a ! notes);
			     t::FPRED (e, c) => do_float_expression''(fty, e, fd, a::CONTROL_DEP_USE c ! notes);
			     t::FEXT float_expression =>
			      extension_comp::compile_fext (reducer()) { e=>float_expression, fd, notes };
			     _ => error("doFexpr''");
			esac;
		}

		###################################################
		# Tie the two styles of fp code generation together
		###################################################
		also
		fun fstore (fty, ea, d, mem, notes)
		    = 
		    if (enable_fast_fpmode and *fast_floating_point)
			 fstore''(fty, ea, d, mem, notes);
		    else fstore' (fty, ea, d, mem, notes);
                    fi

		also
		fun fload (fty, ea, d, mem, notes)
		    = 
		    if (enable_fast_fpmode and *fast_floating_point)
			 fload''(fty, ea, d, mem, notes);
		    else fload' (fty, ea, d, mem, notes);
                    fi

		also
		fun float_expression e
		    = 
		    if  (enable_fast_fpmode
                    and *fast_floating_point)
			 float_expression'' e;
                    else float_expression'  e;
                    fi

		also
		fun do_float_expression (fty, e, fd, notes)
		    = 
		    if (enable_fast_fpmode and *fast_floating_point)
			 do_float_expression''(fty, e, fd, notes);
		    else do_float_expression' (fty, e, fd, notes);
                    fi

		# ================================================================
		# Optimizations for x := x op y 
		# Special optimizations: 
		# Generate a binary operator, result must in memory.
		# The source must not be in memory
		# ================================================================
		also
		fun binary_mem (bin_op, src, dst, mem, notes)
		    =
		    mark (i::BINARY { bin_op, src=>immed_or_reg (operand src),
				  dst=>address (dst, mem) }, notes)
		also
		fun unary_mem (un_op, operand, mem, notes)
		    =
		    mark (i::UNARY { un_op, operand=>address (operand, mem) }, notes)

		also
		fun is_one (t::LITERAL n)   =>   n == 1;
		    is_one _ => FALSE;
		end 


		# Perform optimizations based on recognizing 
		#    x := x op y    or
		#    x := y op x 
		# first.
		#
		also
		fun store (type, ea, d, mem, notes, 
			  { inc, dec, add, sub, notx, neg, shl, shr, sar, orx, andx, xor },
			  do_store
			 )
		    = 
		    {   fun default ()
			    =
			    do_store (ea, d, mem, notes);

			fun binary1 (t, t', unary, binary, ea', x)
			    =
			    if (t == type and t' == type)
				 if (codetree_utils::eq_int_expression (ea, ea'))
				      if (is_one x ) unary_mem (unary, ea, mem, notes);
				      else binary_mem (binary, x, ea, mem, notes);
				      fi;
				 else default();
				 fi;
			    else default();
                            fi;

			fun unary (t, un_op, ea')
			    = 
			    if (t == type
                            and codetree_utils::eq_int_expression (ea, ea')
                            )
			         unary_mem (un_op, ea, mem, notes);
			    else default();
                            fi; 

			fun binary (t, t', bin_op, ea', x)
			    =
			    if (    t == type
			       and  t' == type
			       and  codetree_utils::eq_int_expression (ea, ea')
			    )     
				 binary_mem (bin_op, x, ea, mem, notes);
			    else default();
			    fi;

			fun binary_com1 (t, un_op, bin_op, x, y)
			    = 
			    if (t == type)

				fun again ()
				    =
				    case y   
					t::LOAD (type', ea', _)
					    =>
					    if (type' == type
					    and codetree_utils::eq_int_expression (ea, ea')
					    )
						 if (is_one x)  unary_mem  ( un_op,    ea, mem, notes);
						 else           binary_mem (bin_op, x, ea, mem, notes);
						 fi;
					    else default();
					    fi;

					_ => default();
				    esac;

				case x    
				    t::LOAD (type', ea', _)
					=>
					if (type' == type
					and codetree_utils::eq_int_expression (ea, ea')
					)
					     if (is_one y)   unary_mem  ( un_op,    ea, mem, notes);
					     else            binary_mem (bin_op, y, ea, mem, notes);
					     fi;
					else again();
					fi;

				    _ => again();
				esac;

			    else default();
                            fi;

			fun binary_com (t, bin_op, x, y)
			    = 
			    if   (t == type)

				 fun again ()
				     =
				     case y   
					 t::LOAD (type', ea', _)
                                             =>
					     if (type' == type
                                             and codetree_utils::eq_int_expression (ea, ea')
                                             )
						  binary_mem (bin_op, x, ea, mem, notes);
					     else default();
                                             fi;

					_ => default();
                                     esac;

				 case x    
				     t::LOAD (type', ea', _)
                                         =>
				         if (type' == type
                                         and codetree_utils::eq_int_expression (ea, ea')
                                         )
					      binary_mem (bin_op, y, ea, mem, notes);
				         else again();
                                         fi;

				     _ => again();
                                 esac;

			    else default();
                            fi;

			case d

			     t::ADD (t, x, y)                    => binary_com1 (t, inc, add, x, y);
			     t::SUB (t, t::LOAD (t', ea', _), x) => binary1 (t, t', dec, sub, ea', x);

			     t::BITWISEOR  (t, x, y) => binary_com (t, orx, x, y);
			     t::BITWISEAND (t, x, y) => binary_com (t, andx, x, y);
			     t::BITWISEXOR (t, x, y) => binary_com (t, xor, x, y);

			     t::LEFTSHIFT   (t, t::LOAD (t', ea', _), x) => binary (t, t', shl, ea', x);
			     t::RIGHTSHIFTU (t, t::LOAD (t', ea', _), x) => binary (t, t', shr, ea', x);
			     t::RIGHTSHIFT  (t, t::LOAD (t', ea', _), x) => binary (t, t', sar, ea', x);

			     t::NEG        (t, t::LOAD (t', ea', _)) => unary (t, neg,  ea');
			     t::BITWISENOT (t, t::LOAD (t', ea', _)) => unary (t, notx, ea');
			     _ => default();
			esac;
		    }				# fun store 

		# Generate code for a statement:
		#
		also
		fun do_statement' (t::MOVE_INT(_, rd, e), notes) => do_expression (e, rd, notes);
		    do_statement' (t::MOVE_FLOAT (fty, fd, e), notes) => do_float_expression (fty, e, fd, notes); 
		    do_statement' (t::MOVE_BOOL (ccd, e), notes) => do_bool_expression (e, ccd, notes); 
		    do_statement' (t::COPY_INTS(_, dst, src), notes) => copy_ints (dst, src, notes);
		    do_statement' (t::COPY_FLOATS (fty, dst, src), notes) => copy_floats (fty, dst, src, notes);
		    do_statement' (t::JUMP (e, labs), notes) => jmp (e, labs, notes);

		    do_statement' (t::CALL { funct, targets, defs, uses, region, pops, ... }, notes)
                        =>
			call (funct, targets, defs, uses, region,[], notes, pops);

		    do_statement' (t::FLOW_TO (t::CALL { funct, targets, defs, uses, region, pops, ... }, cut_to), notes)
                        => 
			call (funct, targets, defs, uses, region, cut_to, notes, pops);

		    do_statement' (t::RET _, notes) => mark (i::RET NULL, notes);

		    do_statement' (t::STORE (8, ea, d, mem), notes)
                        => 
			store (8, ea, d, mem, notes, opcodes8, store8);

		    do_statement' (t::STORE (16, ea, d, mem), notes)
                        => 
			store (16, ea, d, mem, notes, opcodes16, store16);

		    do_statement' (t::STORE (32, ea, d, mem), notes)
                        => 
			store (32, ea, d, mem, notes, opcodes32, store32);

		    do_statement' (t::FSTORE (fty, ea, d, mem), notes) => fstore (fty, ea, d, mem, notes);
		    do_statement' (t::BCC (cc, lab), notes) => branch (cc, lab, notes);
		    do_statement' (t::DEFINE l, _) => define_local_label l;
		    do_statement' (t::LIVE s, notes) => mark'(i::LIVE { regs=>cellset s, spilled=>c::empty }, notes);
		    do_statement' (t::DEAD s, notes) => mark'(i::DEAD { regs=>cellset s, spilled=>c::empty }, notes);
		    do_statement' (t::NOTE (s, a), notes) => do_statement' (s, a ! notes);

		    do_statement' (t::EXT s, notes)
                        =>
			extension_comp::compile_sext (reducer()) { statement=>s, notes }; 

		    do_statement' (s, _)
                        =>
                        do_statements (codetree_stuff::compile_statement s);
		end 

		also
		fun do_statement s
                    =
                    do_statement' (s, [])

		also
		fun do_statements ss
                    =
                    apply do_statement ss

		also
		fun begin_cluster' _
		    =
		    {   # Must be cleared by the client.
			# if rewriteMemReg then memRegsUsed := 0u0  

			floating_point_used := FALSE;
			trap_label := NULL; 
			begin_cluster 0;
		    }

		also
		fun end_cluster' a
		    =
		    {   case *trap_label
			   NULL => ();
			   THE(_, lab) => { define_local_label lab; emit (i::INTO);};
		        esac;

			# If floating point has been used
			# allocate an extra register just
			# in case we didn't use any explicit
			# register:
			#
			if *floating_point_used  new_freg(); (); fi;

			end_cluster a;
		   }

		also
		fun reducer ()
		    = 
		    ts::REDUCER
                      { reduce_int_expression   => expr,
			reduce_float_expression => float_expression,
			reduce_bool_expression  => cc_expr,
			reduce_statement        => do_statement',
			operand,
			reduce_operand,
			address_of     => fn e =  address (e, i::region::memory),	# XXX
			emit           => mark',
			instruction_stream, 
			codetree_stream  => self() 
		       }

		also
		fun self ()
		    =
		    ts::instruction_stream::STREAM
		    {  begin_cluster   => begin_cluster',
		       end_cluster     => end_cluster',
		       emit           => do_statement,
		       emit_pseudo_op,
		       define_local_label,
		       define_global_label,
		       emit_comment,
		       add_note,
		       get_notes,
		       end_procedure     =>  fn lowcode =  end_procedure (cellset lowcode)
		    };

		self ();
	    }; 
    };					#  generic package translate_codetree_to_x86_g
end;					#  stipulate





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## COPYRIGHT (c) 1998 Bell Laboratories.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
