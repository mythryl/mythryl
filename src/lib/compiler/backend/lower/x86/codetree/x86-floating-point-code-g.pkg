## x86-floating-point-code-g.pkg

# Compiled by:
#     src/lib/compiler/backend/lower/make7/ia32.make6



# This phase takes a cluster with pseudo x86
# fp instructions, performs liveness analysis
# to determine their live ranges, and rewrites
# the program into the correct stack based code.
#
# The Basics 
# ----------
# o We assume there are 7 pseudo fp registers, %fp (0), ..., %fp (6),
#   which are mapped onto the %st stack.  One stack location is reserved
#   for holding temporaries.
# o Important: for floating point comparisons, we actually need
#   two extra stack locations in the worst case.  We handle this by 
#   specifying that the instruction define an extra temporary fp register
#   when necessary.
# o The mapping between %fp <-> %st may change from program point to 
#   program point.  We keep track of this lazy renaming and try to minimize
#   the number of FXCH that we insert.
# o At split and merge points, we may get inconsistent %fp <-> %st mappings.
#   We handle this by inserting the appropriate renaming code.
# o Parallel copies (renaming) are rewritten into a sequence of FXCHs! 
#
# Pseudo fp instructions     Semantics
# --------------------------------------
# FMOVE   src, dst           dst := src
# FILOAD  ea, dst            dst := cvti2f (mem[ea])
# FBINOP  lsrc, rsrc, dst    dst := lsrc * rsrc
# FIBINOP lsrc, rsrc, dst    dst := lsrc * cvti2f (rsrc)
# FUNOP   src, dst           dst := unaryOp src
# FCMP    lsrc, rsrc         fp condition code := fcmp (lsrc, rsrc) 
# 
# An instruction may use its source operand (s) destructively.
# We find this info using a global liveness analysis.
#
# The Translation
# --------------- 
# o We keep track of the namings between %fp registers and the 
#   %st(..) staack locations.
# o FXCH and FLDL are inserted at the appropriate places to move operands
#   to %st (0).  FLDL is used if the operand is not dead.  FXCH is used
#   if the operand is the last use.
# o FCOPY's between pseudo %fp registers are done by software renaming
#   and generate no code by itself!
# o FSTL %st (1) are also generated to pop the stack after the last use
#   of an operand.
#
# Note
# ----
# 1. This module should be run after floating point register allocation.
# 
# -- Allen Leung Leung (leunga@cs.nyu.edu)
#
# See also:
#
#     Some notes on the new MLRISC X86 floating point code generator (Draft)
#     Allen Leung, Lal George
#     circa 2000, 17p
#     http://www.smlnj.org//compiler-notes/x86-fp.ps



###               "You can't really focus yourself for years
###                unless you have undivided concentration,
###                which too many spectators would have destroyed."
###
###                                       -- Andrew Wiles 



stipulate

   debug = FALSE;         # Set this to TRUE to debug this module 
                          # set this to FALSE for production use.
                          #
   debug_liveness = TRUE; # Debug liveness analysis 
   debug_dead = FALSE;    # Debug dead code removal 
   sanity_check = TRUE;

herein

    # We are invoked from:
    #
    #     src/lib/compiler/backend/lower/x86/reg-alloc/x86-register-allocation-g.pkg

    generic package x86_floating_point_code_g (

	package instruction_set
	    :
	    Instruction_Set_X86;				# Instruction_Set_X86			is from   src/lib/compiler/backend/lower/x86/instruction/instruction-set-x86.api

	package x86_instruction_semantic_properties
            :
            Instruction_Properties				# Instruction_Properties		is from   src/lib/compiler/backend/lower/instruction/instruction-properties.api
	    where instruction_set == instruction_set;

	package flowgraph
            :
            Control_Flow_Graph					# Control_Flow_Graph			is from   src/lib/compiler/backend/lower/flowgraph/control-flow-graph.api
	    where instruction_set == instruction_set;

	package liveness
            :
            Liveness						# Liveness				is from   src/lib/compiler/backend/lower/reg-alloc/liveness.api
	    where control_flow_graph == flowgraph;

	package asm
            :
            Instruction_Emitter					# Instruction_Emitter			is from   src/lib/compiler/backend/lower/emit/instruction-emitter.api
	    where
                  instruction_set == instruction_set
	    also
                  instruction_stream::pseudo_op
                  ==
                  flowgraph::pseudo_op;
    )

    : (weak) Control_Flow_Graph_Optimization			# Control_Flow_Graph_Optimization	is from   src/lib/compiler/backend/lower/flowgraph/cfg-optimization.api

    {
	package control_flow_graph = flowgraph;
	package cells              = instruction_set::cells;

	package g  = graph;					# graph					is from   src/lib/graph/graph.pkg
	package i  = instruction_set;
	package t  = i::codetree;
	package p  = x86_instruction_semantic_properties;
	package c  = cells;
	package a  = rw_vector;					# rw_vector				is from   src/lib/std/src/rw-vector.pkg
	package l  = label;					# label					is from   src/lib/compiler/backend/lower/instruction/label.pkg
	package an = note;					# note					is from   src/lib/src/note.pkg
	package cb = cells_basis;				# cells_basis				is from   src/lib/compiler/backend/lower/instruction/cells-basis.pkg
	package sl = cb::sorted_cells;
	package ht = int_hash_table;				# int_hash_table			is from   src/lib/src/int-hash-table.pkg
	package im = int_red_black_map;				# int_red_black_map			is from   src/lib/src/int-red-black-map.pkg

	Flowgraph = control_flow_graph::Control_Flow_Graph;
	An = an::Notes;

	name = "X86 floating point rewrite";

	x86_fp_debug_mode =  low_code_control::make_bool ("x86_fp_debug_mode", "x86 fp debug mode");
	x86_fp_trace_mode =  low_code_control::make_bool ("x86_fp_trace_mode", "x86 fp trace mode");

	fun error msg
	    =
	    lowcode_error_message::error("x86_floating_point_code_g", msg);

	fun pr msg
	    =
	    file::write (*low_code_control::debug_stream, msg);

	i2s = int::to_string;


        #####################################
	# No overflow checking is needed for
        # integer arithmetic in this module
        #####################################


	fun celllist_to_cellset l =  list::fold_right cb::cell_set::add cb::cell_set::empty l;
	fun celllist_to_string  l =  cb::cell_set::to_string (celllist_to_cellset l);

	# Annotation to mark split edges:
	# 
	exception TARGET_MOVED_TO  g::Node_Id;

	/*-----------------------------------------------------------------------
	 * Primitive instruction handling routines
	 *-----------------------------------------------------------------------*/

	# Annotate an instruction:
	#
	fun mark (instruction, []) => instruction;
	    mark (instruction, note ! notes) => mark (i::NOTE { instruction, note }, notes);
	end;

	# Add pop suffix to a binary operator:
	# 
	fun pop i::FADDL  => i::FADDP;   pop i::FADDS  => i::FADDP;
	    pop i::FSUBL  => i::FSUBP;   pop i::FSUBS  => i::FSUBP;
	    pop i::FSUBRL => i::FSUBRP;  pop i::FSUBRS => i::FSUBRP;
	    pop i::FMULL  => i::FMULP;   pop i::FMULS  => i::FMULP;
	    pop i::FDIVL  => i::FDIVP;   pop i::FDIVS  => i::FDIVP;
	    pop i::FDIVRL => i::FDIVRP;  pop i::FDIVRS => i::FDIVRP;
	    pop _ => error "fbinop::pop";
	end;

	# Invert the operator:
	#
	fun invert i::FADDL  => i::FADDL;   invert i::FADDS  => i::FADDS;
	    invert i::FSUBL  => i::FSUBRL;  invert i::FSUBS  => i::FSUBRS;
	    invert i::FSUBRL => i::FSUBL;   invert i::FSUBRS => i::FSUBS;
	    invert i::FMULL  => i::FMULL;   invert i::FMULS  => i::FMULS;
	    invert i::FDIVL  => i::FDIVRL;  invert i::FDIVS  => i::FDIVRS;
	    invert i::FDIVRL => i::FDIVL;   invert i::FDIVRS => i::FDIVS;
	    invert i::FADDP  => i::FADDP;   invert i::FMULP  => i::FMULP;
	    invert i::FSUBP  => i::FSUBRP;  invert i::FSUBRP => i::FSUBP;
	    invert i::FDIVP  => i::FDIVRP;  invert i::FDIVRP => i::FDIVP;
	    invert _ => error "invert";
	end;

	# Pseudo instructions:
	# 
	fun fld_fn (i::FP32, ea) => i::flds ea;
	    fld_fn (i::FP64, ea) => i::fldl ea;
	    fld_fn (i::FP80, ea) => i::fldt ea;
	end;

	fun fild_fn (i::INT8, ea) => error "FILD";
	    fild_fn (i::INT16, ea) => i::fild ea;
	    fild_fn (i::INT32, ea) => i::fildl ea;
	    fild_fn (i::INT64, ea) => i::fildll ea;
	end;

	fun fstp_fn (i::FP32, ea) => i::fstps ea;
	    fstp_fn (i::FP64, ea) => i::fstpl ea;
	    fstp_fn (i::FP80, ea) => i::fstpt ea;
	end;

	fun fst_fn (i::FP32, ea) => i::fsts ea;
	    fst_fn (i::FP64, ea) => i::fstl ea;
	    fst_fn (i::FP80, ea) => error "FSTT";
	end;

	# -----------------------------------------------------------------------
	# Prettyprint routines
	# -----------------------------------------------------------------------
	fun freg_to_string f
	    =
	    "%f" + i2s (cb::register_num f);

	fun fregs_to_string s
	    =
	    list::fold_right

		fn (r, "") =>  freg_to_string  r;  
		   (r,  s) =>  freg_to_string  r   + " " + s;
		end

		""

		s;


	fun blknum_of (control_flow_graph::BLOCK { id, ... } )
	    =
	    id; 

	# -----------------------------------------------------------------------
	# A stack enum that mimics the x86 floating point stack
	# and keeps track of namings between %st (n) and %fp (n).
	# -----------------------------------------------------------------------
	package st
	    :
	    api {
		Stack; 
		Stnum = Int; #  0 -- 7 
		create:  Void -> Stack;
		stack0:  Stack;
		copy:    Stack -> Stack;
		clear:   Stack -> Void;
		fp:      (Stack, cb::Register_Id) -> Stnum;
		st:      (Stack, Stnum) -> cb::Register_Id;
		set:     (Stack, Stnum, cb::Register_Id) -> Void; 
		push:    (Stack, cb::Register_Id) -> Void;
		xch:     (Stack, Stnum, Stnum) -> Void;
		pop:     Stack -> Void;
		depth:   Stack -> Int;
		non_full:  Stack -> Void;
		kill:    (Stack, cells_basis::Cell) -> Void;
		stack_to_string:  Stack -> String;
		equal:  (Stack, Stack) -> Bool; 
	    }
            = 
	    package {

		Stnum = Int;

		Stack =
		   STACK  
		   { st:   a::Rw_Vector( cb::Register_Id ),	# Mapping %st -> %fp registers 
		     fp:   a::Rw_Vector( Stnum ),    		# Mapping %fp -> %st registers 
		     sp:   Ref( Int )           		# Stack pointer.
		   }; 

	       # Create a new stack:
	       # 
	       fun create ()
		   =
		   STACK { st => a::make_rw_vector (8,-1),
			   fp => a::make_rw_vector (7, 16),
			   sp => REF -1
			 };

	       stack0 = create();

	       # Copy a stack:
	       # 
	       fun copy (STACK { st, fp, sp } )
		   = 
		   {   st' = a::make_rw_vector (8, -1);
		       fp' = a::make_rw_vector (7, 16);

		       a::copy { from=>st, to=>st', di=>0 };
		       a::copy { from=>fp, to=>fp', di=>0 };

		       STACK { st=>st', fp=>fp', sp=>REF *sp };
		   };

	       # Depth of stack:
	       #
	       fun depth (STACK { sp, ... } )
		   =
		   *sp + 1;

	       fun non_full (STACK { sp, ... } )
		   = 
		   if   (*sp >= 7)   error "stack overflow";   fi;

		#  Given %st (n), lookup the corresponding %fp (n) 
		#
		fun st (STACK { st, sp, ... }, n)
		    =
		    a::get (st, *sp - n);

	       # Given %fp (n), lookup the corresponding %st (n)
	       # 
	       fun fp (STACK { fp, sp, ... }, n)
		   =
		   *sp - a::get (fp, n);

	       fun stack_to_string stack
		   = 
		   {   depth = depth stack;

		       fun f i
			   =
			   if   (i >= depth   )   " ]";
			   else                   "%st(" + i2s i + ")=%f" + i2s (st (stack, i)) + " " + f (i+1);
                           fi;

		       "[ " + f 0;
		   };

	       fun clear (STACK { st, fp, sp, ... } )
		   = 
		   {   sp := -1;

		       a::modify (fn _ = -1) st;
		       a::modify (fn _ = 16) fp;
		   };

	       # Set %st (n) := %f
	       # 
	       fun set (STACK { st, fp, sp, ... }, n, f)
		   = 
		   {   a::set (st, *sp - n, f);

		       if (f >= 0)   a::set (fp, f, *sp - n);   fi;
		   };

	       # Pop one entry:
	       #
	       fun pop (STACK { sp, st, fp, ... } )
		   =
		   sp := *sp - 1;

	       # Push %fp (f) onto %st (0)
	       #
	       fun push (stack as STACK { sp, ... }, f)
		   =
		   {   sp := *sp + 1;
		       set (stack, 0, f);
		   };

	       # Exchange the contents of %st (m) and %st (n):
	       #
	       fun xch (stack, m, n)
		   = 
		   {   f_m = st (stack, m);
		       f_n = st (stack, n);

		       set (stack, m, f_n);
		       set (stack, n, f_m);
		   };

	       fun kill (STACK { fp, ... }, f)
		   =
		   a::set (fp, cb::register_num f, 16);

	       fun equal (st1, st2)
		   =
		   {   m = depth st1;
		       n = depth st2;

		       fun loop i
			   = 
			   i >= m
			   or
			   (    st (st1, i) == st (st2, i)
				and
				loop (i+1)
			   );

		       m == n
		       and
		       loop 0; 
		   };

	    };				# pkg st

	# -----------------------------------------------------------------------
	# Module to handle forward propagation.  
	# Forward propagation does the following:
	# Given an instruction
	#   fmove mem, %fp (n)
	# We delay the generation of the load until the first use of %fp (n), 
	# which we can further optimize by folding the load into the operand
	# of the instruction, if it is the last use of this operand.
	# If %fp (n) is dead then no load is necessary. 
	# Of course, we have to be careful whenever we encounter other
	# instruction with a write.
	# -----------------------------------------------------------------------*)
	/*
	package ForwardPropagation :>
	api
	   type readbuffer 
	   my create:  st::stack -> readbuffer
	   my load:    readbuffer * c::cell * i::fsize * i::ea -> Void
	   my getreg:  readbuffer * Bool * c::cell * List( i::instruction ) -> 
			     i::operand * List( i::instruction )
	   my flush:   readbuffer * List( i::instruction ) -> List( i::instruction )
	end =
	pkg

	   enum readbuffer =
	      READ of { stack:     st::stack,
			loads:      a::Rw_Vector( Null_Or( i::fsize * i::ea ) ),
			pending:   Ref( Int )
		      }

	   fun create stack = 
	       READ { stack   =stack, 
		    loads   =a::make_rw_vector (8, NULL),
		    pending =REF 0
		   }

	   fun load (READ { pending, loads, ... }, fd, fsize, mem) = 
	       (a::set (loads, fd, THE (fsize, mem));
		pending := *pending + 1
	       )

	   /* Extract the operand for a register 
	    * If it has a delayed load associated with it then
	    * we perform the load at this time. 
	    */
	   fun getreg (READ { pending, loads, stack, ... }, isLastUse, fs, code) = 
	       case a::get (loads, fs) of
		 NULL => 
		 let n = st::st (stack, fs)
		 in  if isLastUse 
		     then (ST n, code)
		     else let code = i::FLDL (ST n) ! code
			  in  st::push (stack, fs); (ST0, code)
			  end
		 end
	       | THE (fsize, mem) =>
		 let code = fld_fn (fsize, mem) ! code
		 in  a::set (loads, fs, NULL); #  Delete load 
		     pending := *pending - 1;
		     st::push (stack, fs);        #  fs is now in place 
		     (ST0, code)
		 end

	   /* Extract a binary operand.
	    * We'll try to fold this into the operand
	    */
	   fun getopnd (READ { pending, loads, stack, ... }, isLastUse, i::FPR fs, code) =
	       (case a::get (loads, fs) of
		 NULL => 
		 let n = st::st (stack, fs)
		 in  if isLastUse fs #  regmap XXX 
		     then (ST n, code)
		     else let code = i::FLDL (ST n) ! code
			  in  st::push (stack, fs); (ST0, code)
			  end
		 end
	       | THE (fsize, mem) =>
		  (a::set (loads, fs, NULL); #  Delete load 
		   pending := *pending - 1;
		   if isLastUse fs then (mem, code)
		   else let code = fld_fn (fsize, mem) ! code
			in  st::push (stack, fs);
			    (ST0, code)
			end
		  )
	       )
	     | getopnd(_, _, ea, code) = (ea, code)

	   fun flush (READ { pending=REF 0, ... }, code) = code

	end #  pkg 
	 */    

	# -----------------------------------------------------------------------
	# Module to handle delayed stores.  
	# Delayed store does the following:
	# Given an instruction
	#   fstore %fp (n), %mem
	# We delay the generation of the store until necessary.
	# This gives us an opportunity to rearrange the order of the stores
	# to eliminate unnecessary fxch.
	# -----------------------------------------------------------------------
	/*
	package DelayStore :>
	api
	   type writebuffer 
	   my create:  st::stack -> writebuffer
	   my flush:  writebuffer *  List( i::instruction ) -> List( i::instruction )
	end =
	pkg
	   enum writebuffer =
	      WRITE of { front:    Ref( List (i::ea * c::cell) ),
			 back:     Ref( List (i::ea * c::cell) ),
			 stack:    st::stack,
			 pending:  Ref( Int )
		       }
	   fun create stack = WRITE { front=REF [], back=REF [], 
				    stack=stack, pending=REF 0 }
	   fun flush (WRITE { pending=REF 0, ... }, code) = code
	end #  pkg 
	*/

	# -----------------------------------------------------------------------
	# Main routine.
	# 
	# Algorithm:
	#  1. Perform liveness analysis.
	#  2. For each fp register, mark all its last use point (s).
	#     Registers are popped at their last uses.  
	#  3. Rewrite the instructions basic block by basic block.
	#  4. Insert shuffle code at basic block boundaries. 
	#     When necessary, split critical edges.
	#  5. Sacrifice a goat to make sure things don't go wrong.
	# -----------------------------------------------------------------------
	fun run (cfg' as g::GRAPH cfg)
	    = 
	    {
		number_of_blks = cfg.capacity ();

		entry_i        = list::head (cfg.entries ());
		exit_i         = list::head (cfg.exits   ());

		get_cell = c::get_cells_by_kind cb::FLOAT_REGISTER; 
			  # extract the fp component of cellset

		st_table = a::tabulate (8, fn n = i::ST (c::st n));

		fun st_fn n
                    =
                    {   if (sanity_check and (n < 0 or n >= 8))
			       pr("WARNING BAD %st(" + i2s n + ")\n");
			fi;

			a::get (st_table, n);
		    };

		fun fxch_fn n
		    =
		    i::fxch { operand=>c::st n }; 

		st0 = st_fn 0; 
		st1 = st_fn 1;
		pop_st = i::fstpl st0; #  Instruction to pop an entry 

		# Dump instructions:
		#
		fun dump instrs
		    =
		    {   my asm::instruction_stream::STREAM { emit, ... }
			    = 
			    asm_stream::with_stream *low_code_control::debug_stream
			      asm::make_stream [];

			apply emit (reverse instrs);
		    }; 

		# Create assembly of instruction 
		#
		fun assemble instruction
		    = 
		    {   buf = string_out_stream::make_stream_buf();
			stream = string_out_stream::open_string_out buf;

			my asm::instruction_stream::STREAM { emit, ... }
                            = 
			    asm_stream::with_stream stream asm::make_stream [];

			emit instruction;

			s = string_out_stream::get_string buf;
			n = string::length s;

			if (n == 0)    s;
                        else           string::substring (s, 0, n - 1);
                        fi;
		    };

		# ------------------------------------------------------------------ 
		# Perform liveness analysis on the floating point variables
		# p::S. I'm glad I didn't throw away the code liveness code.
		# ------------------------------------------------------------------

		def_use = p::def_use cb::FLOAT_REGISTER;   #  Def/use properties 

		my { live_in=>live_in_table, live_out=>live_out_table }
                    =
                    liveness::liveness {
			 def_use,
			 #  updateCell=c::updateCellsByKind cb::FLOAT_REGISTER, 
			 get_cell
		       } cfg';

		# ------------------------------------------------------------------
		# Scan the instructions compute the last uses and dead definitions
		# at each program point.  Ideally we can do this during the code 
		# rewriting phase. But that's probably too error prone for now.
		# ------------------------------------------------------------------
		fun compute_last_use (blknum, instructions, live_out)
		    = 
		    {   fun scan ([], _, last_use)
                                =>
                                last_use;

			    scan (i ! instrs, live, last_use)
				=> 
				{   my (d, u)  = def_use i;  
				    d       = sl::uniq (d);#  Definitions 
				    u       = sl::uniq (u);#  uses 
				    dead    = sl::return (sl::difference (d, live));
				    live    = sl::difference (live, d);
				    last    = sl::return (sl::difference (u, live));
				    live    = sl::union (live, u);

				    if (debug and debug_liveness)
					case last   
					    [] => ();
					    _  => print (assemble i + "\tlast use=" + 
						    fregs_to_string last + "\n");
					esac;
				    fi;

				    scan (instrs, live, (last, dead) ! last_use);
				};
                        end;

			live_out_set = sl::uniq live_out;

			if (debug and debug_liveness) 
			    print("LiveOut(" + i2s blknum + ") = " + 
			    fregs_to_string (sl::return live_out_set) + "\n");
			fi;

			scan (*instructions, live_out_set, []);
		    };

		# ------------------------------------------------------------------ 
		# Temporary work space 
		# ------------------------------------------------------------------
		my { high, low }
                    =
                    c::cell_range cb::FLOAT_REGISTER;

		n = high+1;

		last_use_table  = a::make_rw_vector (n,-1);	# Table for marking last uses.
		use_table       = a::make_rw_vector (n,-1);	# Table for marking uses.

		#  %fp register namings before and after a basic block 
		#
		namings_in  = a::make_rw_vector (number_of_blks, NULL);
		namings_out = a::make_rw_vector (number_of_blks, NULL);

		stamp_counter = REF -4096;

		# Edges that need splitting:
		#
		exception NO_EDGES_TO_SPLIT;

		edges_to_split    = int_hash_table::make_table (32, NO_EDGES_TO_SPLIT);

		add_edges_to_split = int_hash_table::set edges_to_split;

		fun lookup_edges_to_split b
                    = 
		    the_else (int_hash_table::find edges_to_split b, []);

		# ------------------------------------------------------------------ 
		# Code for handling namings between basic block
		# ------------------------------------------------------------------

		fun split_edge (title, source, target, e)
                    =
		    {   if (debug and *x86_fp_trace_mode)
		            pr (title + " SPLITTING " + i2s source + "->" +  i2s target + "\n");
		        fi;

		        add_edges_to_split (target, (source, target, e) ! lookup_edges_to_split target);
		   };

		fun compute_freq (_, _, control_flow_graph::EDGE { weight, ... } )
                    =
                    *weight;

		# Given a cellset, return a sorted and unique 
		# list of elements with all non-physical registers removed
		#
		fun remove_non_physical celllist
		    = 
		    loop (celllist, [])
                    where
		        fun loop ([], sss)
                                =>
                                sl::return (sl::uniq sss);

			    loop (f ! fs, sss)
				=> 
				{   fx = cb::register_num f; 
				    loop (fs, if (fx <= 7) f ! sss; else sss;fi);
				};
                        end;
		    end;

		# Given a sorted and unique list of registers,
		# Return a stack with these elements
		#
		fun new_stack fregs
		    =
		    {   stack = st::create();

		        apply (fn f = st::push (stack, cb::register_num f))
                              (reverse fregs);

			stack;
		    };


		# This function looks at all the entries on the stack,  
		# and generate code to deallocate all the dead values. 
		# The stack is updated.
		#
		fun remove_dead_values (stack, live_set, code)
		    = 
		    loop (0, st::depth stack, code)
		    where

			stamp = *stamp_counter;

			stamp_counter := *stamp_counter - 1;

			fun mark_live []
                                =>
                                ();

			    mark_live (r ! rs)
                                => 
			        {   a::set (use_table, cb::register_num r, stamp);
                                    mark_live rs;
                                };
			end;

			fun is_live f
			    =
			    a::get (use_table, f)   ==   stamp;

			fun loop (i, depth, code)
			    = 
			    if (i >= depth)

				 code;
			    else 
				  f = st::st (stack, i);

				  if (is_live f)			 #  live? 

				       loop (i+1, depth, code);
				  else 
				       if (debug and *x86_fp_trace_mode)

					   pr("REMOVING %f" + i2s f + " in %st(" + i2s i + ")" + 
					    " current stack=" + st::stack_to_string stack + "\n");
				       fi;

				       if (i == 0) 

					   st::pop stack;
					   loop (0, depth - 1, pop_st ! code);
				       else
					   st::xch (stack, 0, i);
					   st::pop stack;
					   loop (0, depth - 1, i::fstpl (st_fn i) ! code);
				       fi;
				  fi;
			    fi;

			mark_live live_set;
		    end;


		# ------------------------------------------------------------------ 
		# Given two stacks, source and target, where the namings are
		# permutation of each other, generate the minimal number of
		# fxchs to match source with target.
		#
		# Important: source and target MUST be permutations of each other.
		#
		# Essentially, we first decompose the permutation into cycles, 
		# and process each cycle.
		# ------------------------------------------------------------------
		#
		fun shuffle (source, target, code)
		    = 
		    {   stamp = *stamp_counter;
			stamp_counter := *stamp_counter - 1;
			permutation = last_use_table; /* reuse the space */ 

			if (debug and *x86_fp_trace_mode)
				      pr("Shuffle " + st::stack_to_string source + 
					       "->" + st::stack_to_string target + "\n");
			fi;

			#  Compute the initial permutation 
			#
			n = st::depth source;
			#
			fun compute_initial_permutation (i)
			    = 
			    if (i < n)

			       f =  st::st (source, i);
			       j =  st::fp (target, f);

			       a::set (permutation, j, i);

			       compute_initial_permutation (i+1);
			    fi;

			compute_initial_permutation 0;

			# Decompose the initial permutation into cycles.
			# The cycle involving 0 is treated specially.

			visited = use_table;

			fun is_visited i
			    =
			    a::get (visited, i) == stamp;


			fun mark_as_visited i
			    =
			    a::set (visited, i, stamp);

			fun decompose_cycles (i, cycle0, cycles)
			    = 
			    if (i >= n)

                                 (cycle0, cycles);

			    elif (is_visited i  or  a::get (permutation, i) == i)		 #  trivial cycle 

				 decompose_cycles (i+1, cycle0, cycles);
			    else
				fun make_cycle (j, cycle, zero)
				     = 
				     {   k = a::get (permutation, j);
					 cycle = j ! cycle;
					 zero  = zero or j == 0;
					 mark_as_visited j;

					 if (k == i)  (cycle, zero);
					 else         make_cycle (k, cycle, zero);
                                         fi;
				    };

				my (cycle, zero)
                                    =
                                    make_cycle (i, [], FALSE);

				zero
				  ?? decompose_cycles (i+1, [cycle],        cycles)
				  :: decompose_cycles (i+1, cycle0, cycle ! cycles);
			    fi;

			my (cycle0, cycles)
                            =
                            decompose_cycles (0, [], []); 


			# Generate shuffle for a cycle that does not involve 0.
			# Given a cycle (c_1, ..., c_k), we generate this code:
			#  fxch %st (c_1), 
			#  fxch %st (c_2), 
			#  ...
			#  fxch %st (c_k), 
			#  fxch %st (c_1) 
			#
			fun genxch ([], code) => code;
			    genxch (c ! cs, code) => genxch (cs, fxch_fn c ! code);
                        end;

			fun gen ([], code) => error "shuffle::gen";
			    gen (cs as (c ! _), code) => fxch_fn c ! genxch (cs, code);
                        end;


			# Generate shuffle for a cycle that involves 0.
			# Given a cycle (c_1, ..., c_k) we first shuffle this to
			# an equivalent cycle (c_1, ..., c_k) where c'_k = 0, 
			# then we generate this code:
			#  fxch %st (c'_1), 
			#  fxch %st (c'_2), 
			#  ...
			#  fxch %st (c'_{ k - 1 } ), 
			#
			fun gen0 ([], code)
                                =>
                                error "shuffle::gen0";

			    gen0 (cs, code)
				=> 
				{   fun rearrange (0 ! cs, cs') =>  cs@reverse cs';
				        rearrange (c ! cs, cs') =>  rearrange (cs, c ! cs');
				        rearrange ([], _)       =>  error "shuffle::rearrange";
                                    end;

				    cs = rearrange (cs, []);
				    genxch (cs, code);
				};
                        end;

			# Generate code.  Must process
                        # the non-zero cycles first:
			#
			code = list::fold_right gen code cycles;
			code = list::fold_right gen0 code cycle0;

		        code;
		    };				# fun shuffle 

		/*------------------------------------------------------------------ 
		 * Insert code at the end of a basic block.
		 * Make sure we put code in front of a transfer instruction 
		 *------------------------------------------------------------------*/ 
		fun insert_at_end (instructions, code)
                    = 
		    case instructions   

		       [] => code;

		       jmp ! rest
                           => 
		           p::instruction_kind jmp == p::IK_JUMP
			       ??  jmp ! code@rest
			       ::  code@instructions;
                    esac;

		/*------------------------------------------------------------------ 
		 * Magic for inserting shuffle code at the end of a basic block
		 *------------------------------------------------------------------*/ 
		fun shuffle_out (stack_out, instructions, b, block, live_out)
		    = 
		    { 
			live_out = remove_non_physical (live_out);

			# Generate code that removes
                        # unnecessary values:
			# 
			code = remove_dead_values (stack_out, live_out, []); 

			fun done (stack_out, instructions, code)
                            =
			    {   a::set (namings_out, b, THE stack_out);
			        insert_at_end (instructions, code);
			    };

			# Generate code that shuffles values
                        # from source to target:
			#
			fun match (source, target)
                            = 
			    done (target, instructions, shuffle (source, target, []));

			# Generate code that shuffles
                        # values from source to live_out:
			#
			fun match_live_out ()
                            =
			    case live_out   
				[] =>  done  (stack_out, instructions, code);
				_  =>  match (stack_out, new_stack live_out);
                            esac; 

			# With multiple successors, decide
                        # which one to connect to. We choose
                        # the one from the block that follows
                        # from this one, if that exists, or
                        # else the edge with the highest frequency:
			#
			fun find ([], _, id, best)
				=>
				(id, best);

			    find((_, target, _) ! edges, highest_freq, id, best)
				=> 
				{   my control_flow_graph::BLOCK { freq, ... } = cfg.node_info target;

				    if   (target == b+1)

					 (target, a::get (namings_in, target));
				    else
					 case (a::get (namings_in, target))   

					     NULL => find (edges, highest_freq, id, best);

					     this as THE stack
						 => 
						 if   (highest_freq < *freq)
						      find (edges, *freq, target, this);
						 else find (edges, highest_freq, id, best);
						 fi;
					 esac;
				    fi;
				};
			end;

			# Split all edges source->target
                        # except omit_this:
			#
			fun split_all_edges_except ([], omit_this)
                                =>
                                ();

			    split_all_edges_except((source, target, e) ! edges, omit_this)
				=> 
				if (target == exit_i)
				     error "can't split exit edge!";
				else
				    if (   target != omit_this
				       and target <= b          #  XXX
				       and target != entry_i
				       )
					 split_edge("ShuffleOut", source, target, e);
				    fi;

				    split_all_edges_except (edges, omit_this);
				fi;
			  end;

			# Just one successor.
			# Try to match the namings of
                        # the successor if it exists:
			#
			fun match_it next
			    = 
			    {   my (succ_block, target)
                                    =
                                    find (next, -1.0, -1, NULL); 

			        split_all_edges_except (next, succ_block);

				case target   
				    THE stack_in => match (stack_out, stack_in);
				    NULL         => done  (stack_out, instructions, code);
                                esac;
			    };

		        case (cfg.out_edges b)   

			    [] => match_live_out();

			    next as [(_, target, _)]
                                => 
				target == exit_i
                                  ??  match_live_out ()
				  ::  match_it next;

			    next =>
                                match_it next;
                        esac; 
		    };				# fun shuffle_out 

		# ------------------------------------------------------------------ 
		# Compute the initial fp stack namings for basic block b.
		# ------------------------------------------------------------------
		fun shuffle_in (b, block, live_in)
		    = 
		    { 
			live_in_set = remove_non_physical live_in;

			# With multiple predecessors, find out which one we
			# should connect to.   Choose the one from the block that
			# falls into this one, if that exists, or else choose
			# from the edge with the highest frequency.
			#
			fun find ([], _, best)
                                =>
                                best;

			    find ((source, _, _) ! edges, highest_freq, best)
				=> 
				{   my control_flow_graph::BLOCK { freq, ... }
                                        =
                                        cfg.node_info source;

				    case (a::get (namings_out, source))   

					NULL =>
					    find (edges, highest_freq, best);

					this as THE stack
					    => 
					    if (source == b - 1)         this;				# Falls into b. 
					    elif (highest_freq < *freq ) find (edges, *freq, this);
					    else                         find (edges, highest_freq, best);
					    fi;
				    esac;
				};
			end;

			fun split_all_done_edges []
                                =>
                                ();

			    split_all_done_edges ((source, target, e) ! edges)
				=> 
				{   if (   source < b
				       and source != entry_i
				       and source != exit_i
				       )

					split_edge("ShuffleIn", source, target, e);
				    fi;

				   split_all_done_edges edges;
			       };
			end;

			# The initial stack namings are
                        # determined by the live set. 
			# No compensation code is needed.
			#
			fun from_live_in ()
			    =
			    {   stack_in
                                    = 
				    case live_in_set   

				        [] => st::stack0;

				        _  => {   pr("liveIn=" + celllist_to_string live_in + "\n");
				                  new_stack live_in_set ;
				              };
                                    esac;

				stack_out = st::copy stack_in;

			        (stack_in, stack_out, []);
			    };

			prior = cfg.in_edges b; 

			my (stack_in, stack_out, code)
                            =
			    case (find (prior, -1.0, NULL))   

			        NULL =>
                                    {   split_all_done_edges  prior;
                                        from_live_in ();
                                    };

			        THE stack_in'
                                    => 
				    case prior   

				        [_] =>
					    {	# One predecessor.
 
				                # Use the namings as from the previous block 
				                # We first have to deallocate all unused values.
				                #
				                stack_out = st::copy stack_in';

					        # Clean the stack of unused entries:
						#
					        code = remove_dead_values (stack_out, live_in_set, []);

					        (stack_in', stack_out, code);
                                            };

				        prior =>
				            {   # More than one predecessor.

                                                stack_in  =  st::copy stack_in';
					        code      =  remove_dead_values (stack_in, live_in_set, []);
					        stack_out =  st::copy stack_in;

					        # If we have to generate code to deallocate
					        # the stack then we have split the edge:
					        #
					        case code   
					            [] => ();
					            _  => split_all_done_edges (prior);
                                                esac;

					        (stack_in, stack_out, []); 
				            };
                                     esac;

                            esac;

		        a::set (namings_in,  b, THE stack_in );
			a::set (namings_out, b, THE stack_out);

			(stack_in, stack_out, code);
		    };  

		# ------------------------------------------------------------------ 
		# Code for patching up critical edges.
		# The trick is finding a good place to insert the critical edges.
		# Let's call an edge x->y that requires compensation 
		# code c to be inserted an candidate edge.  We write this as x->y (c)
		#
		# Here are the heuristics that we use to improve the final code:
		#
		#    1. Given two candidate edges a->x (c1) and b->x (c2) where c1=c2
		#       then we can merge the two copies of compensation code.
		#       This is quite common.  This generalizes to any number of edges.
		#
		#    2. Given two candidate edges a->x (c1) and b->x (c2) and where
		#       c1 and c2 are pops, we can partially share c1 and c2.
		#       Currently, I think I only recognize this case when
		#       x has no fp registers live-in.  
		#
		#    3. Given two candidate edges a->x (c1) and b->x (c2), 
		#       if a->x has a higher frequency then put the compensation
		#       code in front of x (so that it falls through into x)
		#       whenever possible.
		# 
		# As you can see, the voodoo is strong here. 
		#
		# The routine has two main phases:
		#    1. Determine the compensation code by applying the heuristics
		#       above.
		#    2. Then insert them and rebuild the cfg by renaming all block
		#       ids.  This is currently necessary to keep the layout order
		#       consistent with the order of the id.
		# ------------------------------------------------------------------

		fun repair_critical_edges (cfg' as g::GRAPH cfg)
		    =
		    { 
			cleanup  = [lowcode_notes::comment.create "cleanup edge" ];
			critical = [lowcode_notes::comment.create "critical edge"];

			fun annotate (gen, an)
			    =
			    apply (fn ((_, control_flow_graph::BLOCK { notes, ... } ), _)
				      =
				      notes := an
				  )
				  gen;


			# Special case: target block has stack depth of 0.
			# Just generate code that pop entries from the sources. 
			# To make things interesting, we try to share code among
			# all the critical edges.
			#	
			fun gen_popping_code (_, [])
				=>
				();

			    gen_popping_code (target_id, edges)
				=>
				{   # Edges annotated with the source stack depth 
				    # Ordered by increasing stack height 
				    #
				    edges
					= 
					im::keyvals_list
					    (fold_right
						(fn (edge as (source_id, _, _), mmm)
						    =
						    {   n = st::depth (the (a::get (namings_out, source_id)));
							im::set (mmm, n, edge ! the_else (im::get (mmm, n), [])); 
						    }
						)
						im::empty
						edges
					    );

				    # Generate n pops:
				    #
				    fun pops (0, code) =>  code;
					pops (n, code) =>  pops (n - 1, pop_st ! code);
				    end;

				    # Create the chain of blocks:
				    #
				    fun make_chain (depth, [], chain)
					    =>
					    chain;

					make_chain (depth, (d, es) ! es', chain)
					    =>
					    {   code = pops (d - depth, []);
						make_chain (d, es', (es, code) ! chain);
					    };
				    end;

				    chain = make_chain (0, edges, []);

				    annotate
				      ( control_flow_graph::split_edges
					    cfg'
					    { groups => chain,
					      jump   => FALSE
					    },
					    cleanup
				      );
				};
			end;

			# Generate repair code.
			#
			fun gen_repair_code (target_id, stack_in, edges)
			    =
			    {   live_in = int_hash_table::get  live_in_table  target_id;
				live_in_set = remove_non_physical live_in;

				if debug   pr("LiveIn = " + celllist_to_string live_in + "\n");   fi;

				# Group all edges whose output stack configurations
				# are the same.  Each group is merged together into
				# a single compensation block
				#
				fun partition ([], s)
					=>
					s;

				    partition((e as (src, _, _)) ! es, s)
					=>
					find (s, [])
					where
					    stack_out = st::copy (the (a::get (namings_out, src)));

					    fun find ([], s)
						    =>
						    partition (es, ([e], stack_out) ! s);

						find((x as (es', st')) ! s', s)
						    =>
						    if (st::equal (stack_out, st')) 
						        partition (es, (e ! es', st') ! s' @ s);
						    else
						        find (s', x ! s);
						    fi;
					    end;
					end;
				end;

				# Partition by the source namings:
				#
				sss = partition (edges, []);

				# Compute frequencies 
				#
				sss =   map (fn (es, st)
                                                =
                                                (control_flow_graph::sum_edge_freqs es, es, st)
                                            )
					    sss;

				# Order by non-increasing frequencies:
				#
				sss = list_mergesort::sort
					  (fn ((x, _, _), (y, _, _)) =  x < y)
					  sss;

				# Generate code:
				# 
				fun gen (freq, edges, stack_out)
				    =
				    {   # Deallocate unused values:
					# 
					code = remove_dead_values (stack_out, live_in_set,[]);

					# Shuffle values:
					#	
					code = shuffle (stack_out, stack_in, code);

					annotate(
					     control_flow_graph::split_edges cfg' { groups => [(edges, code)], jump => FALSE },
						   critical);
				    };

				apply gen sss;
			    };

			# Split all edges entering target_id:
			#
			fun split (target_id, edges)
			    = 
			    {   stack_in = the (a::get (namings_in, target_id));

				fun log (s, t, e)
				    =
				    case (a::get (namings_out, s))

					 THE stack_out
					     =>
					     pr ("SPLIT " + i2s s + "->" + i2s t + " " + 
						 st::stack_to_string stack_out + "->" + 
						 st::stack_to_string stack_in + "\n"
						);

					 NULL => error "split: stack_out";
				    esac;

				if (debug and *x86_fp_trace_mode)   apply log edges;   fi;

				st::depth stack_in == 0
				  ??  gen_popping_code (target_id, edges)
				  ::  gen_repair_code  (target_id, stack_in, edges);
			    };

			int_hash_table::keyed_apply split edges_to_split;

			control_flow_graph::mark_as_changed cfg';

			cfg';
		    }; 

		/*------------------------------------------------------------------ 
		 * Process all blocks which are not the entry or the exit
		 *------------------------------------------------------------------*/
		stamp = REF 0;

		fun rewrite_all_blocks (_, control_flow_graph::BLOCK { kind=>control_flow_graph::START, ... } ) =>  ();
		    rewrite_all_blocks (_, control_flow_graph::BLOCK { kind=>control_flow_graph::STOP,  ... } ) =>  ();

		    rewrite_all_blocks (blknum, block as control_flow_graph::BLOCK { instructions, labels, notes, ... } )
			=>
			{ 
			    if (debug and *x86_fp_debug_mode) 

				apply  (fn l = pr (l::to_string l + ":\n"))
                                       *labels;
			    fi;

			    live_in  = ht::get  live_in_table   blknum;
			    live_out = ht::get  live_out_table  blknum;

			    st = rewrite ( *stamp, blknum, block, 
					   instructions, live_in, live_out, 
					   notes
                                         );

			    stamp := st;		# Update stamp.
			};
		end 

		# ------------------------------------------------------------------ 
		# Translate code within a basic block.
		# Each instruction is given a unique stamp for identifying last
		# uses.
		# ------------------------------------------------------------------
		also
		fun rewrite (stamp, blknum, block, instructions, live_in, live_out, notes)
		    = 
		    {   my (stack_in, stack, code)
			    =
			    shuffle_in (blknum, block, live_in);

			# Dump instructions when encountering a bug:
			#
			fun bug msg
			    = 
			    {   pr("-------- bug in block " + i2s blknum + " ----\n");
				dump *instructions;
				error msg;
			    };

			fun loop (stamp, [], [], code)
				=>
				(stamp, code);

			    loop (stamp, instruction ! rest, (last_use, dead) ! last_uses, code)
				=> 
				{   fun mark (table, [])
                                            =>
                                            ();

				        mark (table, r ! rs)
                                            => 
					    {   a::set (table, cb::register_num r, stamp);
                                                mark (table, rs);
                                            };
                                    end;

				    mark (last_use_table, last_use); #  mark all last uses 

				    trans (stamp, instruction, [], rest, dead, last_uses, code); 
				};

			    loop _ => error "loop";
			end 


			# Main routine that does the actual translation. 
			# A few reminders:
			#  o  The instructions are processed in normal order
			#     and generated in the reversed order.
			#  o  (Local) liveness is computed at the same time.
			#  o  For each use, we have to find out whether it is
			#     the last use.  If so, we can kill it and reclaim
			#     the stack entry at the same time. 
			#
			also
			fun trans (stamp, instruction, an, rest, dead, last_uses, code)
			    =
			    {   # Call this fate when
                                # done with code generation:
				# 
				fun finish_fn code
				    =
				    loop (stamp+1, rest, last_uses, code); 

				fun kill_the_dead (dead, code)
				    =
				    kill (dead, code)
                                    where
				        fun kill ([], code)
						=>
						finish_fn code;

					    kill (f ! fs, code)
						=> 
						{   fx = cb::register_num f; 

						    if (debug and debug_dead )
						       pr("DEAD " + freg_to_string f + " in " + 
							  st::stack_to_string stack + "\n");
						    fi;

						    #  not a physical register 
						    if (fx >= 8 )
							kill (fs, code);
						    else
							i = st::fp (stack, fx);

							if (debug and debug_dead )
							    pr("KILLING " + freg_to_string f + 
							       "=%st(" + i2s i + ")\n");
							fi;

							if (i < 0 )
							     kill (fs, code); #  Dead already 
							elif (i == 0) 
							     st::pop stack;
							     kill (fs, pop_st ! code);
							else 
							     st::xch (stack, 0, i); st::pop stack;
							     kill (fs, i::fstpl (st_fn i) ! code);
							fi;
						    fi;
						};
					end;			# fun kill
				    end;			# where (fun kill_the_dead)

				# Call this fate when
                                # done with floating point 
				# code generation.  Remove all
                                # dead code first:
				#
				fun done_fn code
				    =
				    kill_the_dead (dead, code);

				# Is this the last use
                                # of register f? 
				#
				fun is_last_use f
				    =
				    a::get (last_use_table, f) == stamp;

				# Is this value dead?
				#
				fun is_dead f
				    = 
				    loop dead
				    where
					fun loop [] => FALSE;
					    loop (r ! rs) => cb::same_color (f, r) or loop rs;
					end;
				    end;

				# Dump the stack before each intruction for debugging:
				#
				fun log ()
				    =
				    if (debug   and   *x86_fp_trace_mode)

					 pr (st::stack_to_string stack + assemble instruction + "...\n");
				    fi;

				# Find the location of a source register:
				#
				fun getfs (f)
				    = 
				    {   fx = cb::register_num f; 
					s  = st::fp (stack, fx); 

					(is_last_use fx,  s);
				    };

				#  Generate memory to memory move:
				#
				fun mmmove (fsize, src, dst)
				    =
				    {   st::non_full stack;
					code = fld_fn (fsize, src) ! code;
					code = mark (fstp_fn (fsize, dst), an) ! code;
					done_fn code;
				    };

				#  Allocate a new register in %st (0):
				#
				fun alloc (f, code)
				    =
				    {   st::push (stack, cb::register_num f);
					code;
				    };

				# register -> register move
				#
				fun rrmove (fs, fd)
				    = 
				    if (cb::same_color (fs, fd) ) done_fn code; 
				    else
					 my (dead, ss) = getfs fs; 

					 if dead

					      # fs is dead.
						 
					      st::set (stack, ss, cb::register_num fd);		# Rename fd to fs.
					      done_fn code;					# No code is generated.

					 else
                                              # fs is not dead; push it onto %st (0);
					      # set fd to %st (0) 

					      code = alloc (fd, code); 
					      done_fn (mark (i::fldl (st_fn ss), an) ! code);
					 fi;
				    fi;

				# memory -> register move.
				# Do dead code elimination here.
				#
				fun mrmove (fsize, src, fd)
				    = 
				    if   (is_dead fd )

					 finish_fn code;		#  value has been killed 
				    else 
					 code = alloc (fd, code); 
					 done_fn (mark (fld_fn (fsize, src), an) ! code);
				    fi; 

				# Exchange %st (n) and %st (0):
				#
				fun xch n
				    =
				    {   st::xch (stack, 0, n);
					fxch_fn n;
				    };

				# Push %st (n) onto the stack:
				#
				fun push n
				    =
				    {   st::push (stack,-2);
					i::fldl (st_fn n);
				    };


				# Push mem onto the stack:
				#
				fun pushmem src
				    =
				    {   st::push (stack,-2);
					i::fldl (src);
				    };

				# register -> memory move.
				# Use pop version of the opcode
                                # if it is the last use:
				#
				fun rmmove (fsize, fs, dst)
				    = 
				    {   fun fstp code
					    = 
					    {   st::pop stack;
						done_fn (mark (fstp_fn (fsize, dst), an) ! code);
					    };

					fun fst code
					    =
					    done_fn (mark (fst_fn (fsize, dst), an) ! code);

					case (getfs fs)
					    (TRUE,  0) =>  fstp code;
					    (TRUE,  n) =>  fstp (xch n ! code);
					    (FALSE, 0) =>  fst (code); 
					    (FALSE, n) =>  fst (xch n ! code);
					esac;
				    };

				# Floating point move:
				#
				fun fmove { fsize, src=>i::FPR fs, dst=>i::FPR fd } =>  rrmove (fs, fd);
				    fmove { fsize, src, dst=>i::FPR fd }            =>  mrmove (fsize, src, fd);
				    fmove { fsize, src=>i::FPR fs, dst }            =>  rmmove (fsize, fs, dst);
				    fmove { fsize, src, dst }                       =>  mmmove (fsize, src, dst);
				end;

				# Floating point integer load operator:
				#
				fun fiload { isize, ea, dst=>i::FPR fd }
					=> 
					{   code = alloc (fd, code); 
					    code = mark (fild_fn (isize, ea), an) ! code;
					    done_fn code;
					};

				    fiload { isize, ea, dst }
					=> 
					{   code = mark (fild_fn (isize, ea), an) ! code;
					    code = i::fstpl (dst) ! code; #  XXX 
					    done_fn code;
					};
				end;

				# Make a copy of register fs to %st (0). 
				#
				fun moveregtotop (fs, code)
				    = 
				    case (getfs fs)
					(TRUE,  0) =>  code;
					(TRUE,  n) =>  xch n ! code;
					(FALSE, n) =>  push n ! code;
				    esac;

				fun movememtotop (fsize, mem, code)
				    = 
				    {   st::push (stack, -2);
					fld_fn (fsize, mem) ! code;
				    };

				# Move an operand to top of stack:
				# 
				fun movetotop (fsize, i::FPR fs, code) =>  moveregtotop (fs, code);
				    movetotop (fsize, mem,       code) =>  movememtotop (fsize, mem, code);
				end;

				fun store_result (fsize, dst, n, code)
				    = 
				    case dst

					i::FPR fd
                                            =>
                                            {   st::set (stack, n, cb::register_num fd);
                                                done_fn code;
                                            };

					mem =>
                                            {   code =  (n == 0)  ??          code
                                                                  ::  xch n ! code;

						st::pop stack;
						done_fn (fstp_fn (fsize, mem) ! code);
					    };
				    esac;

				# Floating point unary operator:
				# 
				fun funop { fsize, un_op, src, dst }
				    = 
				    {   code = movetotop (fsize, src, code);
					code = mark (i::funary un_op, an) ! code;

					# Moronic hack to deal with partial tangent! 	XXX BUGGO FIXME
					#
					code = 
					    case un_op

					        i::FPTAN
                                                    => 
						    {   if (st::depth stack >= 7 ) error "FPTAN"; fi;
						        pop_st ! code;			#  pop the useless 1.0 
						    };

					        _   => code;
					    esac;

					store_result (fsize, dst, 0, code);
				    };

				# Floating point binary operator. 
				# Note:
				#    binop src, dst
				#    means dst := dst binop src 
				#          (lsrc := lsrc binop rsrc)
				#    on the x86
				#
				fun fbinop { fsize, bin_op, lsrc, rsrc, dst }
				    = 
				    {   # generate code and set %st (n) = fd */ 

					#  op2 := op1 - op2 

					fun oper (bin_op, op1, op2, n, code)
					    = 
					    {   code = mark (i::fbinary { bin_op, src=>op1, dst=>op2 }, an)
						       ! code;
						store_result (i::FP64, dst, n, code);
					    };

					fun oper_r (bin_op, op1, op2, n, code)
					    = 
					    oper (invert bin_op, op1, op2, n, code); 

					fun oper_p (bin_op, op1, op2, n, code)
					    = 
					    {   st::pop stack;
						oper (pop bin_op, op1, op2, n - 1, code);
					    };

					fun oper_rp (bin_op, op1, op2, n, code)
					    = 
					    {   st::pop stack;
						oper_r (pop bin_op, op1, op2, n - 1, code);
					    };

					# Many special cases to consider. 
					# Basically, try to reuse stack space as 
					# much as possible by taking advantage of last uses.
					# 
					#  Stack=[st (0)=3.0 st (1)=2.0]
					#    fsub   %st (1), %st [1, 2.0]
					#    fsubr  %st (1), %st [-1, 2.0]
					#    fsub   %st, %st (1) [3.0, 1.0]
					#    fsubr  %st, %st (1) [3.0,-1.0]
					#
					#    fsubp  %st, %st (1) [1]
					#    fsubrp %st, %st (1) [-1]
					#  So,
					#    fsub  %st (n), %st (means %st - %st (n) -> %st)
					#    fsub  %st, %st (n) (means %st - %st (n) -> %st (n))
					#    fsubr %st (n), %st (means %st (n) - %st -> %st)
					#    fsubr %st, %st (n) (means %st (n) - %st -> %st (n))
					#
					fun reg2 (fx, fy)
					    =
					    {   my (dx, sx) = getfs fx;
						my (dy, sy) = getfs fy;

						fun loop (dx, sx, dy, sy, code)
                                                    =
						    #    op1,   op2 (dst) 
						    case (dx, sx, dy, sy)   

							(TRUE,  0, FALSE, n) =>  oper    (bin_op, st_fn n, st0, 0, code); 
							(FALSE, n, TRUE,  0) =>  oper_r  (bin_op, st_fn n, st0, 0, code);

							(TRUE,  n, TRUE,  0) =>  oper_rp (bin_op, st0, st_fn n, n, code);
							(TRUE,  0, TRUE,  n) =>  oper_p  (bin_op, st0, st_fn n, n, code);

							(FALSE, 0, TRUE,  n) =>  oper    (bin_op, st0, st_fn n, n, code);
							(TRUE,  n, FALSE, 0) =>  oper_r  (bin_op, st0, st_fn n, n, code);

							(TRUE, sx, dy, sy)
							    =>
							    loop (TRUE, 0, dy, sy, xch sx ! code); 

							(dx, sx, TRUE, sy)
							    =>
							    loop (dx, sx, TRUE, 0, xch sy ! code); 

							(FALSE, sx, FALSE, sy)
							    =>
							    loop (TRUE, 0, FALSE, sy+1, push sx ! code);
                                                    esac; 

					        if (sx == sy )		# Same register.

						    code = case (dx, sx)   
							       (TRUE,  0) =>  code;
							       (TRUE,  n) =>  xch n ! code;
							       (FALSE, n) =>  push n ! code;
                                                           esac;

						    oper (bin_op, st0, st0, 0, code); 

						else
                                                    loop (dx, sx, dy, sy, code);
                                                fi;
					    };

					# reg/mem operands
					# 
					fun regmem (bin_op, fx, mem)
					    =
					    case (getfs fx)

						 (TRUE,  0) =>  oper (bin_op, mem, st0, 0, code);
						 (TRUE,  n) =>  oper (bin_op, mem, st0, 0, xch n ! code); 
						 (FALSE, n) =>  oper (bin_op, mem, st0, 0, push n ! code);
					    esac;

					# Two memory operands. Optimize the case when
					# the two operands are identical.
					#
					fun mem2 (lsrc, rsrc)
                                            =
					    {   st::push (stack,-2);

						code = fld_fn (fsize, lsrc) ! code;

						rsrc =   p::eq_opn (lsrc, rsrc)
                                                             ??  st0
                                                             ::  rsrc;

					        oper (bin_op, rsrc, st0, 0, code);
					    };

					fun process (i::FPR fx, i::FPR fy) => reg2 (fx, fy);
					    process (i::FPR fx, mem)       => regmem (bin_op, fx, mem);
					    process (mem, i::FPR fy)       => regmem (invert bin_op, fy, mem);
					    process (lsrc, rsrc)           => mem2 (lsrc, rsrc);
                                        end;

				        process (lsrc, rsrc);
				    };

				# Floating point binary operator with integer conversion:
				#
				fun fibinop { isize, bin_op, lsrc, rsrc, dst }
				    = 
				    {   fun oper (bin_op, src, code)
					    = 
					    {   code = mark (i::fibinary { bin_op, src }, an)
							      ! code;

					        store_result (i::FP64, dst, 0, code);
					    };

					fun regmem (bin_op, fx, mem)
					    = 
					    case (getfs fx)
						(TRUE,  0) =>  oper (bin_op, mem, code);
						(TRUE,  n) =>  oper (bin_op, mem, xch n ! code);
						(FALSE, n) =>  oper (bin_op, mem, push n ! code);
					    esac;

					case (lsrc, rsrc)
					     (i::FPR fx, mem)  =>  regmem (bin_op, fx, mem);
					     (lsrc,      rsrc) =>  oper (bin_op, rsrc, pushmem lsrc ! code);
					esac; 
				    };

				# Floating point comparison 
				# We have to make sure there are enough registers. 
				# The trick is that tmp is always a physical register.
				# So we can always use it as temporary space if we
				# have run out.
				#
				fun fcmp { i, fsize, lsrc, rsrc }
				    = 
				    {   fun fucompp code
					    = 
					    {   st::pop stack; st::pop stack; 

						i   ??   pop_st !  mark (i::fucomip (st_fn 1), an) ! code
						    ::   mark (i::fucompp, an) ! code;
					   };

					fun fucomp n
					    = 
					    {   st::pop stack; 

						mark
                                                  ( (i ?? i::fucomip :: i::fucomp)  (st_fn n),
                                                    an
                                                  );
					    };

					fun fucom n
					    = 
					    mark ((i ?? i::fucomi :: i::fucom) (st_fn n), an);

					fun genmemcmp ()
					    =
					    {   code = movememtotop (fsize, rsrc, code);
						code = movememtotop (fsize, lsrc, code);

						finish_fn (fucompp (code));
					    };

					fun genmemregcmp (lsrc, fy)
					    = 
					    case (getfs fy)

						(FALSE, n)
						    => 
						    {   code = movememtotop (fsize, lsrc, code);
							finish_fn (fucomp (n+1) ! code);
						    };

						(TRUE, n)
						    => 
						    {   code =   n == 0  ??  code
									 ::  xch n ! code;

							code = movememtotop (fsize, lsrc, code);

							finish_fn (fucompp code);
						    };
					    esac; 

					fun genregmemcmp (fx, rsrc)
					    =
					    {   code = case (getfs fx)

							   (TRUE, n)
							       => 
							       {   code =   n == 0  ??  code
									            ::  xch n ! code;

								   code = movememtotop (fsize, rsrc, code);

							           xch 1 ! code;
                                                               };

							   (FALSE, n)
							       => 
							       {   code = movememtotop (fsize, rsrc, code);
								   push (n+1) ! code;
							       };
							esac;

						finish_fn (fucompp code);
					    };

					# Deal with the special case
					# where both sources are
					# in the same register
					#
					fun regsame (dx, sx)
					    =
					    finish_fn (cmp ! code)
                                            where
					        my (code, cmp)
						    = 
						    case (dx, sx)
							(TRUE,  0) =>  (code, fucomp 0);	#  pop once! 
							(FALSE, 0) =>  (code, fucom  0);	#  Don't pop! 

							(TRUE,  n) =>  (xch n ! code, fucomp 0);
							(FALSE, n) =>  (xch n ! code, fucom 0);
						    esac;
					    end;

					fun reg2 (fx, fy)
					    = 
					    # Special case is when things are already in place.  
					    # Note: should also generate FUCOM and FUCOMP!!!	XXX BUGGO FIXME
					    #
					    {   my (dx, sx) = getfs fx;
						my (dy, sy) = getfs fy;

						fun fstp n
						    = 
						    {   st::xch (stack, n, 0);
							st::pop stack;
							i::fstpl (st_fn n);
						    };

						if (sx == sy)

                                                    regsame (dx, sx);				# Same register!
						else
						    # First, move sx to %st (0):
						    # 
						    my (sy, code)
                                                        = 
							if (sx == 0)				# There already. 
                                                             ( sy,
                                                               code
                                                             );
							else
                                                             ( sy == 0 ?? sx :: sy, 
							       xch sx ! code
                                                             );
                                                        fi;

						    # Generate the appropriate comparison op 
						    #
						    my (sy, code, pop_y)
                                                        = 
							case (dx, dy, sy)   
							    (TRUE,  TRUE, 0) =>  (-1, fucompp code, FALSE);
							    (TRUE,  _,    _) =>  (sy - 1, fucomp sy ! code, dy);
							    (FALSE, _,    _) =>  (sy, fucom sy ! code, dy);
                                                        esac;

						    # Pop fy if it is dead and hasn't already
						    # been popped.
						    #
						    code =   pop_y    ??   fstp sy ! code
                                                                      ::             code;

						    finish_fn code;  
                                                fi;
					    };

					case (lsrc, rsrc)
					    (i::FPR x, i::FPR y) =>  reg2 (x, y);
					    (i::FPR x, mem)      =>  genregmemcmp (x, mem);
					    (mem, i::FPR y)      =>  genmemregcmp (mem, y);
					    _                    =>  genmemcmp ();
					esac;
				    };


				fun pr_copy (dst, src)
				    =
				    paired_lists::apply
					(fn (fd, fs)
					    =
					    pr (freg_to_string (fd) + "<-" + freg_to_string fs + " ")
					)
					(dst, src);


				# Parallel copy magic.
				#
				# For each src register, we find out 
				#
				#  1. Whether it is the last use, and if so,
				#  2. whether it is used more than once.
				#
				# If a source is a last and unique use,
                                # then we can simply rename it to
                                # the appropriate destination register:
				#
				fun fcopy (i::COPY { dst, src, tmp, ... } )
					=>
					{
					    fun loop ([], [], copies, renames)
                                                    =>
                                                    (copies, renames);

						loop (fd ! fds, fs ! fss, copies, renames)
						    => 
						    {   fsx = cb::register_num fs;

							if (is_last_use fsx)

							      if (a::get (use_table, fsx) != stamp)

								    # Unused.

								    a::set (use_table, fsx, stamp);

								    loop
                                                                      ( fds,
                                                                        fss,
                                                                        copies, 

									cb::same_color (fd, fs)
                                                                            ??            renames
									    :: (fd, fs) ! renames
                                                                      );

							       else
								    loop (fds, fss, (fd, fs) ! copies, renames);
							       fi;

							  else
							       loop (fds, fss, (fd, fs) ! copies, renames);
							  fi;
						      };

						loop _
						    =>
						    error "fcopy::loop";
					    end;

					    # Generate code for the copies:
					    # 
					    fun gen_copy ([], code)
						    =>
						    code;

						gen_copy((fd, fs) ! copies, code)
						    => 
						    {   ss   = st::fp (stack, cb::register_num fs);
							st::push (stack, cb::register_num fd);
							code = i::fldl (st_fn ss) ! code; 
						        gen_copy (copies, code);
						    };
					    end;

					    # Perform the renaming.
                                            # It must be done in parallel!
					    #
					    fun renaming renames
						= 
						{   ss = map  (fn (_, fs) = st::fp (stack, cb::register_num fs))
                                                              renames;

						    paired_lists::apply
							(fn ((fd, _), ss)
							    =
							    st::set (stack, ss, cb::register_num fd)
							)
							(renames, ss);
						};

					    # if debug then
					    #	       (paired_lists::apply (fn (fd, fs) =>
					    #		   pr (fregToString (regmap fd) + "<-" + 
					    #		      fregToString (regmap fs) + " ")
					    #		   ) (dst, src);
					    #		pr "\n")
					    #	    else ()

					    my (copies, renames)
						=
						loop (dst, src, [], []);

					    code = gen_copy (copies, code);

					    renaming renames;

					       case tmp

						   THE (i::FPR f)
						       => 
						       {   if   (debug and debug_dead )

								pr("KILLING tmp " + freg_to_string f + "\n");
							   fi;

							   st::kill (stack, f);
						       };

						   _   => ();
					       esac;

					       done_fn code;
					};

				    fcopy _ => error "fcopy";
				end;

				fun call (instruction, return)
				    =
				    { 
					code = mark (i::BASE_INSTRUCTION instruction, an) ! code;
					return_set = sl::return (sl::uniq (get_cell return));

					case return_set
					    []  => ();
					    [r] => st::push (stack, cb::register_num r); 
					    _   => error "can't return more than one fp argument (yet)";
					esac;

					kill_the_dead (list::filter is_dead return_set, code);
				    };

				fun x86trans instruction
				    =
				    case instruction 
					i::FMOVE x   => { log(); fmove x;};
					i::FBINOP x  => { log(); fbinop x;};
					i::FIBINOP x => { log(); fibinop x;};
					i::FUNOP x   => { log(); funop x;};
					i::FILOAD x  => { log(); fiload x;};
					i::FCMP x    => { log(); fcmp x;};

					# Handle calling convention:
					#
					i::CALL { return, ... }
					    =>
					    {   log();
						call (instruction, return);
					    };

					# Catch instructions that absolutely 
					# should not have been generated
					# at this point:
					#
					( i::FLD1    | i::FLDL2E    | i::FLDLG2     | i::FLDLN2  | i::FLDPI
					| i::FLDZ    | i::FLDL _    | i::FLDS _     | i::FLDT _
					| i::FILD _  | i::FILDL _   | i::FILDLL _
					| i::FENV _  | i::FBINARY _ | i::FIBINARY _ | i::FUNARY _
					| i::FUCOMPP | i::FUCOM _   | i::FUCOMP _   | i::FCOMPP  | i::FXCH _
					| i::FCOMI _ | i::FCOMIP _  | i::FUCOMI _   | i::FUCOMIP _
					| i::FSTPL _ | i::FSTPS _   | i::FSTPT _    | i::FSTL _  | i::FSTS _ 
					)   =>
                                            bug ("Illegal FP instructions");

					# Leave other instructions untouched:
					#
					other_instruction
                                            =>
                                            finish_fn (mark (i::BASE_INSTRUCTION other_instruction, an) ! code);
				    esac;


				case instruction

				     i::NOTE { note, instruction }
					 =>
					  trans (stamp, instruction, note ! an, rest, dead, last_uses, code);

				     i::COPY { kind => cb::FLOAT_REGISTER, ... }
                                         =>
                                         {   log();
                                             fcopy instruction;
                                         };

				     i::LIVE _
                                         =>
                                         done_fn (mark (instruction, an) ! code);

				     i::BASE_INSTRUCTION instruction
                                         =>
                                         x86trans instruction;

				     _  => finish_fn (mark (instruction, an) ! code);
				esac;
			    };				# fun trans 

			 # Check the translation result
                         # to see if it matches the
			 # original code:
			 #
			fun check_translation (stack_in, stack_out, instructions)
			    = 
			    {   n = REF (st::depth stack_in);

				fun push () =  n := *n + 1;
				fun pop () =  n := *n - 1;

				fun scan (i::BASE_INSTRUCTION (i::FBINARY { bin_op, ... } ))
                                        => 
				        case bin_op    
					    ( i::FADDP | i::FSUBP | i::FSUBRP | i::FMULP
					    | i::FDIVP | i::FDIVRP) => pop();
					    _ => ();
                                        esac;

				    scan (i::BASE_INSTRUCTION (i::FIBINARY { bin_op, ... } )) => ();
				    scan (i::BASE_INSTRUCTION (i::FUNARY i::FPTAN)) => push();
				    scan (i::BASE_INSTRUCTION (i::FUNARY _)) => ();
				    scan (i::BASE_INSTRUCTION (i::FLDL (i::ST n))) => push();
				    scan (i::BASE_INSTRUCTION (i::FLDL mem)) => push();
				    scan (i::BASE_INSTRUCTION (i::FLDS mem)) => push();
				    scan (i::BASE_INSTRUCTION (i::FLDT mem)) => push();
				    scan (i::BASE_INSTRUCTION (i::FSTL (i::ST n))) => ();
				    scan (i::BASE_INSTRUCTION (i::FSTPL (i::ST n))) => pop();
				    scan (i::BASE_INSTRUCTION (i::FSTL mem)) => ();
				    scan (i::BASE_INSTRUCTION (i::FSTS mem)) => ();
				    scan (i::BASE_INSTRUCTION (i::FSTPL mem)) => pop();
				    scan (i::BASE_INSTRUCTION (i::FSTPS mem)) => pop();
				    scan (i::BASE_INSTRUCTION (i::FSTPT mem)) => pop();
				    scan (i::BASE_INSTRUCTION (i::FXCH { operand=>i, ... } )) => ();
				    scan (i::BASE_INSTRUCTION (i::FUCOM _)) => ();
				    scan (i::BASE_INSTRUCTION (i::FUCOMP _)) => pop();
				    scan (i::BASE_INSTRUCTION (i::FUCOMPP)) => { pop(); pop();};
				    scan (i::BASE_INSTRUCTION (i::FILD mem)) => push();
				    scan (i::BASE_INSTRUCTION (i::FILDL mem)) => push();
				    scan (i::BASE_INSTRUCTION (i::FILDLL mem)) => push();

				    scan (i::BASE_INSTRUCTION (i::CALL { return, ... } ))
					=> 
					{   n := 0; #  Clear the stack 

					    #  Simulate the pushing of arguments:
					    # 
					    {   return_set = sl::return (sl::uniq (get_cell return));
						apply (fn _ = push()) return_set;
					    };
					};
				    scan _ => ();
				end;

				apply scan (reverse instructions);  
				n = *n;
				m = st::depth stack_out;

				if (n != m)
				     dump instructions;
				     bug("Bad translation n=" + i2s n +  " expected=" + i2s m + "\n");
				fi;
			    };


			# Dump the initial code:
			#
			if   (debug and *x86_fp_debug_mode)

			     pr("-------- block " + i2s blknum + " ----" + 
				  celllist_to_string live_in + " " + 
				  st::stack_to_string stack_in + "\n");

			     dump *instructions;
			     pr("next=");
			     apply (fn b => pr (i2s b + " "); end ) (cfg.next blknum);
			     pr "\n";

			fi;

			# Compute the last uses:
			#
			last_use =   compute_last_use (blknum, instructions, live_out); 


			# Rewrite the code:
			# 
			my (stamp, instructions')
			    =
			    loop (stamp, reverse *instructions, last_use, code);


			# Insert shuffle code at the end if necessary:
			# 
			instructions' = shuffle_out (stack, instructions', blknum, block, live_out);


			# Dump translation:
			# 
			if (debug and *x86_fp_debug_mode)

			    pr("-------- translation " + i2s blknum + "----" + 
			       celllist_to_string live_in + " " + 
			       st::stack_to_string stack_in + "\n");

			    dump instructions';

			    pr("-------- done " + i2s blknum + "----" + 
			       celllist_to_string live_out + " " + 
			       st::stack_to_string stack + "\n");

			 fi;

			# Check if things are okay:
			#
			if (debug and sanity_check)

			     check_translation (stack_in, stack, instructions');
			fi;

			instructions := instructions';		# Update the instructions.

			stamp;
		    };					# fun rewrite


		# Translate all blocks:
		# 
		stamp := c::first_pseudo; 
		cfg.forall_nodes rewrite_all_blocks; 


		# If we found critical edges
                # then we have to split them:
		# 
		if (int_hash_table::vals_count edges_to_split == 0)

		     cfg'; 
		else
		     repair_critical_edges cfg';
		fi;
	    }; 
	};		# generic package x86_floating_point_code_g
end;			# stipulate






##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## COPYRIGHT (c) 2001 Bell Labs, Lucent Technologies
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
