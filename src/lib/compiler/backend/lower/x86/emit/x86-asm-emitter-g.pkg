## x86-asm-emitter-g.pkg
#
# WARNING: This file was automatically generated by mdl_g (v3.0)
# from the machine description file "x86/x86.mdl".
# DO NOT EDIT this file directly

# Compiled by:
#     src/lib/compiler/backend/lower/make7/ia32.make6

# We are invoked from:
#
#     src/lib/compiler/codegen/x86/x86-codetree.pkg

generic package x86_asm_emitter_g (

    package instruction_stream
	:
	Instruction_Stream;						# Instruction_Stream	is from   src/lib/compiler/backend/lower/instruction/instruction-stream.api

    package instruction_set
        :
        Instruction_Set_X86						# Instruction_Set_X86	is from   src/lib/compiler/backend/lower/x86/instruction/instruction-set-x86.api
        where codetree
              ==
             instruction_stream::pseudo_op::codetree;

    package shuffle
        :
        Xy86Shuffle							# Xy86Shuffle		is from   src/lib/compiler/backend/lower/x86/instruction/x86-shuffle.api
        where instruction_set == instruction_set;

    package codetree_eval
        :
        Codetree_Eval							# Codetree_Eval		is from   src/lib/compiler/backend/lower/codetree/codetree-eval.api
        where codetree == instruction_set::codetree;

###line 512.7 "x86/x86.mdl"
    package mem_regs
        :
        Memory_Registers						# Memory_Registers	is from   src/lib/compiler/backend/lower/x86/instruction/x86-memory-registers.api
        where instruction_set == instruction_set;

###line 513.7 "x86/x86.mdl"
    mem_reg_base:  Null_Or( cells_basis::Cell );
)

: (weak) Instruction_Emitter						# Instruction_Emitter	is from   src/lib/compiler/backend/lower/emit/instruction-emitter.api

=
package {

    package instruction_stream = instruction_stream;
    package instruction_set    = instruction_set;
    package cells              = instruction_set::cells;
    package codetree           = instruction_set::codetree;

    package i  = instruction_set;
    package c  = cells;
    package t  = codetree;
    package s  = instruction_stream;
    package p  = s::pseudo_op;
    package constant = i::constant;

    include asm_flags;

    fun error msg
        =
        lowcode_error_message::error("x86_asm_emitter_g", msg);

    fun make_stream format_annotations
	=
	{   stream = *asm_stream::asm_out_stream;

	    fun emit' s
                =
                file::write (stream, s);

	    newline = REF TRUE;
	    tabs = REF 0;

	    fun tabbing 0 => ();
	        tabbing n => { emit' "\t"; tabbing (n - 1);};
            end;

	    fun emit s = { tabbing *tabs; tabs := 0; newline := FALSE; emit' s;};
	    fun nl () = { tabs := 0; if (not *newline)  newline := TRUE; emit' "\n"; fi; };
	    fun comma () = emit ", ";
	    fun tab () = tabs := 1;
	    fun indent () = tabs := 2;

	    fun ms n
		=
		{   s = int::to_string n;

		    if (n < 0)   "-" + string::substring (s, 1, size s - 1);
		    else         s;
                    fi;
		};

	    fun emit_label lab = emit (p::client::asm_pseudo_ops::lexp_to_string (t::LABEL lab));
	    fun emit_labexp le = emit (p::client::asm_pseudo_ops::lexp_to_string (t::LABEXP le));
	    fun emit_const c = emit (constant::to_string c);
	    fun emit_int i = emit (ms i);
	    fun paren f = { emit "("; f(); emit ")";};
	    fun define_local_label lab = emit (p::client::asm_pseudo_ops::define_local_label lab + "\n");
	    fun define_global_label lab = define_local_label lab;
	    fun emit_comment msg = { tab(); emit("/* " + msg + " */"); nl();};
	    fun add_note a = emit_comment (note::to_string a);
	    fun get_notes () = error "get_notes";
	    fun do_nothing _ = ();
	    fun fail _ = raise exception FAIL "AsmEmitter";
	    fun emit_region mem = emit_comment (i::region::to_string mem);

	    emit_region
                = 
	        if *show_region  emit_region;
                else             do_nothing;
                fi;

	    fun emit_pseudo_op p_op = { emit (p::to_string p_op); emit "\n";};
	    fun init size = { emit_comment("Code Size = " + ms size); nl();};

	    emit_cell_info = asm_formatting_utilities::reginfo
				     (emit, format_annotations);

	    fun emit_cell r = { emit (cells_basis::to_string r); emit_cell_info r;};

	    fun emit_cellset (title, cellset)
                =
	        {   nl();
                    emit_comment (title + cells_basis::cell_set::to_string cellset);
                };

	    emit_cellset
                = 
	        if *show_cellset  emit_cellset; else do_nothing;fi;

	    fun emit_defs cellset = emit_cellset("defs: ", cellset);
	    fun emit_uses cellset = emit_cellset("uses: ", cellset);

	    emit_cuts_to
                = 
	        *show_cuts_to   ??   asm_formatting_utilities::emit_cuts_to emit
	                        ::   do_nothing;

	    fun emitter instruction
		=
		{
		    fun asm_cond (i::EQ) => "e";
			asm_cond (i::NE) => "ne";
			asm_cond (i::LT) => "l";
			asm_cond (i::LE) => "le";
			asm_cond (i::GT) => "g";
			asm_cond (i::GE) => "ge";
			asm_cond (i::BB) => "b";
			asm_cond (i::BE) => "be";
			asm_cond (i::AA) => "a";
			asm_cond (i::AE) => "ae";
			asm_cond (i::CC) => "c";
			asm_cond (i::NC) => "nc";
			asm_cond (i::PP) => "p";
			asm_cond (i::NP) => "np";
			asm_cond (i::OO) => "o";
			asm_cond (i::NO) => "no";
		    end 

		    also
		    fun emit_cond x = emit (asm_cond x)

		    also
		    fun asm_binary_op (i::ADDL) => "addl";
			asm_binary_op (i::SUBL) => "subl";
			asm_binary_op (i::ANDL) => "andl";
			asm_binary_op (i::ORL) => "orl";
			asm_binary_op (i::XORL) => "xorl";
			asm_binary_op (i::SHLL) => "shll";
			asm_binary_op (i::SARL) => "sarl";
			asm_binary_op (i::SHRL) => "shrl";
			asm_binary_op (i::MULL) => "mull";
			asm_binary_op (i::IMULL) => "imull";
			asm_binary_op (i::ADCL) => "adcl";
			asm_binary_op (i::SBBL) => "sbbl";
			asm_binary_op (i::ADDW) => "addw";
			asm_binary_op (i::SUBW) => "subw";
			asm_binary_op (i::ANDW) => "andw";
			asm_binary_op (i::ORW) => "orw";
			asm_binary_op (i::XORW) => "xorw";
			asm_binary_op (i::SHLW) => "shlw";
			asm_binary_op (i::SARW) => "sarw";
			asm_binary_op (i::SHRW) => "shrw";
			asm_binary_op (i::MULW) => "mulw";
			asm_binary_op (i::IMULW) => "imulw";
			asm_binary_op (i::ADDB) => "addb";
			asm_binary_op (i::SUBB) => "subb";
			asm_binary_op (i::BITWISEAND) => "bitwise_and";
			asm_binary_op (i::BITWISEOR) => "bitwise_or";
			asm_binary_op (i::BITWISEXOR) => "bitwise_xor";
			asm_binary_op (i::SHLB) => "shlb";
			asm_binary_op (i::SARB) => "sarb";
			asm_binary_op (i::SHRB) => "shrb";
			asm_binary_op (i::MULB) => "mulb";
			asm_binary_op (i::IMULB) => "imulb";
			asm_binary_op (i::BTSW) => "btsw";
			asm_binary_op (i::BTCW) => "btcw";
			asm_binary_op (i::BTRW) => "btrw";
			asm_binary_op (i::BTSL) => "btsl";
			asm_binary_op (i::BTCL) => "btcl";
			asm_binary_op (i::BTRL) => "btrl";
			asm_binary_op (i::ROLW) => "rolw";
			asm_binary_op (i::RORW) => "rorw";
			asm_binary_op (i::ROLL) => "roll";
			asm_binary_op (i::RORL) => "rorl";
			asm_binary_op (i::XCHGB) => "xchgb";
			asm_binary_op (i::XCHGW) => "xchgw";
			asm_binary_op (i::XCHGL) => "xchgl";
			asm_binary_op (i::LOCK_ADCW) => "lock\n\tadcw";
			asm_binary_op (i::LOCK_ADCL) => "lock\n\tadcl";
			asm_binary_op (i::LOCK_ADDW) => "lock\n\taddw";
			asm_binary_op (i::LOCK_ADDL) => "lock\n\taddl";
			asm_binary_op (i::LOCK_ANDW) => "lock\n\tandw";
			asm_binary_op (i::LOCK_ANDL) => "lock\n\tandl";
			asm_binary_op (i::LOCK_BTSW) => "lock\n\tbtsw";
			asm_binary_op (i::LOCK_BTSL) => "lock\n\tbtsl";
			asm_binary_op (i::LOCK_BTRW) => "lock\n\tbtrw";
			asm_binary_op (i::LOCK_BTRL) => "lock\n\tbtrl";
			asm_binary_op (i::LOCK_BTCW) => "lock\n\tbtcw";
			asm_binary_op (i::LOCK_BTCL) => "lock\n\tbtcl";
			asm_binary_op (i::LOCK_ORW) => "lock\n\torw";
			asm_binary_op (i::LOCK_ORL) => "lock\n\torl";
			asm_binary_op (i::LOCK_SBBW) => "lock\n\tsbbw";
			asm_binary_op (i::LOCK_SBBL) => "lock\n\tsbbl";
			asm_binary_op (i::LOCK_SUBW) => "lock\n\tsubw";
			asm_binary_op (i::LOCK_SUBL) => "lock\n\tsubl";
			asm_binary_op (i::LOCK_XORW) => "lock\n\txorw";
			asm_binary_op (i::LOCK_XORL) => "lock\n\txorl";
			asm_binary_op (i::LOCK_XADDB) => "lock\n\txaddb";
			asm_binary_op (i::LOCK_XADDW) => "lock\n\txaddw";
			asm_binary_op (i::LOCK_XADDL) => "lock\n\txaddl";
		    end 

		    also
		    fun emit_binary_op x = emit (asm_binary_op x)

		    also
		    fun asm_mult_div_op (i::IMULL1) => "imull";
			asm_mult_div_op (i::MULL1) => "mull";
			asm_mult_div_op (i::IDIVL1) => "idivl";
			asm_mult_div_op (i::DIVL1) => "divl";
		    end 

		    also
		    fun emit_mult_div_op x = emit (asm_mult_div_op x)

		    also
		    fun asm_unary_op (i::DECL) => "decl";
			asm_unary_op (i::INCL) => "incl";
			asm_unary_op (i::NEGL) => "negl";
			asm_unary_op (i::NOTL) => "notl";
			asm_unary_op (i::DECW) => "decw";
			asm_unary_op (i::INCW) => "incw";
			asm_unary_op (i::NEGW) => "negw";
			asm_unary_op (i::NOTW) => "notw";
			asm_unary_op (i::DECB) => "decb";
			asm_unary_op (i::INCB) => "incb";
			asm_unary_op (i::NEGB) => "negb";
			asm_unary_op (i::NOTB) => "notb";
			asm_unary_op (i::LOCK_DECL) => "lock\n\tdecl";
			asm_unary_op (i::LOCK_INCL) => "lock\n\tincl";
			asm_unary_op (i::LOCK_NEGL) => "lock\n\tnegl";
			asm_unary_op (i::LOCK_NOTL) => "lock\n\tnotl";
		    end 

		    also
		    fun emit_unary_op x = emit (asm_unary_op x)

		    also
		    fun asm_shift_op (i::SHLDL) => "shldl";
			asm_shift_op (i::SHRDL) => "shrdl";
		    end 

		    also
		    fun emit_shift_op x = emit (asm_shift_op x)

		    also
		    fun asm_bit_op (i::BTW) => "btw";
			asm_bit_op (i::BTL) => "btl";
			asm_bit_op (i::LOCK_BTW) => "lock\n\tbtw";
			asm_bit_op (i::LOCK_BTL) => "lock\n\tbtl";
		    end 

		    also
		    fun emit_bit_op x = emit (asm_bit_op x)

		    also
		    fun asm_move (i::MOVL) => "movl";
			asm_move (i::MOVB) => "movb";
			asm_move (i::MOVW) => "movw";
			asm_move (i::MOVSWL) => "movswl";
			asm_move (i::MOVZWL) => "movzwl";
			asm_move (i::MOVSBL) => "movsbl";
			asm_move (i::MOVZBL) => "movzbl";
		    end 

		    also
		    fun emit_move x = emit (asm_move x)

		    also
		    fun asm_fbin_op (i::FADDP) => "faddp";
			asm_fbin_op (i::FADDS) => "fadds";
			asm_fbin_op (i::FMULP) => "fmulp";
			asm_fbin_op (i::FMULS) => "fmuls";
			asm_fbin_op (i::FCOMS) => "fcoms";
			asm_fbin_op (i::FCOMPS) => "fcomps";
			asm_fbin_op (i::FSUBP) => "fsubp";
			asm_fbin_op (i::FSUBS) => "fsubs";
			asm_fbin_op (i::FSUBRP) => "fsubrp";
			asm_fbin_op (i::FSUBRS) => "fsubrs";
			asm_fbin_op (i::FDIVP) => "fdivp";
			asm_fbin_op (i::FDIVS) => "fdivs";
			asm_fbin_op (i::FDIVRP) => "fdivrp";
			asm_fbin_op (i::FDIVRS) => "fdivrs";
			asm_fbin_op (i::FADDL) => "faddl";
			asm_fbin_op (i::FMULL) => "fmull";
			asm_fbin_op (i::FCOML) => "fcoml";
			asm_fbin_op (i::FCOMPL) => "fcompl";
			asm_fbin_op (i::FSUBL) => "fsubl";
			asm_fbin_op (i::FSUBRL) => "fsubrl";
			asm_fbin_op (i::FDIVL) => "fdivl";
			asm_fbin_op (i::FDIVRL) => "fdivrl";
		    end 

		    also
		    fun emit_fbin_op x = emit (asm_fbin_op x)

		    also
		    fun asm_fibin_op (i::FIADDS) => "fiadds";
			asm_fibin_op (i::FIMULS) => "fimuls";
			asm_fibin_op (i::FICOMS) => "ficoms";
			asm_fibin_op (i::FICOMPS) => "ficomps";
			asm_fibin_op (i::FISUBS) => "fisubs";
			asm_fibin_op (i::FISUBRS) => "fisubrs";
			asm_fibin_op (i::FIDIVS) => "fidivs";
			asm_fibin_op (i::FIDIVRS) => "fidivrs";
			asm_fibin_op (i::FIADDL) => "fiaddl";
			asm_fibin_op (i::FIMULL) => "fimull";
			asm_fibin_op (i::FICOML) => "ficoml";
			asm_fibin_op (i::FICOMPL) => "ficompl";
			asm_fibin_op (i::FISUBL) => "fisubl";
			asm_fibin_op (i::FISUBRL) => "fisubrl";
			asm_fibin_op (i::FIDIVL) => "fidivl";
			asm_fibin_op (i::FIDIVRL) => "fidivrl";
		    end 

		    also
		    fun emit_fibin_op x = emit (asm_fibin_op x)

		    also
		    fun asm_fun_op (i::FCHS) => "fchs";
			asm_fun_op (i::FABS) => "fabs";
			asm_fun_op (i::FTST) => "ftst";
			asm_fun_op (i::FXAM) => "fxam";
			asm_fun_op (i::FPTAN) => "fptan";
			asm_fun_op (i::FPATAN) => "fpatan";
			asm_fun_op (i::FXTRACT) => "fxtract";
			asm_fun_op (i::FPREM1) => "fprem1";
			asm_fun_op (i::FDECSTP) => "fdecstp";
			asm_fun_op (i::FINCSTP) => "fincstp";
			asm_fun_op (i::FPREM) => "fprem";
			asm_fun_op (i::FYL2XP1) => "fyl2xp1";
			asm_fun_op (i::FSQRT) => "fsqrt";
			asm_fun_op (i::FSINCOS) => "fsincos";
			asm_fun_op (i::FRNDINT) => "frndint";
			asm_fun_op (i::FSCALE) => "fscale";
			asm_fun_op (i::FSIN) => "fsin";
			asm_fun_op (i::FCOS) => "fcos";
		    end 

		    also
		    fun emit_fun_op x = emit (asm_fun_op x)

		    also
		    fun asm_fenv_op (i::FLDENV) => "fldenv";
			asm_fenv_op (i::FNLDENV) => "fnldenv";
			asm_fenv_op (i::FSTENV) => "fstenv";
			asm_fenv_op (i::FNSTENV) => "fnstenv";
		    end 

		    also
		    fun emit_fenv_op x = emit (asm_fenv_op x)

		    also
		    fun asm_fsize (i::FP32) => "s";
			asm_fsize (i::FP64) => "l";
			asm_fsize (i::FP80) => "t";
		    end 

		    also
		    fun emit_fsize x = emit (asm_fsize x)

		    also
		    fun asm_isize (i::INT8) => "8";
			asm_isize (i::INT16) => "16";
			asm_isize (i::INT32) => "32";
			asm_isize (i::INT64) => "64"; end 

		    also
		    fun emit_isize x = emit (asm_isize x);

		 ###line 515.6 "x86/x86.mdl"
		    fun mem_reg r = mem_regs::mem_reg { reg=>r, base=>null_or::the mem_reg_base };

		 ###line 516.6 "x86/x86.mdl"
		    fun emit_int32 i = 
			{ 
		 ###line 517.10 "x86/x86.mdl"
			    s = int32::to_string i;

		 ###line 518.10 "x86/x86.mdl"
			    s = (if ((i >= 0))
					s;
				   else ("-" + (string::substring (s, 1, (size s) - 1)));fi);
			 emit s;
			};

		 ###line 521.6 "x86/x86.mdl"
		    my { low=>stoffset, ... } = c::cell_range cells_basis::FLOAT_REGISTER;

		 ###line 523.6 "x86/x86.mdl"
		    fun emit_scale 0 => emit "1";
			emit_scale 1 => emit "2";
			emit_scale 2 => emit "4";
			emit_scale 3 => emit "8";
			emit_scale _ => error "emitScale";
		    end 

		    also
		    fun e_immed (i::IMMED i) => emit_int32 i;
			e_immed (i::IMMED_LABEL lambda_expression) => emit_labexp lambda_expression;
			e_immed _ => error "eImmed";
		    end 

		    also
		    fun emit_operand opn
			= 
			case opn   

			  i::IMMED i
                              => 
			      {   emit "$"; 
			          emit_int32 i;
                              };

			 i::IMMED_LABEL lambda_expression
                             => 
			     {   emit "$"; 
			         emit_labexp lambda_expression;
                             };

			 i::LABEL_EA le => emit_labexp le;
			 i::RELATIVE _ => error "emit_operand";
			 i::DIRECT r => emit_cell r;
			 i::MEM_REG r => emit_operand (mem_reg opn);
			 i::ST f => emit_cell f;

			 i::FPR f
                             => 
			     {   emit "%f"; 
			         emit (int::to_string (cells_basis::register_num f));
                             };

			 i::FDIRECT f => emit_operand (mem_reg opn);

			 i::DISPLACE { base, disp, mem, ... }
                             => 
			     {   emit_disp disp; 
				 emit "("; 
				 emit_cell base; 
				 emit ")"; 
				 emit_region mem;
                             };

			 i::INDEXED { base, index, scale, disp, mem, ... }
                             => 
			     {   emit_disp disp; 
				 emit "("; 

				 case base   
				     NULL     => ();
				     THE base => emit_cell base;
				 esac;

				 comma (); 
				 emit_cell index; 
				 comma (); 
				 emit_scale scale; 
				 emit ")"; 
				 emit_region mem;
                             };
                        esac

		    also
		    fun emit_operand8 (i::DIRECT r)
                            =>
                            emit (cells_basis::to_string_with_size (r, 8));

			emit_operand8 opn
                            =>
                            emit_operand opn;
		    end 

		    also
		    fun emit_disp (i::IMMED 0) => ();
			emit_disp (i::IMMED i) => emit_int32 i;
			emit_disp (i::IMMED_LABEL lambda_expression) => emit_labexp lambda_expression;
			emit_disp _ => error "emit_disp";
		    end;

		 ###line 568.7 "x86/x86.mdl"
		    fun gas_hack (i::IMMED_LABEL lambda_expression) => emit_labexp lambda_expression;
			gas_hack operand => 
			{ emit "*"; 
			  emit_operand operand ;};
		    end;

		 ###line 572.7 "x86/x86.mdl"
		    fun is_mem_operand (i::MEM_REG _) => TRUE;
			is_mem_operand (i::FDIRECT f) => TRUE;
			is_mem_operand (i::LABEL_EA _) => TRUE;
			is_mem_operand (i::DISPLACE _) => TRUE;
			is_mem_operand (i::INDEXED _) => TRUE;
			is_mem_operand _ => FALSE;
		    end;

		 ###line 578.7 "x86/x86.mdl"
		    fun chop fbin_op = 
			{ 
		 ###line 579.15 "x86/x86.mdl"
			    n = size fbin_op;

			   (case (char::to_lower (string::get (fbin_op, n - 1)))   
			     ('s' | 'l') => string::substring (fbin_op, 0, n - 1);
			    _ => fbin_op;
			   esac
			   );
			};

		 ###line 585.7 "x86/x86.mdl"
		    fun is_st0 (i::ST r) => (cells_basis::register_num r) == 0;
		        is_st0 _ => FALSE;
                    end;

		 ###line 589.7 "x86/x86.mdl"
		    fun emit_fbinary_op (bin_op, src, dst)
                        =
                        if ((is_mem_operand src))

			    emit_fbin_op bin_op; 
			    emit "\t"; 
			    emit_operand src;
		        else 
			    emit (chop (asm_fbin_op bin_op)); 
			    emit "\t"; 

			    case (is_st0 src, is_st0 dst)   

				(_, TRUE)
				    => 
				    {   emit_operand src; 
					emit ", %st";
				    };

				(TRUE, _)
				    => 
				    {   emit "%st, "; 
				        emit_operand dst;
                                    };

			         _  => error "emit_fbinaryOp";
                            esac;
			fi;

		 ###line 599.7 "x86/x86.mdl"
		    emit_dst = emit_operand;

		 ###line 600.7 "x86/x86.mdl"
		    emit_src = emit_operand;

		 ###line 601.7 "x86/x86.mdl"
		    emit_operand = emit_operand;

		 ###line 602.7 "x86/x86.mdl"
		    emit_operand8 = emit_operand8;

		 ###line 603.7 "x86/x86.mdl"
		    emit_rsrc = emit_operand;

		 ###line 604.7 "x86/x86.mdl"
		    emit_lsrc = emit_operand;

		 ###line 605.7 "x86/x86.mdl"
		    emit_addr = emit_operand;

		 ###line 606.7 "x86/x86.mdl"
		    emit_src1 = emit_operand;

		 ###line 607.7 "x86/x86.mdl"
		    emit_ea = emit_operand;

		 ###line 608.7 "x86/x86.mdl"
		    emit_count = emit_operand;

		    fun emit_instruction' instruction
			= 
			case instruction

			    i::NOP => emit "nop";

			    i::JMP (operand, list)
                                => 
			        {   emit "jmp\t"; 
			            gas_hack operand;
                                };

			    i::JCC { cond, operand }
                                => 
			        {   emit "j"; 
				    emit_cond cond; 
				    emit "\t"; 
				    gas_hack operand;
                                };

			    i::CALL { operand, defs, uses, return, cuts_to, mem, pops } => 
			     { emit "call\t"; 
			       gas_hack operand; 
			       emit_region mem; 
			       emit_defs defs; 
			       emit_uses uses; 
			       emit_cellset ("return", return); 
			       emit_cuts_to cuts_to ;};

			    i::ENTER { src1, src2 } => 
			     { emit "enter\t"; 
			       emit_operand src1; 
			       emit ", "; 
			       emit_operand src2 ;};

			    i::LEAVE => emit "leave";

			    i::RET option => 
			     { emit "ret"; 

			       (case option   
				 NULL => ();
				THE e => 
				 { emit "\t"; 
				   emit_operand e ;}; esac
			       );};

			    i::MOVE { mv_op, src, dst } => 
			     { emit_move mv_op; 
			       emit "\t"; 
			       emit_src src; 
			       emit ", "; 
			       emit_dst dst ;};

			    i::LEA { r32, address } => 
			     { emit "leal\t"; 
			       emit_addr address; 
			       emit ", "; 
			       emit_cell r32 ;};

			    i::CMPL { lsrc, rsrc } => 
			     { emit "cmpl\t"; 
			       emit_rsrc rsrc; 
			       emit ", "; 
			       emit_lsrc lsrc ;};

			    i::CMPW { lsrc, rsrc } => 
			     { emit "cmpb\t"; 
			       emit_rsrc rsrc; 
			       emit ", "; 
			       emit_lsrc lsrc ;};

			    i::CMPB { lsrc, rsrc } => 
			     { emit "cmpb\t"; 
			       emit_rsrc rsrc; 
			       emit ", "; 
			       emit_lsrc lsrc ;};

			    i::TESTL { lsrc, rsrc } => 
			     { emit "testl\t"; 
			       emit_rsrc rsrc; 
			       emit ", "; 
			       emit_lsrc lsrc ;};

			    i::TESTW { lsrc, rsrc } => 
			     { emit "testw\t"; 
			       emit_rsrc rsrc; 
			       emit ", "; 
			       emit_lsrc lsrc ;};

			    i::TESTB { lsrc, rsrc } => 
			     { emit "testb\t"; 
			       emit_rsrc rsrc; 
			       emit ", "; 
			       emit_lsrc lsrc ;};

			    i::BITOP { bit_op, lsrc, rsrc } => 
			     { emit_bit_op bit_op; 
			       emit "\t"; 
			       emit_rsrc rsrc; 
			       emit ", "; 
			       emit_lsrc lsrc ;};

			    i::BINARY { bin_op, src, dst }
                                => 
				case (src, bin_op)   

				  (i::DIRECT _, (i::SARL | i::SHRL | i::SHLL | i::SARW | i::SHRW | i::SHLW | i::SARB | i::SHRB | i::SHLB))
				      => 
				      { emit_binary_op bin_op; 
					emit "\t%cl, "; 
					emit_dst dst ;
				      };

				  _ => 
				      { emit_binary_op bin_op; 
					emit "\t"; 
					emit_src src; 
					emit ", "; 
					emit_dst dst ;
				      };
				esac;

			    i::SHIFT { shift_op, src, dst, count } => 
			     (case count   
			       i::DIRECT ecx => 
			       { emit_shift_op shift_op; 
				 emit "\t"; 
				 emit_src src; 
				 emit ", "; 
				 emit_dst dst ;};
			      _ => 
			       { emit_shift_op shift_op; 
				 emit "\t"; 
				 emit_src src; 
				 emit ", "; 
				 emit_count count; 
				 emit ", "; 
				 emit_dst dst ;}; esac
			     );
			    i::CMPXCHG { lock, size, src, dst } => 
			     { (if (lock)
				       (emit "lock\n\t");
				  fi); 
			       emit "cmpxchg"; 

			       (case size   
				 i::INT8 => emit "b";
				i::INT16 => emit "w";
				i::INT32 => emit "l";
				i::INT64 => error "CMPXCHG: I64"; esac
			       ); 

			       { emit "\t"; 
				 emit_src src; 
				 emit ", "; 
				 emit_dst dst ;} ;};
			    i::MULTDIV { mult_div_op, src } => 
			     { emit_mult_div_op mult_div_op; 
			       emit "\t"; 
			       emit_src src ;};
			    i::MUL3 { dst, src2, src1 } => 
			     { emit "imull\t$"; 
			       emit_int32 src2; 
			       emit ", "; 
			       emit_src1 src1; 
			       emit ", "; 
			       emit_cell dst ;};
			    i::UNARY { un_op, operand } => 
			     { emit_unary_op un_op; 
			       emit "\t"; 
			       emit_operand operand ;};
			    i::SET { cond, operand } => 
			     { emit "set"; 
			       emit_cond cond; 
			       emit "\t"; 
			       emit_operand8 operand ;};
			    i::CMOV { cond, src, dst } => 
			     { emit "cmov"; 
			       emit_cond cond; 
			       emit "\t"; 
			       emit_src src; 
			       emit ", "; 
			       emit_cell dst ;};
			    i::PUSHL operand => 
			     { emit "pushl\t"; 
			       emit_operand operand ;};
			    i::PUSHW operand => 
			     { emit "pushw\t"; 
			       emit_operand operand ;};
			    i::PUSHB operand => 
			     { emit "pushb\t"; 
			       emit_operand operand ;};
			    i::PUSHFD => emit "pushfd";
			    i::POPFD => emit "popfd";
			    i::POP operand => 
			     { emit "popl\t"; 
			       emit_operand operand ;};
			    i::CDQ => emit "cdq";
			    i::INTO => emit "into";
			    i::FBINARY { bin_op, src, dst } => emit_fbinary_op (bin_op, src, dst);
			    i::FIBINARY { bin_op, src } => 
			     { emit_fibin_op bin_op; 
			       emit "\t"; 
			       emit_src src ;};
			    i::FUNARY fun_op => emit_fun_op fun_op;
			    i::FUCOM operand => 
			     { emit "fucom\t"; 
			       emit_operand operand ;};
			    i::FUCOMP operand => 
			     { emit "fucomp\t"; 
			       emit_operand operand ;};
			    i::FUCOMPP => emit "fucompp";
			    i::FCOMPP => emit "fcompp";
			    i::FCOMI operand => 
			     { emit "fcomi\t"; 
			       emit_operand operand; 
			       emit ", %st" ;};

			    i::FCOMIP operand
				=> 
			        {   emit "fcomip\t"; 
			            emit_operand operand; 
			            emit ", %st";
				};

			    i::FUCOMI operand
				=> 
			        {   emit "fucomi\t"; 
			            emit_operand operand; 
			            emit ", %st";
				};

			    i::FUCOMIP operand
				=> 
			        {   emit "fucomip\t"; 
			            emit_operand operand; 
			            emit ", %st";
				};

			    i::FXCH { operand }
				=> 
			        {   emit "fxch\t"; 
			            emit_cell operand;
				};

			    i::FSTPL operand
				=>
				case operand   

				    i::ST _
                                        => 
				        {   emit "fstp\t"; 
				            emit_operand operand;
					};

				    _   => 
				        {   emit "fstpl\t"; 
				            emit_operand operand;
					};
                               esac;

			    i::FSTPS operand
				=> 
			        {   emit "fstps\t"; 
			            emit_operand operand;
				};

			    i::FSTPT operand
				=> 
			        {   emit "fstps\t"; 
			            emit_operand operand;
				};

			    i::FSTL operand
				=> 
			        case operand   

				    i::ST _ => {   emit "fst\t"; 
				                   emit_operand operand;
                                               };

				    _       => {   emit "fstl\t"; 
				                   emit_operand operand;
                                               };
                                esac;

			    i::FSTS operand
				=> 
			        {   emit "fsts\t"; 
			            emit_operand operand;
				};

			    i::FLD1   =>  emit "fld1";
			    i::FLDL2E =>  emit "fldl2e";
			    i::FLDL2T =>  emit "fldl2t";
			    i::FLDLG2 =>  emit "fldlg2";
			    i::FLDLN2 =>  emit "fldln2";
			    i::FLDPI  =>  emit "fldpi";
			    i::FLDZ   =>  emit "fldz";

			    i::FLDL operand
				=> 
				case operand   
				    i::ST _ => {   emit "fld\t"; 
						   emit_operand operand;
					       };
				    _       => {   emit "fldl\t"; 
				                   emit_operand operand;
					       };
				esac;

			    i::FLDS operand
				=> 
			        {   emit "flds\t"; 
			            emit_operand operand;
				};

			    i::FLDT operand
				=> 
			        {   emit "fldt\t"; 
			            emit_operand operand;
				};

			    i::FILD operand
				=> 
			        {   emit "fild\t"; 
			            emit_operand operand;
				};

			    i::FILDL operand
				=> 
			        {   emit "fildl\t"; 
			            emit_operand operand;
				};

			    i::FILDLL operand
				=>
			        {   emit "fildll\t"; 
			            emit_operand operand;
				};

			    i::FNSTSW => emit "fnstsw";

			    i::FENV { fenv_op, operand }
				=> 
			        {   emit_fenv_op fenv_op; 
				    emit "\t"; 
				    emit_operand operand;
				};

			    i::FMOVE { fsize, src, dst }
                                => 
				{   emit "fmove"; 
				    emit_fsize fsize; 
				    emit "\t"; 
				    emit_src src; 
				    emit ", "; 
				    emit_dst dst;
				};

			    i::FILOAD { isize, ea, dst }
                                => 
			        {   emit "fiload"; 
				    emit_isize isize; 
				    emit "\t"; 
				    emit_ea ea; 
				    emit ", "; 
				    emit_dst dst;
                                };

			    i::FBINOP { fsize, bin_op, lsrc, rsrc, dst }
                                => 
				{   emit_fbin_op bin_op; 
				    emit_fsize fsize; 
				    emit "\t"; 
				    emit_lsrc lsrc; 
				    emit ", "; 
				    emit_rsrc rsrc; 
				    emit ", "; 
				    emit_dst dst;
				};

			    i::FIBINOP { isize, bin_op, lsrc, rsrc, dst }
                                => 
			        {   emit_fibin_op bin_op; 
				    emit_isize isize; 
				    emit "\t"; 
				    emit_lsrc lsrc; 
				    emit ", "; 
				    emit_rsrc rsrc; 
				    emit ", "; 
				    emit_dst dst;
                                };

			    i::FUNOP { fsize, un_op, src, dst }
                                => 
			        {   emit_fun_op un_op; 
				    emit_fsize fsize; 
				    emit "\t"; 
				    emit_src src; 
				    emit ", "; 
				    emit_dst dst;
                                };

			    i::FCMP { i, fsize, lsrc, rsrc }
                                => 
			        {   if (i)   emit "fcmpi";
				    else     emit "fcmp";
                                    fi; 

				    emit_fsize fsize; 
				    emit "\t"; 
				    emit_lsrc lsrc; 
				    emit ", "; 
				    emit_rsrc rsrc;
                                };

			    i::SAHF => emit "sahf";
			    i::LAHF => emit "lahf";
			    i::SOURCE { } => emit "source";
			    i::SINK { } => emit "sink";
			    i::PHI { } => emit "phi";
			esac;

		    tab ();
                    emit_instruction' instruction;
                    nl ();
	        }						# fun emitter 

	   also
	   fun emit_instr_indented i
               =
               {   indent();
                   emit_instruction i;
                   nl();
               }

	   also
	   fun emit_instrs instrs
               =
	       apply (if *indent_copies  emit_instr_indented;
		     else emit_instruction;fi) instrs

	   also
	   fun emit_instruction (i::NOTE { instruction, note } )
                   =>
		   {   emit_comment (note::to_string note);
		       nl();
		       emit_instruction instruction;
                   };

	       emit_instruction (i::LIVE { regs, spilled } )
                   => 
		   emit_comment("live= " + cells_basis::cell_set::to_string regs +
			 "spilled= " + cells_basis::cell_set::to_string spilled);

	       emit_instruction (i::DEAD { regs, spilled } )
                   => 
		   emit_comment("dead= " + cells_basis::cell_set::to_string regs +
			 "spilled= " + cells_basis::cell_set::to_string spilled);

	       emit_instruction (i::BASE_INSTRUCTION i)
                   =>
                   emitter i;

	       emit_instruction (i::COPY { kind=>cells_basis::REGISTER, size_in_bits, src, dst, tmp } )
                   =>
		   emit_instrs (shuffle::shuffle { tmp, src, dst } );

	       emit_instruction (i::COPY { kind=>cells_basis::FLOAT_REGISTER, size_in_bits, src, dst, tmp } )
                   =>
		   emit_instrs (shuffle::shufflefp { tmp, src, dst } );

	       emit_instruction _
                   =>
                   error "emitInstr";
	 end;

	  s::STREAM { begin_cluster=>init,
		      emit_pseudo_op,
		      emit => emit_instruction,
		      end_cluster=>fail,
		      define_local_label,
		      define_global_label,
		      emit_comment,
		      end_procedure => do_nothing,
		      add_note,
		      get_notes
		    };
	};
};

