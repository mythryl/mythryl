## instruction-set-x86-g.pkg
#
# WARNING: This file was automatically generated by mdl_g (v3.0)
# from the machine description file "x86/x86.mdl".
# DO NOT EDIT this file directly

# Compiled by:
#     src/lib/compiler/backend/lower/make7/ia32.make6

# We are invoked from:
# 
#     src/lib/compiler/codegen/x86/x86-codetree.pkg

generic package instruction_set_x86_g (

    codetree: Codetree					# Codetree		is from   src/lib/compiler/backend/lower/codetree/codetree.api
)

: (weak) Instruction_Set_X86				# Instruction_Set_X86	is from   src/lib/compiler/backend/lower/x86/instruction/instruction-set-x86.api

{
    package codetree = codetree;
    package t        = codetree;

    package cells = x86cells;				# x86cells		is from   src/lib/compiler/backend/lower/x86/instruction/x86-cells.pkg
    package cb= cells_basis;				# cells_basis		is from   src/lib/compiler/backend/lower/instruction/cells-basis.pkg
    package region = t::region;
    package constant = t::constant;

    Operand
      = IMMED  int32::Int
      | IMMED_LABEL  t::Labexp
      | RELATIVE  Int
      | LABEL_EA  t::Labexp
      | DIRECT  cells_basis::Cell
      | FDIRECT  cells_basis::Cell
      | FPR  cells_basis::Cell
      | ST  cells_basis::Cell
      | MEM_REG  cells_basis::Cell
      | DISPLACE  { base: cells_basis::Cell, disp: Operand, mem: region::Region }
      | INDEXED  { base: Null_Or( (cells_basis::Cell) ), index: cells_basis::Cell, scale: Int, 
	   disp: Operand, mem: region::Region };
       Addressing_Mode = Operand;

    Ea = Operand;

    Cond
      = EQ
      | NE
      | LT
      | LE
      | GT
      | GE
      | BB
      | BE
      | AA
      | AE
      | CC
      | NC
      | PP
      | NP
      | OO
      | NO;

    Binary_Op
      = ADDL
      | SUBL
      | ANDL
      | ORL
      | XORL
      | SHLL
      | SARL
      | SHRL
      | MULL
      | IMULL
      | ADCL
      | SBBL
      | ADDW
      | SUBW
      | ANDW
      | ORW
      | XORW
      | SHLW
      | SARW
      | SHRW
      | MULW
      | IMULW
      | ADDB
      | SUBB
      | BITWISEAND
      | BITWISEOR
      | BITWISEXOR
      | SHLB
      | SARB
      | SHRB
      | MULB
      | IMULB
      | BTSW
      | BTCW
      | BTRW
      | BTSL
      | BTCL
      | BTRL
      | ROLW
      | RORW
      | ROLL
      | RORL
      | XCHGB
      | XCHGW
      | XCHGL
      | LOCK_ADCW
      | LOCK_ADCL
      | LOCK_ADDW
      | LOCK_ADDL
      | LOCK_ANDW
      | LOCK_ANDL
      | LOCK_BTSW
      | LOCK_BTSL
      | LOCK_BTRW
      | LOCK_BTRL
      | LOCK_BTCW
      | LOCK_BTCL
      | LOCK_ORW
      | LOCK_ORL
      | LOCK_SBBW
      | LOCK_SBBL
      | LOCK_SUBW
      | LOCK_SUBL
      | LOCK_XORW
      | LOCK_XORL
      | LOCK_XADDB
      | LOCK_XADDW
      | LOCK_XADDL;

    Mult_Div_Op
      = IMULL1
      | MULL1
      | IDIVL1
      | DIVL1;

    Unary_Op
      = DECL
      | INCL
      | NEGL
      | NOTL
      | DECW
      | INCW
      | NEGW
      | NOTW
      | DECB
      | INCB
      | NEGB
      | NOTB
      | LOCK_DECL
      | LOCK_INCL
      | LOCK_NEGL
      | LOCK_NOTL;

    Shift_Op
      = SHLDL
      | SHRDL;

    Bit_Op
      = BTW
      | BTL
      | LOCK_BTW
      | LOCK_BTL;

    Move
      = MOVL
      | MOVB
      | MOVW
      | MOVSWL
      | MOVZWL
      | MOVSBL
      | MOVZBL;

    Fbin_Op
      = FADDP
      | FADDS
      | FMULP
      | FMULS
      | FCOMS
      | FCOMPS
      | FSUBP
      | FSUBS
      | FSUBRP
      | FSUBRS
      | FDIVP
      | FDIVS
      | FDIVRP
      | FDIVRS
      | FADDL
      | FMULL
      | FCOML
      | FCOMPL
      | FSUBL
      | FSUBRL
      | FDIVL
      | FDIVRL;

    Fibin_Op
      = FIADDS
      | FIMULS
      | FICOMS
      | FICOMPS
      | FISUBS
      | FISUBRS
      | FIDIVS
      | FIDIVRS
      | FIADDL
      | FIMULL
      | FICOML
      | FICOMPL
      | FISUBL
      | FISUBRL
      | FIDIVL
      | FIDIVRL;

    Fun_Op
      = FCHS
      | FABS
      | FTST
      | FXAM
      | FPTAN
      | FPATAN
      | FXTRACT
      | FPREM1
      | FDECSTP
      | FINCSTP
      | FPREM
      | FYL2XP1
      | FSQRT
      | FSINCOS
      | FRNDINT
      | FSCALE
      | FSIN
      | FCOS;

    Fenv_Op
      = FLDENV
      | FNLDENV
      | FSTENV
      | FNSTENV;

    Fsize
      = FP32
      | FP64
      | FP80;

    Isize
      = INT8
      | INT16
      | INT32
      | INT64;

    Base_Instruction
      = NOP
      | JMP  (Operand, List( label::Label ))
      | JCC  { cond: Cond, operand: Operand }
      | CALL  { operand: Operand, defs: cells::Cellset, uses: cells::Cellset, return: cells::Cellset, 
	   cuts_to: List( label::Label ), mem: region::Region, pops: int32::Int }
      | ENTER  { src1: Operand, src2: Operand }
      | LEAVE
      | RET  Null_Or( Operand )
      | MOVE  { mv_op: Move, src: Operand, dst: Operand }
      | LEA  { r32: cells_basis::Cell, address: Operand }
      | CMPL  { lsrc: Operand, rsrc: Operand }
      | CMPW  { lsrc: Operand, rsrc: Operand }
      | CMPB  { lsrc: Operand, rsrc: Operand }
      | TESTL  { lsrc: Operand, rsrc: Operand }
      | TESTW  { lsrc: Operand, rsrc: Operand }
      | TESTB  { lsrc: Operand, rsrc: Operand }
      | BITOP  { bit_op: Bit_Op, lsrc: Operand, rsrc: Operand }
      | BINARY  { bin_op: Binary_Op, src: Operand, dst: Operand }
      | SHIFT  { shift_op: Shift_Op, src: Operand, dst: Operand, count: Operand }
      | CMPXCHG  { lock: Bool, size: Isize, src: Operand, dst: Operand }
      | MULTDIV  { mult_div_op: Mult_Div_Op, src: Operand }
      | MUL3  { dst: cells_basis::Cell, src2: int32::Int, src1: Operand }
      | UNARY  { un_op: Unary_Op, operand: Operand }
      | SET  { cond: Cond, operand: Operand }
      | CMOV  { cond: Cond, src: Operand, dst: cells_basis::Cell }
      | PUSHL  Operand
      | PUSHW  Operand
      | PUSHB  Operand
      | PUSHFD
      | POPFD
      | POP  Operand
      | CDQ
      | INTO
      | FBINARY  { bin_op: Fbin_Op, src: Operand, dst: Operand }
      | FIBINARY  { bin_op: Fibin_Op, src: Operand }
      | FUNARY  Fun_Op
      | FUCOM  Operand
      | FUCOMP  Operand
      | FUCOMPP
      | FCOMPP
      | FCOMI  Operand
      | FCOMIP  Operand
      | FUCOMI  Operand
      | FUCOMIP  Operand
      | FXCH  { operand: cells_basis::Cell }
      | FSTPL  Operand
      | FSTPS  Operand
      | FSTPT  Operand
      | FSTL  Operand
      | FSTS  Operand
      | FLD1
      | FLDL2E
      | FLDL2T
      | FLDLG2
      | FLDLN2
      | FLDPI
      | FLDZ
      | FLDL  Operand
      | FLDS  Operand
      | FLDT  Operand
      | FILD  Operand
      | FILDL  Operand
      | FILDLL  Operand
      | FNSTSW
      | FENV     { fenv_op: Fenv_Op, operand: Operand }
      | FMOVE    { fsize:   Fsize,   src:     Operand,   dst:  Operand }
      | FILOAD   { isize:   Isize,   ea:      Operand,   dst:  Operand }
      | FBINOP   { fsize:   Fsize,   bin_op:  Fbin_Op,   lsrc: Operand,  rsrc: Operand,  dst: Operand }
      | FIBINOP  { isize:   Isize,   bin_op:  Fibin_Op,  lsrc: Operand,  rsrc: Operand,  dst: Operand }
      | FUNOP    { fsize:   Fsize,   un_op:   Fun_Op,    src:  Operand,  dst:  Operand }
      | FCMP     { i:       Bool,    fsize:   Fsize,     lsrc: Operand,  rsrc: Operand }
      | SAHF
      | LAHF
      | SOURCE  { }
      | SINK  { }
      | PHI  { }

    also
    Instruction
	= LIVE  { regs: cells::Cellset, spilled: cells::Cellset }
	| DEAD  { regs: cells::Cellset, spilled: cells::Cellset }
	| COPY  { kind: cells_basis::Cellkind, 
		  size_in_bits: Int,          #  in bits 
		  dst: List( cells_basis::Cell ),
		  src: List( cells_basis::Cell ),
		  tmp: Null_Or(  Ea ) /* NULL if |dst| == { src| == 1 */
		}
	| NOTE  { instruction: Instruction,
                  note:        note::Note
                }
	| BASE_INSTRUCTION  Base_Instruction
        ;

    nop     = BASE_INSTRUCTION NOP;

    jmp     = BASE_INSTRUCTION o JMP;
    jcc     = BASE_INSTRUCTION o JCC;
    call    = BASE_INSTRUCTION o CALL;
    ret     = BASE_INSTRUCTION o RET;

    enter   = BASE_INSTRUCTION o ENTER;
    leave   = BASE_INSTRUCTION LEAVE;

    move    = BASE_INSTRUCTION o MOVE;
    lea     = BASE_INSTRUCTION o LEA;

    cmpl    = BASE_INSTRUCTION o CMPL;
    cmpw    = BASE_INSTRUCTION o CMPW;
    cmpb    = BASE_INSTRUCTION o CMPB;

    testl   = BASE_INSTRUCTION o TESTL;
    testw   = BASE_INSTRUCTION o TESTW;
    testb   = BASE_INSTRUCTION o TESTB;

    bitop   = BASE_INSTRUCTION o BITOP;
    binary  = BASE_INSTRUCTION o BINARY;

    shift   = BASE_INSTRUCTION o SHIFT;
    cmpxchg = BASE_INSTRUCTION o CMPXCHG;

    multdiv = BASE_INSTRUCTION o MULTDIV;
    mul3    = BASE_INSTRUCTION o MUL3;
    unary   = BASE_INSTRUCTION o UNARY;

    set     = BASE_INSTRUCTION o SET;
    cmov    = BASE_INSTRUCTION o CMOV;

    pushl   = BASE_INSTRUCTION o PUSHL;
    pushw   = BASE_INSTRUCTION o PUSHW;
    pushb   = BASE_INSTRUCTION o PUSHB;

    pushfd  = BASE_INSTRUCTION PUSHFD;
    popfd   = BASE_INSTRUCTION POPFD;
    pop     = BASE_INSTRUCTION o POP;

    cdq     = BASE_INSTRUCTION CDQ;
    into    = BASE_INSTRUCTION INTO;
    fbinary = BASE_INSTRUCTION o FBINARY;

    fibinary = BASE_INSTRUCTION o FIBINARY;

    funary  = BASE_INSTRUCTION o FUNARY;
    fucom   = BASE_INSTRUCTION o FUCOM;
    fucomp  = BASE_INSTRUCTION o FUCOMP;

    fucompp = BASE_INSTRUCTION FUCOMPP;
    fcompp  = BASE_INSTRUCTION FCOMPP;

    fcomi   = BASE_INSTRUCTION o FCOMI;
    fcomip  = BASE_INSTRUCTION o FCOMIP;

    fucomi  = BASE_INSTRUCTION o FUCOMI;
    fucomip = BASE_INSTRUCTION o FUCOMIP;

    fxch    = BASE_INSTRUCTION o FXCH;
    fstpl   = BASE_INSTRUCTION o FSTPL;

    fstps   = BASE_INSTRUCTION o FSTPS;
    fstpt   = BASE_INSTRUCTION o FSTPT;

    fstl    = BASE_INSTRUCTION o FSTL;
    fsts    = BASE_INSTRUCTION o FSTS;

    fld1    = BASE_INSTRUCTION FLD1;

    fldl2e  = BASE_INSTRUCTION FLDL2E;
    fldl2t  = BASE_INSTRUCTION FLDL2T;

    fldlg2  = BASE_INSTRUCTION FLDLG2;
    fldln2  = BASE_INSTRUCTION FLDLN2;

    fldpi   = BASE_INSTRUCTION FLDPI;
    fldz    = BASE_INSTRUCTION FLDZ;

    fldl    = BASE_INSTRUCTION o FLDL;
    flds    = BASE_INSTRUCTION o FLDS;

    fldt    = BASE_INSTRUCTION o FLDT;
    fild    = BASE_INSTRUCTION o FILD;

    fildl   = BASE_INSTRUCTION o FILDL;
    fildll  = BASE_INSTRUCTION o FILDLL;

    fnstsw  = BASE_INSTRUCTION FNSTSW;
    fenv    = BASE_INSTRUCTION o FENV;

    fmove   = BASE_INSTRUCTION o FMOVE;
    fiload  = BASE_INSTRUCTION o FILOAD;

    fbinop  = BASE_INSTRUCTION o FBINOP;
    fibinop = BASE_INSTRUCTION o FIBINOP;

    funop   = BASE_INSTRUCTION o FUNOP;
    fcmp    = BASE_INSTRUCTION o FCMP;

    sahf    = BASE_INSTRUCTION SAHF;
    lahf    = BASE_INSTRUCTION LAHF;

    source  = BASE_INSTRUCTION o SOURCE;
    sink    = BASE_INSTRUCTION o SINK;
    phi     = BASE_INSTRUCTION o PHI;
};

