## instruction-set-x86.api
#
# WARNING: This file was automatically generated by mdl_g (v3.0)
# from the machine description file "x86/x86.mdl".
# DO NOT EDIT this file directly

# Compiled by:
#     src/lib/compiler/backend/lower/make7/ia32.make6


api Instruction_Set_X86 {

    package cells:  Xy86Cells;				# Xy86Cells	is from   src/lib/compiler/backend/lower/x86/instruction/x86-cells.pkg

    package cb:  Cells_Basis				# Cells_Basis	is from   src/lib/compiler/backend/lower/instruction/cells-basis.api
	=
	cells_basis;

    package codetree:  Codetree;			# Codetree	is from   src/lib/compiler/backend/lower/codetree/codetree.api
    package constant:  Constant;			# Constant	is from   src/lib/compiler/backend/lower/instruction/constant.api

    package region:    Region;				# Region	is from   src/lib/compiler/backend/lower/instruction/region.api

    sharing constant == codetree::constant;
    sharing region   == codetree::region;

    Operand
	= IMMED  int32::Int
	| IMMED_LABEL  codetree::Labexp
	| RELATIVE  Int
	| LABEL_EA  codetree::Labexp
	| DIRECT    cells_basis::Cell
	| FDIRECT   cells_basis::Cell
	| FPR       cells_basis::Cell
	| ST        cells_basis::Cell
	| MEM_REG   cells_basis::Cell
	| DISPLACE  { base: cells_basis::Cell, disp: Operand, mem: region::Region }
	| INDEXED  { base: Null_Or( (cells_basis::Cell) ),
                     index: cells_basis::Cell,
                     scale: Int, 
	             disp: Operand,
                     mem: region::Region
                   }
        ;

    Addressing_Mode = Operand;
    Ea = Operand;

    Cond
       = EQ
       | NE
       | LT
       | LE
       | GT
       | GE
       | BB
       | BE
       | AA
       | AE
       | CC
       | NC
       | PP
       | NP
       | OO
       | NO
       ;

    Binary_Op
      = ADDL
      | SUBL
      | ANDL
      | ORL
      | XORL
      | SHLL
      | SARL
      | SHRL
      | MULL
      | IMULL
      | ADCL
      | SBBL
      | ADDW
      | SUBW
      | ANDW
      | ORW
      | XORW
      | SHLW
      | SARW
      | SHRW
      | MULW
      | IMULW
      | ADDB
      | SUBB
      | BITWISEAND
      | BITWISEOR
      | BITWISEXOR
      | SHLB
      | SARB
      | SHRB
      | MULB
      | IMULB
      | BTSW
      | BTCW
      | BTRW
      | BTSL
      | BTCL
      | BTRL
      | ROLW
      | RORW
      | ROLL
      | RORL
      | XCHGB
      | XCHGW
      | XCHGL
      | LOCK_ADCW
      | LOCK_ADCL
      | LOCK_ADDW
      | LOCK_ADDL
      | LOCK_ANDW
      | LOCK_ANDL
      | LOCK_BTSW
      | LOCK_BTSL
      | LOCK_BTRW
      | LOCK_BTRL
      | LOCK_BTCW
      | LOCK_BTCL
      | LOCK_ORW
      | LOCK_ORL
      | LOCK_SBBW
      | LOCK_SBBL
      | LOCK_SUBW
      | LOCK_SUBL
      | LOCK_XORW
      | LOCK_XORL
      | LOCK_XADDB
      | LOCK_XADDW
      | LOCK_XADDL
      ;

    Mult_Div_Op
      = IMULL1
      | MULL1
      | IDIVL1
      | DIVL1
      ;

    Unary_Op
      = DECL
      | INCL
      | NEGL
      | NOTL
      | DECW
      | INCW
      | NEGW
      | NOTW
      | DECB
      | INCB
      | NEGB
      | NOTB
      | LOCK_DECL
      | LOCK_INCL
      | LOCK_NEGL
      | LOCK_NOTL
      ;

    Shift_Op
      = SHLDL
      | SHRDL
      ;

    Bit_Op
      = BTW
      | BTL
      | LOCK_BTW
      | LOCK_BTL
      ;

    Move
      = MOVL
      | MOVB
      | MOVW
      | MOVSWL
      | MOVZWL
      | MOVSBL
      | MOVZBL
      ;

    Fbin_Op
      = FADDP
      | FADDS
      | FMULP
      | FMULS
      | FCOMS
      | FCOMPS
      | FSUBP
      | FSUBS
      | FSUBRP
      | FSUBRS
      | FDIVP
      | FDIVS
      | FDIVRP
      | FDIVRS
      | FADDL
      | FMULL
      | FCOML
      | FCOMPL
      | FSUBL
      | FSUBRL
      | FDIVL
      | FDIVRL
      ;

    Fibin_Op
      = FIADDS
      | FIMULS
      | FICOMS
      | FICOMPS
      | FISUBS
      | FISUBRS
      | FIDIVS
      | FIDIVRS
      | FIADDL
      | FIMULL
      | FICOML
      | FICOMPL
      | FISUBL
      | FISUBRL
      | FIDIVL
      | FIDIVRL
      ;

    Fun_Op
      = FCHS
      | FABS
      | FTST
      | FXAM
      | FPTAN
      | FPATAN
      | FXTRACT
      | FPREM1
      | FDECSTP
      | FINCSTP
      | FPREM
      | FYL2XP1
      | FSQRT
      | FSINCOS
      | FRNDINT
      | FSCALE
      | FSIN
      | FCOS
      ;

    Fenv_Op
      = FLDENV
      | FNLDENV
      | FSTENV
      | FNSTENV
      ;

    Fsize
      = FP32
      | FP64
      | FP80
      ;

    Isize
      = INT8
      | INT16
      | INT32
      | INT64
      ;

    Base_Instruction
      = NOP
      | JMP  (Operand, List( label::Label ))
      | JCC  { cond: Cond, operand: Operand }
      | CALL  { operand: Operand, defs: cells::Cellset, uses: cells::Cellset, return: cells::Cellset, 
	   cuts_to: List( label::Label ), mem: region::Region, pops: int32::Int }
      | ENTER  { src1: Operand, src2: Operand }
      | LEAVE
      | RET  Null_Or( Operand )
      | MOVE  { mv_op: Move, src: Operand, dst: Operand }
      | LEA  { r32: cells_basis::Cell, address: Operand }
      | CMPL  { lsrc: Operand, rsrc: Operand }
      | CMPW  { lsrc: Operand, rsrc: Operand }
      | CMPB  { lsrc: Operand, rsrc: Operand }
      | TESTL  { lsrc: Operand, rsrc: Operand }
      | TESTW  { lsrc: Operand, rsrc: Operand }
      | TESTB  { lsrc: Operand, rsrc: Operand }
      | BITOP  { bit_op: Bit_Op, lsrc: Operand, rsrc: Operand }
      | BINARY  { bin_op: Binary_Op, src: Operand, dst: Operand }
      | SHIFT  { shift_op: Shift_Op, src: Operand, dst: Operand, count: Operand }
      | CMPXCHG  { lock: Bool, size: Isize, src: Operand, dst: Operand }
      | MULTDIV  { mult_div_op: Mult_Div_Op, src: Operand }
      | MUL3  { dst: cells_basis::Cell, src2: int32::Int, src1: Operand }
      | UNARY  { un_op: Unary_Op, operand: Operand }
      | SET  { cond: Cond, operand: Operand }
      | CMOV  { cond: Cond, src: Operand, dst: cells_basis::Cell }
      | PUSHL  Operand
      | PUSHW  Operand
      | PUSHB  Operand
      | PUSHFD
      | POPFD
      | POP  Operand
      | CDQ
      | INTO
      | FBINARY  { bin_op: Fbin_Op, src: Operand, dst: Operand }
      | FIBINARY  { bin_op: Fibin_Op, src: Operand }
      | FUNARY  Fun_Op
      | FUCOM  Operand
      | FUCOMP  Operand
      | FUCOMPP
      | FCOMPP
      | FCOMI  Operand
      | FCOMIP  Operand
      | FUCOMI  Operand
      | FUCOMIP  Operand
      | FXCH  { operand: cells_basis::Cell }
      | FSTPL  Operand
      | FSTPS  Operand
      | FSTPT  Operand
      | FSTL  Operand
      | FSTS  Operand
      | FLD1
      | FLDL2E
      | FLDL2T
      | FLDLG2
      | FLDLN2
      | FLDPI
      | FLDZ
      | FLDL  Operand
      | FLDS  Operand
      | FLDT  Operand
      | FILD  Operand
      | FILDL  Operand
      | FILDLL  Operand
      | FNSTSW
      | FENV  { fenv_op: Fenv_Op, operand: Operand }
      | FMOVE  { fsize: Fsize, src: Operand, dst: Operand }
      | FILOAD  { isize: Isize, ea: Operand, dst: Operand }
      | FBINOP  { fsize: Fsize, bin_op: Fbin_Op, lsrc: Operand, rsrc: Operand, dst: Operand }
      | FIBINOP  { isize: Isize, bin_op: Fibin_Op, lsrc: Operand, rsrc: Operand, dst: Operand }
      | FUNOP  { fsize: Fsize, un_op: Fun_Op, src: Operand, dst: Operand }
      | FCMP  { i: Bool, fsize: Fsize, lsrc: Operand, rsrc: Operand }
      | SAHF
      | LAHF
      | SOURCE  { }
      | SINK  { }
      | PHI  { }

    also
    Instruction
      = LIVE  { regs: cells::Cellset, spilled: cells::Cellset }
      | DEAD  { regs: cells::Cellset, spilled: cells::Cellset }
      | COPY  { kind: cells_basis::Cellkind, 
		size_in_bits: Int,          #  in bits 
		dst: List( cells_basis::Cell ),
		src: List( cells_basis::Cell ),
		tmp: Null_Or(  Ea ) /* NULL if |dst| == { src| == 1 */
	      }
      | NOTE  { instruction: Instruction,
		note:        note::Note
	      }
      | BASE_INSTRUCTION  Base_Instruction
      ;


    nop:  Instruction;
    jmp:  (Operand, List( label::Label )) -> Instruction;

    jcc:  { cond: Cond, operand: Operand } -> Instruction;
    call:  { operand: Operand, defs: cells::Cellset, uses: cells::Cellset, return: cells::Cellset, 

    cuts_to: List( label::Label ), mem: region::Region, pops: int32::Int } -> Instruction;

    enter:  { src1: Operand, src2: Operand } -> Instruction;
    leave:  Instruction;

    ret:   Null_Or( Operand ) -> Instruction;

    move:   { mv_op: Move, src: Operand, dst: Operand } -> Instruction;
    lea:    { r32: cells_basis::Cell, address: Operand } -> Instruction;

    cmpl:   { lsrc: Operand, rsrc: Operand } -> Instruction;
    cmpw:   { lsrc: Operand, rsrc: Operand } -> Instruction;
    cmpb:   { lsrc: Operand, rsrc: Operand } -> Instruction;

    testl:  { lsrc: Operand, rsrc: Operand } -> Instruction;
    testw:  { lsrc: Operand, rsrc: Operand } -> Instruction;
    testb:  { lsrc: Operand, rsrc: Operand } -> Instruction;

    bitop:  { bit_op: Bit_Op, lsrc: Operand, rsrc: Operand } -> Instruction;
    binary: { bin_op: Binary_Op, src: Operand, dst: Operand } -> Instruction;
    shift:  { shift_op: Shift_Op, src: Operand, dst: Operand, count: Operand } -> Instruction;

    cmpxchg:  { lock: Bool, size: Isize, src: Operand, dst: Operand } -> Instruction;
    multdiv:  { mult_div_op: Mult_Div_Op, src: Operand } -> Instruction;

    mul3:  { dst: cells_basis::Cell, src2: int32::Int, src1: Operand } -> Instruction;
    unary: { un_op: Unary_Op, operand: Operand } -> Instruction;
    set:   { cond: Cond, operand: Operand } -> Instruction;
    cmov:  { cond: Cond, src: Operand, dst: cells_basis::Cell } -> Instruction;

    pushl:  Operand -> Instruction;
    pushw:  Operand -> Instruction;
    pushb:  Operand -> Instruction;
    pop:    Operand -> Instruction;

    pushfd: Instruction;
    popfd:  Instruction;

    cdq:   Instruction;
    into:  Instruction;

    fbinary:   { bin_op: Fbin_Op, src: Operand, dst: Operand } -> Instruction;
    fibinary:  { bin_op: Fibin_Op, src: Operand } -> Instruction;

    funary:  Fun_Op -> Instruction;

    fucom:   Operand -> Instruction;
    fucomp:  Operand -> Instruction;

    fucompp: Instruction;
    fcompp:  Instruction;

    fcomi:    Operand -> Instruction;
    fcomip:   Operand -> Instruction;
    fucomi:   Operand -> Instruction;
    fucomip:  Operand -> Instruction;

    fxch:  { operand: cells_basis::Cell } -> Instruction;

    fstpl:  Operand -> Instruction;
    fstps:  Operand -> Instruction;
    fstpt:  Operand -> Instruction;
    fstl:   Operand -> Instruction;
    fsts:   Operand -> Instruction;

    fld1:    Instruction;
    fldl2e:  Instruction;
    fldl2t:  Instruction;
    fldlg2:  Instruction;
    fldln2:  Instruction;
    fldpi:   Instruction;
    fldz:    Instruction;

    fldl:    Operand -> Instruction;
    flds:    Operand -> Instruction;
    fldt:    Operand -> Instruction;
    fild:    Operand -> Instruction;
    fildl:   Operand -> Instruction;
    fildll:  Operand -> Instruction;

    fnstsw:  Instruction;

    fenv:    { fenv_op: Fenv_Op, operand: Operand } -> Instruction;
    fmove:   { fsize: Fsize, src: Operand, dst: Operand } -> Instruction;
    fiload:  { isize: Isize, ea: Operand, dst: Operand } -> Instruction;
    fbinop:  { fsize: Fsize, bin_op: Fbin_Op, lsrc: Operand, rsrc: Operand, dst: Operand } -> Instruction;
    fibinop: { isize: Isize, bin_op: Fibin_Op, lsrc: Operand, rsrc: Operand, dst: Operand } -> Instruction;
    funop:   { fsize: Fsize, un_op: Fun_Op, src: Operand, dst: Operand } -> Instruction;
    fcmp:    { i: Bool, fsize: Fsize, lsrc: Operand, rsrc: Operand } -> Instruction;

    sahf:  Instruction;
    lahf:  Instruction;

    source:  { } -> Instruction;
    sink:    { } -> Instruction;
    phi:     { } -> Instruction;
};

