# WARNING: this is generated by running 'nowhere x86Peephole.peep'.
# Do not edit this file directly.
# Version 1.2.2

# Compiled by:
#     src/lib/compiler/backend/lower/make7/ia32-peephole.make6


###line 20.1 "x86Peephole::peep"
generic package x86_peephole_g(
###line 21.5 "x86Peephole::peep"
                    package instruction_set:  Instruction_Set_X86;			# Instruction_Set_X86	is from   src/lib/compiler/backend/lower/x86/instruction/instruction-set-x86.api

###line 22.5 "x86Peephole::peep"
                    package eval:  Codetree_Eval;					# Codetree_Eval		is from   src/lib/compiler/backend/lower/codetree/codetree-eval.api

###line 23.7 "x86Peephole::peep"
                    sharing instruction_set::codetree == eval::codetree;
)

: (weak) Peephole									# Peephole		is from   src/lib/compiler/backend/lower/instruction/peephole.api

{
  
###line 26.4 "x86Peephole::peep"
   package instruction_set = instruction_set;
   package cells           = instruction_set::cells;

   package i               = instruction_set;

###line 27.4 "x86Peephole::peep"
   package c = cells;

###line 28.4 "x86Peephole::peep"
   package cbase= cells_basis;	# cells_basis	is from   src/lib/compiler/backend/lower/instruction/cells-basis.pkg

###line 31.4 "x86Peephole::peep"
   fun peephole instrs = 
       { 
###line 32.8 "x86Peephole::peep"
           fun is_stack_ptr (i::DIRECT r) => cbase::same_color (r, c::esp);
              is_stack_ptr _ => FALSE; end;

###line 35.8 "x86Peephole::peep"
           fun is_zero_le le = (((eval::value_of le) == 0) except _ => FALSE; end 
);

###line 37.8 "x86Peephole::peep"
           fun is_zero (i::IMMED n)   =>   n == 0;
              is_zero (i::IMMED_LABEL le) => is_zero_le le;
              is_zero _ => FALSE; end;

###line 41.8 "x86Peephole::peep"
           fun is_zero_opt NULL => TRUE;
              is_zero_opt (THE opn) => is_zero opn; end;

###line 44.8 "x86Peephole::peep"
           fun loop (code, instrs) = 
               { v_34 = code;
                   fun state_9 (v_0, v_3) = 
                       { i = v_0;
                         rest = v_3;
                        loop (rest, i ! instrs);
                       };
                   fun state_22 (v_0, v_17, v_3) = 
                       { le = v_17;
                         rest = v_3;
                        (if ((is_zero_le le))
                                  (loop (rest, instrs));
                             else (state_9 (v_0, v_3));fi);
                       };
                   fun state_51 (v_0, v_1, v_2, v_3) = 
                       (case v_1   
                         i::DIRECT v_26 => 
                         { dst = v_1;
                           rest = v_3;
                           src = v_2;
                          (if ((is_zero src))
                                    (loop (rest, (i::binary { bin_op=>i::XORL, src=>dst, dst } ) ! instrs));
                               else (state_9 (v_0, v_3));fi);
                         };
                        _ => state_9 (v_0, v_3); esac
                       );
                
                  (case v_34   
                    (!) v_33 => 
                    { my (v_0, v_3) = v_33;
                     
                       (case v_0   
                         i::BASE_INSTRUCTION v_32 => 
                         (case v_32   
                           i::BINARY v_19 => 
                           { my { bin_op=>v_31, dst=>v_1, src=>v_2, ... } = v_19;
                            
                              (case v_31   
                                i::ADDL => 
                                (case v_2   
                                  i::IMMED v_17 => 
                                  (case v_1   
                                    i::DIRECT v_26 => 
                                    (case v_3   
                                      (!) v_14 => 
                                      { my (v_13, v_4) = v_14;
                                       
                                         (case v_13   
                                           i::BASE_INSTRUCTION v_12 => 
                                           (case v_12   
                                             i::BINARY v_11 => 
                                             { my { bin_op=>v_10, dst=>v_9, src=>v_8, ... } = v_11;
                                              
                                                (case v_10   
                                                  i::SUBL => 
                                                  (case v_9   
                                                    i::DIRECT v_5 => 
                                                    (case v_8   
                                                      i::IMMED v_7 => 
                                                      { d_i = v_26;
                                                          d_j = v_5;
                                                          m = v_7;
                                                          n = v_17;
                                                          rest = v_4;
                                                       (if (((cbase::same_color (d_i, c::esp)) and (cbase::same_color (d_j, c::esp))))
                                                                 (if ((m == n))
                                                                    (loop (rest, instrs));
                                                               else (if ((m < n))
                                                                       (loop (rest, (i::binary { bin_op=>i::ADDL, src=>i::IMMED (n - m), dst=>i::DIRECT c::esp } ) ! instrs));
                                                                  else (loop (rest, (i::binary { bin_op=>i::SUBL, src=>i::IMMED (m - n), dst=>i::DIRECT c::esp } ) ! instrs));fi);fi);
                                                            else (state_9 (v_0, v_3));fi);
                                                      };
                                                     _ => state_9 (v_0, v_3); esac
                                                    );
                                                   _ => state_9 (v_0, v_3); esac
                                                  );
                                                 _ => state_9 (v_0, v_3); esac
                                                );
                                             };
                                            _ => state_9 (v_0, v_3); esac
                                           );
                                          _ => state_9 (v_0, v_3); esac
                                         );
                                      };
                                     NIL => state_9 (v_0, v_3); esac
                                    );
                                   _ => state_9 (v_0, v_3); esac
                                  );
                                 i::IMMED_LABEL v_17 => state_22 (v_0, v_17, v_3);
                                 _ => state_9 (v_0, v_3); esac
                                );
                               i::SUBL => 
                                (case v_2   
                                  i::IMMED v_17 => 
                                  (case v_1   
                                    i::DIRECT v_26 => 
                                    (case v_17   
                                      4 => 
                                      (case v_3   
                                        (!) v_14 => 
                                        { my (v_13, v_4) = v_14;
                                         
                                           (case v_13   
                                             i::BASE_INSTRUCTION v_12 => 
                                             (case v_12   
                                               i::MOVE v_11 => 
                                               { my { dst=>v_9, mv_op=>v_28, src=>v_8, ... } = v_11;
                                                
                                                  (case v_9   
                                                    i::DISPLACE v_5 => 
                                                    { my { base=>v_27, disp=>v_30, ... } = v_5;
                                                     
                                                       (case v_30   
                                                         i::IMMED v_29 => 
                                                         (case v_29   
                                                           0 => 
                                                           (case v_28   
                                                             i::MOVL => 
                                                             { base = v_27;
                                                                 dst_i = v_26;
                                                                 rest = v_4;
                                                                 src = v_8;
                                                              (if ((((cbase::same_color (base, c::esp)) and (cbase::same_color (dst_i, c::esp))) and (not (is_stack_ptr src))))
                                                                        (loop (rest, (i::pushl src) ! instrs));
                                                                   else (state_9 (v_0, v_3));fi);
                                                             };
                                                            _ => state_9 (v_0, v_3); esac
                                                           );
                                                          _ => state_9 (v_0, v_3); esac
                                                         );
                                                        _ => state_9 (v_0, v_3); esac
                                                       );
                                                    };
                                                   _ => state_9 (v_0, v_3); esac
                                                  );
                                               };
                                              _ => state_9 (v_0, v_3); esac
                                             );
                                            _ => state_9 (v_0, v_3); esac
                                           );
                                        };
                                       NIL => state_9 (v_0, v_3); esac
                                      );
                                     _ => state_9 (v_0, v_3); esac
                                    );
                                   _ => state_9 (v_0, v_3); esac
                                  );
                                 i::IMMED_LABEL v_17 => state_22 (v_0, v_17, v_3);
                                 _ => state_9 (v_0, v_3); esac
                                );
                               _ => state_9 (v_0, v_3); esac
                              );
                           };
                          i::LEA v_19 => 
                           { my { address=>v_25, r32=>v_20, ... } = v_19;
                            
                              (case v_25   
                                i::DISPLACE v_24 => 
                                { my { base=>v_22, disp=>v_23, ... } = v_24;
                                 
                                   (case v_23   
                                     i::IMMED_LABEL v_21 => 
                                     { base = v_22;
                                         le = v_21;
                                         r32 = v_20;
                                         rest = v_3;
                                      (if (((is_zero_le le) and (cbase::same_color (r32, base))))
                                                (loop (rest, instrs));
                                           else (state_9 (v_0, v_3));fi);
                                     };
                                    _ => state_9 (v_0, v_3); esac
                                   );
                                };
                               _ => state_9 (v_0, v_3); esac
                              );
                           };
                          i::MOVE v_19 => 
                           { my { dst=>v_1, mv_op=>v_18, src=>v_2, ... } = v_19;
                            
                              (case v_18   
                                i::MOVL => 
                                (case v_2   
                                  i::DISPLACE v_17 => 
                                  { my { base=>v_6, disp=>v_16, ... } = v_17;
                                   
                                     (case v_16   
                                       i::IMMED v_15 => 
                                       (case v_15   
                                         0 => 
                                         (case v_3   
                                           (!) v_14 => 
                                           { my (v_13, v_4) = v_14;
                                            
                                              (case v_13   
                                                i::BASE_INSTRUCTION v_12 => 
                                                (case v_12   
                                                  i::BINARY v_11 => 
                                                  { my { bin_op=>v_10, dst=>v_9, src=>v_8, ... } = v_11;
                                                   
                                                     (case v_10   
                                                       i::ADDL => 
                                                       (case v_9   
                                                         i::DIRECT v_5 => 
                                                         (case v_8   
                                                           i::IMMED v_7 => 
                                                           (case v_7   
                                                             4 => 
                                                             { base = v_6;
                                                                 dst = v_1;
                                                                 dst_i = v_5;
                                                                 rest = v_4;
                                                              (if ((((cbase::same_color (base, c::esp)) and (cbase::same_color (dst_i, c::esp))) and (not (is_stack_ptr dst))))
                                                                        (loop (rest, (i::pop dst) ! instrs));
                                                                   else (state_51 (v_0, v_1, v_2, v_3));fi);
                                                             };
                                                            _ => state_51 (v_0, v_1, v_2, v_3); esac
                                                           );
                                                          _ => state_51 (v_0, v_1, v_2, v_3); esac
                                                         );
                                                        _ => state_51 (v_0, v_1, v_2, v_3); esac
                                                       );
                                                      _ => state_51 (v_0, v_1, v_2, v_3); esac
                                                     );
                                                  };
                                                 _ => state_51 (v_0, v_1, v_2, v_3); esac
                                                );
                                               _ => state_51 (v_0, v_1, v_2, v_3); esac
                                              );
                                           };
                                          NIL => state_51 (v_0, v_1, v_2, v_3); esac
                                         );
                                        _ => state_51 (v_0, v_1, v_2, v_3); esac
                                       );
                                      _ => state_51 (v_0, v_1, v_2, v_3); esac
                                     );
                                  };
                                 _ => state_51 (v_0, v_1, v_2, v_3); esac
                                );
                               _ => state_9 (v_0, v_3); esac
                              );
                           };
                          _ => state_9 (v_0, v_3); esac
                         );
                        _ => state_9 (v_0, v_3); esac
                       );
                    };
                   NIL => instrs; esac
                  );
               };
        loop (instrs, []);
       };
};

