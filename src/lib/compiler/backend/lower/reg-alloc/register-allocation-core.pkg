## register-allocation-core.pkg

# Compiled by:
#     src/lib/compiler/backend/lower/make7/lowcode.make6



# Overview
# ========
# This implementation of iterated coalescing differ from the old one in
# various substantial ways:
#
# 1. The move list is prioritized.  Higher ranking moves are coalesced first.
#    This tends to favor coalescing of moves that has higher priority.
#
# 2. The freeze list is prioritized.  Lower ranking nodes are unfrozen
#    first.  Since freeze disable moves, this tends to disable moves
#    of low priority.
#
# 3. The simplify worklist is not kept explicitly during the 
#    simplify/coalesce/freeze phases.  Instead, whenever a non-move
#    related node with degree < K is discovered, we call simplify
#    to remove it from the graph immediately.  
#
#    I think this has a few advantages.
#    (a) There is less bookkeeping.
#    (b) Simplify adds coalescable moves to the move list.
#        By doing simplify eagerly, moves are added to the move list
#        faster, allowing higher ranking moves to ``preempt'' low
#        ranking moves.
#
# 4. Support for register pairs
#
# Important Invariants
# ====================
#   1. Adjacency list
#      a. All nodes on the adjacency list are distinct
#      b. nodes with color ALIASED or REMOVED are NOT consider to be
#         on the adjacency list
#      c. If a node x is COLORED, then we DON'T keep track of 
#         its adjacency list 
#      d. When a node has been removed, there aren't any moves associated
#         with it.    
#   2. Moves
#      a. Moves marked WORKLIST are on the worklist.
#      b. Moves marked MOVE are NOT on the worklist.
#      c. Moves marked LOST are frozen and are in fact never considered again.
#      d. Moves marked CONSTRAINED cannot be coalesced because the src and dst
#         interfere
#      e. Moves marked COALESCED have been coalesced.  
#      f. The movecnt in a node is always the number of nodes 
#         currently marked as WORKLIST or MOVE, i.e. the moves that
#         are associated with the node.  When this is zero, the node is
#         considered to be non-move related.
#      g. Moves on the move worklist are always distinct.
#   3.
#
# Allen.


###           "If you want to build a ship,
###            don't drum up people together
###            to collect wood and don't assign
###            them tasks and work, but rather
###            teach them to long for the endless
###            immensity of the sea."
###
###                -- Antoine de Saint-Exupery


stipulate

   debug = FALSE;
   tally = FALSE; 

herein

    package register_allocation_core

    : (weak)  Register_Allocation_Core					# Register_Allocation_Core	is from   src/lib/compiler/backend/lower/reg-alloc/register-allocation-core.api

    {
	package g= register_allocation_graph;				# register_allocation_graph	is from   src/lib/compiler/backend/lower/reg-alloc/ra-graph.pkg
	package a= rw_vector;						# rw_vector			is from   src/lib/std/src/rw-vector.pkg
	package w= unt;							# unt				is from   src/lib/std/unt.pkg
      #  package w8a  = rw_unt8_vector
	package w8= unt8;						# unt8				is from   src/lib/std/unt8.pkg
	package c= register_allocation_graph::c;			# register_allocation_graph	is from   src/lib/compiler/backend/lower/reg-alloc/ra-graph.pkg

	#  For debugging, uncomment unsafe. 
	package ua   = unsafe::rw_vector; 
	package uw8a= unsafe::rw_unt8_vector;	# unsafe	is from   src/lib/std/src/unsafe/unsafe.pkg

	include g;

	verbose       = low_code_control::make_bool ("verbose", "RA chattiness");

	ra_spill_coalescing
            =
            low_code_control::make_counter (
                "ra_spill_coalescing",
		"RA spill coalescing counter"
            );

	ra_spill_propagation
            =
            low_code_control::make_counter (
                "ra_spill_propagation",
		"RA spill propagation counter"
            );

      /*
	good_briggs   = LowCodeControl::getCounter "good_briggs"
	bad_briggs    = LowCodeControl::getCounter "bad_briggs"
	good_george   = LowCodeControl::getCounter "good_george"
	bad_george    = LowCodeControl::getCounter "bad_george"
	good_freeze   = LowCodeControl::getCounter "good_freeze"
	bad_freeze    = LowCodeControl::getCounter "bad_freeze"
       */

	no_optimization     = 0ux0;
	biased_selection    = 0ux1;
	dead_copy_elim      = 0ux2;
	compute_span        = 0ux4;
	save_copy_temps     = 0ux8; 
	has_parallel_copies = 0ux10;
	spill_coalescing    = 0ux100;
	spill_coloring      = 0ux200;
	spill_propagation   = 0ux400;

	memory_coalescing
            = 
	    spill_coalescing + spill_coloring + spill_propagation;

	i2s = int::to_string;
	r2s = float::to_string;

	stipulate

	    fun is_on (flag, mask)
		=
		unt::bitwise_and (flag, mask) != 0u0;

	    fun error msg
		=
		lowcode_error_message::error("register_allocation_core", msg);

	    fun cat ([],    b) =>  b;
		cat (x ! a, b) =>  cat (a, x ! b);
	    end;

	herein

	    package fz
                =
                register_allocation_leftist_priority_queue_g (			# register_allocation_leftist_priority_queue_g		is from   src/lib/compiler/backend/lower/reg-alloc/register-allocation-leftist-priority-queue-g.pkg

		    Element = Node; 

		    fun less ( NODE { movecost=>REF p1, ... },
                               NODE { movecost=>REF p2, ... }
                             )
                        =
                        p1 <= p2;
		);

	    package mv
		=
                register_allocation_leftist_priority_queue_g (			# register_allocation_leftist_priority_queue_g		is from   src/lib/compiler/backend/lower/reg-alloc/register-allocation-leftist-priority-queue-g.pkg

	            Element = g::Move; 

		    fun less ( MOVE_INT { cost=>p1, ... },
                               MOVE_INT { cost=>p2, ... }
                             )
                        =
                        p1 >= p2;
	        );

	    Move_Queue   =  mv::Priority_Queue;
	    Freeze_Queue =  fz::Priority_Queue;



	    # Utility functions
	    #
	    fun chase (NODE { color=>REF (ALIASED r), ... } )
                    =>
                    chase r;

	        chase x => x;
            end;

	    fun cell_id (c::CELL { id, ... } ) = id;

	    fun col2s col
                =
		case col
                  
		     PSEUDO         =>  "";
		     REMOVED        =>  "r";
		     ALIASED _      =>  "a";
		     COLORED c      =>  "[" + i2s c + "]";
		     MEMREG (_, m)  =>  "m" + "{ " + c::to_string m + "}";
		     SPILLED        =>  "s";
		     SPILL_LOC c    =>  "s" + "{ " + i2s c + "}";
                esac;

	    fun node2s (NODE { cell, color, pri, ... } )
                =
                i2s (cell_id cell) + col2s *color;

	    fun show ggg (node as NODE { pri, ... } )
                = 
		node2s node + (if *verbose  "(" + r2s *pri + ")"; else "";fi);


	    # Dump the interference graph

	    fun dump_register_interference_graph (ggg as g::GRAPH { nodes, show_reg, k, ... } ) stream
		=
		{   fun pr s
                        =
                        file::write (stream, s);

		    show = show ggg;

		    fun pr_move (MOVE_INT { src, dst, status=>REF (WORKLIST | BRIGGS_MOVE | GEORGE_MOVE),
				  cost, ... } )
                            => 
			    pr (node2s (chase dst) + " <- " + node2s (chase src) + "(" + r2s (cost) + ") ");

		        pr_move _ => ();
                    end;

		    fun pr_adj (n, n' as NODE { adj, degree, uses, defs,
					   color, pri, movecnt, movelist, ... } )
                        =
			{   pr (show n');

			    if *verbose
                                 pr(" deg=" + i2s *degree);
                            fi;

			    case *color
                              
			         ALIASED n
                                     =>
                                     {   pr " => ";
                                         pr (show n);
                                         pr "\n";
                                     };

			         _   =>
				     {   pr(" <-->");

				         apply
                                             (fn n = { pr " "; pr (show n);})
                                             *adj;

                                         pr "\n";

				         if   (*verbose and *movecnt > 0)
                                              
					      pr("\tmoves " + i2s *movecnt + ": ");
					      apply  pr_move  *movelist;
					      pr "\n";
				         fi;
				     };
                            esac;
		       };

		    pr("=========== k=" + i2s k + " ===========\n");

		    apply
                        pr_adj
                        (list_mergesort::sort
                            (fn ((x, _), (y, _)) = x > y)
			    (int_hash_table::keyvals_list nodes)
                        );
		};



	    # Function to create new nodes.
	    # Note: it is up to the caller to remove all dedicated registers.

	    fun new_nodes (g::GRAPH { nodes, first_pseudo_r,  ... } )
		=
		def_use
		where

		    getnode = int_hash_table::get  nodes;
		    addnode = int_hash_table::set   nodes;

		    fun color_of (c::CELL { ref_color => REF (c::MACHINE r), ... } )
                            =>
                            r;

		        color_of (c::CELL { id, ... } )
                            =>
                            id;
                    end;

		    fun get_node (cell as c::CELL { ref_color, ... } )
                        = 
		        (getnode (color_of cell))
			except
                            _ = {   reg = color_of cell;

			            col = case *ref_color 
					    
					     c::MACHINE r => g::COLORED r;
					     c::PSEUDO    => g::PSEUDO;
					     c::ALIASED _ => error "get_node: ALIASED";
					     c::SPILLED   => error "get_node: SPILLED";
					  esac;

			            node = NODE { number=>reg,
						  cell, color=> REF col, degree=>REF 0,
						  adj=>REF [], movecnt=>REF 0, movelist=>REF [],
						  movecost=>REF 0.0, pri=>REF 0.0, defs=>REF [],
						  uses=>REF [] };

			            addnode (reg, node);

                                    node;
			        };


		    fun def_use { defs, uses, pt, cost }
			=
			{
			    fun def cell
				=
				{   my node as NODE { pri, defs, ... }
					=
					get_node (cell);

				    pri  :=  *pri + cost;
				    defs :=  pt ! *defs;

				    node;
				};

			    fun use cell
				=
				{   my node as NODE { pri, uses, ... }
                                        =
                                        get_node (cell);

				    pri  :=  *pri + cost;
				    uses :=  pt ! *uses;
				};

			    list::apply use uses;
			    list::map def defs;     
		      };
		end;


	    # Add an edge (x, y) to the interference graph.
	    # Nop if the edge already exists.
	    # Note: adjacency lists of colored nodes are not stored 
	    #       within the interference graph to save space.
	    # Now we allow spilled node to be added to the edge; these do not
	    # count toward the degree. 

	    fun add_edge (GRAPH { bit_matrix, ... } )
		= 
		{   add_bit_matrix = bm::add *bit_matrix;

		    fn (x as NODE { number=>xn, color=>colx, adj=>adjx, degree=>degx, ... }, 
			  y as NODE { number=>yn, color=>coly, adj=>adjy, degree=>degy, ... }
		       )
			  => 
			  if (xn == yn ) ();
			  elif (add_bit_matrix (xn, yn) )
			      case (*colx, *coly)   
				  (PSEUDO,      PSEUDO) => { adjx := y ! *adjx; degx := *degx+1;
							     adjy := x ! *adjy; degy := *degy+1;};
				  (PSEUDO,   COLORED _) => { adjx := y ! *adjx; degx := *degx+1;};
				  (PSEUDO,    MEMREG _) => { adjx := y ! *adjx; adjy := x ! *adjy;};
				  (PSEUDO, SPILL_LOC _) => { adjx := y ! *adjx; adjy := x ! *adjy;};
				  (PSEUDO,     SPILLED) => ();
				  (COLORED _,   PSEUDO) => { adjy := x ! *adjy; degy := *degy+1;};
				  (COLORED _, COLORED _) => (); #  x!=y, can't alias 
				  (COLORED _, MEMREG _) => (); #  x!=y, can't alias 
				  (COLORED _, SPILL_LOC _) => (); #  x!=y, can't alias 
				  (COLORED _,   SPILLED) => ();
				  (MEMREG _,    PSEUDO) => { adjx := y ! *adjx; adjy := x ! *adjy;};
				  (MEMREG _, COLORED _) => ();   #  x!=y, can't alias 
				  (MEMREG _,  MEMREG _) => ();   #  x!=y, can't alias 
				  (MEMREG _, SPILL_LOC _) => (); #  x!=y, can't alias 
				  (MEMREG _,   SPILLED) => ();
				  (SPILL_LOC _, PSEUDO) => { adjx := y ! *adjx; adjy := x ! *adjy;};
				  (SPILL_LOC _, COLORED _) => ();     #  x!=y, can't alias 
				  (SPILL_LOC _, MEMREG _) => ();    #  x!=y, can't alias 
				  (SPILL_LOC _, SPILL_LOC _) => (); #  x!=y, can't alias 
				  (SPILL_LOC _, SPILLED) => (); #  x!=y, can't alias 
				  (SPILLED,  _) => ();
				  (colx, coly) => 
				     error("addEdge x=" + i2s xn + col2s colx + " y=" + i2s yn + col2s coly);
			      esac;

			   #  edge already there 
			  fi;
                  end;
		};

	    fun is_fixed_mem (SPILL_LOC _) =>  TRUE;
	        is_fixed_mem (MEMREG _)    =>  TRUE;
	        is_fixed_mem (SPILLED)     =>  TRUE;
	        is_fixed_mem _             =>  FALSE;
            end;

	    fun is_fixed (COLORED _) => TRUE;
	        is_fixed c => is_fixed_mem (c);
            end; 


	    # Initialize a list of worklists
	    #
	    fun init_work_lists 
		( GRAPH { nodes, k, bit_matrix, pseudo_count, first_pseudo_r, dead_copies, mem_moves, mode, ... } )
                { moves }
		=
		{ 
		    # Filter moves that already have an interference
		    # Also initialize the movelist and
                    # movecnt fields:
		    #	
		    member = bm::member *bit_matrix;

		    fun set_info (NODE { color=>REF PSEUDO, movecost, movecnt, movelist, ... }, 
				mv, cost)
			     =>
			     { movelist := mv ! *movelist; 
			       movecnt := *movecnt + 1;
			       movecost := *movecost + cost;
			     };

		       set_info _ => ();
                     end;


		    # Filter moves that cannot be coalesced 
		    #
		    fun filter ([], mvs', mem)
                            =>
                            (mvs', mem);

		        filter((mv as MOVE_INT { src as NODE { number=>x, color=>REF col_src, ... },
					 dst as NODE { number=>y, color=>REF col_dst, ... }, 
					 cost, ... } ) ! mvs, 
			       mvs', mem)
                            =>
			    if (is_fixed col_src  and  is_fixed col_dst)

				 filter (mvs, mvs', mem);

			    elif (is_fixed_mem col_src  or  is_fixed_mem col_dst)

				 filter (mvs, mvs', mv ! mem);

			    elif (member (x, y))

				 filter (mvs, mvs', mem); 

			    else 
				 set_info (src, mv, cost);
				 set_info (dst, mv, cost);
				 filter (mvs, mv::add (mv, mvs'), mem);
                            fi;
                    end;

		    # Like filter but does dead copy elimination:
                    #
		    fun filter_dead ([], mvs', mem, dead)
                            =>
                            (mvs', mem, dead);

		        filter_dead
                            ((mv as 
				MOVE_INT { src as NODE { number=>x, color as REF col_src, 
					       pri, adj, uses, ... },
				   dst as NODE { number=>y, cell=>celly, color=>REF col_dst, 
					       defs=>dst_defs, uses=>dst_uses, ... },
				   cost, ... } ) ! mvs, 
			       mvs', mem, dead
                            )
			    =>  
			    if (is_fixed col_src and is_fixed col_dst) 

			      filter_dead (mvs, mvs', mem, dead);

			    elif (is_fixed_mem col_src or is_fixed_mem col_dst )

			      filter_dead (mvs, mvs', mv ! mem, dead);

			    else
				case (col_src, col_dst, dst_defs, dst_uses) 

				     (_, PSEUDO, REF [pt], REF [])
					 => 
					 # Eliminate dead copy:
					 # 
					 {   fun dec_degree []
                                                     =>
                                                     ();

						 dec_degree (NODE { color=>REF PSEUDO, degree, ... } ! adj)
                                                     =>
						     {   degree := *degree - 1;
                                                         dec_degree adj;
                                                     };
						 dec_degree(_ ! adj)
                                                     =>
                                                     dec_degree adj;
                                             end;

					     fun elim_uses ([], _, uses, pri, cost)
                                                     =>
                                                     (uses, pri);

						 elim_uses (pt ! pts, pt': g::Program_Point, uses, pri, cost)
						     =>
						     if (pt == pt')  elim_uses (pts, pt', uses, pri-cost, cost);
						     else            elim_uses (pts, pt', pt ! uses, pri, cost);
                                                     fi;
                                             end;

					     my (uses', pri')
                                                 =
                                                 elim_uses(*uses, pt, [], *pri, cost);

					     pri   := pri';
					     uses  := uses';
					     color := ALIASED src;

					     dec_degree *adj;

					     filter_dead (mvs, mvs', mem, celly ! dead);
					 };

				     _   =>
					 # Normal moves 
					 #
					 if (member (x, y))     #  moves that interfere 
					      filter_dead (mvs, mvs', mem, dead); 
					 else
					       set_info (src, mv, cost);
					       set_info (dst, mv, cost);
					       filter_dead (mvs, mv::add (mv, mvs'), mem, dead);
					 fi;
				 esac;
			      fi;
                    end;


		    # Scan all nodes in the graph and check
                    # which worklist they should go in:
		    #
		    fun collect ([], simp, fz, moves, spill, pseudos)
			    =>
			    {   pseudo_count := pseudos;

			        { simplify_worklist => simp,
			          move_worklist     => moves,
			          freeze_worklist   => fz,
			          spill_worklist    => spill
			        };
			    };

		        collect (node ! rest, simp, fz, moves, spill, pseudos)
			    => 
			    case node   

				NODE { color=>REF PSEUDO, movecnt, degree, ... }
				    =>
				    if (*degree >= k)

				        collect (rest, simp, fz, moves, node ! spill, pseudos+1);

				    elif (*movecnt > 0)

				        collect (rest, simp, fz::add (node, fz), 
					       moves, spill, pseudos+1);

				    else

				        collect (rest, node ! simp, fz, moves, spill, 
					       pseudos+1);
				    fi;

			       _   =>
                                   collect (rest, simp, fz, moves, spill, pseudos);
			     esac;
		    end;

		    # First build the move priority queue:
		    #
		    my (mvs, mem)
                        = 
			if (is_on (mode, dead_copy_elim))

			    my (mvs, mem, dead) = filter_dead (moves, mv::EMPTY, [], []);
			    dead_copies := dead; (mvs, mem);
			else
                            filter (moves, mv::EMPTY, []);
                        fi;

		    mem_moves := mem;  #  memory moves 

		    collect (int_hash_table::vals_list nodes, [], fz::EMPTY, mvs, [], 0);
		};


	    # Return a regmap that returns the current spill location
	    # during spilling.
            #
	    fun spill_loc (g::GRAPH { nodes, ... } )
		= 
		get'
                where
		    getnode =   int_hash_table::get  nodes;

		    fun num (NODE { color=>REF (ALIASED n), ... } ) => num n;
			num (NODE { color=>REF (SPILLED), number, ... } ) => number;
			num (NODE { color=>REF (SPILL_LOC s), number, ... } ) => -s;
			num (NODE { color=>REF (MEMREG (m, _)), number, ... } ) => m;
			num (NODE { number, ... } ) => number;
		    end;

		    fun get' r
			=
			num (getnode r)
                        except
                            _ = r;
		end;

	    fun spill_loc_to_string (g::GRAPH { nodes, ... } )
		= 
		get'
                where
		    getnode = int_hash_table::get  nodes;

		    fun num (NODE { color=>REF (ALIASED n), ... } ) => num n;
			num (NODE { color=>REF (SPILLED), cell, ... } ) => "spilled " + c::to_string cell;
			num (NODE { color=>REF (SPILL_LOC s), number, ... } ) => "frame " + i2s s;
			num (NODE { color=>REF (MEMREG(_, m)), ... } ) => "memreg " + c::to_string m; 
			num (NODE { number, ... } ) => "error " + i2s number;
		    end;

		    fun get' r
                        =
                        num (getnode r); 
		end;


	    # Core phases:
	    #   Simplify, coalesce, freeze.
	    #
	    # NOTE: When a node's color is REMOVED or ALIASED, 
	    #       it is not considered to be part of the adjacency list
	    #
	    #  1.  The move list has no duplicate
	    #  2.  The freeze list may have duplicates
	    #
	    fun iterated_coalescing_phases
		 (ggg as GRAPH { k, bit_matrix, spill_flag, trail, stamp, mode,
			     pseudo_count,  ... } )
		=
		{   member = bm::member *bit_matrix;
		    add_edge = add_edge ggg;
		    show = show ggg;
		    memory_coalescing_on = is_on (mode, memory_coalescing);


		    # SIMPLIFY node:
		    #   Precondition: Node must be part
                    #   of the interference graph (PSEUDO)
		    #	
		    fun simplify (node as NODE { color, number, adj, degree, /*pair,*/... },
				 mv, fz, stack)
			=
			{   if debug  print("Simplifying " + show node + "\n"); fi;

			    fun forall_adj ([], mv, fz, stack)
                                    =>
                                    (mv, fz, stack);

			        forall_adj((n as NODE { color=>REF PSEUDO, degree as REF d, ... } ) ! adj,
					  mv, fz, stack)
                                    =>
				    if (d == k)
				        my (mv, fz, stack)
                                            =
                                            low_degree (n, mv, fz, stack);

				        forall_adj (adj, mv, fz, stack);
				    else
                                        degree := d - 1;
                                        forall_adj (adj, mv, fz, stack);
                                    fi;

				forall_adj(_ ! adj, mv, fz, stack)
                                    =>
                                    forall_adj (adj, mv, fz, stack);
                            end;

			    color := REMOVED;
			    pseudo_count := *pseudo_count - 1;

			    forall_adj (*adj, mv, fz, node ! stack);		# Push onto stack. 
			}							# fun simplify 

		    also
                    fun simplify_all ([], mv, fz, stack)
                            =>
                            (mv, fz, stack);

		        simplify_all (node ! simp, mv, fz, stack)
                            =>
			    {   my (mv, fz, stack)
                                    =
                                    simplify (node, mv, fz, stack);

			        simplify_all (simp, mv, fz, stack);
                             };
                    end 


		    # Decrement the degree of a pseudo node.
		    #   precondition: node must be part of the interference graph
		    #   If the degree of the node is now k-1.
		    #   Then if (a) the node is move related, freeze it.
		    #           (b) the node is non-move related, simplify it
		    #
		    #   node  -- the node to decrement degree
		    #   mv    -- queue of move candidates to be coalesced
		    #   fz    -- queue of freeze candidates
		    #   stack -- stack of removed nodes
		    #	
		    also
                    fun low_degree
                        (node as NODE { degree as REF d, movecnt, adj, color, ... }, /* FALSE, */ mv, fz, stack)
                         = 
			 # Normal edge. 
			 {   if debug  print("DecDegree " + show node + " d=" + i2s (d - 1) + "\n"); fi; 

			     degree := k - 1;

			     #  node is now low degree!!! 

			     mv = enable_moves (*adj, mv);

			     if (*movecnt > 0)  (mv, fz::add (node, fz), stack);	 # Move related. 
			     else		simplify (node, mv, fz, stack);		 # Non-move related, simplify now.
                             fi;
			 }


#		      | decDegree (node as NODE { degree as REF d, movecnt, adj, color, ... },
#				  TRUE, mv, fz, stack) = #  register pair edge 
#			(degree := d - 2;
#			 if d >= k and *degree < k then 
#			   #  node is now low degree!!! 
#			   let mv = enableMoves (node ! *adj, mv)
#			   in  if *movecnt > 0 then #  move related 
#				  (mv, fz::add (node, fz), stack)
#			       else #  non-move related, simplify now! 
#				  simplify (node, mv, fz, stack)
#			   end
#			 else
#			   (mv, fz, stack)
#			)



		    # Enable moves:
		    #   given: a list of nodes (some of which are not in the graph)
		    #   do:    all moves associated with these nodes are inserted
		    #          into the move worklist
		    #
		    also
                    fun enable_moves ([], mv)
                            =>
                            mv;

		        enable_moves (n ! ns, mv)
			    =>
			    {   # Add valid moves onto the worklist.
				# There are no duplicates on the move worklist.
				#
				fun add_mv ([], ns, mv)
                                        =>
                                        enable_moves (ns, mv);

				    add_mv((m as MOVE_INT { status, hicount as REF hi, ... } ) ! rest, ns, mv)
                                        => 
					case *status   

					    (BRIGGS_MOVE | GEORGE_MOVE)
                                                => 
					        #  Decrements hi, when hi <= 0 enable move 
					        if (hi <= 1)
					            status := WORKLIST;
                                                    add_mv (rest, ns, mv::add (m, mv));
					        else
					            hicount := hi - 1;
                                                    add_mv (rest, ns, mv);
                                                fi;
					    _   =>
                                                add_mv (rest, ns, mv);
                                        esac;
				end;

			        # Make sure the nodes are
                                # actually in the graph:
				# 
				case n

				    NODE { movelist, color=>REF PSEUDO, movecnt, ... }
					=>
					if (*movecnt > 0)			# Is it move related? 
					    add_mv (*movelist, ns, mv);
					else
					    enable_moves (ns, mv);
                                        fi;

				    _   => enable_moves (ns, mv);
				esac;
			    };
                    end;			# fun enable_moves 


		   #  Brigg's conservative coalescing test:
		   #    given: an unconstrained move (x, y)  
		   #    return: TRUE or FALSE
		   #
		   fun conservative (hicount,
				    x as NODE { degree=>REF dx, adj=>xadj, /* pair=px, */ ... },
				    y as NODE { degree=>REF dy, adj=>yadj, /* pair=py, */ ... } )
                       =
		       dx + dy < k
                       or
		       {   # hi -- is the number of nodes with deg > k (without duplicates)
			   # n -- the number of nodes that have deg = k but not neighbors
			   #        of both x and y
			   # We use the movecnt as a flag indicating whether
			   # a node has been visited.  A negative count is used to mark
			   # a visited node.
			   #	
			   fun undo ([], extra_hi)
                                   => 
			           extra_hi <= 0 or { hicount := extra_hi; FALSE;};

			       undo (movecnt ! tr, extra_hi)
                                   => 
				   {   movecnt := -1 - *movecnt;
                                       undo (tr, extra_hi);
                                   };
                           end;

			   fun loop ([],   [], hi, n, tr) =>  undo (tr, (hi + n) - k + 1);
			       loop ([], yadj, hi, n, tr) =>  loop (yadj, [], hi, n, tr);

			       loop (NODE { color, movecnt as REF m, degree=>REF deg, ... } ! vs, yadj, hi, n, tr)
				   =>
				   case *color   

				      COLORED _
					  =>
					  if (m < 0)
					       #  node has been visited before 
					       loop (vs, yadj, hi, n, tr);
					  else
					       movecnt := -1 - m;  #  mark as visited 
					       loop (vs, yadj, hi+1, n, movecnt ! tr);
					  fi;

				      PSEUDO
					  =>
					  if   (deg < k)

                                              loop (vs, yadj, hi, n, tr);

					  elif (m >= 0)

					      # Node has never been visited before:

					      movecnt := -1 - m;		# Mark as visited. 

					      if (deg == k) 
						   loop (vs, yadj, hi, n+1, movecnt ! tr);
					      else loop (vs, yadj, hi+1, n, movecnt ! tr);
                                              fi;

					     #  node has been visited before 
					  elif (deg == k ) loop (vs, yadj, hi, n - 1, tr);
					  else             loop (vs, yadj, hi, n, tr);
					  fi;

				     _ => loop (vs, yadj, hi, n, tr); #  REMOVED/ALIASED 
				    esac;
			   end;

			   loop (*xadj, *yadj, 0, 0, []);
                       };					# fun conservative 


		   #  Heuristic used to determine whether a pseudo and machine register     
		   #  can be coalesced. 
		   #  Precondition:
		   #     The two nodes are assumed not to interfere.
		   #
		   fun safe (hicount, reg, NODE { adj, ... } )
		       =
		       loop (*adj, 0)
                       where
		           fun loop ([], hi)
				   =>
				   hi == 0   or   { hicount := hi; FALSE;};

			       loop (n ! adj, hi)
                                   =>
			           case n   
				       # Note: We only have to consider pseudo nodes and not
				       # nodes that are removed, since removed nodes either have
				       # deg < k or else optimistic spilling must be in effect:
				       #	
				       NODE { degree, number, color=>REF (PSEUDO | REMOVED), ... }
					   => 
					   (*degree < k or member (reg, number))
                                               ??  loop (adj, hi  )
					       ::  loop (adj, hi+1);

				       _   => loop (adj, hi);
                                   esac;
                           end;
		      end;


		   #  Decrement the active move count of a node.
		   #  When the move count reaches 0 and the degree < k
		   #  simplify the node immediately.    
		   #      Precondition: node must be a node in the interference graph
		   #      The node can become a non-move related node.
		   #
		   fun dec_move_count
			   ( node as NODE { movecnt, color=>REF PSEUDO, degree, movecost, ... }, 
			     count, cost, mv, fz, stack
			   )
			   =>
			   {   new_count = *movecnt - count;

			       movecnt  := new_count;
			       movecost := *movecost - cost;

			       if (new_count == 0 and *degree < k)	 #  low degree and movecnt == 0 
				    (simplify (node, mv, fz, stack));
			       else (mv, fz, stack);
                               fi;
			   };

		      dec_move_count(_, _, _, mv, fz, stack)
                          =>
                          (mv, fz, stack);
                   end;


		   # Combine two nodes u and v into one.
		   #   v is replaced by u  
		   #   u is the new combined node
		   #   Precondition: u != v and u and v must be unconstrained
		   #
		   #  u, v   -- two nodes to be merged, must be distinct!
		   #  coloingv -- is u a colored node?
		   #  mvcost -- the cost of the move that has been eliminated
		   #  mv     -- the queue of moves
		   #  fz     -- the queue of freeze candidates
		   #  stack  -- stack of removed nodes
		   #
		   fun combine (u, v, coloringv, mvcost, mv, fz, stack)
		       =
		       {   v ->  NODE { color=>vcol, pri=>pv, movecnt=>cntv, movelist=>movev, adj=>adjv, defs=>defsv, uses=>usesv, degree=>degv, ... };
			   u ->  NODE { color=>ucol, pri=>pu, movecnt=>cntu, movelist=>moveu, adj=>adju, defs=>defsu, uses=>usesu, degree=>degu, ... };

			   # Merge movelists together,
                           # taking the opportunity
			   # to prune the lists:
			   #
			   fun merge_move_list ([], mv)
                                   =>
                                   mv;

			       merge_move_list((m as MOVE_INT { status, hicount, src, dst, ... } ) ! rest, mv)
                                   => 
				   case *status   

				      BRIGGS_MOVE
                                          =>  
					  # If we are changing a copy from v <-> w to uv <-> w
					  # makes sure we reset its trigger count, so that it
					  # will be tested next.
					  #
					  {   if coloringv  
					          status := GEORGE_MOVE; 
					          hicount := 0;
					          if debug print ("New george " + show src + "<->" + show dst + "\n"); fi;
					      fi;

					      merge_move_list (rest, m ! mv);
					  };

				      GEORGE_MOVE
                                          => 
					  # If u is colored and v is not,
                                          # then the move  v <-> w
					  # becomes       uv <-> w
                                          # where w is colored.
                                          # This can always be discarded.
					  #
					  if coloringv  merge_move_list (rest,     mv);
					  else          merge_move_list (rest, m ! mv);
                                          fi;

				      WORKLIST
                                          =>
                                          merge_move_list (rest, m ! mv);

				      _   =>
                                          merge_move_list (rest, mv);
				   esac;
                           end;

			   # Form combined node.
                           # Add the adjacency list of v to u:
			   #
			   fun union ([], mv, fz, stack)
                                   =>
                                   (mv, fz, stack);

			       union((t as NODE { color, degree, ... } ) ! adj, mv, fz, stack)
                                   =>
				   case *color   

				       (COLORED _ | SPILL_LOC _ | MEMREG _ | SPILLED)
                                           => 
				           {   add_edge (t, u);
                                               union (adj, mv, fz, stack);
                                           };

				       PSEUDO
                                           =>
				           {   add_edge (t, u);

					       d = *degree;

					       if (d == k) 

					           my (mv, fz, stack)
                                                       =
                                                       low_degree (t, mv, fz, stack);

					           union (adj, mv, fz, stack);

					       else
                                                   degree := d - 1;

                                                   union (adj, mv, fz, stack);
                                               fi;

				     }; 
				  _ => union (adj, mv, fz, stack);
                                 esac;
			   end;

			   vcol := ALIASED u; 
				#
				# Combine the priority of both: 
				# Note that since the mvcost has been counted twice
				# in the original priority, we substract it twice
				# from the new priority.

			   pu   := *pu + *pv - mvcost - mvcost;
				#
				# Combine the def/use pts of both nodes.
				# Strictly speaking, the def/use points of the move
				# should also be removed.  But since we never spill
				# a coalesced node and only spilling makes use of these
				# def/use points, we are safe for now.  
				#
				# New comment: with spill propagation, it is necessary
				# to keep track of the spilled program points.

			   if memory_coalescing_on 

			       defsu := cat (*defsu, *defsv); 
			       usesu := cat (*usesu, *usesv);

			   fi;

			   case *ucol   

			       PSEUDO
                                   => 
			           {   if (*cntv > 0)  moveu := merge_move_list(*movev, *moveu);   fi; 

				       movev := [];			#  XXX kill the list to free space 
				       cntu  := *cntu + *cntv;
			           };

			       _   => ();
                           esac;

			   cntv := 0;

			   removing_hi
                               =
                               *degv >= k   and   (*degu >= k or coloringv); 

			   # Update the move count of the combined node:
			   #	
			   my (mv, fz, stack)
			       =
			       union(*adjv, mv, fz, stack);

			   my (mv, fz, stack)
			       = 
			       dec_move_count (u, 2, mvcost + mvcost, mv, fz, stack);  

			   # If either v or u are high degree then at least one high degree
			   # node is removed from the neighbors of uv after coalescing
			   #	
			   mv = if removing_hi  enable_moves(*adju, mv); else mv;fi;

			   coalesce (mv, fz, stack);
		       }


		   #  COALESCE:
		   #    Repeat coalescing and simplification until mv is empty.
		   #
		   also
                   fun coalesce (mv::EMPTY, fz, stack)
                           =>
                           (fz, stack);

		       coalesce (mv::TREE (MOVE_INT { src, dst, status, hicount, cost, ... }, _, l, r), fz, stack)
			   => 
			   {   # coalesce_count := *coalesce_count + 1 

			       u = chase src;

			       my v as NODE { color=>REF vcol, ... }
                                   =
                                   chase dst;

			       # Make u the colored one:
			       #	 
			       my  ( u as NODE { number=>u', color=>REF ucol, ... },
				     v as NODE { number=>v', color=>REF vcol, ... }
                                   )
                                   = 
				   case vcol   COLORED _ => (v, u);
					       _         => (u, v);
                                   esac;

			       if debug   print ("Coalescing " + show u + "<->" + show v +  " (" + r2s cost + ")");  fi;

			       mv = mv::merge (l, r);

			       fun coalesce_it (status, v)
                                   = 
				   {   status := COALESCED;

				       if *spill_flag  trail := UNDO (v, status, *trail);  fi;
				  };

			       if (u' == v')			# Trivial move 

				   if debug  print(" Trivial\n");   fi;

				   coalesce_it (status, v);
				   coalesce (dec_move_count (u, 2, cost+cost, mv, fz, stack));

			       else 
				   case vcol   

				       COLORED _
					   => 
					   # Two colored nodes cannot be coalesced:
					   # 
					   {   status := CONSTRAINED;

					       if debug  print(" Both Colored\n");  fi; 

					       coalesce (mv, fz, stack);
                                           };

				       _   =>
					   if (member (u', v') ) 

					       # U and v interfere. 

					       status := CONSTRAINED;
					       if debug  print(" Interfere\n");  fi;  

					       my (mv, fz, stack) = (dec_move_count (u, 1, cost, mv, fz, stack));
					       coalesce             (dec_move_count (v, 1, cost, mv, fz, stack));
					   else
					       case ucol    

						   COLORED _		# u is colored, v is not 
						       =>
						       if (safe (hicount, u', v) ) 

							  if debug  print(" Safe\n");  fi; 

							  # if tally then good_george := *good_george+1 

							  coalesce_it (status, v);
							  combine (u, v, TRUE, cost, mv, fz, stack);

						       else

							  # Remove it from the move list:
 

							  status := GEORGE_MOVE;

							  # if tally then bad_george := *bad_george + 1 

							  if debug  print(" Unsafe\n");  fi; 

							  coalesce (mv, fz, stack);
						       fi;

					           _   =>		# u, v are not colored 
						       if (conservative (hicount, u, v) ) 

							   if debug  print(" OK\n");  fi; 

							   # if tally then good_briggs := *good_briggs+1 

							   coalesce_it (status, v);
							   combine (u, v, FALSE, cost, mv, fz, stack);

						       else
                                                           # Conservative test failed. 
							   # Remove it from the move list:
 
							   status := BRIGGS_MOVE;

							   # if tally then bad_briggs := *bad_briggs + 1 

							   if debug  print(" Non-conservative\n");  fi; 
							   coalesce (mv, fz, stack);
						       fi;
                                               esac;
                                           fi;
				   esac;
			       fi;
			   };
                    end;				# fun coalesce 

		    # Mark a node n as frozen: 
		    #  Go thru all the moves (n, m), decrement the move count of m
		    #  precondition: degree must be < k
		    #                movecnt must be > 0
		    #    node  -- the node to be frozen
		    #    fz    -- a queue of freeze candidates
		    #    stack -- stack of removed nodes
		    #
		    fun mark_as_frozen
                        (
			  node as NODE { number=>me, degree, 
				       adj, movelist, movecnt as REF mc, ... },
			  fz, stack
                        )
                        = 
		        {   if debug  print("Mark as frozen " + i2s me + "\n"); fi;

			    # Eliminate all moves,
                            # return a list of nodes that
			    # can be simplified:
			    #
			    fun elim_moves ([], simp)
                                    =>
                                    simp;

			        elim_moves (MOVE_INT { status, src, dst, ... } ! mvs, simp)
				    =>
				    case *status    

				        WORKLIST
                                            =>
                                            error "elimMoves";

				        (BRIGGS_MOVE | GEORGE_MOVE)		# Mark move as lost.
					    => 
					    {   status := LOST;

						my src as NODE { number=>s, ... }
                                                    =
                                                    chase src;

						you  =  (s == me)  ??  chase dst
                                                                   ::        src;
					        case you   

						    NODE { color=>REF (COLORED _), ... }
                                                        => 
						        elim_moves (mvs, simp);

						    NODE { movecnt as REF c, degree, ... }	#  pseudo 
							=>
						        {   movecnt := c - 1; 

						            (c == 1 and *degree < k)  
							        ??  elim_moves (mvs, you ! simp)
							        ::  elim_moves (mvs, simp);
						        };
                                                esac;
					    };

				        _   => elim_moves (mvs, simp);
                                    esac;
                            end;

			    # Note:
			    # We are removing a high degree node,
                            # so try to enable all moves 
			    # associated with its neighbors.
			    #	
			    mv =   if (*degree >= k)   enable_moves(*adj, mv::EMPTY); 
				   else                mv::EMPTY;
                                   fi;

			    if (mc == 0) 
				simplify (node, mv, fz, stack);
			    else 
				movecnt := 0; 
				simplify_all (node ! elim_moves(*movelist, []), mv, fz, stack);
			    fi;
			};


		    # FREEZE: 
		    #   Repeat picking 
		    #   a node with degree < k from the freeze list and freeze it.
		    #   fz    -- queue of freezable nodes 
		    #   stack -- stack of removed nodes
		    #   undo  -- trail of coalesced moves after potential spill
		    #
		    fun freeze (fz, stack)
			= 
			loop (fz, fz::EMPTY, stack)
                        where
			    fun loop (fz::EMPTY, fz::EMPTY, stack)
                                    =>
                                    stack;

			        loop (fz::EMPTY, new_fz, _)
                                    =>
                                    error "no freeze candidate";

			        loop (fz::TREE (node, _, l, r), new_fz, stack)
				    =>
				    {   fz = fz::merge (l, r);

				        case node   

					    # This node has not been simplified 
					    # This must be a move-related node.
					    #
					    NODE { color=>REF PSEUDO, degree, ... }
						=>
						if (*degree >= k)	#  Can't be frozen yet? 

						    # if tally then bad_freeze := *bad_freeze+1;  fi;

						    loop (fz, fz::add (node, new_fz), stack);

						else
                                                    # Freeze node. 

						    if debug  print("Freezing " + show node + "\n");  fi;

						    #  if tally then good_freeze := *good_freeze + 1

						    my (mv, fz, stack)
                                                        =
                                                        mark_as_frozen (node, fz, stack);

						    my (fz, stack)
                                                        =
                                                        coalesce (mv, fz, stack);

						    # print("[freezing again "  + i2s *blocked  +  "]");

						    loop (fz::merge (fz, new_fz), fz::EMPTY, stack);
						fi;

					    _   => 
					        {   # if tally then bad_freeze := *bad_freeze + 1 

					            loop (fz, new_fz, stack);
                                                };
				        esac;
				    };
                            end;

			    # print("[freezing "  +  i2s *blocked  +  "]"); 

			end;


		    # Sort simplify worklist in increasing degree.
		    # Matula and Beck suggest that we should always
                    # first remove the node with the lowest degree.
                    # This is an approximation of that idea. 


#		    buckets = a::rw_vector (k, []) : a::Rw_Vector(  List( g::node ) )
#		    fun sortByDegree nodes =
#		    let fun insert [] = ()
#			  | insert((n as NODE { degree=REF deg, ... } ) ! rest) =
#			    (ua::set (buckets, deg, n ! ua::sub (buckets, deg)); insert rest)
#			fun collect (-1, L) = L
#			  | collect (deg, L) = collect (deg - 1, cat (ua::sub (buckets, deg), L))
#		    in  insert nodes; 
#			collect (k - 1, [])
#		    end



		    # Iterate over simplify, coalesce, freeze
		    #
		    fun iterate { simplify_worklist, move_worklist, freeze_worklist, stack }
			=
			{   # Simplify everything:
 
			    my (mv, fz, stack)
                                = 
				simplify_all( /* sort_by_degree */ simplify_worklist, move_worklist, freeze_worklist, stack);

			    my (fz, stack)
                                =
                                coalesce (mv, fz, stack);

			    stack = freeze (fz, stack);

			    { stack };
			};

		    { mark_as_frozen, iterate };
		};


	    # The main entry point for the
            # iterated coalescing algorithm:
	    #	
	    fun iterated_coalescing ggg
		= 
		{   my { iterate, ... } = iterated_coalescing_phases ggg;
		    iterate;
                };



	    # Potential Spill:
	    #   Find some node on the spill list and just optimistically
	    # remove it from the graph.
	    #
	    fun potential_spill_node (ggg as g::GRAPH { spill_flag, ... } )
		=
		{
		    my { mark_as_frozen, ... }
			 =
			 iterated_coalescing_phases ggg;

		    fn { node, cost, stack }
			=
			{   spill_flag := TRUE;		# Potential spill found.

			    my (mv, fz, stack)
                                =
                                mark_as_frozen (node, fz::EMPTY, stack);

			    if (cost < 0.0)

				 my NODE { color, ... } = node;
				 color := SPILLED;
			    fi;

			    { move_worklist=>mv, freeze_worklist=>fz, stack };
			};
		};




	    #  SELECT: 
	    #    Using optimistic spilling
	    #
	    fun select (ggg as GRAPH { getreg, getpair, trail, first_pseudo_r, stamp, 
				  spill_flag, prohibitions, mode, ... } ) { stack }
		=
		{   fun undo_coalesced END
                            =>
                            ();

		        undo_coalesced (UNDO (NODE { number, color, ... }, status, trail))
			    =>
			    {   status := BRIGGS_MOVE;

			        if  (number >= first_pseudo_r  )  color := PSEUDO;   fi;

			        undo_coalesced trail;
			    };
                    end;

		    show = show ggg;

		    # Fast coloring, assume no spilling can occur 
		    #
		    fun fastcoloring ([], stamp)
                            =>
                            ([], stamp);

			fastcoloring((node as NODE { color, /* pair, */ adj, ... } ) ! stack, stamp)
			    =>
			    {   # Set up the prohibitions rw_vector:
				# 
				fun neighbors []
                                        =>
                                        ();

				    neighbors (r ! rs)
					=> 
					mark r
                                        where
					    fun mark (NODE { color=>REF (COLORED c), ... } )
                                                    =>
						    { ua::set (prohibitions, c, stamp); neighbors rs;};

						mark (NODE { color=>REF (ALIASED n), ... } )
						    =>
						    mark n;

						mark _
						    =>
                                                    neighbors rs;
                                            end;
                                        end;
                                end;

				neighbors *adj;

			        color
                                    :=
                                    COLORED (getreg { pref => [], prohibitions, stamp } );

				fastcoloring (stack, stamp+1); 
			    };
		    end;

		    #  Briggs' optimistic spilling heuristic 
		    #
		    fun optimistic ([], spills, stamp)
                            =>
                            (spills, stamp);

		        optimistic((node as NODE { color=>REF (SPILLED), ... } ) ! stack, spills, stamp)
                            =>
			    optimistic (stack, node ! spills, stamp);

		        optimistic((node as NODE { color as REF REMOVED, /* pair, */ adj, ... } ) ! stack, spills, stamp)
                            =>
                            {   # Set up the prohibitions rw_vector:
				# 
				fun neighbors []
                                        =>
                                        ();

				    neighbors (r ! rs)
					=> 
					mark r
                                        where
					    fun mark (NODE { color=>REF (COLORED c), ... } )
                                                    =>
						    {   ua::set (prohibitions, c, stamp);
                                                        neighbors rs;
                                                    };

					        mark (NODE { color=>REF (ALIASED n), ... } )
                                                    =>
                                                    mark n;

					        mark _ => neighbors rs;
                                            end;
                                        end;
                                end;

				neighbors *adj;

				spills
                                    =
                                    {   col = getreg { pref => [], prohibitions, stamp };

				        color := COLORED col; spills;

				    }
                                    except
                                        _ = node ! spills;

			        optimistic (stack, spills, stamp+1); 
			    };

		        optimistic _
                            =>
                            error "optimistic";
                    end;

		    # Briggs' optimistic spilling heuristic, with biased coloring:
		    # 
		    fun biased_coloring ([], spills, stamp)
                            =>
                            (spills, stamp);

			biased_coloring((node as NODE { color=>REF (SPILLED), ... } ) ! stack, spills, stamp)
                            =>
			    biased_coloring (stack, node ! spills, stamp);

			biased_coloring((node as NODE { color=>REF (SPILL_LOC _), ... } ) ! stack, spills, stamp)
                            =>
			    biased_coloring (stack, node ! spills, stamp);

			biased_coloring((node as NODE { color=>REF (MEMREG _), ... } ) ! stack, spills, stamp)
                            =>
			    biased_coloring (stack, node ! spills, stamp);

			biased_coloring
                            (
			      (node as NODE { number, color, adj, 
					  /* pair, */ movecnt, movelist, ... } ) ! stack, 
			      spills, stamp
                            )
                            =>
			    {   # Set up the prohibitions rw_vector:
				# 
			        fun neighbors []
                                        =>
                                        ();

				    neighbors (r ! rs)
                                        => 
				        case (chase r)   

				            NODE { color=>REF (COLORED c), ... }
                                                => 
				                {   ua::set (prohibitions, c, stamp);
                                                    neighbors rs;
                                                };

				            _   =>
                                                neighbors rs;
                                        esac;
                                end;

				 # Look at lost moves and
				 # see if it is possible to 
				 # color the move with the same color
				 #
				 fun get_pref ([], pref)
					 =>
					 pref;

				     get_pref (MOVE_INT { status=>REF (LOST | BRIGGS_MOVE | GEORGE_MOVE), src, dst, ... } ! mvs, pref)
					 =>
					 {   my src as NODE { number=>s, ... }
						 =
						 chase src;

					     other =   (s == number)   ??   chase dst
								       ::         src;
					     case other   

						 NODE { color=>REF (COLORED c), ... }
						     =>
						     get_pref (mvs, c ! pref);

						 _   =>
						     get_pref (mvs, pref);
					     esac;
					 };

				     get_pref(_ ! mvs, pref)
					 =>
					 get_pref (mvs, pref);
				 end;

				 neighbors *adj;

				 pref = get_pref (*movelist,[]);

				 spills
				     =
				     {   col = getreg { pref => [], prohibitions, stamp };

					 color := COLORED col; spills;
				     }
				     except
					 _ = node ! spills;

				 biased_coloring (stack, spills, stamp+1);
                            };
                    end;				# fun biased_coloring

		    my (spills, st)
			= 
			if   (is_on (mode, biased_selection))  biased_coloring (stack, [], *stamp);
			elif *spill_flag 		       optimistic      (stack, [], *stamp);
			else			               fastcoloring    (stack,     *stamp);
			fi;

		    stamp := st;

		    case spills
                      
		         [] => { spills => [] };

			 spills
                             => 
			     {   fun undo []
                                         =>
                                         ();

				     undo (NODE { color, ... } ! nodes)
                                         =>
                                         {   color := PSEUDO;
                                             undo nodes;
                                         };
                                 end;

			         undo stack;
			         undo_coalesced *trail;

			         trail := END;

			         { spills };
			     };
                    esac;

		};			# fun select


	    # Incorporate memory<->register moves
	    # into the interference graph:
	    #
	    fun init_mem_moves (GRAPH { mem_moves, ... } )
		=
		{   fun move (NODE { movelist, movecost, ... }, mv, cost)
                        = 
			{   movelist := mv ! *movelist;
			    movecost := cost + *movecost;
			};

		    fun set_move (dst, src, mv, cost)
                        = 
			{   move (dst, mv, cost);
                            move (src, mv, cost);
                        };

		    fun init []
                            =>
                            ();

			init ((mv as MOVE_INT { dst, src, cost, ... } ) ! mvs)
			    => 
			    {   (chase dst) ->  dst as NODE { color=>REF dst_col, ... };
				(chase src) ->  src as NODE { color=>REF src_col, ... };

			        if (is_fixed_mem (src_col) and is_fixed_mem (dst_col) )
				    set_move (dst, src, mv, cost);
			        else
                                    case (src_col, dst_col)

				        (PSEUDO, _)
                                            =>
				            if (is_fixed_mem dst_col)  set_move (dst, src, mv, cost); 
				            else                       error "init_mem_moves";
                                            fi;

				        (_, PSEUDO)
                                            => 
					    if (is_fixed_mem src_col)  set_move (dst, src, mv, cost); 
					    else                       error "init_mem_moves";
                                            fi;

				        (COLORED _, _) => if (not (is_fixed_mem dst_col))  error "init_mem_moves"; fi;
				        (_, COLORED _) => if (not (is_fixed_mem src_col))  error "init_mem_moves"; fi;
				        _              =>                                  error "init_mem_moves";
                                   esac;
			         fi;

				 init mvs;
			    };
		    end;

		    moves = *mem_moves; 

		    mem_moves := [];

		    init moves;
		};				# fun init_mem_moves



	    # Compute savings due to memory<->register moves
	    #
	    fun move_savings (GRAPH { mem_moves=>REF [], ... } )
                    =>
                    (fn node = 0.0);

	        move_savings (GRAPH { mem_moves, bit_matrix, ... } )
                    => 
		    {   exception SAVINGS;

			savings_map = int_hash_table::make_table (32, SAVINGS)
				 : int_hash_table::Hash_Table { pinned: Int, cost: Cost }; 

			savings =  int_hash_table::find savings_map;

			savings =  fn r = case (savings r)    NULL  => { pinned=> -1, cost=>0.0 };
							    THE s => s;
                                          esac;

			add_savings = int_hash_table::set savings_map;
			member     = bm::member *bit_matrix;

			fun inc_savings (u, v, c)
			    =
			    {   my { pinned, cost } = savings u;

			        if   (pinned != -1 and v != pinned or member (u, v))
				     ();
				else 
                                     add_savings (u, { pinned=>v, cost=>cost + c + c } );
                                fi;
			    };

			fun compute_savings []
                                =>
                                ();

			    compute_savings (MOVE_INT { dst, src, cost, ... } ! mvs)
				=>
				{   (chase src) ->  src as NODE { number=>u, color=>cu, ... };
				    (chase dst) ->  dst as NODE { number=>v, color=>cv, ... };

				    case (*cu, *cv) 

				        (cu, PSEUDO) => if (is_fixed_mem cu) inc_savings (v, u, cost); fi;
				        (PSEUDO, cv) => if (is_fixed_mem cv) inc_savings (u, v, cost); fi;
				        _            => ();
                                    esac;

				    compute_savings mvs;
				};
                        end;

		        compute_savings *mem_moves;

			fn node =  .cost (savings node);
		    };
             end;		# fun move_savings


	    # Update the color of cells:
	    #
	    fun update_cell_colors (GRAPH { nodes, dead_copies, ... } )
		= 
		{   fun enter (c::CELL { ref_color, ... }, c)
                        =
                        ref_color := c;

		    fun cell_of (NODE { cell, ... } )
                        =
                        cell;

		    fun set (NODE { cell, color=>REF (COLORED c), ... } )
                            => 
			    enter (cell, c::MACHINE c);

		        set (NODE { cell, color=>REF (ALIASED alias), ... } )
			    => 
			    enter (cell, c::ALIASED (cell_of alias));

		        set (NODE { cell, color=>REF (SPILLED), ... } )
			    => 
			    enter (cell, c::SPILLED);

		        set (NODE { cell, color=>REF (SPILL_LOC s), ... } )
			    => 
			    enter (cell, c::SPILLED);

		        set (NODE { cell, color=>REF (MEMREG (m, _)), ... } )
			    => 
			    enter (cell, c::MACHINE m);

		        set (NODE { cell, color=>REF PSEUDO, ... } )
                            =>
                            ();

		        set (_)
                            =>
                            error("updateCellColors");
                    end;

		    int_hash_table::apply set nodes;
		};


	    # Update aliases before spill rewriting:
	    #
	    fun update_cell_aliases (GRAPH { nodes, dead_copies, ... } )
		= 
		{   fun enter (c::CELL { ref_color, ... }, c)
                        =
                        ref_color := c;

		    fun cell_of (NODE { cell, ... } )
                        =
                        cell;

		    fun set (NODE { cell, color=>REF (COLORED c), ... } )
                            =>
                            ();

		        set (NODE { cell, color=>REF (ALIASED alias), ... } )
			    => 
			    enter (cell, c::ALIASED (cell_of alias));

		        set (NODE { cell, color=>REF (SPILLED),     ... } ) =>  ();
		        set (NODE { cell, color=>REF (SPILL_LOC s), ... } ) =>  ();
		        set (NODE { cell, color=>REF (MEMREG _),    ... } ) =>  ();
		        set (NODE { cell, color=>REF PSEUDO,        ... } ) =>  ();

		        set (_)
                            =>
                            error "updateCellAliases";
                    end;

		    int_hash_table::apply set nodes;
		};

	    fun mark_dead_copies_as_spilled (GRAPH { dead_copies, ... } )
		= 
		{   fun enter (c::CELL { ref_color, ... }, c)
                            =
                            ref_color := c;

		    case *dead_copies
		      
			[]   => ();
			dead => apply (fn r = enter (r, c::SPILLED)) dead;
		    esac;
		}; 


	    # Clear the interference graph
            # but keep the nodes:
	    #
	    fun clear_graph
                (GRAPH { bit_matrix, max_regs, trail, spill_flag, 
				 dead_copies, mem_moves, copy_tmps, ... }
                )
		=
		{   edges =  bm::edges *bit_matrix;

		    trail       :=  END;
		    spill_flag  :=  FALSE;
		    dead_copies :=  [];
		    mem_moves   :=  [];
		    copy_tmps   :=  [];
		    bit_matrix  :=  bm::empty;
		    bit_matrix  :=  g::new_bit_matrix { edges, max_regs=>max_regs() };
		}; 

	    fun clear_nodes (GRAPH { nodes, ... } )
		=
		{   fun init (_, NODE { pri, degree, adj, movecnt, movelist,
				     movecost, defs, uses, ... } )
                        =
			{   pri := 0.0;
                            degree := 0;
                            adj := [];
                            movecnt := 0;
                            movelist := [];
			    defs := [];
                            uses := [];
                            movecost := 0.0;
                        };

		    int_hash_table::keyed_apply init nodes;
		};

	end;			# stipulate
    }; 				# package register_allocation_core
end;				# stipulate


## COPYRIGHT (c) 2002 Bell Labs, Lucent Technologies.
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
