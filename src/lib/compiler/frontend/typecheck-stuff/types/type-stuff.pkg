## type-stuff.pkg 

# Compiled by:
#     src/lib/compiler/frontend/typecheck-stuff/typecheckdata.make6


package type_stuff: (weak)  Type_Stuff {	# Type_Stuff	is from   src/lib/compiler/frontend/typecheck-stuff/types/type-stuff.api

    stipulate

	package a   = var_home;			# var_home			is from   src/lib/compiler/frontend/typecheck-stuff/basics/var-home.pkg
	package ctt = core_type_types;		# core_type_types		is from   src/lib/compiler/frontend/typecheck-stuff/types/core-type-types.pkg
	package em  = error_message;		# error_message			is from   src/lib/compiler/frontend/basics/errormsg/error-message.pkg
	package ep  = module_path;		# module_path			is from   src/lib/compiler/frontend/typecheck-stuff/modules/module-path.pkg
	package ip  = inverse_path;		# inverse_path			is from   src/lib/compiler/frontend/typecheck-stuff/basics/symbol-path.pkg
	package s   = symbol;			# symbol			is from   src/lib/compiler/frontend/basics/mlcomp/symbol.pkg
	package sp  = symbol_path;		# symbol_path			is from   src/lib/compiler/frontend/typecheck-stuff/basics/symbol-path.pkg
	package ss  = substring;		# substring			is from   src/lib/std/substring.pkg
						# stamp				is from   src/lib/compiler/frontend/typecheck-stuff/basics/stamp.pkg

	include types;
        include variables_and_constructors; 

    herein

	make_rw_vector =   rw_vector::make_rw_vector;
	sub            =   rw_vector::get;
	update         =   rw_vector::set;

	infix val 99  sub ;

	my   -->   =   core_type_types::(-->);

	infix val  --> ;

	say        =   control_print::say;
        debugging  =   typecheck_data_control::type_stuff_debugging;		#  REF FALSE 

	fun bug msg
            =
            em::impossible("type_stuff: " + msg);

	fun equality_property_to_string p
            =
	    case p
	      
		NO            =>  "NO";
		YES           =>  "YES";
		INDETERMINATE =>  "INDETERMINATE";
		CHUNK         =>  "CHUNK";
		DATA          =>  "DATA";
		UNDEF         =>  "UNDEF";
		EQ_ABSTRACT   =>  "EQ_ABSTRACT";
            esac;


	# ************** operations to build type_variables, VARtys **************

	# Make a META type variable for a possibly
        # polymorphically typed expression.
        #
	# This function is local to this file:
	#
	fun make_meta_type_variable  fn_nesting
            =
	    {
		if *debugging  printf "src/lib/compiler/frontend/typecheck-stuff/types/type-stuff.pkg: Creating META typevar fn_nesting==%d\n" fn_nesting; fi;

		META_TYPE_VARIABLE
		    {
		      eq    => FALSE,
		      fn_nesting
		    };
	    };

	# Make a variable for an incompletely
	# specified record (one where "..." was used):
	#
	fun make_incomplete_record_type_variable (known_fields, fn_nesting)
            =
	    INCOMPLETE_RECORD_TYPE_VARIABLE
                {
                  eq           => FALSE,
                  known_fields,
                  fn_nesting
                 };

        # Given  'a return ("a", FALSE),
        # given ''a return ("a", TRUE ):
	#
	fun extract_variable_name_information name
            =
	    {   name = ss::from_string name;			#  Convert String to Substring.

	        # Strip leading '$' if any:
                #
		name
                    =
		    if  (ss::get (name, 0) ==  '$')   ss::drop_first 1 name;
		    else                                               name;
                    fi;
            
		my (name, eq)
                    =
		    if (  ss::get (name, 0) ==  '$'	#  Initial "$" signifies equality
		       or ss::get (name, 0) ==  '_'	#  Initial "_" signifies equality
                       )
		         (ss::drop_first 1 name,  TRUE);
		    else (                 name, FALSE);
                    fi;
            
                ( ss::to_string name,			# Convert Substring back to String.
                  eq					# TRUE iff this is an "equality" typevar.
                );
	    };

	# This function is called exactly once, by  typecheck_type_variable()  in
	#     src/lib/compiler/frontend/typechecker/typecheck/typecheck-type.pkg
	#
	fun make_user_type_variable (id:  symbol::Symbol)
            :
            Type_Variable
	    =
	    {   my (name, eq)
		    =
                    extract_variable_name_information (symbol::name id);
	    
		USER_TYPE_VARIABLE
                    {
                      name       => symbol::make_type_variable_symbol  name,
                      fn_nesting => infinity,
                      eq
                    };
	    };



	fun make_overloaded_literal_type_variable (
                kind:                Literal_Kind,
                source_code_region:  source_map::Source_Code_Region,
                stack:               List(String)
            )
            :
            Type
            =
	    TYPE_VARIABLE_REF
              (
                make_type_variable_ref
                  (
                    LITERAL_TYPE_VARIABLE { kind, source_code_region },
                    stack
              )   );



	# This is called exactly once, from  copy_type_scheme() in
        #
        #     src/lib/compiler/frontend/typechecker/types/resolve-overloaded-variables.pkg
	#
	fun make_overloaded_type_variable_and_type (stack: List(String))
            :
            Type
            =
            TYPE_VARIABLE_REF
              (
                make_type_variable_ref
                  (
                    OVERLOADED_TYPE_VARIABLE  FALSE,
                    stack
              )   );



	# make_meta_type_variable_and_type:
	#
	# This function returns a type that represents a new meta variable
	# which does NOT appear in the "context" anywhere.  To do the same
	# thing for a meta variable which will appear in the context (because,
	# for example, we are going to assign the resulting type to a program
	# variable), use make_meta_type_variable_and_type with the appropriate fn_nesting.
	#
	fun make_meta_type_variable_and_type
            (
              fn_nesting: Int,
              stack:      List(String)
            )
            : Type
            =
            TYPE_VARIABLE_REF
              (
                make_type_variable_ref
                  (
                    make_meta_type_variable  fn_nesting,
                    stack
              )   );




	# ************** primitive operations on tycons **************

	fun bug_type_constructor (s: String, type_constructor)
            =
 	    case type_constructor
	      
		PRIMITIVE_TYPE_CONSTRUCTOR   { path, ... } => bug (s + " PRIMITIVE_TYPE_CONSTRUCTOR " + s::name (ip::last path));
		DEFINED_TYPE_CONSTRUCTOR     { path, ... } => bug (s + " DEFINED_TYPE_CONSTRUCTOR " + s::name (ip::last path));
		TYPE_CONSTRUCTOR_BY_MODULE_PATH { path, ... } => bug (s + " TYPE_CONSTRUCTOR_BY_MODULE_PATH " + s::name (ip::last path));

		RECORD_TYPE_CONSTRUCTOR _                  => bug (s + " RECORD_TYPE_CONSTRUCTOR");
		RECURSIVE_TYPE _               => bug (s + " RECURSIVE_TYPE");
		FREE_TYPE _                    => bug (s + " FREE_TYPE");
		ERRONEOUS_TYPE_CONSTRUCTOR                 => bug (s + " ERRONEOUS_TYPE_CONSTRUCTOR");
            esac;

	#  short (single symbol) name of type_constructor 

	fun type_constructor_name (PRIMITIVE_TYPE_CONSTRUCTOR { path, ... } | DEFINED_TYPE_CONSTRUCTOR { path, ... } | TYPE_CONSTRUCTOR_BY_MODULE_PATH { path, ... } )
		=>
		ip::last path;

	    type_constructor_name (RECORD_TYPE_CONSTRUCTOR    _) => s::make_type_symbol "<RECORD_TYPE_CONSTRUCTOR>";
	    type_constructor_name (RECURSIVE_TYPE _) => s::make_type_symbol "<RECURSIVE_TYPE>";
	    type_constructor_name (FREE_TYPE      _) => s::make_type_symbol "<FREE_TYPE>";
	    type_constructor_name ERRONEOUS_TYPE_CONSTRUCTOR     => s::make_type_symbol "<ERRONEOUS_TYPE_CONSTRUCTOR>";
        end;

	# Get the stamp of a type_constructor:
	# 
	fun type_constructor_stamp (PRIMITIVE_TYPE_CONSTRUCTOR { stamp, ... } | DEFINED_TYPE_CONSTRUCTOR { stamp, ... } ) => stamp;
	    type_constructor_stamp type_constructor => bug_type_constructor("type_constructor_stamp", type_constructor);
        end;

	# Full path name of type_constructor,
        # an inverse_path::path:
	#
	fun type_constructor_path
                ( PRIMITIVE_TYPE_CONSTRUCTOR               { path, ... }
                | DEFINED_TYPE_CONSTRUCTOR                 { path, ... }
                | TYPE_CONSTRUCTOR_BY_MODULE_PATH { path, ... }
                )
                => path;

	    type_constructor_path ERRONEOUS_TYPE_CONSTRUCTOR    => ip::INVERSE_PATH [s::make_type_symbol "Error"];
	    type_constructor_path type_constructor  => bug_type_constructor("type_constructor_path", type_constructor);
        end;

	fun type_constructor_module_path (TYPE_CONSTRUCTOR_BY_MODULE_PATH { module_path, ... } ) => module_path;
	    type_constructor_module_path type_constructor => bug_type_constructor("type_constructor_module_path", type_constructor);
        end;

	fun type_constructor_arity (PRIMITIVE_TYPE_CONSTRUCTOR { arity, ... } | TYPE_CONSTRUCTOR_BY_MODULE_PATH { arity, ... } ) => arity;
	    type_constructor_arity (DEFINED_TYPE_CONSTRUCTOR { type_scheme=>TYPE_SCHEME { arity, ... }, ... } ) => arity;
	    type_constructor_arity (RECORD_TYPE_CONSTRUCTOR l) => length l;
	    type_constructor_arity (ERRONEOUS_TYPE_CONSTRUCTOR) => 0;
	    type_constructor_arity type_constructor => bug_type_constructor("type_constructor_arity", type_constructor);
        end;

	fun set_type_constructor_path (type_constructor, path)
            =
	    case type_constructor
              
		PRIMITIVE_TYPE_CONSTRUCTOR { stamp, arity, eq, kind, path => _, stub => _ }
		    =>
		    PRIMITIVE_TYPE_CONSTRUCTOR { stamp, arity, eq, kind, path,  stub => NULL };

		DEFINED_TYPE_CONSTRUCTOR { type_scheme, strict, stamp, path=>_}
		    =>
		    DEFINED_TYPE_CONSTRUCTOR { type_scheme, path, strict, stamp };

		_   => bug_type_constructor("setTypeConstructorName", type_constructor);
            esac;

	fun eq_record_labels (NIL, NIL) => TRUE;
	    eq_record_labels (x ! xs, y ! ys) => symbol::eq (x, y) and eq_record_labels (xs, ys);
	    eq_record_labels _ => FALSE;
        end;

												# stamp				is from   src/lib/compiler/frontend/typecheck-stuff/basics/stamp.pkg

	fun type_constructors_are_equal (PRIMITIVE_TYPE_CONSTRUCTOR g, PRIMITIVE_TYPE_CONSTRUCTOR g') => stamp::eq (g.stamp, g'.stamp);
	    type_constructors_are_equal (ERRONEOUS_TYPE_CONSTRUCTOR, _) => TRUE;
	    type_constructors_are_equal (_, ERRONEOUS_TYPE_CONSTRUCTOR) => TRUE;

	    # This rule for PATHtycs is conservatively correct,
	    # but is only an approximation:
	    #
	    type_constructors_are_equal (TYPE_CONSTRUCTOR_BY_MODULE_PATH { module_path=>ep, ... }, TYPE_CONSTRUCTOR_BY_MODULE_PATH { module_path=>ep', ... } )
                =>
	        ep::module_paths_are_equal (ep, ep');

	    # This last case used for comparing DEFINED_TYPE_CONSTRUCTOR's, RECORD_TYPE_CONSTRUCTOR's.
	    # Also used in PPBasics to check data constructors of
	    # a enum.  Used elsewhere?
	    #
	    type_constructors_are_equal (RECORD_TYPE_CONSTRUCTOR l1, RECORD_TYPE_CONSTRUCTOR l2)
                =>
                eq_record_labels (l1, l2);

	    type_constructors_are_equal _
	        =>
                FALSE;
        end;

		#  for now... 
	fun make_constructor_type (ERRONEOUS_TYPE_CONSTRUCTOR, _)
                =>
                WILDCARD_TYPE;

	    make_constructor_type (type_constructor as DEFINED_TYPE_CONSTRUCTOR { type_scheme, strict, ... }, args)
		=>
		CONSTRUCTOR_TYPE (type_constructor, paired_lists::map
				  (fn (type, strict) => if strict  type; else WILDCARD_TYPE;fi; end )
				  (args, strict));

	    make_constructor_type (type_constructor, args)
	        =>
                CONSTRUCTOR_TYPE (type_constructor, args);
        end;

	fun prune (TYPE_VARIABLE_REF { ref_typevar => tv as REF (RESOLVED_TYPE_VARIABLE type), ... }) : Type
		=>
		{   pruned = prune type;

		    tv := RESOLVED_TYPE_VARIABLE pruned;
		    pruned;
		};

	    prune  type
	        =>
                type;
        end;

	fun typevar_refs_are_equal
            ( { id => _, ref_typevar => tv1: Ref( Type_Variable ) },
              { id => _, ref_typevar => tv2: Ref( Type_Variable ) }
            )
            =
            tv1 == tv2;

	fun resolve_type_variables_to_typescheme_slots (type_variables: List( Typevar_Ref )) : Void
            =
            loop (type_variables, 0)
            where
	        fun loop ([], _)
                        =>
                        ();

		    loop ({ ref_typevar, id } ! rest, n)
                        =>
		        {   ref_typevar := RESOLVED_TYPE_VARIABLE (TYPE_SCHEME_ARG_I n);
		            loop (rest, n+1);
                        };
                end;
	    end;

	fun resolve_type_variables_to_typescheme_slots_1 (type_variables: List( Typevar_Ref )) : types::Type_Scheme_Arg_Eq_Properties
            =
            loop (type_variables, 0)
            where
	        fun loop ([], _)
                        =>
                        [];

		    loop( { id, ref_typevar as REF (USER_TYPE_VARIABLE { eq, ... } ) } ! rest, n)
			=>
			{   ref_typevar := RESOLVED_TYPE_VARIABLE (TYPE_SCHEME_ARG_I n);
			    eq ! loop (rest, n+1);
			};

		    loop _
			=>
			bug "resolve_type_variables_to_typescheme_slots_1: USER_TYPE_VARIABLE";
                end;
	    end;

	exception SHARE;


	# This function should be merged soon with
	# instantiate_if_type_scheme    --zsh  XXX BUGGO FIXME **
	#
	fun apply_type_scheme (TYPE_SCHEME { arity, body }, args)
            =
	    if (arity > 0)

		substitute body
		except
		    SHARE
			=>
			body;

		    (SUBSCRIPT | INDEX_OUT_OF_BOUNDS)
			=>
			bug "apply_type_scheme - not enough arguments";
		end;
	    else
		body;
	    fi
	    where

		# We assume that f fails on identity,
		# i.e. f x raises SHARE instead of 
		# returning x:
		#
		fun share_map f NIL
			=>
			raise exception SHARE;

		    share_map f (x ! l)
			=>
			(f x) ! ((share_map f l) except SHARE = l)
			except
			    SHARE = x ! (share_map f l);
		end;

                fun substitute (TYPE_SCHEME_ARG_I n)
                        =>
                        list::nth (args, n);

		    substitute (CONSTRUCTOR_TYPE (type_constructor, args))
                        =>
                        CONSTRUCTOR_TYPE (type_constructor, share_map substitute args);

		    substitute (TYPE_VARIABLE_REF { id, ref_typevar as (REF (RESOLVED_TYPE_VARIABLE type)) } )
                        =>
                        substitute type;

		    substitute _
                        =>
                        raise exception SHARE;
                end;
	    end;					# where

	# Transform every
        #     CONSTRUCTOR_TYPE.type_constructor
	# in given type:
	#
	fun map_constructor_type_dot_type_constructor  transform
            =
            map_type
            where
	        fun map_type type
                    =
		    case type
		      
		         CONSTRUCTOR_TYPE (type_constructor, types)
			     => 
			     make_constructor_type
                               (
                                 transform  type_constructor,
                                 map  map_type  types
                               );

		         TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties,
                                            type_scheme => TYPE_SCHEME { arity, body }
                                          }
			     =>
			     TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties,
						type_scheme
                                                    =>
                                                    TYPE_SCHEME { arity,
								  body  => map_type body
								}
					      };

		         TYPE_VARIABLE_REF { id, ref_typevar as REF (RESOLVED_TYPE_VARIABLE type) }
			     =>
			     map_type type;

		         _ => type;
                    esac;
	    end;


	# Same as above, without constructing return value.
	# Commented out because it is nowhere used -- 2009-07-18 CrT
	#
#	fun apply_constructor_type_dot_type_constructor  user_fn
#            =
#            apply_type
#            where
#
#	        fun apply_type type
#                    =
#		    case type
#		      
#		         CONSTRUCTOR_TYPE (type_constructor, types)
#			     =>
#			     {   user_fn  type_constructor;
#				 apply  apply_type  types;
#			     };
#
#		         TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties,
#                                            type_scheme => TYPE_SCHEME { arity, body }
#                                          }
#			     =>
#			     apply_type  body;
#
#		         TYPE_VARIABLE_REF { id, ref_typevar as REF (RESOLVED_TYPE_VARIABLE type) }
#			     =>
#			     apply_type  type;
#
#		         _ => ();
#                    esac;
#	    end;


	exception BAD_TYPE_REDUCTION;


	fun reduce_type (CONSTRUCTOR_TYPE (DEFINED_TYPE_CONSTRUCTOR { type_scheme, ... }, args))
		=>
		apply_type_scheme (type_scheme, args);

	    reduce_type (TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties =>  [],
                                            type_scheme                   =>  TYPE_SCHEME { arity=>0, body }
                                          }
                        )
		=>
		body;

	    reduce_type (TYPE_VARIABLE_REF { id, ref_typevar as REF (RESOLVED_TYPE_VARIABLE type) } )
		=>
		type;

	    reduce_type _
		=>
		raise exception BAD_TYPE_REDUCTION;
        end;

	fun head_reduce_type  type
            =
            head_reduce_type (reduce_type  type)
            except
                BAD_TYPE_REDUCTION
		    =
		    type;

	fun types_are_equal (type, type')
            =
            eq (prune type, prune type')
            where

	        fun eq (TYPE_SCHEME_ARG_I i1, TYPE_SCHEME_ARG_I i2)
			=>
			i1 == i2;

		    eq (TYPE_VARIABLE_REF  tv, TYPE_VARIABLE_REF tv')
			=>
			typevar_refs_are_equal (tv, tv');

		    eq (   type  as CONSTRUCTOR_TYPE (type_constructor,  args ),
                           type' as CONSTRUCTOR_TYPE (type_constructor', args')
                       )
			=>
			if   (type_constructors_are_equal (type_constructor, type_constructor'))
			    
			     paired_lists::all types_are_equal (args, args'); 
			else
			     eq (reduce_type type, type')
			     except
				 BAD_TYPE_REDUCTION
				     =
				     eq (type, reduce_type type')
				     except
					 BAD_TYPE_REDUCTION
					     =
					     FALSE;
                        fi;

		    eq (type1 as (TYPE_VARIABLE_REF _ | TYPE_SCHEME_ARG_I _), type2 as CONSTRUCTOR_TYPE _)
                        =>
		        eq (type1, reduce_type type2)
		        except
                            BAD_TYPE_REDUCTION
				=
				FALSE;


		    eq (type1 as CONSTRUCTOR_TYPE _, type2 as (TYPE_VARIABLE_REF _ | TYPE_SCHEME_ARG_I _))
                        =>
		        eq (reduce_type type1, type2)
		        except
                            BAD_TYPE_REDUCTION
				=
				FALSE;


		    eq (WILDCARD_TYPE, _) => TRUE;
		    eq(_, WILDCARD_TYPE) => TRUE;
		    eq _ => FALSE;
                end;
	    
	    end;

	stipulate

	    #  Making dummy argument lists to be used in type_constructor_equality 

												# stamp				is from   src/lib/compiler/frontend/typecheck-stuff/basics/stamp.pkg
	    generator = stamp::new_generator();

	    fun make_dummy_type ()
                =
		CONSTRUCTOR_TYPE
                  (
                    PRIMITIVE_TYPE_CONSTRUCTOR {

                        stamp => stamp::fresh generator,
			path  => ip::INVERSE_PATH [ symbol::make_type_symbol "Dummy" ],
			arity => 0,
                        eq    => REF YES,
                        stub  => NULL,
		        kind  => PRIMITIVE core_primitive_type_constructor_numbers::prim_type_num_void
                    },

                    []
                  );

		 # Making dummy type is a temporary hack ! pt_void is not used
		 # anywhere in the source language ... Requires major clean up 
		 # in the future. (ZHONG)
		 # David B MacQueen: shouldn't cause any problem here.  Only thing relevant
		 # property of the dummy types is that they have different stamps
		 # and their stamps should not agree with those of any "real" tycons.

	    # precomputing dummy argument lists
	    # -- perhaps a bit of over-optimization here. [dbm]

	    fun makeargs (0, args) =>  args;
	        makeargs (i, args) =>  makeargs (i - 1, make_dummy_type() ! args);
            end;

	    args10 = makeargs (10,[]);  #  10 dummys 
	    args1  = [head args10];
	    args2  = list::take (args10, 2);
	    args3  = list::take (args10, 3);  #  rarely need more than 3 args 

	 herein

            fun dummyargs 0 =>  [];    
		dummyargs 1 =>  args1;
		dummyargs 2 =>  args2;
		dummyargs 3 =>  args3;

		dummyargs n
		    =>
		    if (n <= 10)
		        
			list::take (args10, n);     #  Should be plenty 
		    else
			makeargs (n - 10, args10);  #  But make new dummys if needed 
                    fi;
            end;
	end;

	# type_constructor_equality.  This definition deals only partially with types that
	# contain PATHtycs.  There is no interpretation of the PATHtycs, but
	# PATHtycs with the same module_path will be seen as equal because of the
	# definition on type_constructors_are_equal.
	#
	fun type_constructor_equality (ERRONEOUS_TYPE_CONSTRUCTOR, _)   =>   TRUE;
	    type_constructor_equality (_, ERRONEOUS_TYPE_CONSTRUCTOR)   =>   TRUE;

	    type_constructor_equality (t1, t2)
		=>
		{   a1 = type_constructor_arity t1;
		    a2 = type_constructor_arity t2;

		    if (a1 != a2)
		        
			FALSE;
		    else
			args = dummyargs a1;

			types_are_equal
			    ( make_constructor_type (t1, args),
			      make_constructor_type (t2, args)
			    );
		    fi;
		};
        end;

	#  Instantiating polytypes 
	#
# 2009-04-17 CrT: Following is never actually used.
# Function  copy_type_scheme()  in   src/lib/compiler/frontend/typechecker/types/resolve-overloaded-variables.pkg
# has an almost identical function, however.
#	fun make_type_args n
#            = 
#	    if   (n > 0)
#	         make_meta_type_variable_and_type() ! make_type_args (n - 1);
#	    else [];
#            fi;

	default_type_variable_property = FALSE;



	fun make_polymorphic_api 0
                =>
                [];

	    make_polymorphic_api n
		=>
		default_type_variable_property ! make_polymorphic_api (n - 1);
        end;


	fun datatype_constructor_to_type_constructor (ENUM_CONSTRUCTOR { constructor_type, const, symbol, ... } )
            =
            f (constructor_type, const)
            where
		fun f (TYPE_SCHEME_TYPE { type_scheme => TYPE_SCHEME { body, ... }, ... }, b)
			=>
			f (body, b);

		    f (CONSTRUCTOR_TYPE (type_constructor, _), TRUE)
			=>
			type_constructor;

		    f (CONSTRUCTOR_TYPE (_, [_, CONSTRUCTOR_TYPE (type_constructor, _) ] ), FALSE)
			=>
			type_constructor;

		    f _
			=>
			bug "datatype_constructor_to_type_constructor";
                end;
	    end;

	fun boundargs n
            = 
            loop 0
            where
	        fun loop (i)
                    =
		    if   (i >= n)   NIL;
		    else            TYPE_SCHEME_ARG_I i ! loop (i+1);
                    fi;
	    end;

	fun datatype_constructor_to_type (type_constructor, domain)
            =
	    {   arity = type_constructor_arity type_constructor;
	    
		case arity
		  
		    0   =>  case domain

				 NULL    =>         CONSTRUCTOR_TYPE (type_constructor, []);
				 THE dom => dom --> CONSTRUCTOR_TYPE (type_constructor, []);
			    esac;


		   _ => TYPE_SCHEME_TYPE {

                             type_scheme_arg_eq_properties
                                 =>
                                 make_polymorphic_api  arity,

			     type_scheme
                                 =>
                                 TYPE_SCHEME {
                                     arity,
		                     body => case domain   NULL    =>         CONSTRUCTOR_TYPE (type_constructor, boundargs (arity));
						           THE dom => dom --> CONSTRUCTOR_TYPE (type_constructor, boundargs (arity));
                                             esac
                                 }
                         };
                esac;
	    };

	# Matching a scheme against a
        # target type -- used declaring
        # overloadings
	#
	fun match_scheme
            ( TYPE_SCHEME { arity, body }: Type_Scheme,
              target: Type
            )
            : Type
            =
	    {   tyenv = make_rw_vector (arity, UNDEFINED_TYPE);

		fun match_tyvar (i: Int, type: Type) : Void
                    = 
		    case (tyenv sub i)
		      
			UNDEFINED_TYPE
			    =>
			    update (tyenv, i, type);

			type'
			    =>
			    if (not (types_are_equal (type, type')))

				 bug("src/lib/compiler/frontend/typecheck-stuff/types/type-stuff.pkg: Inconsistent types in overload statement");
			    fi;
                    esac;

		fun match (scheme: Type, target: Type)
                    =
		    case (prune scheme, prune (target))
		      
			(WILDCARD_TYPE, _) => ();		#  Wildcards match any type 
			(_, WILDCARD_TYPE) => ();		#  Wildcards match any type 

			((TYPE_SCHEME_ARG_I i), type)
			    =>
                            match_tyvar (i, type);

			(       CONSTRUCTOR_TYPE (type_constructor1, args1),
			  pt as CONSTRUCTOR_TYPE (type_constructor2, args2)
			)
			    =>
			    if (type_constructors_are_equal (type_constructor1, type_constructor2))

				paired_lists::apply match (args1, args2);
			    else
				match (reduce_type scheme, target)
				except
				    BAD_TYPE_REDUCTION
					=
					match (scheme, reduce_type pt)
					except
					    BAD_TYPE_REDUCTION
						=
						bug "match_scheme, match -- types ";

			    fi;

		        _ => bug "match_scheme, match";
                    esac;

	    
                case (prune target)
		  
		     TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties,
                                        type_scheme => TYPE_SCHEME { arity => arity', body => body' }
                                      }
			 =>
			 {   match (body, body');

			     TYPE_SCHEME_TYPE {

				 type_scheme_arg_eq_properties,

				 type_scheme => TYPE_SCHEME { arity => arity',
							      body  => if    (arity > 1)
									    ctt::tuple_type (rw_vector::fold_right (!) NIL tyenv);
								       else 
									     tyenv sub 0;
								       fi
							    }
			     };
			 };

		     type
			 => 
			 {   match (body, type);

			     arity > 1   ??   ctt::tuple_type (rw_vector::fold_right (!) NIL tyenv)
			                 ::   tyenv sub 0;
			 };
                esac;
	    };

	recursive val  drop_macro_expanded_indirections_from_type
                =
		fn t as TYPE_VARIABLE_REF { id => _, ref_typevar as REF (RESOLVED_TYPE_VARIABLE (TYPE_VARIABLE_REF { id => _, ref_typevar => REF v })) }
		       =>
		       {   ref_typevar := v;
			   drop_macro_expanded_indirections_from_type t;
		       };


		   TYPE_VARIABLE_REF { id, ref_typevar as REF (INCOMPLETE_RECORD_TYPE_VARIABLE { known_fields, ... } ) }
		       =>
		       apply (drop_macro_expanded_indirections_from_type o #2) known_fields;


		   CONSTRUCTOR_TYPE (type_constructor, tyl)
		       =>
		       apply drop_macro_expanded_indirections_from_type tyl;


		   TYPE_SCHEME_TYPE { type_scheme => TYPE_SCHEME { body, ... }, ... }
		       =>
		       drop_macro_expanded_indirections_from_type body;

		   _ => ();
	end ;





	# For background see the discussion near the top of
        #
	#     src/lib/compiler/frontend/typechecker/types/unify-and-generalize-types-g.pkg
        #
	# If argument is not a TYPE_SCHEME_TYPE, return it unchanged.
        #
	# Otherwise instantiate body of TYPE_SCHEME_TYPE
        # with new META type variables, returning the
        # instantiated body and the list of fresh META
        # type variables.
        #
	#
	# We are invoked from:
	#
        #     new ()
        #         in
        #         src/lib/compiler/frontend/typechecker/types/resolve-overloaded-variables.pkg
	#
        #     eqv_tnsp_type ()
        #     match_abstract_type_to_actual_type ()
        #         in
        #         src/lib/compiler/frontend/typechecker/modules/api-match-g.pkg
	#
	#     compute_pattern_type ()
	#     compute_expression_type ()
        #         in
        #         src/lib/compiler/frontend/typechecker/types/unify-and-generalize-types-g.pkg
	#
	fun instantiate_if_type_scheme
                (
                  TYPE_SCHEME_TYPE
                      {
                        type_scheme_arg_eq_properties,
                        type_scheme
                      }
                )
                :
                ( Type,
                  List( Type )
                )
		=>
		{   # Create N new META type variables given
		    # a list of N boolean values specifying
		    # the equality property for them:
		    #
                    fresh_meta_type_variables
                        =
                        map  f  type_scheme_arg_eq_properties
                        where
			    fun f eq
                                =
                                TYPE_VARIABLE_REF
                                    (make_type_variable_ref
                                        ( META_TYPE_VARIABLE { fn_nesting => infinity, eq },
                                          ["instantiate_if_type_scheme  from  type-stuff.pkg"]
                                        )
                                    );
                        end;

		    ( apply_type_scheme (type_scheme, fresh_meta_type_variables),
		      fresh_meta_type_variables
		    );
		};

	    instantiate_if_type_scheme  type
		=>
		(type, []);
        end;


	stipulate 

	    exception CHECKEQ;

	herein

	    fun check_eq_type_api (type,  type_scheme_arg_eq_properties: Type_Scheme_Arg_Eq_Properties)
                =
		{   {   eqty  type;
			TRUE;
                    }
                    where
			fun eqty (TYPE_VARIABLE_REF { id, ref_typevar => REF (RESOLVED_TYPE_VARIABLE type) } )
				=>
				eqty type;

			    eqty (CONSTRUCTOR_TYPE (DEFINED_TYPE_CONSTRUCTOR { type_scheme, ... }, args))
				=>
				eqty (apply_type_scheme (type_scheme, args));

			    eqty (CONSTRUCTOR_TYPE (PRIMITIVE_TYPE_CONSTRUCTOR { eq, ... }, args))
				=>
				case *eq
				    CHUNK          =>  ();
				    YES            =>  apply eqty args;

				    ( NO
				    | EQ_ABSTRACT
				    | INDETERMINATE
				    )              =>  raise exception CHECKEQ;

				    p              =>  bug ("checkEqTySig: " + equality_property_to_string p);
				esac;

			    eqty (CONSTRUCTOR_TYPE (RECORD_TYPE_CONSTRUCTOR _, args))
				=>
				apply eqty args;

			    eqty (TYPE_SCHEME_ARG_I n)
				=>
				if (not (list::nth (type_scheme_arg_eq_properties, n)))

				     raise exception CHECKEQ;
				fi;

			    eqty _ => ();
			end;
		    end;
		}
		except CHECKEQ = FALSE;
	end;

	exception COMPARE_TYPES;

	fun compare_type ( spec_type,
                           spec_api:    Type_Scheme_Arg_Eq_Properties,
                           actual_type,
		           actual_api:  Type_Scheme_Arg_Eq_Properties,
                           actual_arity
                         )
                         : Void
            =
            compare (spec_type, actual_type)
            where
	        type_vector = make_rw_vector (actual_arity, UNDEFINED_TYPE);

		fun compare (type1, type2)
                    =
                    compare'
                      ( head_reduce_type type1,
                        head_reduce_type type2
                      )

		also	    
		fun compare'(WILDCARD_TYPE, _) => ();
		    compare'(_, WILDCARD_TYPE) => ();

		    compare'(type1, TYPE_SCHEME_ARG_I i)
			=>
			case (type_vector sub i)
			  
			    UNDEFINED_TYPE
				=>
				(   {   eq = list::nth (actual_api, i);

					if  (eq and not (check_eq_type_api (type1, spec_api)))
					    raise exception COMPARE_TYPES;
					fi;

					update (type_vector, i, type1);
				    }
				    except (SUBSCRIPT|INDEX_OUT_OF_BOUNDS) = ()
				);

			    type => if (not (types_are_equal (type1, type)))

					 raise exception COMPARE_TYPES;
				    fi;
                       esac;

		    compare' (   CONSTRUCTOR_TYPE (type_constructor1, args1),
                                 CONSTRUCTOR_TYPE (type_constructor2, args2)
                             )
			=>
			if (type_constructors_are_equal (type_constructor1, type_constructor2))
			    paired_lists::apply compare (args1, args2);
			else
                            raise exception COMPARE_TYPES;
                        fi;

		   compare' _
                       =>
                       raise exception COMPARE_TYPES;
                end; 
	    end;



	#  Return TRUE if package type > api type 
	#
	fun pkg_type_matches_api_type
            { type_per_api: Type,
              type_per_pkg: Type
            }
            : Bool
            = 
	    {   type_per_pkg   =   prune type_per_pkg;					# Drop redundant RESOLVED_TYPE_VARIABLE indirections.
	    
                case type_per_api
		  
		     TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties => eq_props,
                                        type_scheme => TYPE_SCHEME { body, ... }
                                      }
                         =>
		         case type_per_pkg
			   
			     TYPE_SCHEME_TYPE {   type_scheme_arg_eq_properties => eq_props',
						  type_scheme => TYPE_SCHEME { arity, body => body' }
					      }
				 =>
				 {   compare_type (body, eq_props, body', eq_props', arity);
				     TRUE;
				 };

			     WILDCARD_TYPE => TRUE;
			     _             => FALSE;
                         esac;


		    WILDCARD_TYPE
                        =>
                        TRUE;

		    _   =>
			case type_per_pkg
			  
			     TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties,
						type_scheme => TYPE_SCHEME { arity, body }
					      }
				 =>
				 {   compare_type (type_per_api, [], body, type_scheme_arg_eq_properties, arity);
				     TRUE;
				 };

			     WILDCARD_TYPE =>  TRUE;
			     _             =>  types_are_equal (type_per_api, type_per_pkg);
			esac;
                esac;
	    }
            except
                COMPARE_TYPES
                =
                FALSE;

	#  Given a single-type-variable type, extract out the Typevar_Ref 
	#
	fun type_variable_of_type (TYPE_VARIABLE_REF (tv as { id, ref_typevar => REF (META_TYPE_VARIABLE              _) } )) =>   tv;
	    type_variable_of_type (TYPE_VARIABLE_REF (tv as { id, ref_typevar => REF (INCOMPLETE_RECORD_TYPE_VARIABLE _) } )) =>   tv;
	    type_variable_of_type (TYPE_VARIABLE_REF        { id, ref_typevar => REF (RESOLVED_TYPE_VARIABLE t         ) }  ) =>   type_variable_of_type t;

	    type_variable_of_type WILDCARD_TYPE
                =>
                # Fake a Typevar_Ref:
		#
                make_type_variable_ref
                    ( make_meta_type_variable  infinity,
                      ["type_variable_of_type  from  type-stuff.pkg"]
                    );

	    type_variable_of_type (TYPE_SCHEME_ARG_I i)     =>   bug "type_variable_of_type: TYPE_SCHEME_ARG_I";
	    type_variable_of_type (CONSTRUCTOR_TYPE(_, _))  =>   bug "type_variable_of_type: CONSTRUCTOR_TYPE";
	    type_variable_of_type (TYPE_SCHEME_TYPE _)      =>   bug "type_variable_of_type: TYPE_SCHEME_TYPE";
	    type_variable_of_type UNDEFINED_TYPE            =>   bug "type_variable_of_type: UNDEFINED_TYPE";
	    type_variable_of_type _                         =>   bug "type_variable_of_type 124";
        end; 

	# get_recursive_type_variable_map:  (Int, Type) -> (Int -> Bool) 
	# See if a bound Typevar_Ref has occurred in some datatypes, e::g. List(X).
	# This is useful for representation analysis. This function probably
	# will soon be obsolete. 
	#
	fun get_recursive_type_variable_map (n, type)
            =
	    {   s = rw_vector::make_rw_vector (n, FALSE);

		fun not_arrow type_constructor
                    =
                    not (type_constructors_are_equal (type_constructor, ctt::arrow_tycon));
	       #  or type_constructors_are_equal (type_constructor, fate_type) 

		fun special (type_constructor as PRIMITIVE_TYPE_CONSTRUCTOR { arity, ... } )
			=>
			arity != 0 and not_arrow type_constructor;

		    special (RECORD_TYPE_CONSTRUCTOR _) => FALSE;
		    special type_constructor => not_arrow type_constructor;
                end;

		fun scan (b, (TYPE_SCHEME_ARG_I n))
			=>
			if   b      (update (s, n, TRUE));   fi;


		    scan (b, CONSTRUCTOR_TYPE (type_constructor, args))
			=> 
			{   nb = (special type_constructor) or b;

			    apply  (fn t =  scan (nb, t))  args;
			};

		    scan (b, TYPE_VARIABLE_REF { id, ref_typevar => REF (RESOLVED_TYPE_VARIABLE type) } )
			=>
			scan (b, type);

		    scan _ => ();
                end;
		                                                  
                scan (FALSE, type);

	    
                fn i =  (   rw_vector::get (s, i)
                            except
                                (exceptions::SUBSCRIPT|exceptions::INDEX_OUT_OF_BOUNDS)
                                =
			        bug "Strange things in type_stuff::get_recursive_type_variable_map"
                        );
	    };

	fun label_is_greater_than (a, b)
            =
	    {   a' = symbol::name a;
                b' = symbol::name b;

		a0 = string::get (a', 0);
                b0 = string::get (b', 0);
	    
                if (char::is_digit a0)
		    
		    if (char::is_digit b0)
			(size a' > size b' or size a' == size b' and a' > b');
		    else
                        FALSE;
                    fi;
		else
		    if (char::is_digit b0)
			TRUE;
		    else
                        (a' > b');
                    fi;
                fi;
	    };

	#  Tests used to implement the value restriction 
	#  Based on Ken Cline's version; allows refutable patterns 
	#  Modified to support CAST, and special naming CASE_EXPRESSION. (ZHONG) 

	# Modified to allow applications of lazy my rec Y combinators to
	# be nonexpansive. (Taha, David B MacQueen)

	stipulate

            include deep_syntax;

        herein

	    # This function is invoked exactly one place
	    # in the codebase, by
            #     unify_and_generalize_types_g::declaration_type'()
	    # 	
	    fun is_value { inlining_info_says_it_is_pure }
                =
		is_val
                where

		    fun is_val (       VARIABLE_IN_EXPRESSION     _) =>  TRUE;
			is_val (       CONSTRUCTOR_EXPRESSION     _) =>  TRUE;
			is_val (   INT_CONSTANT_IN_EXPRESSION     _) =>  TRUE;
			is_val (   UNT_CONSTANT_IN_EXPRESSION     _) =>  TRUE;
			is_val ( FLOAT_CONSTANT_IN_EXPRESSION     _) =>  TRUE;
			is_val (STRING_CONSTANT_IN_EXPRESSION     _) =>  TRUE;
			is_val (  CHAR_CONSTANT_IN_EXPRESSION     _) =>  TRUE;
			is_val (                FN_EXPRESSION     _) =>  TRUE;
			is_val (   RECORD_SELECTOR_EXPRESSION(_, e)) =>  is_val e;

			is_val (RECORD_EXPRESSION fields)
			    =>
			    fold_right  (fn ((_, expression), x) =  x and (is_val expression))
                                        TRUE
                                        fields;


		        is_val (VECTOR_EXPRESSION (exps, _))
			    =>
			    fold_right
                                (fn (expression, x) =  x and (is_val expression))
                                TRUE
                                exps;

			is_val (SEQUENTIAL_EXPRESSIONS NIL) => TRUE;
			is_val (SEQUENTIAL_EXPRESSIONS [e]) => is_val e;
			is_val (SEQUENTIAL_EXPRESSIONS _)   => FALSE;

			is_val (APPLY_EXPRESSION (operator, operand))
			    =>
			    {   fun isrefdcon (ENUM_CONSTRUCTOR { representation=>a::REF_REP, ... } )
					=>
					TRUE;

				    isrefdcon _
                                        =>
                                        FALSE;
                                end;

				fun iscast (ORDINARY_VARIABLE { inlining_info, ... } )
					=>
					inlining_info_says_it_is_pure inlining_info;

				    iscast _
                                        =>
                                        FALSE;
                                end;

				/*
				fun iscast (ORDINARY_VARIABLE { inlining_info, ... } ) = ii::pure_info (ii::fromExn inlining_info)
				  | iscast _ = FALSE
				 */

				# LAZY: The following function allows applications of the
				# fixed-point combinators generated for lazy my recs to
				# be non-expansive.

				fun issafe (ORDINARY_VARIABLE { path=>(symbol_path::SYMBOL_PATH [s]), ... } )
					=> 
					case (string::explode (symbol::name s))
					  
					     'Y' ! '$' ! _ =>  TRUE;
					     _             =>  FALSE;
					esac;

				    issafe _
                                        =>
                                        FALSE;
                                end;

				fun iscon (CONSTRUCTOR_EXPRESSION (dcon, _)) => not (isrefdcon dcon);
				    iscon (SOURCE_CODE_REGION_FOR_EXPRESSION (e, _)) => iscon e;
				    iscon (VARIABLE_IN_EXPRESSION (REF v, _)) => (iscast v) or (issafe v);
				    iscon _ => FALSE;
                                end;

				iscon operator   ??   is_val operand
				                 ::   FALSE;
			    };

		        is_val (TYPE_CONSTRAINT_EXPRESSION (e, _))
                            =>
                            is_val e;

		        is_val (CASE_EXPRESSION (e, (CASE_RULE (p, _)) ! _, FALSE))
			    => 
			    (is_val e) and (irrefutable p);				#  special bind CASEexps 

		        is_val (LET_EXPRESSION (RECURSIVE_VALUE_DECLARATIONS _, e))
			    =>
			    (is_val e);							#  special NAMED_RECURSIVE_VALUES hacks 

		        is_val (SOURCE_CODE_REGION_FOR_EXPRESSION (e, _)) => is_val e;
		        is_val _ => FALSE;
                    end;
		end

	    #  Test if a case pattern is irrefutable --- complete 
	    #
	    also
	    fun irrefutable  case_rule_pattern
		= 
		g  case_rule_pattern
                where
		    fun udcon (ENUM_CONSTRUCTOR { signature => a::CONSTRUCTOR_SIGNATURE (x, y), ... } )
			    =>
			    (x+y) == 1;

		        udcon _
                            =>
                            FALSE;
                    end;

		    fun g (CONSTRUCTOR_PATTERN (dc, _))     =>    udcon dc;
		        g (APPLY_PATTERN (dc, _, p))   =>   (udcon dc) and (g p);

		        g (RECORD_PATTERN { fields => ps, ... } )
			    => 
			    h ps
                            where
			        fun h ((_, p) ! r)
					=>
					g p   ??   h r
					      ::   FALSE;

				    h _ => TRUE;
				end;   
			    end;

		        g (TYPE_CONSTRAINT_PATTERN (p, _))  =>   g p;
		        g (AS_PATTERN (p1, p2))             =>   (g p1) and (g p2);
		        g (OR_PATTERN (p1, p2))             =>   (g p1) and (g p2);

		        g (VECTOR_PATTERN (ps, _))
			   => 
			   h ps
                           where
			       fun h (p ! r)
				       =>
				       g p   ??   h r
					     ::   FALSE;

				   h _ => TRUE;
			       end;
			   end;

		        g _ => TRUE;
                    end;
		end;

	end; #  local 

	fun is_variable_type (TYPE_VARIABLE_REF { id, ref_typevar => REF (RESOLVED_TYPE_VARIABLE type) } )
		=>
		is_variable_type type;

	    is_variable_type (TYPE_VARIABLE_REF _)
		=>
		TRUE;

	    is_variable_type (_)
		=>
		FALSE;
        end;


	# sort_fields, map_unzip: Two utility functions used in type checking
	# (unify-and-generalize-types-g.pkg):
	#
	fun sort_fields fields
            =
	    list_mergesort::sort
                      fn ((deep_syntax::NUMBERED_LABEL { number=>n1, ... }, _),
			  (deep_syntax::NUMBERED_LABEL { number=>n2, ... }, _)) => n1>n2;
                      end
		      fields;

	# Given input List( X )
        # and a function f: X -> (Y, Z),
        # return (List( Y ), List( Z ))
        # generated by applying f to all given x:
	#
	fun map_unzip f NIL
		=>
		(NIL, NIL);

	    map_unzip f (first ! rest)
		=>
		{   my (x,  y )  =  f first;
		    my (xs, ys)  =  map_unzip f rest;

		    (x ! xs, y ! ys);
		};
        end;

	fun fold_type_entire f
            =
	    {   fun fold_tc (type_constructor, b0)
                    = 
		    case type_constructor
		      	
		         PRIMITIVE_TYPE_CONSTRUCTOR { kind, ... }
                             =>
			     case kind
			       
			          DATATYPE {   family => { members=>ms, ... }, ... }
				      =>
				      b0;

                    	  #       fold_left (fn ( { dcons, ... }, b) => fold_left foldDcons b dcons) b0 ms 

			          ABSTRACT tc
				      =>
				      fold_tc (tc, b0);

			          _   =>   b0;
                             esac;


		         DEFINED_TYPE_CONSTRUCTOR { type_scheme => TYPE_SCHEME { arity, body }, ... }
			     =>
			     fold_type (body, b0);

		        _ => b0;
                    esac

		also
		fun fold_dcons ( { name, representation, domain=>NULL }, b0)
			=>
			b0;

		    fold_dcons ( { domain=>THE type, ... }, b0)
			=>
			fold_type (type, b0);
                end 

		also
		fun fold_type (type, b0)
                    =
		    case type
		      
			CONSTRUCTOR_TYPE (tc, tl)
			    => 
			    {   b1 = f      (tc, b0);
				b2 = fold_tc (tc, b1);

				fold_left fold_type b2 tl;
			    };

			TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties, type_scheme => TYPE_SCHEME { arity, body } }
			    =>
			    fold_type (body, b0);

			TYPE_VARIABLE_REF { id, ref_typevar => REF (RESOLVED_TYPE_VARIABLE type) }
			    =>
			    fold_type (type, b0);

			_ => b0;
                    esac;
	    
                fold_type;
	    };

	fun map_type_entire f
            =
	    {   fun map_type type
                    =
		    case type
		      
			CONSTRUCTOR_TYPE (tc, tl)
			    =>
			    make_constructor_type (f (map_tc, tc), map map_type tl);

			TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties, type_scheme => TYPE_SCHEME { arity, body } }
			    =>
			    TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties,
					       type_scheme => TYPE_SCHEME { arity,
									    body  => map_type body
									  }
					     };

			TYPE_VARIABLE_REF { id, ref_typevar => REF (RESOLVED_TYPE_VARIABLE type) }
			    =>
			    map_type type;

			_ => type;
                    esac

		also
		fun map_tc type_constructor
                    = 
		    case type_constructor
		      
			PRIMITIVE_TYPE_CONSTRUCTOR { stamp, arity, eq, path, kind, stub => _ }
			    =>
			    case kind

				 DATATYPE { index, family=> { members, ... }, ... } => type_constructor;

			      /*
			       *  XXX BUGGO FIXME The following code needs to be rewritten !!! (ZHONG)

					     PRIMITIVE_TYPE_CONSTRUCTOR { stamp=stamp, arity=arity, eq=eq, path=path,
						     kind=DATATYPE { index=index, members=map mapMb members, 
								    lambdatyc = REF NULL }}
			      */

				 ABSTRACT tc
				     =>
				     PRIMITIVE_TYPE_CONSTRUCTOR {   stamp,
								    arity,
								    eq,
								    path,
								    kind  => ABSTRACT (map_tc tc),
								    stub  => NULL
								};
				_ => type_constructor;
			   esac;


			DEFINED_TYPE_CONSTRUCTOR { stamp, strict, type_scheme, path }
			    => 
			    DEFINED_TYPE_CONSTRUCTOR {   stamp,
							strict,
							path,
							type_scheme => map_tf type_scheme
						    };

			_ => type_constructor;
                    esac

		also
		fun map_mb { type_constructor_name, stamp, arity, dcons, lambdatyc }
		    = 
		    {   type_constructor_name,
			stamp,
			arity, 
			dcons               => (map map_dcons dcons),
			lambdatyc           => REF NULL
		    }

		also
		fun map_dcons (x as { name, representation, domain=>NULL } )
			=> x;

		    map_dcons (x as { name, representation, domain=>THE type } )
			=> 
			{   name,
			    domain => THE (map_type type),
			    representation
			};
                end 

		also
		fun map_tf (TYPE_SCHEME { arity, body } )
		    = 
		    TYPE_SCHEME { arity,
				    body  => map_type body
				  };

	    
                map_type;
	    };


	# Using a set implementation should suffice here,
	# but I am using a binary dictionary instead. (ZHONG)
	#
	stipulate

	    package type_constructor_set= stamp_map;	# stamp_map	is from   src/lib/compiler/frontend/typecheck-stuff/basics/stampmap.pkg

	herein

	    Type_Constructor_Set
                =
                type_constructor_set::Map( Type_Constructor );

	    make_type_constructor_set
                =
                fn () =  type_constructor_set::empty;



	    fun insert_type_constructor_into_set (type_constructor as PRIMITIVE_TYPE_CONSTRUCTOR { stamp, ... }, tycset)
		    => 
		    type_constructor_set::set (tycset, stamp, type_constructor);

	        insert_type_constructor_into_set _
		    =>
		    bug "unexpected tycons in insert_type_constructor_into_set";
            end;



	    fun is_in_type_constructor_set ( type_constructor as PRIMITIVE_TYPE_CONSTRUCTOR { stamp, ... }, tycset)
		    =>
		    not_null (type_constructor_set::get (tycset, stamp));

	        is_in_type_constructor_set _
                    =>
                    FALSE;
            end;



	    fun filter_type_constructor_set (type, tycs)
		= 
	        fold_type_entire pass1 (type, [])
                where
		    fun in_list (a ! r, tc)
			    =>
			    if (type_constructors_are_equal (a, tc))
			        TRUE;
			    else
                                in_list (r, tc);
                            fi;

		        in_list ([], tc)
                            =>
                            FALSE;
                    end;

		    fun pass1 (tc, tset)
			= 
			if (is_in_type_constructor_set (tc, tycs))

			    if (in_list (tset, tc))       tset;
			    else                     tc ! tset;
			    fi;
			else
                            tset;
                        fi;
		end;

	    /*
	      filter_type_constructor_set = fn x =>
	      compile_statistics::do_phase (compile_statistics::make_phase "Compiler 034 filter_type_constructor_set") filter_type_constructor_set x
	    */

	end;



	fun datatype_sibling (n, type_constructor as PRIMITIVE_TYPE_CONSTRUCTOR { kind => DATATYPE dt, ... } )
		=>
		{   dt -> { index, stamps, free_type_constructors, root, family as { members, ... } };

		    if (n == index)
		        type_constructor;
		    else
			(vector::get (members, n))
			    ->
			    { type_constructor_name,
			      arity,
			      constructor_list,
			      eq,
			      is_lazy,
			      an_api
			    };


			stamp = vector::get (stamps, n);

			PRIMITIVE_TYPE_CONSTRUCTOR {   stamp,
					   arity,
					   eq,
					   stub  => NULL,
					   path  => ip::INVERSE_PATH [ type_constructor_name ],
					   kind  => DATATYPE { index    => n,
							       stamps,
							       free_type_constructors,
							       root     => NULL /* ! */,
							       family
							     }
				       };
		    fi;
		};

	    datatype_sibling _
                =>
                bug "datatype_sibling";
        end;

	# NOTE: this only works (perhaps) for enum declarations, but not           XXX BUGGO FIXME
	# specifications. The reason: the root field is used to connect mutually
	# recursive enum specifications together, its information cannot be
	# fully recovered in datatype_sibling. (ZHONG)
	#
	fun extract_datatype_constructor (type_constructor as PRIMITIVE_TYPE_CONSTRUCTOR { kind => DATATYPE dt, ... } )
		=>
		map make_datatype_constructor
                    constructor_list
                where
		    dt -> { index, stamps, free_type_constructors, root, family as { members, ... }};

		    my { constructor_list, an_api, is_lazy, ... }
			=
			vector::get (members, index);

		    fun expand_type_constructor (TYPE_CONSTRUCTOR_BY_MODULE_PATH _)
			    =>
			    bug "expandTypeConstructor: TYPE_CONSTRUCTOR_BY_MODULE_PATH"; #  use expandTypeConstructor? 

		        expand_type_constructor (RECURSIVE_TYPE n)
			    =>
			    datatype_sibling (n, type_constructor);

		        expand_type_constructor (FREE_TYPE n)
			    => 
			    ((list::nth (free_type_constructors, n))
			    except _
			       =>
			       bug "unexpected free_type_constructors in extract_datatype_constructor"; end );

		        expand_type_constructor type_constructor
			    =>
			    type_constructor;
                    end;

		    fun expand type
			=
			map_constructor_type_dot_type_constructor
                            expand_type_constructor
                            type;


		    fun make_datatype_constructor ( { name, representation, domain } )
			=
			ENUM_CONSTRUCTOR {
			    symbol         => name,
			    representation,
			    signature => an_api,
			    is_lazy,
			    constructor_type => datatype_constructor_to_type (type_constructor, null_or::map expand domain),
			    const            => case domain
						     NULL => TRUE;
						     _    => FALSE;
						esac
			};
		end;

	    extract_datatype_constructor _
		=>
		bug "extract_datatype_constructor";
        end;

	fun make_strict 0 =>  [];
	    make_strict n =>  TRUE ! make_strict (n - 1);
        end;

	# Used in typecheck_api for enum replication specs,
        # where the type_constructor arg is expected to be
        # either a PRIMITIVE_TYPE_CONSTRUCTOR/DATATYPE
        # or a TYPE_CONSTRUCTOR_BY_MODULE_PATH.
	#
	fun wrap_definition (type_constructor as DEFINED_TYPE_CONSTRUCTOR _, _)
		=>
		type_constructor;

	    wrap_definition (type_constructor, s)
		=>
		{   arity = type_constructor_arity type_constructor;
		    name  = type_constructor_name type_constructor;
		    args  = boundargs arity;

		    DEFINED_TYPE_CONSTRUCTOR {
			stamp  => s,
			strict => make_strict arity,
			path   => ip::INVERSE_PATH [ name ],

			type_scheme => TYPE_SCHEME {   arity,
							 body  => CONSTRUCTOR_TYPE (type_constructor, args)
						     }
		    };
		};
        end;


	#  eta-reduce a type function: \args.tc args => tc 
	#
	fun unwrap_definition_1 (type_constructor as DEFINED_TYPE_CONSTRUCTOR {
                                               type_scheme => TYPE_SCHEME {
                                                                  body => CONSTRUCTOR_TYPE (type_constructor', args),
                                                                  arity
                                                              },
                                               ...
                                           }
                       )
		=>
		{   fun formals ((TYPE_SCHEME_ARG_I i) ! rest, j)
			    =>
			    (i == j)  ??  formals (rest, j+1)
				      ::  FALSE;

			formals (NIL, _) => TRUE;
			formals _        => FALSE;
		    end;

		    (formals (args, 0))
		       ??  THE type_constructor'
		       ::  NULL;
		};

	    unwrap_definition_1 type_constructor
                =>
                NULL;
        end;


	# Closure under iterated eta-reduction 
	#
	fun unwrap_definition_star type_constructor
            =
	    case (unwrap_definition_1 type_constructor)

		THE type_constructor'
		    =>
		    unwrap_definition_star type_constructor';

		NULL
		    =>
		    type_constructor;
	    esac;



    end;	# stipulate

};		# package type_stuff 










##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## Copyright 1996 by Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
