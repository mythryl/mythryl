## typecheck-stuff.pkg 

# Compiled by:
#     src/lib/compiler/frontend/typechecker/typecheck.make6


# The center of the typechecker is
#
#     src/lib/compiler/frontend/typechecker/typecheck/typecheck-package-language-g.pkg
#
# -- see it for a higher-level overview.
# It calls us for utility functions to build
# deep syntax trees from raw syntax trees.



###                 "Strunk felt that the reader was in serious
###                  trouble most of the time, a man floundering
###                  in a swamp, and that it was the duty of anyone
###                  attempting to write English to drain the swamp
###                  quickly and get his man up on dry ground, or
###                  at least throw him a rope."
###
###                                            -- EB White



package typecheck_stuff

: (weak) Typecheck_Stuff				# Typecheck_Stuff		is from   src/lib/compiler/frontend/typechecker/typecheck/typecheck-stuff.api

{
    stipulate

	package sp  = symbol_path;			# symbol_path			is from   src/lib/compiler/frontend/typecheck-stuff/basics/symbol-path.pkg
	package lu  = find_in_symbol_table;		# find_in_symbol_table		is from   src/lib/compiler/frontend/typecheck-stuff/symbol-table/find-in-symbol-table.pkg
	package a   = var_home;				# var_home			is from   src/lib/compiler/frontend/typecheck-stuff/basics/var-home.pkg
	package b   = symbol_table_entry;		# symbol_table_entry		is from   src/lib/compiler/frontend/typecheck-stuff/symbol-table/symbol-table-entry.pkg
	package st  = symbol_table;			# symbol_table			is from   src/lib/compiler/frontend/typecheck-stuff/symbol-table/symbol-table.pkg
	package ee  = typechecker_dictionary;		# typechecker_dictionary	is from   src/lib/compiler/frontend/typecheck-stuff/modules/typechecker-dictionary.pkg
	package ts  = type_variable_set;		# type_variable_set		is from   src/lib/compiler/frontend/typechecker/typecheck/type-variable-sets.pkg
	package s   = symbol;				# symbol			is from   src/lib/compiler/frontend/basics/mlcomp/symbol.pkg
	package v   = variables_and_constructors;	# variables_and_constructors	is from   src/lib/compiler/frontend/typecheck-stuff/deep-syntax/variables-and-constructors.pkg
	package bt  = type_types;			# type_types			is from   src/lib/compiler/frontend/typechecker/types/type-types.pkg
        package raw = raw_syntax; 
        package em  = error_message;

	include symbol;
        include deep_syntax;
        include print_utilities;
        include raw_syntax_stuff;
        include types;
        include type_types;
        include eq_types;
        include module_stuff;
        include type_stuff;
        include variables_and_constructors;

    herein 

	#  Debugging 
	say = control_print::say;
#	debugging = REF FALSE;
	debugging   =   typechecking_control::typecheck_stuff_debugging;		#  REF FALSE 

	fun if_debugging_say (msg: String)
            =
	    if   *debugging     say msg;   say "\n";   fi;

	fun bug msg
            =
            error_message::impossible ("typecheck_stuff: " + msg);

	print_depth = control_print::print_depth;

	prettyprint_declaration         = prettyprint_deep_syntax::prettyprint_declaration (symbol_table::empty, NULL);
	prettyprint_expression          = prettyprint_deep_syntax::prettyprint_expression  (symbol_table::empty, NULL);
	prettyprint_pattern             = prettyprint_deep_syntax::prettyprint_pattern      symbol_table::empty;

	unparse_type                    = unparse_type::unparse_type                            symbol_table::empty;
	unparse_typevar_ref             = unparse_type::unparse_typevar_ref                     symbol_table::empty;
	unparse_pattern                 = unparse_deep_syntax::unparse_pattern                  symbol_table::empty;
	unparse_expression              = unparse_deep_syntax::unparse_expression              (symbol_table::empty, NULL);
	unparse_rule                    = unparse_deep_syntax::unparse_rule                    (symbol_table::empty, NULL);
	unparse_named_value             = unparse_deep_syntax::unparse_named_value             (symbol_table::empty, NULL);
	unparse_recursively_named_value = unparse_deep_syntax::unparse_recursively_named_value (symbol_table::empty, NULL);

	unparse_declaration
	    = 
	    (fn stream
		=
		fn d
		    =
		    unparse_deep_syntax::unparse_declaration
			    (symbol_table::empty, NULL)
			    stream
			    (d, *print_depth)
	    );

	fun if_debugging_unparse_declaration (msg, declaration)
	    =
	    if *debugging
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, unparse_declaration, declaration));
	    fi;

	fun if_debugging_unparse_type (msg, type)
	    =
	    if *debugging
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, unparse_type, type));
	    fi;

	fun if_debugging_unparse_typevar_ref  (msg, typevar_ref)
	    = 
	    if *debugging		# Without this 'if' (and the matching one in unify_types), compiling the compiler takes 5X as long! :-)
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, unparse_typevar_ref, typevar_ref));
	    fi;

	fun if_debugging_unparse_pattern (msg, pattern)
	    =
	    if *debugging
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, unparse_pattern, pattern));
	    fi;

	fun if_debugging_unparse_expression (msg, expression)
	    =
	    if *debugging	
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, unparse_expression, expression));
	    fi;


	fun if_debugging_prettyprint_expression (msg, expression)
	    =
	    if *debugging	
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, prettyprint_expression, expression));
	    fi;

	fun if_debugging_prettyprint_pattern (msg, pattern)
	    =
	    if *debugging	
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, prettyprint_pattern, pattern));
	    fi;

	fun if_debugging_prettyprint_declaration (msg, declaration)
	    =
	    if *debugging	
		typechecking_debugging::with_internals
		    (fn () =  typechecking_debugging::debug_print debugging (msg, prettyprint_declaration, declaration));
	    fi;





	fun for' l f
            =
            apply f l;

	fun discard _   =   ();
	fun single x    =   [x];

	internal_sym   =   special_symbols::internal_var_id;


	Syntactic_Typechecking_Context 

	    = AT_TOPLEVEL                   #  At top level -- not inside any module, rigid.               
	    | IN_PACKAGE                    #  Inside a rigid package, i.e. not inside any generic package body. 
	    | IN_API                        #  Within a api body.                                    
	    | IN_GENERIC                    #  Inside a generic package.                                           

	      { flex:  stamp::Stamp         #  Predicate recognizing flexible stamps.                      
		    -> Bool,
		depth: debruijn_index::Depth
	      };


        Compile_Info
            =
            compile_info::Compile_Info( deep_syntax::Declaration );


	fun new_valvar (s, make_highcode_variable)
            =
            v::make_ordinary_variable (s, a::named_var_home (s, make_highcode_variable));

	fun smash f l
            = 
            fold_right h (NIL, NIL, NIL) l
            where
	        fun h (a, (pl, oldl, newl))
                    =
		    {   my (p, old, new) = f a;

                        (   p ! pl,
                            old @ oldl,
                            new @ newl
                        );
		    };
	    end;

	stipulate

	    fun uniq ((a0 as (a, _, _)) ! (r as (b, _, _) ! _))
		    => 
		    if (s::eq (a, b) )  uniq r;
		    else                a0 ! uniq r;
                    fi;

	        uniq l
                    =>
                    l;
            end;

	    fun gtr ((a, _, _), (b, _, _))
                =
                {   a' = s::name a;
                    b' = s::name b;

		    a0 = string::get (a', 0);
                    b0 = string::get (b', 0);

		    if   (char::is_digit a0)
		        
                         if   (char::is_digit b0   )   size a' > size b' or size a' == size b' and a' > b';
			 else                          FALSE;                                           fi;
		    else
                         if   (char::is_digit b0   )   TRUE;
			 else                          (a' > b');                fi;
                    fi;
		};

	herein

            fun sort3 x
                =
                uniq (list_mergesort::sort gtr x);
	end;

	equalsym        =   s::make_value_symbol "=";
	anon_param_name =   s::make_package_symbol "<AnonParam>";

	#  following could go in deep_syntax 

	bogus_id      =   s::make_value_symbol "*bogus*";
	bogus_exn_id  =   s::make_value_symbol "*Bogus*";


	truepat    =   CONSTRUCTOR_PATTERN    (true_dcon, []);
	trueexp    =   CONSTRUCTOR_EXPRESSION (true_dcon, []);

	falsepat   =   CONSTRUCTOR_PATTERN    (false_dcon, []);
	falseexp   =   CONSTRUCTOR_EXPRESSION (false_dcon, []);

	nilpat     =   CONSTRUCTOR_PATTERN    (nil_dcon,[]);
	nilexp     =   CONSTRUCTOR_EXPRESSION (nil_dcon,[]);

	conspat    =   fn pattern = APPLY_PATTERN (cons_dcon, [], pattern);
	consexp    =   CONSTRUCTOR_EXPRESSION (cons_dcon,[]);

	unit_expression
            =
            deep_syntax_stuff::unit_expression;

	void_pattern
            =
            RECORD_PATTERN
              {
                fields        =>  NIL,
		is_incomplete =>  FALSE,
		type_ref      =>  REF UNDEFINED_TYPE
	      };

	bogus_expression
            =
            VARIABLE_IN_EXPRESSION
              ( REF (v::make_ordinary_variable (bogus_id, a::null_var_home)),
                []
	      );



	#  Verify that all the elements of a list are unique,    
        #  By sorting and then equality-checking adjacent pairs: 
	#
	fun forbid_duplicates_in_list (err, message, names)
            =
            f names'
            where
	        names' = list_mergesort::sort s::symbol_gt names;

		fun f (x ! y ! rest)
			=>
			{   if (s::eq (x, y))   err em::ERROR (message + ": " + s::name x) em::null_error_body;   fi;
			    f (y ! rest);
			};

		   f _ => ();
                end;
	    end;

	# Extract all the variable namings from a pattern,
        # and return as a new Symbol_Table.
        #
	# NOTE: the "free_or_vars" function in
        # typecheck-core-language.pkg should
	# probably be merged with this.        XXX BUGGO FIXME
	#
	fun bind_varp (patlist, err)
            =
	    {   vl = REF (NIL: List( Symbol ));

		symbol_table = REF (st::empty: st::Symbol_Table);

		fun f (VARIABLE_IN_PATTERN (v as ORDINARY_VARIABLE { path => sp::SYMBOL_PATH [name], inlining_info, ... } ))
			=> 
			{   if (s::eq (name, equalsym))            #  Major hack XXX BUGGO FIXME 
				# if inlining_info::is_primitive_info (inlining_info::fromExn inlining_info) then ()
				# else
                                err  em::WARNING  "renaming ="  em::null_error_body;
			    fi;

			    symbol_table := st::bind (name, b::NAMED_VARIABLE v, *symbol_table); 

			    vl := name ! *vl;
		       };

		   f (RECORD_PATTERN { fields, ... } )      =>  apply (fn(_, pattern)=>f pattern; end ) fields;
		   f (VECTOR_PATTERN (patterns, _))         =>  apply f patterns;
		   f (APPLY_PATTERN (_, _, pattern))        =>  f pattern;
		   f (TYPE_CONSTRAINT_PATTERN (pattern, _)) =>  f pattern;
		   f (AS_PATTERN (p1, p2))                  =>  { f p1; f p2;};
		   f (OR_PATTERN (p1, p2))                  =>  { f p1; bind_varp([p2], err); ();};
		   f _ => ();
               end;

	       apply f patlist;

	       forbid_duplicates_in_list (err, "duplicate variable in pattern (s)", *vl);

	       *symbol_table;
	    };


#	fun isPrimPattern (VARIABLE_IN_PATTERN { info, ... } ) = ii::is_primitive_info (info)
#	  | isPrimPattern (COSTRAINTpat (VARIABLE_IN_PATTERN { info, ... }, _)) = ii::is_primitive_info (info)
#	  | isPrimPattern _ = FALSE;


	# replace_pattern_variables:
	#   "alpha convert" a pattern, replacing old variables by
	#   new ones, with new HIGHCODE_VARIABLE var_homees.
	#   Returns the converted pattern, the list of old variables (VARpats)
	#   and the list of new variables (VALvars).
	# called only once, in typecheckValueNaming in elabcore.sml

	fun replace_pattern_variables (prettyprint, compile_info as { make_highcode_variable, ... } : Compile_Info)
            =
	    {   my oldnew:  Ref( List( (deep_syntax::Case_Pattern, Variable) ) )
                           = REF NIL;

		fun f (p as VARIABLE_IN_PATTERN (ORDINARY_VARIABLE { var_home => acc, inlining_info, var_type => REF type', path } ))
			=>
			{   fun find ((VARIABLE_IN_PATTERN (ORDINARY_VARIABLE { var_home => acc', ... } ), x) ! rest, v)
				    => 
				    case (a::highcode_variable_or_null  acc')            #  David B MacQueen: can this return NULL? XXX BUGGO FIXME 

					 THE w
					 =>
					 if   (v == w)   x;
					 else            find (rest, v);
					 fi;

						   # David B MacQueen:  Can the TRUE branch happen?
						   # ie. two variables with same highcode_variable
						   # in a pattern?

					_ => find (rest, v);
				    esac;


			        find (_ ! rest, v)
				    =>
				    find    (rest, v);

			        find (NIL, v)            #  David B MacQueen: assert this rule always applies ? XXX FIXME BUGGO 
				    =>                      
				    {   x = ORDINARY_VARIABLE {

						var_home        => a::duplicate_var_home (v, make_highcode_variable),
						inlining_info,

						var_type      => REF type',
						path
					    };

					oldnew := (p, x) ! *oldnew;

					x;
				    };
                            end;

			    case (a::highcode_variable_or_null  acc)

				THE v   =>   VARIABLE_IN_PATTERN (find (*oldnew, v));
				_       =>   bug "unexpected var_home in replace_pattern_variables";
			    esac;

			};

		    f (RECORD_PATTERN { fields, is_incomplete, type_ref } )
			=>
			RECORD_PATTERN {

			    fields  => map   (fn (l, p)  =>  (l, f p); end )   fields,
			    is_incomplete,
			    type_ref
			};

		    f (VECTOR_PATTERN (patterns, t))   =>   VECTOR_PATTERN (map f patterns,  t);
		    f (APPLY_PATTERN (d, c, p))      =>   APPLY_PATTERN (d, c, f p);
		    f (OR_PATTERN (a, b))          =>   OR_PATTERN (f a, f b);
		    f (TYPE_CONSTRAINT_PATTERN (p, t))  =>   TYPE_CONSTRAINT_PATTERN (f p, t);
		    f (AS_PATTERN (p, q))     =>   AS_PATTERN (f p, f q);
		    f p => p;
                end;

		np   =   f prettyprint;

		fun h ((a, b) ! r, x, y)   =>   h (r, a ! x, b ! y);
		    h (      [], x, y)   =>   (np, x, y);
                end;


                h (*oldnew, [], []);
	    };



	# Sort the labels in a record.
        # The order is redefined to take
        # the usual ordering on numbers
        # expressed by strings (tuples):
        #
	stipulate 

	    fun sort x
                = 
	        list_mergesort::sort
                    (   fn ((a, _), (b, _))
                           =>
                           type_stuff::label_is_greater_than (a, b); end 
                    )
                    x;
	herein
            fun sort_record (l, err)
                =
	        {   forbid_duplicates_in_list (err, "duplicate label in record", map #1 l);
	            sort l;
                };
	end;


	fun make_record_expression (fields, err)
            =
	    {   fields'
                    =
                    map
                        (   fn (id, expression)
                               =>
                               (id, (expression, REF 0)); end 
                        )
                        fields;


		fun assign (i,   (_, (_, r))  !  tl)
			=>
			{   r := i;
			    assign (i+1, tl);
			};

		    assign (_, NIL)
                        =>
                        ();
                end;


		fun f (i, (id, (expression, REF n)) ! rest)
			=>
			(   NUMBERED_LABEL {  name => id,   number => n },
			    expression
			)
			!
			f (i+1, rest);

		    f (_, NIL)
                        =>
                        NIL;
                end;

                assign (0, sort_record (fields', err));

                RECORD_EXPRESSION (f (0, fields'));
	    };

	tupleexp   =   deep_syntax_stuff::tupleexp;

	/*
	fun TUPLEexp l
            = 
	    {   fun addlabels (i, e ! r) = 
		      (LABEL { number=i - 1, name=(tuples::number_to_label i) }, e) 
		       ! addlabels (i+1, r)
		  | addlabels(_, NIL) = NIL;
	     
                RECORD_EXPRESSION (addlabels (1, l));
	    }
	*/

	fun tpselexp (e, i)
            = 
	    {   lab = NUMBERED_LABEL {
                          number => i - 1,
                          name   => (tuples::number_to_label i)
                      };

                RECORD_SELECTOR_EXPRESSION (lab, e);
	    };

	# Adds a default case to a list of rules. 
	# If given list is marked, all ordinarily-marked expressions 
	#   in default case are also marked, using end of given list 
	#   as location.
        #
	# KLUDGE! The debugger distinguishes marks in the default case by
	#   the fact that start and end locations for these marks 
	#   are the same!
	#
	fun complete_match'' rule [ r as CASE_RULE ( pattern, SOURCE_CODE_REGION_FOR_EXPRESSION (_, (_, right))) ]
		=>
		[ r, rule (fn expression => SOURCE_CODE_REGION_FOR_EXPRESSION (expression, (right, right)); end ) ];

	    complete_match'' rule [r as CASE_RULE (pattern, TYPE_CONSTRAINT_EXPRESSION (SOURCE_CODE_REGION_FOR_EXPRESSION (_, (_, right)), _)) ]
		=>
		[ r, rule (fn expression => SOURCE_CODE_REGION_FOR_EXPRESSION (expression, (right, right)); end ) ];

	    complete_match'' rule [r]
		=>
		[ r, rule (fn expression => expression; end ) ];

	    complete_match'' rule (a ! r)
		=>
		a ! complete_match'' rule r;

	    complete_match'' _ _
		=>
		bug "completeMatch''";
        end;

	fun complete_match' (CASE_RULE (p, e))
            =
	    complete_match'' (fn marker => CASE_RULE (p, marker e); end );

	fun complete_match (symbol_table, name)
            =
	    complete_match'' 
	        (   fn marker
                       =
		       CASE_RULE (
                           WILDCARD_PATTERN, 
		           marker (
                               RAISE_EXPRESSION (
                                   CONSTRUCTOR_EXPRESSION (
                                       core_access::get_exception (symbol_table, name),
                                       []
                                   ),
				   UNDEFINED_TYPE
                               )
                           )
                       )
                );

	trivial_complete_match   =   complete_match (st::empty, "MATCH");

	tuplepat   =   deep_syntax_stuff::tuplepat;

	/*
	fun TUPLEpat l
            =
	    {   fun addlabels (i, e ! r) = (tuples::number_to_label i, e) ! addlabels (i+1, r)
		  | addlabels(_, NIL) = NIL;

                RECORD_PATTERN { fields => addlabels (1, l), is_incomplete => FALSE, type_ref => REF UNDEFINED_TYPE };
	    }
	*/

	fun wrap_recdec (rvbs, compile_info as { make_highcode_variable, ... } : Compile_Info)
            = 
	    {   fun g (   NAMED_RECURSIVE_VALUES {

                              variable => v
					 as
					 ORDINARY_VARIABLE {
					     path => sp::SYMBOL_PATH [ symbol ],
					     ...
					 },
                              ...
                          },
                          nvars
                      )
			=> 
			{   nv = new_valvar (symbol, make_highcode_variable);

			    ( (v, nv, symbol)   !   nvars);
			};

		    g _
			=>
			bug "wrapRECdecGen: NAMED_RECURSIVE_VALUES";
                end;

		vars   =   fold_right g [] rvbs;

		odec   =   RECURSIVE_VALUE_DECLARATIONS  rvbs;

		ref_typevar_refs
                    = 
		    case rvbs
		      
		         (NAMED_RECURSIVE_VALUES { ref_typevar_refs, ... } ) ! _
			     =>
			     ref_typevar_refs;

		        _   =>   bug "unexpected empty rvbs list in wrap_recdec";
                    esac;


		declarations
		    =
		    case vars
		      
		         [ (v, nv, symbol) ]
			     =>
			     VALUE_DECLARATIONS [
				 NAMED_VALUE {
				     pattern            => VARIABLE_IN_PATTERN nv,
				     expression         => LET_EXPRESSION (odec, VARIABLE_IN_EXPRESSION (REF v, [])),
				     bound_typevar_refs => [],
				     ref_typevar_refs
				 }
			     ];


		         _
			     => 
			     {   vs = map (   fn (v, _, _)
						 =
						 VARIABLE_IN_EXPRESSION (REF v, [])
					  )
					  vars;

				 rootv   =   new_valvar (internal_sym, make_highcode_variable);

				 rvexp   =   VARIABLE_IN_EXPRESSION (REF rootv, []);

				 nvdec
				     = 
				     VALUE_DECLARATIONS (
					 [   NAMED_VALUE {

						 pattern            =>  VARIABLE_IN_PATTERN rootv,
						 expression         =>  LET_EXPRESSION (odec, tupleexp vs),
						 bound_typevar_refs =>  [],
						 ref_typevar_refs
					     }
					 ]
				     );

				 h (vars, 1, [])
                                 where
				     fun h ([], _, d)
					     =>  
					     LOCAL_DECLARATIONS (nvdec, SEQUENTIAL_DECLARATIONS (reverse d));

					 h ((_, nv, _) ! r, i, d)
					     => 
					     {   nvb =  NAMED_VALUE {
							    pattern            => VARIABLE_IN_PATTERN nv,
							    expression         => tpselexp (rvexp, i),
							    bound_typevar_refs => [],
							    ref_typevar_refs   => REF []
							};

						 h   (r,   i + 1,   VALUE_DECLARATIONS ([ nvb ]) ! d);
					     };
                                     end;
                                 end;

			     };
                    esac;


                ( vars, 
		  declarations
                );
	    };

# Commented out 2009-04-21 CrT because it is never referenced:
#
#	fun wrap_named_recursive_values_list0 (rvbs, compile_info)
#	    = 
#	    {   my   (vars, ndec)   =   wrap_recdec (rvbs, compile_info);
#
#		case vars
#		  
#		     [(_, nv, _)]   =>   (nv, ndec);
#		     _              =>   bug "unexpected case in wrapRecursiveValueNamingsList0";
#                esac;
#	    };

	# This gets called once locally (below) and once from
        #
        #     src/lib/compiler/frontend/typechecker/typecheck/typecheck-core-language.pkg
        #
	fun wrap_named_recursive_values_list (rvbs, compile_info)
	    = 
	    {   my (vars, new_declaration)
                    =
                    wrap_recdec (rvbs, compile_info);

		fun h ((v, nv, symbol), symbol_table)
                    =
                    st::bind (symbol, b::NAMED_VARIABLE nv, symbol_table);

		new_symbol_table
                    =
                    fold_left h st::empty vars;

		( new_declaration,
                  new_symbol_table
                );
	    };

	arg_var_sym   =   s::make_value_symbol "arg";

	fun c_markexp (e, r)
            =
            if   (*typechecking_control::mark_deep_syntax_tree)
                
                 SOURCE_CODE_REGION_FOR_EXPRESSION (e, r);
            else
                 e;
            fi;

	fun make_deep_syntax_for_mutually_recursive_functions
            ( complete_match,
	      named_function_list,
	      compile_info as   {   make_highcode_variable,   error_match,   ...   }: Compile_Info
	    )
	    = 
	    wrap_named_recursive_values_list (

		map named_function_to_named_recursive_values
		    named_function_list,

		compile_info
	    )
	    where
	        fun named_function_to_named_recursive_values (
                        {   var,
                            clauses as (   { deep_syntax_patterns, result_type, deep_syntax_expression }   !   _),
                            ref_typevar_refs,
                            source_code_region
                        }
                    )
			=>
			{   fun getvar _
				=
				new_valvar (arg_var_sym, make_highcode_variable);

			    vars   =   map getvar deep_syntax_patterns;

			    fun not1 (f,[a]) =>   a;
				not1 (f,  l) =>   f l;
			    end;

			    fun do_var valvar
				=
				VARIABLE_IN_EXPRESSION (REF (valvar), []);

			    fun do_clause ( { deep_syntax_patterns, deep_syntax_expression, result_type=>NULL } )
				    =>
				    CASE_RULE   (not1 (tuplepat, deep_syntax_patterns),   deep_syntax_expression);

				do_clause ( { deep_syntax_patterns, deep_syntax_expression, result_type=>THE type } )
				    =>
				    CASE_RULE (   not1 (tuplepat, deep_syntax_patterns),
						  TYPE_CONSTRAINT_EXPRESSION (deep_syntax_expression, type)
					      );
			    end;

    #	   -- Matthias says: this seems to generate slightly bogus marks:            XXX BUGGO FIXME
    #	 
    #			mark =  case (hd clauses, list::last clauses)
    #
    #				      of (   { expression=SOURCE_CODE_REGION_FOR_EXPRESSION(_, (a, _)), ... },
    #					     { expression=SOURCE_CODE_REGION_FOR_EXPRESSION(_, (_, b)), ... }
    #                                         )
    #                                         =>
    #					 (fn e => SOURCE_CODE_REGION_FOR_EXPRESSION (e, (a, b)))
    #
    #				       | _ => fn e => e

			    fun make_expression [var]
				    => 
				    FN_EXPRESSION (complete_match (map do_clause clauses), UNDEFINED_TYPE);

				make_expression vars
				    => 
				    fold_right
					(   fn (w, e)
					       => 
					       FN_EXPRESSION (
						   complete_match
						       [   CASE_RULE (VARIABLE_IN_PATTERN w,   /*mark*/ e)   ],
						       UNDEFINED_TYPE
					       ); end 
					)
					(   CASE_EXPRESSION (
						tupleexp (map do_var vars),
						complete_match (map do_clause clauses),
						TRUE
					    )
					)
					vars;
			    end;

			    NAMED_RECURSIVE_VALUES {

				variable             =>  var,
				expression           =>  c_markexp (make_expression vars, source_code_region),
				bound_typevar_refs =>  [],
				null_or_type         =>  NULL,
				ref_typevar_refs
			    };
			};

		    named_function_to_named_recursive_values _
                        =>
                        bug "make_deep_syntax_for_mutually_recursive_functions";
                end;
	    end;							# fun make_deep_syntax_for_mutually_recursive_functions

	fun make_handle_expression (
                expression,
                rules,
                compile_info as { make_highcode_variable, ... }: Compile_Info
            )
            =
	    {   v     = new_valvar (exn_id, make_highcode_variable);
		r     = CASE_RULE (VARIABLE_IN_PATTERN v, RAISE_EXPRESSION (VARIABLE_IN_EXPRESSION (REF (v),[]), UNDEFINED_TYPE));
		rules = complete_match' r rules;

                EXCEPT_EXPRESSION (expression, (rules, UNDEFINED_TYPE));
	    };



	# Transform a raw-syntax var_pattern
        # into either a deep-syntax variable
        # or a deep-syntax constructor.
        #
	# If we are given a long path (>1)
        # then it has to be a constructor:
	#
	fun do_var_pattern ( spath,
			     symbol_table,
			     err,
			     compile_info as { make_highcode_variable, ... }: Compile_Info
	    )
	    = 
	    case spath
	      
	         symbol_path::SYMBOL_PATH [id]
		     =>
		     case (lu::find_value_by_symbol   (symbol_table,   id,   fn _ = raise exception st::UNBOUND))
		       	
			  v::CONSTRUCTOR c
			      =>
			      CONSTRUCTOR_PATTERN (c,[]); 

			  _
			      =>
			      VARIABLE_IN_PATTERN (new_valvar (id, make_highcode_variable));
		     esac
		     except
			 st::UNBOUND
			 =
                         {   name = symbol::name id;

                             if   (string::has_upper name)
                                 
				  err em::ERROR 
				      (   "Undefined constructor: "
				      +   name
				      )
				      em::null_error_body;
                             fi;

# XXX PLUGH
# print ("src/lib/compiler/frontend/typechecker/typecheck/typecheck-stuff.pkg/do_var_pattern: symbol::name(id) = '" + (symbol::name id) + "'\n");
			     VARIABLE_IN_PATTERN (new_valvar (id, make_highcode_variable));

                         };


	         _
		     =>
		     CONSTRUCTOR_PATTERN 

			 case (lu::find_value_via_symbol_path (symbol_table, spath, err))
			   
			      v::VARIABLE c
				  =>
				  {   err em::ERROR 
					  (   "variable found where constructor is required: "
					  +   symbol_path::to_string spath
					  )
					  em::null_error_body;

				      (bogus_constructor, []);
				  };

			      v::CONSTRUCTOR c
				  =>
				  (c, []);
			 esac
			 except
			     st::UNBOUND
			     =
			     bug "unbound untrapped";

            esac;


	fun make_record_pattern (l, is_incomplete, err)
	    =
	    RECORD_PATTERN {
                fields   =>  sort_record (l, err),
	        type_ref =>  REF UNDEFINED_TYPE,
	        is_incomplete
            };


	fun clean_pattern
		err 
		(CONSTRUCTOR_PATTERN (ENUM_CONSTRUCTOR { const => FALSE, symbol, ... }, _ ))
		=> 
		{   err
			em::ERROR
                        (   "data constructor "
			+   s::name symbol
			+   " used without argument in pattern"
			)
			em::null_error_body;

		    WILDCARD_PATTERN;
		};

	    clean_pattern
		err
		(p as CONSTRUCTOR_PATTERN (ENUM_CONSTRUCTOR { is_lazy => TRUE, ... }, _ ))
		=> 
		APPLY_PATTERN (
		    bt::dollar_dcon,
		    [],
		    p
		);                #  LAZY   # second argument = NIL OK? 

	    clean_pattern err p
		=>
		p;
        end;

	fun pattern_to_string WILDCARD_PATTERN => "_";

	    pattern_to_string (VARIABLE_IN_PATTERN (ORDINARY_VARIABLE  { path, ... }   ))  =>  sp::to_string path;
	    pattern_to_string (CONSTRUCTOR_PATTERN (ENUM_CONSTRUCTOR { symbol, ... }, _))  =>  s::name symbol;

	    pattern_to_string (INT_CONSTANT_IN_PATTERN (i, _)) => integer::to_string i;

	    pattern_to_string (FLOAT_CONSTANT_IN_PATTERN  s)   =>   s;
	    pattern_to_string (STRING_CONSTANT_IN_PATTERN s)   =>   s;
	    pattern_to_string (CHAR_CONSTANT_IN_PATTERN   s)   =>   "'" + s + "'";

	    pattern_to_string (RECORD_PATTERN _)   =>   "<record>";
	    pattern_to_string (APPLY_PATTERN    _)   =>   "<application>";

	    pattern_to_string (TYPE_CONSTRAINT_PATTERN _)   =>   "<constraint pattern>";
	    pattern_to_string (AS_PATTERN    _)   =>   "<layered pattern>";

	    pattern_to_string (VECTOR_PATTERN     _)   =>   "<vector pattern>";
	    pattern_to_string (OR_PATTERN         _)   =>   "<or pattern>";

	    pattern_to_string _ => "<illegal pattern>";
        end;

	fun make_apply_pattern err (CONSTRUCTOR_PATTERN (d as ENUM_CONSTRUCTOR { const=>FALSE, is_lazy, ... }, t), p)
		=>
		{   p1 = APPLY_PATTERN (d, t, p);

		    if   is_lazy        #  LAZY 
			 APPLY_PATTERN (bt::dollar_dcon, [], p1);
		    else
			 p1;
		    fi;
		};

	    make_apply_pattern err (CONSTRUCTOR_PATTERN (d as ENUM_CONSTRUCTOR { symbol, ... }, _), _)
		=> 
		{   err
			em::ERROR
			(   "constant constructor applied to argument in pattern:"
			+   s::name symbol
			)
			em::null_error_body;

		    WILDCARD_PATTERN;
		};

	    make_apply_pattern err (operator, _)
		=> 
		{   err
			em::ERROR
                        (
			    cat [
			       "non-constructor applied to argument in pattern: ",
			       pattern_to_string operator
			    ]
			)
			em::null_error_body;

		    WILDCARD_PATTERN;
		};
        end;

	fun make_layered_pattern ((x as VARIABLE_IN_PATTERN _), y, _)
		=>
		AS_PATTERN (x, y);

	    make_layered_pattern (TYPE_CONSTRAINT_PATTERN (x, t), y, err)
		=> 
		make_layered_pattern (x, TYPE_CONSTRAINT_PATTERN (y, t), err);

	    make_layered_pattern (x, y, err)
		=>
		{   err em::ERROR "pattern to left of \"as\" must be variable" em::null_error_body;
		    y;
		};
        end;

	fun calculate_strictness (arity, body)
	    =
	    {   argument_found =   rw_vector::make_rw_vector (arity, FALSE);

		fun search (TYPE_VARIABLE_REF { id, ref_typevar => REF (RESOLVED_TYPE_VARIABLE type) } ) =>  search type;
		    search (TYPE_SCHEME_ARG_I n)                              =>  rw_vector::set (argument_found, n, TRUE);
		    search (CONSTRUCTOR_TYPE (type_constructor, args))   =>  apply search args;
		    search _ => (); 		#  for now... 
                end;

		search body;

		rw_vector::fold_right   (!)   NIL   argument_found;
	    };



        # Check whether the
        # type variables appearing in a type
        # (used) are bound (as parameters in
        # a type declaration):
	#
	fun check_bound_type_variables (used, bound, err)
            =
	    {   boundset
                    = 
		    fold_right
                        (   fn (v, s)
                               =
                               ts::union (ts::singleton v, s, err)
                        )
			ts::empty
                        bound;

                apply nasty (ts::get_elements (ts::diff (used, boundset, err)))
                where
		    fun nasty { id => _, ref_typevar => REF (RESOLVED_TYPE_VARIABLE (TYPE_VARIABLE_REF (typevar_ref as { id, ref_typevar }) )) }
			    =>
			    nasty  typevar_ref;

			nasty (typevar_ref as { id => _, ref_typevar => (user_bound as REF (USER_TYPE_VARIABLE _)) })
			    => 
			    err
				em::ERROR
				(   "Unbound type variable in type declaration: "
				+    unparse_type::typevar_ref_printname  typevar_ref
				)
				em::null_error_body;

			nasty _
			    =>
			    bug "check_bound_type_variables";
		    end;
                end;

	    };



	#
	fun symbol_naming_label
            ( (NUMBERED_LABEL { name, ... }):  deep_syntax::Numbered_Label
            )
            : symbol::Symbol
            =
            name;

	exception IS_RECURSIVE;



        # Convert a deep syntax NAMED_RECURSIVE_VALUES
        # expression to a deep syntax VALUE_DECLARATIONS
        # if we can and a deep syntax RECURSIVE_VALUE_DECLARATIONS
        # if we must.
        #
	# This was formerly done in
        #     src/lib/compiler/backend/upper/translate/nonrec.pkg;
        # but is now done during type checking -- our sole
        # call is currently in
        #    src/lib/compiler/frontend/typechecker/types/unify-and-generalize-types-g.pkg
	#
	fun convert_deep_syntax_named_recursive_values_list_to_deep_syntax_value_declarations_or_recursive_value_declarations
                (   rvbs
                    as
		    [   NAMED_RECURSIVE_VALUES {
			    variable as
				     v::ORDINARY_VARIABLE {
					 var_home => a::HIGHCODE_VARIABLE our_root_variable,
					 ...
				     }, 
			    expression,
			    null_or_type,
			    ref_typevar_refs,
			    bound_typevar_refs
			}
		    ]
                )
		=> 
		{
                    {
			# If 'expression' contains an internal
                        # reference to 'our_root_variable'
                        # from above then we must build
			# a RECURSIVE_VALUE_DECLARATIONS
			# return value, but otherwise we
			# can get away with a simple
			# VALUE_DECLARATIONS return value. 
                        #
                        # Here we recursively treewalk
                        # 'expression' searching for appearances
			# of our_root_variable.  If we find one
                        # we raise IS_RECURSIVE and exit via the
                        # below 'except' clause, otherwise we
                        # return the below VALUE_DECLARATIONS
                        # expression:
			#
			check_exp expression;
			#
			pattern    =  VARIABLE_IN_PATTERN variable;
                        expression =  case null_or_type
					   THE type => TYPE_CONSTRAINT_EXPRESSION (expression, type);
					   NULL       => expression;
				      esac;
			#
			if (*debugging and ((list::length bound_typevar_refs) > 0))
			    printf "Creating NAMED_VALUE from NAMED_RECURSIVE_VALUES with %d-entry bound_typevar_refs list in convert_deep_syntax_named_recursive_values_list_to_deep_syntax_value_declarations_or_recursive_value_declarations in typecheck-stuff.pkg\n" (list::length bound_typevar_refs);
			    printf "\nNAMED_VALUE.bound_typevar_refs: (%d)\n" (list::length bound_typevar_refs);
			    apply  unparse_typevar_ref  bound_typevar_refs
			    where
				fun unparse_typevar_ref  typevar_ref
				    =
				    if_debugging_unparse_typevar_ref ("", typevar_ref);
			    end;
			    printf "\n";
			    if_debugging_unparse_pattern    ("\nNAMED_VALUE.pattern == \n", (pattern,100));
			    if_debugging_unparse_expression ("\nNAMED_VALUE.expression == \n", (expression,100));
			    if_debugging_prettyprint_pattern    ("\nNAMED_VALUE.pattern    prettyprint == \n", (pattern,   100));
			    if_debugging_prettyprint_expression ("\nNAMED_VALUE.expression prettyprint == \n", (expression,100));
                        fi;

			VALUE_DECLARATIONS [
			    NAMED_VALUE {
			      pattern,
			      expression,
			      ref_typevar_refs,
			      bound_typevar_refs
			    }
			];
		    }
		    except
			IS_RECURSIVE   =   RECURSIVE_VALUE_DECLARATIONS rvbs;
		}
		where

		    # All we do here is raise IS_RECURSIVE
                    # if 'e' anywhere contains 'our_root_variable':
		    #
		    fun check_exp e					# 'e' == 'exp' == 'expression'
			=
			case e

			     VARIABLE_IN_EXPRESSION (REF (v::ORDINARY_VARIABLE { var_home => a::HIGHCODE_VARIABLE v, ... } ), _)
				 =>
				 if (v == our_root_variable)   raise exception IS_RECURSIVE;    fi;

			     VARIABLE_IN_EXPRESSION _           => ();
			     RECORD_EXPRESSION l                => apply (fn (lab, x) = check_exp x)  l;
			     SEQUENTIAL_EXPRESSIONS l           => apply check_exp l;

			     APPLY_EXPRESSION (a, b)            => { check_exp a; check_exp b;};
			     TYPE_CONSTRAINT_EXPRESSION (x, _)  =>   check_exp x;
			     EXCEPT_EXPRESSION (x, (l, _))      => { check_exp x;   apply   (fn CASE_RULE (_, x) =  check_exp x)   l;};

			     RAISE_EXPRESSION (x, _)     =>   check_exp x;
			     LET_EXPRESSION   (d, x)     => { check_dec d;   check_exp x;};
			     CASE_EXPRESSION  (x, l, _)  => { check_exp x;   apply   (fn CASE_RULE (_, x) =  check_exp x)   l; };

			     IF_EXPRESSION { test_case, then_case, else_case }
				 =>
				 {   check_exp test_case;
				     check_exp then_case;
				     check_exp else_case;
				 };

			     (   AND_EXPRESSION (e1, e2)
			     |   OR_EXPRESSION  (e1, e2)
			     |   WHILE_EXPRESSION { test => e1, expression => e2 }
			     )
				 =>
				 {   check_exp e1;
				     check_exp e2;
				 };

			     FN_EXPRESSION                     (l, _) => apply   (fn CASE_RULE (_, x) =  check_exp x)   l;
			     SOURCE_CODE_REGION_FOR_EXPRESSION (x, _) => check_exp x;
			     RECORD_SELECTOR_EXPRESSION        (_, e) => check_exp e;

			     VECTOR_EXPRESSION (el, _) => apply check_exp el;
			     PACK_EXPRESSION (e, _, _) => check_exp e;

			     ( CONSTRUCTOR_EXPRESSION _
			     | INT_CONSTANT_IN_EXPRESSION _
			     | UNT_CONSTANT_IN_EXPRESSION _
			     | FLOAT_CONSTANT_IN_EXPRESSION _
			     | STRING_CONSTANT_IN_EXPRESSION _
			     | CHAR_CONSTANT_IN_EXPRESSION _
			     )
			     => ();
			esac


		    # All we do here is raise IS_RECURSIVE
                    # if 'd' anywhere contains 'our_root_variable':
		    #
		    also
		    fun check_dec d					# 'd' == 'dec' == 'declaration'
			=
			case d
				VALUE_DECLARATIONS            vbl =>  apply (fn (NAMED_VALUE            { expression, ... } ) =  check_exp expression)  vbl;
				RECURSIVE_VALUE_DECLARATIONS rvbl =>  apply (fn (NAMED_RECURSIVE_VALUES { expression, ... } ) =  check_exp expression)  rvbl;
				LOCAL_DECLARATIONS (a, b) =>  { check_dec a;  check_dec b;};

				SEQUENTIAL_DECLARATIONS l               => apply check_dec l;
				ABSTRACT_TYPE_DECLARATION { body, ... }  => check_dec body;
				SOURCE_CODE_REGION_FOR_DECLARATION (declaration, _) => check_dec declaration;

				_ => ();
			esac;
		end;


	    convert_deep_syntax_named_recursive_values_list_to_deep_syntax_value_declarations_or_recursive_value_declarations
               rvbs
               =>
               RECURSIVE_VALUE_DECLARATIONS rvbs;
        end;


	# has_modules() tests whether there are
        # explicit module declarations in a declaration.
        #
	# This is used in typecheck_package_language when
        # typechecking LOCAL_DECLARATIONS, as a cheap approximate
        # check of whether a declaration contains any
        # generic declarations.
	#
	fun has_modules (raw::PACKAGE_DECLARATIONS          _) =>   TRUE;
	    has_modules (raw::GENERIC_DECLARATIONS          _) =>   TRUE;

	    has_modules (raw::LOCAL_DECLARATIONS (dec_in, dec_out))
		=>
		has_modules dec_in    or
		has_modules dec_out;

	    has_modules (raw::SEQUENTIAL_DECLARATIONS decs)
		=>
		list::exists has_modules decs;

	    has_modules (raw::SOURCE_CODE_REGION_FOR_DECLARATION (declaration, _))
		=>
		has_modules declaration;

	    has_modules _ => FALSE;
	end;


    end;	#  top-level local 
};		#  package typecheck_stuff 


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Copyright 1992 by AT&T Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
