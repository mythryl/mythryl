## api-match-g.pkg

# Compiled by:
#     src/lib/compiler/frontend/typechecker/typecheck.make6



# The center of the typechecker is
#
#     src/lib/compiler/frontend/typechecker/typecheck/typecheck-package-language-g.pkg
#
# -- see it for a higher-level overview.
# It calls us to do specialized typechecking
# of apis and generics.



###              "If language is not correct,
###                   then what is said is not what is meant.
###               If what is said is not what is meant,
###                   then what ought to be done remains undone."
###
###                                   -- Kong Fu Zi
###                                      (aka "Confucius")


api Api_Match {

    package expand_generic:  Expand_Generic;		# Expand_Generic	is from   src/lib/compiler/frontend/typechecker/modules/expand-generic-g.pkg

    # These four functions are only called
    # inside typecheck-package-language.pkg.


    # thin_package() and cast_package() are a pair.
    #
    # Essentially, the first removes A_PACKAGE.an_api.elements
    # which are not declared in the constraining
    # API, while the second converts A_PACKAGE.an_api.elements
    # to abstract form as required by the constraining API.
    #    
    # We apply both in order to implement strong
    # sealing (SML ":>", Mythryl ":") -- see
    #
    #     typecheck_constrained_package
    #
    # in  src/lib/compiler/frontend/typechecker/typecheck/typecheck-package-language-g.pkg
    #
    # To implement weak sealing
    # (SML ":",  Mythry ": (weak) ")
    # we call the first but not the second.


    thin_package:
                        {    constrained_package:        module::Package,			# Check this package
			     constraining_api:           module::Api,				# against this API.
			     
			     package_expression:         module::Package_Expression,

			     module_stamp_or_null:       Null_Or( module_path::Module_Stamp ),
			     depth:                      debruijn_index::Depth,
			     typechecker_dictionary:     module::Typechecker_Dictionary,

			     inverse_path:               inverse_path::Inverse_Path,
			     symbol_table:               symbol_table::Symbol_Table,

			     source_code_region:         source_map::Source_Code_Region,
			     compile_info:               typecheck_stuff::Compile_Info
                         }
			 ->
                         {   result_declaration:         deep_syntax::Declaration,
			     result_package:             module::Package,
			     coerced_package_expression: module::Package_Expression	# a module::COERCED_PACKAGE coercing original package_expression to proper api.
                         };

    cast_package:
                         {   constrained_package:        module::Package,
			     constraining_api:           module::Api,

			     package_expression:         module::Package_Expression,
			     depth:                      debruijn_index::Depth,

			     typechecker_dictionary:        module::Typechecker_Dictionary,
			     inverse_path:               inverse_path::Inverse_Path,

			     symbol_table:               symbol_table::Symbol_Table,
			     source_code_region:         source_map::Source_Code_Region,
			     compile_info:               typecheck_stuff::Compile_Info
                         }
			 ->	
                         {   result_declaration:         deep_syntax::Declaration,
			     result_package:             module::Package,
			     result_expression:          module::Package_Expression
                         };




     match_generic:  	 {   an_api:                     module::Generic_Api,
			     a_generic:                  module::Generic,
			     generic_expression:         module::Generic_Expression,

			     depth:                      debruijn_index::Depth,
			     typechecker_dictionary:     module::Typechecker_Dictionary,
			     inverse_path:               inverse_path::Inverse_Path,

			     symbol_table:               symbol_table::Symbol_Table,
			     source_code_region:         source_map::Source_Code_Region,
			     compile_info:               typecheck_stuff::Compile_Info
                         }
			 ->
                         {   result_declaration:         deep_syntax::Declaration,
			     result_generic:             module::Generic,
			     result_expression:          module::Generic_Expression
                         };

     apply_generic:    {     a_generic:                  module::Generic,
			     generic_expression:         module::Generic_Expression,
			     arg_package:                module::Package,

			     arg_expression:             module::Package_Expression,
			     module_stamp_or_null:       Null_Or( module_path::Module_Stamp ),
			     depth:                      debruijn_index::Depth,

			     module_path_context:        module_path_context::Context,                                
			     symbol_table:               symbol_table::Symbol_Table,
			     inverse_path:               inverse_path::Inverse_Path,

			     source_code_region:         source_map::Source_Code_Region,
			     compile_info:               typecheck_stuff::Compile_Info
                         }
			 ->
                         {   result_declaration:         deep_syntax::Declaration,
			     result_package:             module::Package,
			     result_expression:          module::Package_Expression
                         };


     debugging:  Ref(  Bool );
     show_apis:  Ref(  Bool );

}; #  Api Api_Match


#  We use a generic to factor out dependencies on highcode:
#
# This generic is invoked in
#     src/lib/compiler/frontend/semantic/modules/api-match.pkg
#
generic package api_match_g (package expand_generic:  Expand_Generic;)		# Expand_Generic			is from   src/lib/compiler/frontend/typechecker/modules/expand-generic-g.pkg
									# expand_generic			is from   src/lib/compiler/frontend/semantic/modules/expand-generic.pkg
: (weak)  Api_Match							# Api_Match				is from   src/lib/compiler/frontend/typechecker/modules/api-match-g.pkg

{
    stipulate

	package ep = module_path;					# module_path				is from   src/lib/compiler/frontend/typecheck-stuff/modules/module-path.pkg
	package epc= module_path_context;				# module_path_context			is from   src/lib/compiler/frontend/typecheck-stuff/modules/module-path-context.pkg

        package deep = deep_syntax;					# deep_syntax				is from   src/lib/compiler/frontend/typecheck-stuff/deep-syntax/deep-syntax.pkg
	package ste  = symbol_table_entry;				# symbol_table_entry			is from   src/lib/compiler/frontend/typecheck-stuff/symbol-table/symbol-table-entry.pkg
	package vh   = var_home;					# var_home				is from   src/lib/compiler/frontend/typecheck-stuff/basics/var-home.pkg

	package td  = typechecker_dictionary;				# typechecker_dictionary		is from   src/lib/compiler/frontend/typecheck-stuff/modules/typechecker-dictionary.pkg
	package em  = error_message;					# error_message				is from   src/lib/compiler/frontend/basics/errormsg/error-message.pkg
	package tcs = typecheck_stuff;					# typecheck_stuff			is from   src/lib/compiler/frontend/typechecker/typecheck/typecheck-stuff.pkg

	package ip  = inverse_path;					# inverse_path				is from   src/lib/compiler/frontend/typecheck-stuff/basics/symbol-path.pkg
	package m   = module;						# module				is from   src/lib/compiler/frontend/typecheck-stuff/modules/module.pkg
	package ms  = module_stuff;					# module_stuff				is from   src/lib/compiler/frontend/typecheck-stuff/modules/module-stuff.pkg

	package pp = prettyprint;					# prettyprint				is from   src/lib/prettyprint/src/prettyprint.pkg
	package s  = symbol;						# symbol				is from   src/lib/compiler/frontend/basics/mlcomp/symbol.pkg
	package se = symbol_table;					# symbol_table				is from   src/lib/compiler/frontend/typecheck-stuff/symbol-table/symbol-table.pkg

	package sp = symbol_path;					# symbol_path				is from   src/lib/compiler/frontend/typecheck-stuff/basics/symbol-path.pkg
	package st = stamp;						# stamp					is from   src/lib/compiler/frontend/typecheck-stuff/basics/stamp.pkg
	package t  = types;						# types					is from   src/lib/compiler/frontend/typecheck-stuff/types/types.pkg

	package ts = type_stuff;					# type_stuff				is from   src/lib/compiler/frontend/typecheck-stuff/types/type-stuff.pkg
	package v  = variables_and_constructors;			# variables_and_constructors		is from   src/lib/compiler/frontend/typecheck-stuff/deep-syntax/variables-and-constructors.pkg

	package gxs= expand_generic::generics_expansion_stuff;

	include types;
	include module;
	include variables_and_constructors;
	include typechecking_debugging;

    herein

	package expand_generic = expand_generic;

	exception BAD_NAMING;

	show_apis = REF FALSE;
	debugging = typechecking_control::api_match_debugging; 		#  eval:   set_control "typechecker::api_match_debugging" "TRUE";

	# To use the above "debugging" flag you might (say) do
        #
        #     linux$ cd src/app/tut/test
        #     linux$ touch test.pkg
        #     linux$ my
        #     eval:  set_control "typechecker::api_match_debugging" "TRUE";
        #     eval:  make "test.make6";
        #
        # This will spew debug printouts of various datastructures
        # as the code in this file runs.


	say = control_print::say;

	fun if_debugging_say (msg: String)
            =
	    if   *debugging       say msg;   say "\n";   fi;



	fun bug msg
            =
            em::impossible ("api_match:" + msg);

	nth = list::nth;

	fun for' l f
            =
            apply f l;

	fun unwrap_typecon_entry (TYPE_CONSTRUCTOR_ENTRY x) => x;
	    unwrap_typecon_entry _ => bug "unwrap_typecon_entry";
        end;

        # Given a list of symbols created by
        #     src/lib/compiler/frontend/basics/mlcomp/symbol.pkg
        # return "a, b, c" or such:
	#
	fun symbols_to_string [ ] =>  "";
	    symbols_to_string [n] =>  s::name n;

	    symbols_to_string (n ! r)
                =>
	        cat (s::name n ! fold_right
                                     (fn (n, b) = (", " ! s::name n ! b))
                                     []
                                     r);
        end;

	bogus_type = UNDEFINED_TYPE; 

	# Bogus coercion expressions returned by the matching functions.
	# These should never be evaluated. 
        #
	bogus_package_expression =   m::VARIABLE_PACKAGE [];
	bogus_generic_expression =   m::VARIABLE_GENERIC [];

	fun if_debugging_show_package (msg, pkg)
            =
	    with_internals (fn () =  debug_print
                                        debugging
					( msg,
					  (fn pps =  fn pkg =  unparse_package_language::unparse_package pps (pkg, se::empty, 100)),
					  pkg
                                        )
                          );

	fun exception_representation (vh::EXCEPTION _, var_home) =>  vh::EXCEPTION var_home;
	    exception_representation _                           =>  bug "unexpected Constructor_Form in exception_representation";
        end;

	fun is_named (THE _) =>  TRUE;
	    is_named _       =>  FALSE;
        end;

	anonymous_package_symbol =  s::make_package_symbol  "<anonymous_package>";
	anonymous_generic_symbol =  s::make_generic_symbol  "<anonymous_generic>";

	generic_api_parameter_typechecked_package_symbol
            =
            s::make_package_symbol
                "<generic_api_parameter_evaluation>";

	fun ident _ = ();



	#  Match an abstract version of a type with its actual version.
	#  Return TRUE and the new instantiations if package type > api type 
	#
	fun try_unifying_pkg_with_api_type
            ( type_per_api,
              type_per_pkg,
              inlining_info
            )
            :
	    ( List( Type        ),
	      List( Typevar_Ref ),
	      Type,
	      Bool			# TRUE iff the two match.
	    )
            =
	    {   type_per_pkg =  ts::prune type_per_pkg;			# Drop redundant RESOLVED_TYPE_VARIABLE indirections.
		type_per_api =  ts::prune type_per_api;			# Drop redundant RESOLVED_TYPE_VARIABLE indirections.

		my   (type_per_pkg', types_per_pkg') =   ts::instantiate_if_type_scheme  type_per_pkg;
		my   (type_per_api', types_per_api') =   ts::instantiate_if_type_scheme  type_per_api;

                paired_lists::apply  unify  (types_per_pkg', types_per_api')
                where
		    fun unify (type1, type2)
                        =
                        unify_types::unify_types ("1", "2", type1, type2, ["try_unifying_pkg_with_api_type"]);
                end;

		# This is a gross hack. Inlining-information such as primops 
		# (or inline-able expressions) are propagated through api
		# matching. However, their types may change. The following code
		# is to figure out the proper type application arguments, insttys.
		# The typechecker has a similar hack. We will clean this up in the
		# future (ZHONG).
		#
		# Change: The hack is gone, but I am not sure whether the code
		# below could be further simplified.  (inline_primitive now has mandatory
		# type information, and this type information is always correctly
		# provided by primitives-symbol-table.pkg.)  (Blume, 1/2001)


		types
                    = 
		    case (gxs::param::inlining_info_to_my_type  inlining_info)

			THE type_per_inlining_info
			    =>
			    {   my  (type_per_inlining_info', types_per_inlining_info')
				    =
				    ts::instantiate_if_type_scheme  type_per_inlining_info;

				unify_types::unify_types ("1", "2", type_per_inlining_info', type_per_pkg', ["try_unifying_pkg_with_api_type"])
				except
				    _ = ();

				types_per_inlining_info';
			    };

		        NULL => types_per_pkg';

                    esac;

		types_matched
                    =
                    {   unify_types::unify_types ("1", "2", type_per_pkg', type_per_api', ["try_unifying_pkg_with_api_type"]);
                        TRUE;
                    }
                    except
                        _ = FALSE;

		typevar_refs
                    =
                    map ts::type_variable_of_type
                        types_per_pkg';						# Should I use types_per_api' here instead, why types_per_pkg' ? XXX BUGGO FIXME 


                (types, typevar_refs, type_per_api', types_matched);
	    };									# fun try_unifying_pkg_with_api_type



	# This function does about 80%
	# of what the above function does.
	#
        # This one  gets used in thin_package();
	# the above gets used in cast_package().
	#
	# This one gets called only when the pkg and api types are known to match;
	# the above gets called when this is not known, hence returns that information.
	#
	fun unify_pkg_with_api_type { type_per_api, type_per_pkg, inlining_info }
            :
            ( List( Type        ),
              List( Typevar_Ref )
            )
            = 
	    {   type_per_pkg
                    =
                    ts::prune  type_per_pkg;					# Drop redundant RESOLVED_TYPE_VARIABLE indirections.

		my (type_per_pkg', types_per_pkg') =  ts::instantiate_if_type_scheme  type_per_pkg;
		my (type_per_api', types_per_api') =  ts::instantiate_if_type_scheme  type_per_api;

		types
                    = 
		    case (gxs::param::inlining_info_to_my_type  inlining_info)

			THE type_per_inlining_info
			    =>
			    {   my (type_per_inlining_info', types_per_inlining_info')
				    =
				    ts::instantiate_if_type_scheme   type_per_inlining_info;

				unify_types::unify_types  ("1", "2", type_per_inlining_info', type_per_pkg', ["unify_pkg_with_api_type"])
				except
				    _ = ();

				types_per_inlining_info';
			    };


			NULL => types_per_pkg';

                    esac;

		(unify_types::unify_types  ("1", "2", type_per_pkg', type_per_api', ["unify_pkg_with_api_type"]))
		except
		    _ = bug "unexpected types in unify_pkg_with_api_type";


		typevar_refs	
                    =
                    map  ts::type_variable_of_type
                         types_per_api';


                (types, typevar_refs);
	    };



	##########################################################################
	#
	# thin_package':   Matching a package against an api.
	# 
	# WARNING: rpath is an inverse module_path, so it has to be
	#          reversed to produce an module_path.
	#
	fun thin_package'
                (
		  constrained_pkg
                      as
                      A_PACKAGE {
                          an_api => API {
                                        stamp    =>  pkg_api_stamp,
				        elements =>  pkg_api_elements,
				        ...
				    },

			  typechecked_package
                              as
                              { stamp                  =>  pkg_stamp,
				typechecker_dictionary =>  package_typechecker_dictionary,
			        ...
			      },

			  var_home      =>  constrained_pkg_var_home,
			  inlining_info =>  constrained_pkg_inline_info
		      }
                      : Package,

                  constraining_api
                      as
                      API {
			  stamp            =>  constraining_api_stamp,
			  closed           =>  constraining_api_is_closed,
			  contains_generic =>  constraining_api_contains_generic,
			  elements         =>  constraining_api_elements,
			  ...
		      }
                      : Api,

		  package_name:                 s::Symbol,

		  depth:                        debruijn_index::Depth,
		  match_typechecker_dictionary: Typechecker_Dictionary, 

		  rpath:                        List( ep::Module_Stamp ),
		  inverse_path:                 ip::Inverse_Path,

		  symbol_table:                 symbol_table::Symbol_Table,
		  source_code_region:           source_map::Source_Code_Region,

		  compile_info
                      as
                      { make_stamp,
			make_highcode_variable => make_var,
			error_fn,
			...
		      }
                      : tcs::Compile_Info
		)
                :
                ( deep::Declaration,		# Thinned declaration	(Becomes PACKAGE_LET.declaration in eventual deep syntax tree.)
                  m::Package,			# Thinned package	(Becomes PACKAGE_LET.expression  in eventual deep syntax tree.)
                  m::Package_Expression		# Only for internal generics typechecking use: This will be used to module::COERCED_PACKAGE original package_expression to correct api.
                )
		=>
		{   err  =  error_fn  source_code_region;

		    fun unparse_api  pps  an_api
			=
			unparse_package_language::unparse_api pps (an_api, symbol_table, 6);

		    title = "thin_package'/TOP - constraining_api:";

		    debug_print  show_apis  (title, unparse_api, constraining_api);


		    fun unify_types { type_per_api, type_per_pkg, inlining_info, name }
			:
			( List( t::Type        ),
                          List( t::Typevar_Ref )
                        )
			= 
			if (ts::pkg_type_matches_api_type { type_per_api, type_per_pkg })

			     my (types, typevar_refs)
                                 =
                                 unify_pkg_with_api_type { type_per_api, type_per_pkg, inlining_info };

			     (types, typevar_refs);

			else
			     err em::ERROR 
				 "value type in package doesn't match api declaration"
				 (fn stream
				     =
				     {   unparse_type::reset_unparse_type ();
					 pp::newline stream;
					 apply (pp::string stream) ["  name: ", s::name name];
					 pp::newline stream;
					 pp::string stream "type_per_api:   ";
					 unparse_type::unparse_type  symbol_table  stream  type_per_api;
					 pp::newline stream;
					 pp::string stream "type_per_pkg: ";
					 unparse_type::unparse_type  symbol_table  stream  type_per_pkg;
				     }
				 );

			     ([],[]);
			fi;

		    fun complain s    =   err em::ERROR s em::null_error_body;
		    fun complain' x   =   { complain x;   raise exception BAD_NAMING;};


		    # Compute mismatches between the API and package
                    # definitions of a datatype.
                    #
                    # We are given two sorted lists of symbols:
                    #  o The datatype constructor list per API definition,
                    #  o The datatype constructor list per pkg definition.
		    #
                    # We return two lists:
                    #  o Data constructors appearing only the API     version,
                    #  o Data constructors appearing only the package version.
                    #  
		    # We depend on the fact that
                    # data constructors have been
                    # sorted by name:
		    #
		    fun find_unmatched_data_constructors (in_api, in_pkg)
			=
			find_unmatched (in_api, in_pkg, [], [])
			where 
			    fun find_unmatched
                                    ( l1 as dc1 ! r1,	# "dc" == "data constructor";  "r" == "rest"
				      l2 as dc2 ! r2,
				      in_api_only,		# 
				      in_pkg_only		# 
				    )
				    =>
				    if (s::eq (dc1, dc2))
					 find_unmatched (r1, r2, in_api_only, in_pkg_only);
				    else
					 s::symbol_gt (dc1, dc2)  ??   find_unmatched ( l1, r2,        in_api_only,  dc2 ! in_pkg_only )
								  ::   find_unmatched ( r1, l2,  dc1 ! in_api_only,        in_pkg_only );
				   fi;

			       find_unmatched ([], [], in_api_only, in_pkg_only)   =>   (reverse  in_api_only,       reverse  in_pkg_only     );
			       find_unmatched ([],  r, in_api_only, in_pkg_only)   =>   (reverse  in_api_only,       reverse  in_pkg_only  @ r);
			       find_unmatched ( r, [], in_api_only, in_pkg_only)   =>   (reverse  in_api_only  @ r,  reverse  in_pkg_only     );
			    end;
			end;


		    fun check_named_type_constructor (_, t::ERRONEOUS_TYPE_CONSTRUCTOR, _)
			    =>
                            {
if_debugging_say ("check_named_type_constructor(_, t::ERRONEOUS_TYPE_CONSTRUCTOR, _): Just returning  Void");
                                ();
                            };

			check_named_type_constructor (type_per_api, type_per_pkg, typechecker_dictionary)
			    =>
			    {   name_per_api
				    =
				    s::name   (ts::type_constructor_name  type_per_api);

if_debugging_say ("check_named_type_constructor/TOP name_per_api = " + name_per_api);
				case type_per_api

				     PRIMITIVE_TYPE_CONSTRUCTOR
                                         {
                                           stamp =>  s,
					   kind  =>  api_kind,
					   eq    =>  REF equality_property,
					   arity,
					   ...
					 }
					 =>
					 {   fun no_datatype ()
						 =
						 complain'("type " + name_per_api + " must be an enum");
if_debugging_say ("check_named_type_constructor/PRIMITIVE_TYPE_CONSTRUCTOR name_per_api = " + name_per_api);


					     if (arity != ts::type_constructor_arity type_per_pkg)

						  complain' (   "type_constructor arity for "
							    +   name_per_api
							    +   " does not match specified arity"
							    );
					     else
						  # BUG: under certain circumstances (bug 1364),
						  # a DEFINED_TYPE_CONSTRUCTOR type_per_pkg should not be unwrapped.
						  #
						  # However, it must be unwrapped if it is a DEFINED_TYPE_CONSTRUCTOR
						  # created by instantiating a direct or indirect
						  # enum replication spec (see bug 1432).
						  #
						  # For direct enum replication {\em declarations },
						  # there is no problem because the replicated
						  # enum is a PRIMITIVE_TYPE_CONSTRUCTOR.
						  #
						  # The unwrapping of enum relicants should be
						  # performed in macro_expand, not here.		XXX BUGGO FIXME
						  #
						  case (api_kind, /* ts::unwrap_definition_star */ type_per_pkg)

						       ( DATATYPE { index => api_index, family => { members, ... }, ... },
							 PRIMITIVE_TYPE_CONSTRUCTOR { arity => a', kind => pkg_kind, ... }
						       )
							   =>
							   case pkg_kind

								DATATYPE { index  => pkg_index,
									   family => { members => members', ... },
									   ...
									 }
								    =>
								    {   api_dcons = .constructor_list (vector::get (members , api_index));
									pkg_dcons = .constructor_list (vector::get (members', pkg_index));

									api_names = map .name  api_dcons;
									pkg_names = map .name  pkg_dcons;

                                                                        if *debugging
									    apply   (fn s =  (if_debugging_say (s::name s)))   api_names;
									    if_debugging_say "******";
									    apply   (fn s =  (if_debugging_say (s::name s)))   pkg_names;
									fi;

									case (find_unmatched_data_constructors (api_names, pkg_names))

									     ([], []) => ();

									     (in_api_only, in_pkg_only)
										 =>
										 complain' (
										     cat (
											 list::cat
											     [   [ "enum ", name_per_api, " does not match api declaration"],

												 case in_api_only
												     [] => [];

												     _  => [  "\n   constructors in api declaration only: ",
													      symbols_to_string  in_api_only
													   ];
												 esac,

												 case in_pkg_only
												     [] => [];

												     _  => [  "\n   constructors in package declaration only: ",
													      symbols_to_string  in_pkg_only
													   ];
												 esac
											     ]
										     )
										 );
									esac;
								    };

							       _   =>   no_datatype ();
							   esac;


						      (DATATYPE _, _) => no_datatype ();

						      (FORMAL, _)
							   =>
							   if  (equality_property == YES
								and
								not (eq_types::is_equality_tycon  type_per_pkg)
							       )

							       complain'("type " + name_per_api + " must be an equality type");
							   fi;

						      _ => {   debug_print
								    debugging
								    (   "type_per_api: ",
									unparse_type::unparse_type_constructor  symbol_table,
									type_per_api
								    );

								debug_print
								    debugging
								    (   "type_per_pkg: ",
									unparse_type::unparse_type_constructor  symbol_table,
									type_per_pkg
								    );

								bug "check_type_constructor_naming 1";
							    };
						    esac;

					     fi;
					 };

				    DEFINED_TYPE_CONSTRUCTOR { type_scheme => TYPE_SCHEME { body, arity }, strict, stamp, path }
					=> 
					{
if_debugging_say ("check_named_type_constructor/DEFINED_TYPE_CONSTRUCTOR/TOP name_per_api = " + name_per_api + "   src/lib/compiler/frontend/typechecker/modules/api-match-g.pkg");
					    type_scheme
                                                =
                                                TYPE_SCHEME
                                                  { body  => ms::translate_type  typechecker_dictionary  body,
						    arity
						  };

if_debugging_say ("check_named_type_constructor/DEFINED_TYPE_CONSTRUCTOR/AAA name_per_api = " + name_per_api + "   src/lib/compiler/frontend/typechecker/modules/api-match-g.pkg");
					    type_per_api'
                                                =
                                                DEFINED_TYPE_CONSTRUCTOR
                                                  {
                                                    type_scheme,		# The only part we change.
						    strict,
						    stamp,
						    path
					          };


if_debugging_say ("check_named_type_constructor/DEFINED_TYPE_CONSTRUCTOR/BBB name_per_api = " + name_per_api + "   src/lib/compiler/frontend/typechecker/modules/api-match-g.pkg");
					    if (not (ts::type_constructor_equality (type_per_api', type_per_pkg)))

						 debug_print
						     debugging
						     (   "type_per_api': ",
							 unparse_type::unparse_type_constructor  symbol_table,
							 type_per_api'
						     );

						 debug_print
						     debugging
						     (   "type_per_pkg: ",
							 unparse_type::unparse_type_constructor  symbol_table,
							 type_per_pkg
						     );

						 complain'
						     (   "type "
						     +   name_per_api
						     +   " does not match api declaration"
						     );
					    fi;
					};

				    ERRONEOUS_TYPE_CONSTRUCTOR =>   raise exception BAD_NAMING;
				    _              =>   bug "check_named_type_constructor 2";

			        esac;
			    };
		    end;							# fun check_named_type_constructor

                    stipulate

			# Two support functions local to check_sharing():

			fun find_package_via_symbol_path
			    (
                              elements,
                              typechecker_dictionary
                            )
			    (sp::SYMBOL_PATH  spath)
			    :
			    ( m::Api,
                              m::Typechecker_Dictionary_Entry
                            )
			    =
			    loop (spath, elements, typechecker_dictionary)
			    where 
				fun loop ( [symbol], elements, typechecker_dictionary)
					=>
				       case (ms::get_api_element (elements, symbol))

					   PACKAGE_IN_API { module_stamp, an_api, ... }
					       =>
					       {   if_debugging_say ("@@@find_package_via_symbol_path.1: " + s::name symbol + ", " + ep::module_stamp_to_string  module_stamp);

						   (an_api, td::find_entry_by_module_stamp (typechecker_dictionary, module_stamp));
					       };

					   _ => bug "loop_package 1b";
				       esac
				       except
                                           ms::UNBOUND _ =  bug "find_package_via_symbol_path 1c";


				    loop (symbol ! rest, elements, typechecker_dictionary)
					=>
					case (ms::get_api_element (elements, symbol))

					    PACKAGE_IN_API { an_api => API { elements, ... }, module_stamp, ... }
						=>
						case (td::find_entry_by_module_stamp (typechecker_dictionary, module_stamp))

						    PACKAGE_ENTRY { typechecker_dictionary, ... }
							=>
							{   if_debugging_say ( "@@@find_package_via_symbol_path.2: "
									   + s::name symbol
									   + ", "
									   + ep::module_stamp_to_string module_stamp
									   );

							    loop (rest, elements, typechecker_dictionary);
							};

						    ERRONEOUS_ENTRY
							=>
							(ERRONEOUS_API, ERRONEOUS_ENTRY);

						     _   => bug "find_package_via_symbol_path 2a";
						esac;

					    _   => bug "find_package_via_symbol_path 2b";
					esac
					except
                                            ms::UNBOUND _ =  bug "find_package_via_symbol_path 2c";


				   loop _ => bug "find_package_via_symbol_path 3";

				end;			# fun loop
			    end;			# where



			fun find_type_constructor_via_symbol_path (elements, typechecker_dictionary) (sp::SYMBOL_PATH spath)
			    :
			    t::Type_Constructor
			    =
			    loop (spath, elements, typechecker_dictionary)
			    where
				fun loop ([symbol], elements, typechecker_dictionary)
				       =>
				       case (ms::get_api_element (elements, symbol))

					   TYPE_CONSTRUCTOR_IN_API { module_stamp, ... }
					       =>
					       case (td::find_entry_by_module_stamp (typechecker_dictionary, module_stamp))

						   TYPE_CONSTRUCTOR_ENTRY  type_constructor
						       =>
						       type_constructor;

						   ERRONEOUS_ENTRY
						       =>
						       ERRONEOUS_TYPE_CONSTRUCTOR;

						   _   => bug "find_type_constructor_via_symbol_path 1a";
					       esac;

					    _ => bug "find_type_constructor_via_symbol_path 1b";
					esac
					except
					    ms::UNBOUND _ =  bug "find_type_constructor_via_symbol_path 1c";


				    loop (symbol ! rest, elements, typechecker_dictionary)
					=>
					case (ms::get_api_element (elements, symbol))

					     PACKAGE_IN_API { an_api => API { elements, ... }, module_stamp, ... }
						 =>
						 case (td::find_entry_by_module_stamp (typechecker_dictionary, module_stamp))

						     PACKAGE_ENTRY { typechecker_dictionary, ... }
							  =>
							  loop (rest, elements, typechecker_dictionary);

						     ERRONEOUS_ENTRY => ERRONEOUS_TYPE_CONSTRUCTOR;
						     _                            => bug "find_type_constructor_via_symbol_path 2a";
						 esac;

					    _ => bug "find_type_constructor_via_symbol_path 2b";
					esac
					except
					    ms::UNBOUND _
						=
						bug ("find_type_constructor_via_symbol_path 2c:" + symbol::name symbol +  sp::to_string (sp::SYMBOL_PATH spath));


				   loop _ => bug "find_type_constructor_via_symbol_path 3";
				end;
			    end;

		    herein

			# Check whether all sharing constraints are satisfied:
			#
			fun check_sharing ( an_api as ERRONEOUS_API, typechecker_dictionary)
				=>
				();		      #  Don't do anything if an error has occurred, resulting in an ERRONEOUS_API 

			    check_sharing (an_api as API { elements, type_sharing, package_sharing, ... }, typechecker_dictionary)
				=>
				{   fun errmsg sp x
					=
					sp::to_string x + " != " + sp::to_string sp;

				    fun eq_type_constructor (_, ERRONEOUS_TYPE_CONSTRUCTOR) => TRUE;
					eq_type_constructor (ERRONEOUS_TYPE_CONSTRUCTOR, _) => TRUE;

					eq_type_constructor (type_constructor1, type_constructor2)
					    =>
					    ts::type_constructor_equality (type_constructor1, type_constructor2);
				    end;

				    find_package_via_symbol_path
					=
					find_package_via_symbol_path
                                          ( elements,
					    typechecker_dictionary
					  );


				    fun common_elements (API api1, API api2)
					    =>
					    {   elements1 =  api1.elements;
						elements2 =  api2.elements;

						fun elem_gt ((s1, _), (s2, _))
						    =
						    s::symbol_gt (s1, s2);

						elements1 =  list_mergesort::sort  elem_gt  elements1;
						elements2 =  list_mergesort::sort  elem_gt  elements2;

						intersect (elements1, elements2)
						where
						    fun intersect (e1 as ((s1, spec1) ! rest1),
								   e2 as ((s2, spec2) ! rest2))
							    =>
							    if   (s::eq (s1, s2))

								 (s1, spec1, spec2)   !   intersect (rest1, rest2);
							    else 
								 if   (s::symbol_gt (s1, s2))   intersect (e1, rest2);
								 else			        intersect (rest1, e2);
								 fi;
							    fi;

							intersect(_, _)
							    =>
							    NIL;

						    end;			# fun intersect
						end;				# where
					    };

					common_elements _
					    =>
					    bug "common_elements";
				    end;					# fun common_elements

				    # Apply 'test' to all possible
                                    # pairs of values from given
                                    # list -- O(N**2) tests for
                                    # length-N list:
				    #
				    fun apply_to_all_pairs  test  NIL
					    =>
					    ();

					apply_to_all_pairs  test  (a ! r)
					    =>
					    {   apply  (fn x = test (a, x))  r;
						apply_to_all_pairs test r;
					    };
				    end;

				    fun compare_packages
					    ( (p1, (an_api1, ent1)),
					      (p2, (an_api2, ent2))
					    )
					= 
					case (ent1, ent2)

					     ( PACKAGE_ENTRY { stamp => s1, typechecker_dictionary => dict1, ... },
					       PACKAGE_ENTRY { stamp => s2, typechecker_dictionary => dict2, ... }
					     )
						 =>
						 if (st::eq (s1, s2))

						      ();   #  shortcut! 
						 else
						      if   (ms::apis_equal (an_api1, an_api2))

							   if_debugging_say "@@@compare_packages: an_api1 == an_api2";

							   my { elements, ... }
							       =
							       case an_api1
								   API sg => sg;
								   _ => bug "compare_packages: API";
							       esac;

							   for' elements compare
							   where 
							       fun compare (symbol, TYPE_CONSTRUCTOR_IN_API { module_stamp, ... } )
								       => 
								       {   type_constructor1   =   unwrap_typecon_entry (td::find_entry_by_module_stamp (dict1, module_stamp));
									   type_constructor2   =   unwrap_typecon_entry (td::find_entry_by_module_stamp (dict2, module_stamp));

									   if (not (eq_type_constructor (type_constructor1, type_constructor2)))

									        complain (
										    cat
											[   "implied type sharing violation: ",
											    errmsg
											       (sp::extend (p1, symbol))
											       (sp::extend (p2, symbol))
											]
										);
									   fi;
								       };

								   compare (symbol, PACKAGE_IN_API { module_stamp, an_api, ... } )
								       => 
								       {   ent1' = td::find_entry_by_module_stamp (dict1, module_stamp);
									   ent2' = td::find_entry_by_module_stamp (dict2, module_stamp);

									   compare_packages (
									       (sp::extend (p1, symbol),   (an_api, ent1')),
									       (sp::extend (p2, symbol),   (an_api, ent2'))
									   );
								       };

								   compare _   => ();

								end; 			# fun compare
							    end;			# where


						      else
							   if_debugging_say "@@@compare_packages: an_api1 != an_api2";

							   common_api_elements
                                                               =
                                                               common_elements (an_api1, an_api2);

							   for' common_api_elements

								fn ( symbol,
								     TYPE_CONSTRUCTOR_IN_API { module_stamp => v1, ... },
								     TYPE_CONSTRUCTOR_IN_API { module_stamp => v2, ... }
								   )
								       =>
								       {   type_constructor1 = unwrap_typecon_entry (td::find_entry_by_module_stamp (dict1, v1));
									   type_constructor2 = unwrap_typecon_entry (td::find_entry_by_module_stamp (dict2, v2));

									   if (not (eq_type_constructor (type_constructor1, type_constructor2)))

									        complain( cat [ "type sharing violation: ",
												errmsg (sp::extend (p1, symbol))
												(sp::extend (p2, symbol))
											      ]
											);
									   fi;
								       };

								   ( symbol,
								     PACKAGE_IN_API { module_stamp=>v1, an_api => an_api1', ... },
								     PACKAGE_IN_API { module_stamp=>v2, an_api => an_api2', ... }
								   )
								       =>
								       {   str1 = td::find_entry_by_module_stamp (dict1, v1);
									   str2 = td::find_entry_by_module_stamp (dict2, v2);

									   compare_packages ( (sp::extend (p1, symbol), (an_api1', str1)),
											      (sp::extend (p2, symbol), (an_api2', str2))
											    );
								       };


								   _   => ();

								end;		# fn
						      fi;
						 fi;

					    (ERRONEOUS_ENTRY, _) => ();  #  error upstream 
					    (_, ERRONEOUS_ENTRY) => ();  #  error upstream 
					     _                   => bug "compare_packages";

					esac;

				    fun check_package  paths
					=
					{   pathstrs
                                                =
                                                map  (fn p =  (p, find_package_via_symbol_path p))
                                                     paths;

					    apply_to_all_pairs  compare_packages  pathstrs;
					};

				    fun check_type_constructor' (first_path, rest)
					=
					{   find_type_constructor_via_symbol_path
						=
						find_type_constructor_via_symbol_path
						    (
						      elements,
						      typechecker_dictionary
						    );

					    err_msg =   errmsg first_path;

					    first   =   find_type_constructor_via_symbol_path
							    first_path;

					    apply  check_path  rest
					    where
						fun check_path p
						    = 
						    if (not (eq_type_constructor (first, find_type_constructor_via_symbol_path p)))
						        complain (cat [ "type sharing violation: ", err_msg p ] );
						    fi;
					    end;
					};

				    fun check_type_constructor (sp ! rest) =>   check_type_constructor' (sp, rest);
					check_type_constructor _           =>   bug "check_sharing: check_type_constructor";
				    end;


				    apply  check_package          package_sharing;
				    apply  check_type_constructor    type_sharing;
				};
			end;			# fun check_sharing 
		    end;			# stipulate

		    # Matching: Go through the `elements' of the specified api,
		    # and  construct a corresponding typechecked_package
                    # from typechecker_dictionary found in the given package.
		    #
		    # The package's typechecker_dictionary entries are found
                    # by using the module_path in each of the given package api's
                    # elements to access the given package's typechecked_package
                    # = stored typechecker_dictionary.
		    #
		    # Subpackages are processed recursively.
		    #
		    # Build the formal typechecked_package in parallel.
		    #
		    # Finally check sharing constraints.


		    # fun match_all_api_elements:
                    #     ( List( s::Symbol, Api_Element ),
		    #       Typechecker_Dictionary,
		    #       List( Module_Declaration ),
		    #       List( deep::Declaration ),
		    #       List( ste::Symbol_Table_Entry )
		    #     )
		    #     ->
		    #     ( List( deep::Declaration ),
		    #       List( ste::Symbol_Table_Entry ),
		    #       Typechecker_Dictionary,
		    #       List( Module_Declaration)
		    #     )  
		    #
		    # Given the elements and the typechecker_dictionary
                    # of a constrained package and a constraining api,
                    # extend the typechecked_package (Typechecker_Dictionary)
		    # with the typechecked_package specified by the spec,
                    # extend the list of coercions (typechecked_package declarations)
                    # with a declaration which will evaluate to the
                    # new typechecked_package, and extend the thinning.
		    #
		    # We assume that if a match error occurs
                    # then the resulting thinning and the
		    # list of module_declarations
                    # will never be used -- they will not be
		    # well-formed in case of errors. 

                    stipulate

			# A private support function for
                        #     fun match_all_api_elements:
			#
			fun match_def_package  args
			    =
			    case args
				( api_elements,
				  A_PACKAGE { an_api => api_d, typechecked_package => typechecked_package_d, ... },		# Package from constraining api.
				  A_PACKAGE { an_api => api_m, typechecked_package => typechecked_package_m, ... }		# Package from constrained package.
				)
				    =>
				    {   stamp_d =  typechecked_package_d.stamp;
					stamp_m =  typechecked_package_m.stamp;

					if (st::eq (stamp_d, stamp_m))		#  eq_origin 
					     TRUE;
					else
					     match_def_package'
						 (
						   api_elements,
						   api_d,  typechecked_package_d,
						   api_m,  typechecked_package_m
						 );
					fi;
				    };

				_   => bug "match_def_package (2)";
			    esac
			    where
				# Private support function for match_def_package():
				#
				fun match_def_package'
				    (
				      api_elements,
				      api_d, typechecked_package_d,
				      api_m, typechecked_package_m
				    )
				    =
				    {	# Function to drop from api element list all elements
					# except for TYPE_CONSTRUCTOR_IN_API and PACKAGE_IN_API:
					#
					drop_vals
					    =
					    list::filter
						fn (s, (TYPE_CONSTRUCTOR_IN_API _ | PACKAGE_IN_API _ )) => TRUE;
						   _                                                    => FALSE;
						end ;


					nonvalue_api_elements
					   =
					   drop_vals api_elements;


					fun elem_gt ((s1, _), (s2, _))
					    =
					    s::symbol_gt (s1, s2);

                                        # Get the list of elements from an API.
                                        # Each element is a (name, value) pair
					# where the name is a symbol:
					#
                                        fun get_elements (m::API { elements, ... }) =>  elements;
                                            get_elements _                          =>  bug "match_def_package': API (1)";
                                        end;

					# The api_d (constraining) api elements will be a list of (symbol, type_d) pairs.
					# The api_m (constrained ) api elements will be a list of (symbol, type_m) pairs.
					#
					# From the pairs with matching symbols, create a list of triples
					#     (symbol, type_d, type_m)
                                        #
					common_dm_api_elements
					    =
					    if (ms::apis_equal (api_d, api_m))

						 elements
                                                     =
                                                     list_mergesort::sort
                                                         elem_gt
                                                         (drop_vals  (get_elements  api_d));

						 map (fn (s, spec) =  (s, spec, spec))
						     elements;

					    else

						 elements_d =   list_mergesort::sort  elem_gt  (drop_vals  (get_elements  api_d));
						 elements_m =   list_mergesort::sort  elem_gt  (drop_vals  (get_elements  api_m));

						 intersect (elements_d, elements_m)
						 where
						     fun intersect (list1 as ((symbol1, spec1) ! rest1),
								    list2 as ((symbol2, spec2) ! rest2)
								   )
							     =>
							     if   (s::eq (symbol1, symbol2))

								  (symbol1, spec1, spec2) ! intersect (rest1, rest2);
							     else
								  (s::symbol_gt (symbol1, symbol2))
                                                                      ?? intersect (list1, rest2)
								      :: intersect (rest1, list2);
							     fi;

							 intersect(_, _) => NIL;

						     end;			# fun intersect
						 end;				# where
					    fi;

					# Here we reduce the above list of triples to
					# those it has in common with nonvalue_api_elements,
					# and add in the type information from the latter,
					# yielding a list of quadruples
					#     (symbol, type_a, type_d, type_m)
					#
					common_api_elements
					    =
					    intersect' (nonvalue_api_elements, common_dm_api_elements)
					    where
						fun intersect' (  elements1 as ((symbol1, x)    ! rest1),
								  elements2 as ((symbol2, y, z) ! rest2)
							       )
							=>
							if   (s::eq (symbol1, symbol2))

							     (symbol1, x, y, z)   !   intersect' (rest1, rest2);
							else
							     s::symbol_gt (symbol1, symbol2)
								 ?? intersect' (elements1, rest2)	#  Discard symbol2 
							         :: intersect' (rest1, elements2);	#  Discard symbol1 
						        fi;

						    intersect' (_, _)
							=>
							NIL;
						end;			# fun intersect'
					    end;			# where



					loop  common_api_elements
					where
					    fun loop NIL
                                                    =>
                                                    TRUE;

						loop ((symbol, api_element, spec_d, spec_m) ! rest)
						    =>
						    case api_element

							 TYPE_CONSTRUCTOR_IN_API _
							     =>
							     {   fun unwrap_typecon (TYPE_CONSTRUCTOR_IN_API x) =>  x;
								     unwrap_typecon _                           =>  bug "thin_package': unTYCspec";
								 end;

								 modstamp_d =  (unwrap_typecon spec_d).module_stamp;
								 modstamp_m =  (unwrap_typecon spec_m).module_stamp;

								 dictionary_d =  typechecked_package_d.typechecker_dictionary;
								 dictionary_m =  typechecked_package_m.typechecker_dictionary;

								 tyc_d = unwrap_typecon_entry (td::find_entry_by_module_stamp (dictionary_d, modstamp_d));
								 tyc_m = unwrap_typecon_entry (td::find_entry_by_module_stamp (dictionary_m, modstamp_m));

								 ts::type_constructor_equality (tyc_d, tyc_m)
                                                                 and
                                                                 loop rest;			# Added recursive call because a 'loop' fn which didn't loop seemed odd.	-- 2009-07-18 CrT
							     };

						         PACKAGE_IN_API { an_api => API { elements, ... }, ... }
							     =>
							     {   fun unwrap_pkg_spec (PACKAGE_IN_API x) =>  x;
								     unwrap_pkg_spec _                  =>  bug "thin_package': unwrap_pkg_spec";
								 end;

								 my { module_stamp => modstamp_d,  an_api => api_d',  ... } =  unwrap_pkg_spec spec_d;
								 my { module_stamp => modstamp_m,  an_api => api_m',  ... } =  unwrap_pkg_spec spec_m;

								 dictionary_d =  typechecked_package_d.typechecker_dictionary;
								 dictionary_m =  typechecked_package_m.typechecker_dictionary;

								 fun unwrap_pkg_entry (PACKAGE_ENTRY x) =>  x;
								     unwrap_pkg_entry _                 =>  bug "thin_package': unwrap_pkg_entry";
								 end;

								 typechecked_package_d' = unwrap_pkg_entry (td::find_entry_by_module_stamp (dictionary_d, modstamp_d));
								 typechecked_package_m' = unwrap_pkg_entry (td::find_entry_by_module_stamp (dictionary_m, modstamp_m));

								 # Call ourself recursively
								 # to process subpackage:
								 #
								 match_def_package'
								   (
								     elements,
								     api_d', typechecked_package_d',
								     api_m', typechecked_package_m'
								   )
                                                                 and
                                                                 loop rest;			# Added recursive call because a 'loop' fn which didn't loop seemed odd.	-- 2009-07-18 CrT
							     };

						      _   => bug "thin_package'";

						esac;
					    end;		# fun loop
					end;			# where
				    };				# fun match_def_package'
			    end;				# where

		    herein	

			fun match_all_api_elements
				( [],				# Input list exhausted, time to construct final result.
				  typechecker_dictionary,
				  module_declarations,
				  abstract_declarations,
				  symbol_table_entries,
				  match_succeeded
				)
				=>
				( reverse  abstract_declarations,
				  reverse  symbol_table_entries,
				  typechecker_dictionary,
				  reverse  module_declarations,
				  match_succeeded
				);

			    match_all_api_elements
				( (api_element_symbol, api_element) ! remaining_api_elements,	# Input list, starts as constraining_api_elements.
				  typechecker_dictionary,					# Dictionary accumulating seen generics, also TYPE_CONSTRUCTOR_ENTRY, also thinned_package from  thin_package'.
				  module_declarations,						# List accumulating module::Module_Declaration stuff: TYPE_CONSTRUCTOR_DECLARATION, PACKAGE_DECLARATION, GENERIC_DECLARATION (...?) 
				  abstract_declarations,					# List accumulating deep syntax: deep::VALUE_DECLARATIONS[ ORDINARY_VARIABLE | NAMED_VALUE ]
				  symbol_table_entries,						# List accumulating symbol table entries: ste::NAMED_CONSTRUCTOR, NAMED_VARRIABLE, NAMED_PACKAGE, NAMED_GENERIC.
				  match_succeeded						# Starts TRUE, set FALSE at first api/pkg mismatch detected.
				)
				=>
				{   if_debugging_say "match_all_api_elements/TOP";

				    # Issue an error message,
				    # remember that the api match failed,
				    # process rest of api elements anyhow:
				    #
				    fun complain_and_loop (kind_op: Null_Or( String ))
					=
					{   typechecker_dictionary'
						= 
						case (ms::get_api_element_variable  api_element)
						    THE v => td::set (typechecker_dictionary, v, ERRONEOUS_ENTRY);
						    NULL  => typechecker_dictionary;
						esac;

					    # Synthesize a new error naming
                                            # to remove improper error
					    # messages on inline_info (ZHONG)

					    symbol_table_entries'
						= 
						case api_element
						    TYPE_CONSTRUCTOR_IN_API _                   =>  symbol_table_entries;
						    ENUM_CONSTRUCTOR_IN_API { slot=>NULL, ... } =>  symbol_table_entries;

						    _ => ste::NAMED_CONSTRUCTOR variables_and_constructors::bogus_exception ! symbol_table_entries;
						esac;

					    case kind_op
						THE kind =>   complain("unmatched " + kind + " specification: " + s::name api_element_symbol);
						NULL     =>   ();
					    esac;

					    # Match has failed, but process rest of API
					    # to maybe generate additional useful diagnostics
					    # for user:
					    #	
					    match_all_api_elements
					      (
						remaining_api_elements,
						typechecker_dictionary',
						module_declarations,
						abstract_declarations,
						symbol_table_entries',
						FALSE				# Remember that API match failed.
					      );
					};

				     fun type_in_matched (kind, type)
					 = 
					 (ms::translate_type  typechecker_dictionary  type) 
					 except
                                             td::UNBOUND
						 =
						 {   debug_print  debugging  (kind, unparse_type::unparse_type  symbol_table, type);
						     raise exception td::UNBOUND;
						 };

				     fun type_in_original (kind, type)
					 = 
					 (ms::translate_type  package_typechecker_dictionary  type) 
					 except
					     td::UNBOUND
						 =
						 {   debug_print  debugging  (kind, unparse_type::unparse_type  symbol_table, type);
						     raise exception td::UNBOUND;
						 };


				    case api_element

					 TYPE_CONSTRUCTOR_IN_API { type_constructor => type_per_api, module_stamp, is_a_replica, scope }
					     =>
					     {   if_debugging_say ( string::cat [ "match_all_api_elements TYPE_CONSTRUCTOR_IN_API/TOP: ",
								                  s::name api_element_symbol, ", ",
								                  st::to_string  module_stamp ] );

						 my (type_per_pkg, pkg_typechecked_package_variable)
						     =
						     ms::get_type_constructor (pkg_api_elements, package_typechecker_dictionary, api_element_symbol)
						     except
                                                         td::UNBOUND 
							    =
							    {   debug_print
								    debugging
								    (   "package_typechecker_dictionary: ", 
									(fn pps = fn ee = unparse_package_language::unparse_typechecker_dictionary pps (ee, symbol_table, 6)),
									package_typechecker_dictionary
								    );
								raise exception td::UNBOUND;
							    };

						 if_debugging_say ("--match_all_api_elements TYPE_CONSTRUCTOR_IN_API - pkg_typecheck_package_variable: " +
								   st::to_string  pkg_typechecked_package_variable);

						 # ** DAVE: please check the following ! XXX BUGGO FIXME **

						 tyc_module_expression
						     = 
						     case rpath
							 [] =>  CONSTANT_TYPE_CONSTRUCTOR type_per_pkg;
							 _  =>  TYPE_VARIABLE_TYPE_CONSTRUCTOR (reverse (pkg_typechecked_package_variable ! rpath));
						     esac;

						 if_debugging_say "--match_all_api_elements TYPE_CONSTRUCTOR_IN_API calling check_named_type_constructor";

						 check_named_type_constructor (type_per_api, type_per_pkg, typechecker_dictionary);

						 if_debugging_say "--match_all_api_elements TYPE_CONSTRUCTOR_IN_API calling td::set";

						 typechecker_dictionary'
						     =
						     td::set
                                                       (
							 typechecker_dictionary,
							 module_stamp,
							 TYPE_CONSTRUCTOR_ENTRY type_per_pkg
						       );

						 module_declarations'
						     =
						     TYPE_CONSTRUCTOR_DECLARATION (

							 module_stamp,
							 tyc_module_expression
						     )
						     !
						     module_declarations;

						 if_debugging_say "match_all_api_elements TYPE_CONSTRUCTOR_IN_API/BOT  check_named_type_constructor";

						 match_all_api_elements (

						     remaining_api_elements,
						     typechecker_dictionary',
						     module_declarations',
						     abstract_declarations,
						     symbol_table_entries,
						     match_succeeded
						 );
					     }
					     except
						 ms::UNBOUND symbol
						     =>
						     complain_and_loop (THE "type");

						 BAD_NAMING
						     =>
						     complain_and_loop NULL;

						 td::UNBOUND
						     =>
						     {   if_debugging_say ("match_all_api_elements (TYPE_CONSTRUCTOR_IN_API) td::UNBOUND raised for: " + s::name  api_element_symbol);
							 raise exception td::UNBOUND;
						     };
					     end; 


					 PACKAGE_IN_API
					     { an_api => this_spec_api as API api_record,
					       module_stamp,
					       definition,
					       ...
					     }
					     =>
					     {   this_elements = api_record.elements;

						 if_debugging_say (
						     string::cat [
							 "--match_all_api_elements PACKAGE_IN_API: ",
							 s::name  api_element_symbol,
							 ", ",
							  st::to_string module_stamp
						     ]
						 );

						 my (pkg_package, pkg_package_module_stamp)
						     = 
						     ms::get_package
                                                       (
                                                         pkg_api_elements,
                                                         package_typechecker_dictionary,
                                                         api_element_symbol,
                                                         constrained_pkg_var_home,
                                                         constrained_pkg_inline_info
                                                       );

						 #  Verify spec definition, if any 

						 # match_def_package now does the proper deep, component-wise
						 # comparison of api_package and pkg_package when their stamps
						 # don't agree, but the error message printed
						 # when definition spec is not matched leaves something
						 # to be desired XXX BUGGO FIXME
						 #
						 case definition

						     NULL => ();

						     THE (package_definition, _)
							 =>
							 {    api_package
								  =
								  ms::package_definition_to_package (
								      package_definition,
								      typechecker_dictionary
								  );

							      if (not (match_def_package (this_elements, api_package, pkg_package)))

								  case package_definition

								       m::VARIABLE_PACKAGE_DEFINITION (an_api, module_path)
									   =>
									   if_debugging_say (   "spec def VAR: "
											  +   ep::module_path_to_string  module_path
											  +   "\n"
											  );

								       m::CONSTANT_PACKAGE_DEFINITION _
									   =>
									   if_debugging_say ("spec def CONST\n");
								   esac;

								   if_debugging_show_package("api_package: ", api_package);
								   if_debugging_show_package("pkg_package: ", pkg_package);

								   complain (   "package def spec for "
									    +   s::name  api_element_symbol
									    +   " not matched"
									    );

							      fi;
							  };
						 esac;

						 rpath'         =   pkg_package_module_stamp ! rpath;
						 inverse_path'  =   ip::extend (inverse_path,  api_element_symbol);

						 # Call ourself recursively
						 # to process subpackage:
						 #
						 my  ( thinned_declaration,
						       thinned_package,
						       package_expression
						     )
						     = 
						     thin_package' (
							 pkg_package,
							 this_spec_api,
							 api_element_symbol,
							 depth,
							 typechecker_dictionary,
							 rpath',
							 inverse_path',
							 symbol_table,
							 source_code_region,
							 compile_info
						     );

						 typechecker_dictionary'
						     = 
						     {   typechecked_package
							     = 
							     case thinned_package
								 m::A_PACKAGE { typechecked_package, ... } =>  typechecked_package;
								 _                                         =>  m::bogus_typechecked_package;
							     esac;

							 td::set (typechecker_dictionary,  module_stamp,  m::PACKAGE_ENTRY typechecked_package);
						     };

						 module_declarations'
						     =
						     m::PACKAGE_DECLARATION  (module_stamp,  package_expression,  api_element_symbol)
						     !
						     module_declarations ;

						 abstract_declarations'
						      =
						      thinned_declaration ! abstract_declarations;

						 symbol_table_entries'
						     =
						     (ste::NAMED_PACKAGE thinned_package)
						     !
						     symbol_table_entries;


						 match_all_api_elements
						   (
						     remaining_api_elements,
						     typechecker_dictionary',
						     module_declarations',
						     abstract_declarations',
						     symbol_table_entries',
						     match_succeeded
						   );
					     }
					     except ms::UNBOUND symbol
						    =
						    complain_and_loop (THE "package");


					 GENERIC_IN_API { a_generic_api => spec_api, module_stamp, ... }
					     => 
					     (   {   if_debugging_say (
							 string::cat [
							     "--match_all_api_elements GENERIC_IN_API: ",
							     s::name  api_element_symbol,
							     ", ",
							     st::to_string module_stamp
							 ]
						     );

						     my (pkg_g, generic_module_stamp)
							 = 
							 ms::get_generic (

							     pkg_api_elements,
							     package_typechecker_dictionary,
							     api_element_symbol,
							     constrained_pkg_var_home,
							     constrained_pkg_inline_info
							 );

						     expression'
							 =
							 m::VARIABLE_GENERIC (reverse (generic_module_stamp ! rpath));

						     inverse_path'
							 =
							 ip::extend (inverse_path,  api_element_symbol);

						     my (thinned_declaration, thinned_g, generic_expression)
							 = 
							 match_generic1
                                                           (
							     spec_api,
							     pkg_g,
							     api_element_symbol,
							     depth,
							     typechecker_dictionary,
							     expression', 
							     inverse_path',
							     symbol_table,
							     source_code_region,
							     compile_info
							   );

						     typechecker_dictionary'
							 = 
							 {   typechecked_generic
								 = 
								 case thinned_g
								     m::GENERIC { typechecked_generic, ... } => typechecked_generic;
								     _                                       => m::bogus_typechecked_generic;
								 esac;

							     td::set (

								 typechecker_dictionary,
								 module_stamp,
								 m::GENERIC_ENTRY typechecked_generic
							     );
							 };

						     module_declarations'
							 =
							 m::GENERIC_DECLARATION (module_stamp, generic_expression)
							 !
							 module_declarations;

						     abstract_declarations'
							 =
							 thinned_declaration ! abstract_declarations;

						     symbol_table_entries'
							 =
							 (ste::NAMED_GENERIC thinned_g) ! symbol_table_entries;

						     match_all_api_elements (

							 remaining_api_elements,
							 typechecker_dictionary',
							 module_declarations',
							 abstract_declarations',
							 symbol_table_entries',
							 match_succeeded
						     );
						 }
						 except ms::UNBOUND symbol
							=
							complain_and_loop (THE "generic package")
					     );

					 VALUE_IN_API { type => type_per_api, ... }
					     => 
					     case (ms::get_api_element (pkg_api_elements, api_element_symbol))

						  VALUE_IN_API { type => type_per_pkg, slot => slot_per_pkg }
						      =>
						      {   type_per_api = type_in_matched  ("@@@type_per_api (my/val)", type_per_api);
							  type_per_pkg = type_in_original ("@@@type_per_pkg (my/val)", type_per_pkg);

							  var_home      =  vh::select_var_home (constrained_pkg_var_home, slot_per_pkg);
							  inlining_info =  inlining_information::select (constrained_pkg_inline_info, slot_per_pkg);

							  my (types, bound_typevar_refs)
							      = 
							      unify_types { type_per_api, type_per_pkg, inlining_info, name => api_element_symbol };

							  path = sp::SYMBOL_PATH [api_element_symbol];

							  pkg_var
							      =
							      ORDINARY_VARIABLE {

								  path,
								  var_type => REF type_per_pkg,

								  var_home,
								  inlining_info
							      };

							  my (abstract_declarations', new_var)
							      = 
							      case ( ts::head_reduce_type  type_per_pkg, 
								     ts::head_reduce_type  type_per_api
								   )

								   ((TYPE_SCHEME_TYPE _, _) | (_, TYPE_SCHEME_TYPE _))
								       => 
								       {   var_home = vh::named_var_home (api_element_symbol, make_var);

									   api_var
									       = 
									       ORDINARY_VARIABLE {

										   path,
										   var_type => REF type_per_api,

										   inlining_info,
										   var_home
									       };

									   if (*debugging and ((list::length bound_typevar_refs) > 0))

                                                                               printf "api-match-g.pkg: Creating deep::NAMED_VALUE node with length(bound_typevar_refs) d=%d  (I)\n" (list::length bound_typevar_refs);

									       apply  unparse_typevar_ref  bound_typevar_refs
									       where
	                                                                           unparse_typevar_ref
                                                                                       =
                                                                                       unparse_type::unparse_typevar_ref
                                                                                           symbol_table;

										   fun if_debugging_unparse_typevar_ref  (msg, typevar_ref)
										       = 
										       if *debugging		# Without this 'if' (and the matching one in unify_types), compiling the compiler takes 5X as long! :-)
											   typechecking_debugging::with_internals
											       (fn () =  typechecking_debugging::debug_print debugging (msg, unparse_typevar_ref, typevar_ref));
										       fi;

										   fun unparse_typevar_ref  typevar_ref
										       =
										       if_debugging_unparse_typevar_ref ("", typevar_ref);
									       end;
									       printf "\n";
                                                                           fi;

									   named_value
									       = 
									       deep::NAMED_VALUE {
										   pattern              =>  deep::VARIABLE_IN_PATTERN api_var,
										   expression           =>  deep::VARIABLE_IN_EXPRESSION (REF pkg_var, types),
										   ref_typevar_refs     =>  REF [],
										   bound_typevar_refs
									       };

									   ( (deep::VALUE_DECLARATIONS [named_value]) ! abstract_declarations,
									     api_var
									   );
								       };

								  _ => (abstract_declarations, pkg_var);

							      esac;

							  symbol_table_entries'
							      =
							      (ste::NAMED_VARIABLE new_var) ! symbol_table_entries;

							  match_all_api_elements (

							      remaining_api_elements,
							      typechecker_dictionary,
							      module_declarations,
							      abstract_declarations',
							      symbol_table_entries',
							      match_succeeded
							  );
						      };

						  ENUM_CONSTRUCTOR_IN_API
						      {
							slot,
							a_datatype => ENUM_CONSTRUCTOR { constructor_type => type_per_pkg,
											 symbol,
											 const,
											 representation,
											 signature,
											 is_lazy
										       }
						      }
						      => 
						      {   type_per_api = type_in_matched  ("@@@type_per_api (my/con)", type_per_api );
							  type_per_pkg = type_in_original ("@@@type_per_pkg (my/con)", type_per_pkg );

							  my (types, bound_typevar_refs)
							      = 
							      unify_types { type_per_api, type_per_pkg, inlining_info => inlining_information::NULL, name => symbol };

							  new_representation
                                                              =
                                                              case slot 
								  THE s =>  exception_representation (representation, vh::select_var_home (constrained_pkg_var_home, s));
								  NULL  =>  representation;
							      esac;

							  my (abstract_declarations', symbol_table_entries')
							      =
							      {   con = ENUM_CONSTRUCTOR {

									    constructor_type => type_per_pkg,
									    representation   => new_representation,

									    symbol,
									    const,
									    signature,
									    is_lazy
									};

								  var_home  = vh::named_var_home (symbol, make_var);

								  api_var
								      = 
								      ORDINARY_VARIABLE {

									  path          =>  sp::SYMBOL_PATH [symbol],
									  var_home,

									  inlining_info =>  inlining_information::NULL,
									  var_type      =>  REF type_per_api
								      };

								  if (*debugging and ((list::length bound_typevar_refs) > 0))
								      printf "api-match-g.pkg: Creating deep::NAMED_VALUE node with length(bound_typevar_refs) d=%d  (II)\n" (list::length bound_typevar_refs);
								  fi;

								  named_value
								      = 
								      deep::NAMED_VALUE {
									  pattern              =>  deep::VARIABLE_IN_PATTERN api_var,
									  expression           =>  deep::CONSTRUCTOR_EXPRESSION (con, types),
									  ref_typevar_refs     =>  REF [],
									  bound_typevar_refs
								      };

								  ( (deep::VALUE_DECLARATIONS  [named_value])  !   abstract_declarations, 
								    (ste::NAMED_VARIABLE api_var)              !   symbol_table_entries
								  );
							      };

							  match_all_api_elements
							      (
								remaining_api_elements,
								typechecker_dictionary,
								module_declarations,
								abstract_declarations', 
								symbol_table_entries',
								match_succeeded
							      );
						      };

						  _ => bug "match v elem.1";
					     esac
					     except ms::UNBOUND symbol
						    =
						    complain_and_loop (THE "value");


					 ENUM_CONSTRUCTOR_IN_API {

					     a_datatype => ENUM_CONSTRUCTOR {

							     symbol,
							     constructor_type => type_per_api,
							     is_lazy,
							     representation => representation_per_api,
							     ...
							 },
					     ...
					 }
					     => 
					     case (ms::get_api_element (pkg_api_elements, symbol))

						  ENUM_CONSTRUCTOR_IN_API {

						      a_datatype => ENUM_CONSTRUCTOR {

								      constructor_type =>  type_per_pkg,
								      representation   =>  representation_per_pkg,
								      const, 
								      signature,
								      ...
								  },
						      slot
						  }
						      =>
						      if ( vh::is_exception representation_per_api
							   ==
							   vh::is_exception representation_per_pkg
							 )

							   type_per_api =   type_in_matched ("@@@type_per_api (con/con)", type_per_api);
							   type_per_pkg =   type_in_original("@@@type_per_pkg (con/con)", type_per_pkg);

							   unify_types { type_per_api, type_per_pkg, inlining_info => inlining_information::NULL, name => symbol };

							   symbol_table_entries'
							       =
							       case slot 

								    NULL => symbol_table_entries; 

								    THE s
									=> 
									{   var_home   =   vh::select_var_home (constrained_pkg_var_home, s);

									    new_representation =   exception_representation (representation_per_pkg, var_home); 

									    con = ENUM_CONSTRUCTOR {

										      constructor_type =>  type_per_pkg,
										      representation   =>  new_representation,

										      symbol,
										      const,

										      is_lazy,
										      signature
										  };

									    (ste::NAMED_CONSTRUCTOR con) ! symbol_table_entries;
									};
								  esac;

							   match_all_api_elements
							       (
								 remaining_api_elements,
								 typechecker_dictionary,
								 module_declarations,
								 abstract_declarations,
								 symbol_table_entries',
								 match_succeeded
							       );

						      else
							  raise exception ms::UNBOUND symbol;
						      fi;

						  VALUE_IN_API _
						      =>
						      if   (vh::is_exception representation_per_api)   complain_and_loop (THE "exception"  );
						      else                                             complain_and_loop (THE "constructor");
						      fi;

						 _ => bug "match v elem.2";
					     esac
					     except
						 ms::UNBOUND symbol
						 =
						 if   (vh::is_exception representation_per_api)   complain_and_loop (THE "exception"  );
						 else                                             complain_and_loop (THE "constructor");
						 fi;


					_ => bug "match_all_api_elements";
				  esac;

				};
			end;		# fun  match_all_api_elements 
		    end;		# Stipulate.


		    fun match_pkg_to_api  typechecker_dictionary
			= 
			{   if_debugging_say "match_pkg_to_api/TOP";

			    my  ( abstract_declarations,		# Goes into      thinned_declarations.
                                  symbol_table_entries,			# Contributes to thinned_declarations, also inlining_info in thinned_package.
                                  typechecker_dictionary,		# Goes into      thinned_package.
                                  module_declarations,			# Goes into      coerced_package_expression. 
                                  match_succeeded
                                )
				= 
				match_all_api_elements
                                    (
                                      constraining_api_elements,
                                      typechecker_dictionary,	# 
                                      [],			# module_declarations
                                      [],			# abstract_declarations
                                      [],			# symbol_table_entries
                                      TRUE			# match_succeeded
                                    )
				except
				    td::UNBOUND
					=
					{   if_debugging_say "match_pkg_to_api 1: UNBOUND raised.";

					    raise exception td::UNBOUND;
					};

			    if match_succeeded

				 typechecker_dictionary
				     =
				     td::mark (make_stamp, typechecker_dictionary);

				 if_debugging_say "--match_pkg_to_api: elements matched successfully";

				 check_sharing (constraining_api, typechecker_dictionary)
				 except
				     td::UNBOUND
					 =
					 {   if_debugging_say "@@@match_pkg_to_api 3";

					     raise exception td::UNBOUND;
					 };

				 if_debugging_say "--match_pkg_to_api: sharing checked";

				 thinned_package
				     =
				     m::A_PACKAGE {
                                         an_api        =>  constraining_api,
					 var_home      =>  vh::make_var_home  make_var,
					 inlining_info =>  inlining_information::LIST (map ms::extract_inlining_info  symbol_table_entries),
					 typechecked_package
					     =>
					     {   stamp            =>  pkg_stamp,
						 property_list    =>  property_list::make_property_list (),
						 stub             =>  NULL,
						 typechecker_dictionary,
						 inverse_path
					     }
				       };

				 thinned_declarations
				     = 
				     deep::PACKAGE_DECLARATIONS [
					 deep::NAMED_PACKAGE {
					     name_symbol =>  package_name,
					     a_package   =>  thinned_package,
					     definition
                                                 =>
				                 deep::PACKAGE_LET
                                                   {
						     declaration => deep::SEQUENTIAL_DECLARATIONS  abstract_declarations,
						     expression  => deep::PACKAGE_DEFINITION       symbol_table_entries
						   }
					 }
				     ];

				 coerced_package_expression 
				     =
				     m::PACKAGE { stamp                     =>  GET_STAMP (m::VARIABLE_PACKAGE (reverse rpath)),
						  module_declaration =>  SEQUENTIAL_DECLARATIONS  module_declarations
						};

				 if_debugging_say "match_pkg_to_api/BOT";

				 ( thinned_declarations,
                                   thinned_package,
                                   coerced_package_expression
                                 );

			    else	# !match_succeeded

				 ( deep::SEQUENTIAL_DECLARATIONS [],
				   ERRONEOUS_PACKAGE,
				   m::CONSTANT_PACKAGE (m::bogus_typechecked_package)
				 );
			    fi;
			};			# fun match_pkg_to_api


		    # We should not do such short-cut matching because we need to
		    # recalculuate the Type_Constructor_Path information for generic
		    # components.
		    #
		    # But completely turning this off is a bit too expensive, so 
		    # we add a contains_generic in the api to indicate whether it 
		    # contains generic components. 
		    #	
		    if ( (st::eq (constraining_api_stamp, pkg_api_stamp))
			 and      constraining_api_is_closed
			 and (not constraining_api_contains_generic)
		       )

                         # Short-cut matching:
                         # 
			 ( deep::SEQUENTIAL_DECLARATIONS [],
                           constrained_pkg,
                           m::VARIABLE_PACKAGE (reverse rpath)
                         );
		    else
			 match_pkg_to_api
			     (
			       constraining_api_is_closed
                                   ?? td::empty
				   :: match_typechecker_dictionary
			     );
		    fi;
		};

	    thin_package' _
                =>
                ( deep::SEQUENTIAL_DECLARATIONS [],
                  ERRONEOUS_PACKAGE,
                  bogus_package_expression
                );

        end			# fun thin_package' 


        ########################################################################################
        #
	# fun thin_package
        #
        # This gets invoked (only) from two points in
        #
        #     src/lib/compiler/frontend/typechecker/typecheck/typecheck-package-language-g.pkg
        #
	also
	fun thin_package
            {
	      constrained_package:     module::Package,
              constraining_api:        module::Api,

	      package_expression:      module::Package_Expression,

	      module_stamp_or_null:    Null_Or(stamp::Stamp),

	      depth:                   debruijn_index::Depth,
	      typechecker_dictionary:  module::Typechecker_Dictionary,
	      inverse_path:            inverse_path::Inverse_Path,
	      symbol_table:            symbol_table::Symbol_Table,
	      source_code_region:      source_map::Source_Code_Region,

	      compile_info => compile_info as { make_stamp, ... }: tcs::Compile_Info
	    }
            :
            { result_declaration:          deep_syntax::Declaration,	# Package type info for the resulting deep syntax tree. (deep_syntax::PACKAGE_LET.declaration)
              result_package:              module::Package, 		# Package code info for the resulting deep syntax tree. (deep_syntax::PACKAGE_LET.expression )
              coerced_package_expression:  module::Package_Expression	# This winds up in module_declarations (i.e., internal to typechecker).
	    }
            =
	    {   if_debugging_say "thin_package/TOP";

		uncoerced_module_stamp
                    =
                    case module_stamp_or_null
			THE x =>  x;
			NULL  =>  make_stamp ();
		    esac;

		my (result_declaration, result_package, coercion_expression)
                    = 
		    thin_package'  ( constrained_package,
                                     constraining_api,
                                     
                                     anonymous_package_symbol,			#  Added.  
                                     depth,
                                     typechecker_dictionary,
                                     [ uncoerced_module_stamp ],		#  Added.  
                                     inverse_path, 
			             symbol_table,
                                     source_code_region,
                                     compile_info
                                   );

		coerced_package_expression
                    =
                    m::COERCED_PACKAGE
                        {
                          boundvar => uncoerced_module_stamp,
                          raw      => package_expression,
                          coercion => coercion_expression
                        };

	  #     result_expression = m::PACKAGE_LET { declaration => m::PACKAGE_DECLARATION (uncoerced_module_stamp, package_expression), expression };
	  #     result_expression = m::APPLY (m::LAMBDA { parameter=uncoerced_module_stamp, body=expression }, package_expression) ;

		if_debugging_say "thin_package/BOT";

                { result_declaration,		# deep_syntax::Declaration,
                  result_package,		# module::Generic,
                  coerced_package_expression	# module::Package_Expression -- coerced version of original package_expression.
                };
	    }
	    except td::UNBOUND
                   =
                   {   if_debugging_say "thin_package: UNBOUND was thrown.  src/lib/compiler/frontend/typechecker/modules/api-match-g.pkg";
                       raise exception td::UNBOUND;
                   }


	########################################################################## 
	#
	# Matching a generic package against a generic api:
	#
	#
	#  Arguments: funsig  F (fsigParVariable:  fsigParSig) = fsigBodySig
	#             generic package F (genericParVariable:  genericParSig) : genericBodySig = bodyExpression
	#
	#  Result:    generic package F (genericParVariable:  genericParSig) : genericBodySig = resultBodyExpression
	#
	########################################################################## 

	also
	fun match_generic1
            (
              spec_api
                  as
                  GENERIC_API
                      { parameter_api      => fsig_param_sig,
			parameter_variable => fsig_param_variable,
			parameter_symbol,
			body_api           => fsig_body_sig,
			    ...
		      }
                  :
                  Generic_Api,

	      a_generic
                  as
                  GENERIC { typechecked_generic,
			    ...
			  }
                  :
                  Generic,

	      generic_name:             s::Symbol,
	      depth:                    debruijn_index::Depth,
	      typechecker_dictionary:   Typechecker_Dictionary,
	      uncoerced_generic:        m::Generic_Expression,
	      inverse_path:             ip::Inverse_Path,
	      symbol_table:             symbol_table::Symbol_Table,
	      source_code_region:       source_map::Source_Code_Region,

	      compile_info
                  as
                  { make_stamp,
                    make_highcode_variable => make_var,
                    ...
                  }
                  : tcs::Compile_Info
	    )
	    :
            ( deep::Declaration,
              m::Generic,
              m::Generic_Expression
            )
		=>
		(   {   # ** the typechecked_package var for the source generic "uncoerced_generic" 
			uncoerced = make_stamp();

			src_generic_expression
			    =
			    m::VARIABLE_GENERIC [uncoerced];

			generic_api_parameter_typechecked_package_symbol
			    =
			    case parameter_symbol
				THE x => x; 
				NULL  => generic_api_parameter_typechecked_package_symbol;
                            esac;

			# ** parameter api instantiation **

			my  { typechecked_package        => fsig_par_typechecked_package,
			      type_constructor_paths => param_tps
			    }
			    = 
			    gxs::do_generic_parameter_api {

				an_api       =>  fsig_param_sig,
				inverse_path =>  ip::INVERSE_PATH [generic_api_parameter_typechecked_package_symbol],

				typechecker_dictionary,
				depth,
				source_code_region,
				compile_info
			    };

			depth'   = debruijn_index::next depth;

			fsig_par_inst
			    = 
			    {   fsig_par_var_home = vh::make_var_home  make_var;

				m::A_PACKAGE { an_api              => fsig_param_sig,
					       typechecked_package  => fsig_par_typechecked_package, 
					       var_home              => fsig_par_var_home,
					       inlining_info       => inlining_information::NULL
					     };
			    };

			# ** applying aGeneric to the fsigParInst package **

			param_id = fsig_param_variable;    #  make_stamp()

			my  { result_declaration =>  result_declaration1,
			      result_package     =>  result_package1,
			      result_expression  =>  result_expression1
			    }
			    = 
			    {   param_expression
				    =
				    m::VARIABLE_PACKAGE [param_id];

				apply_generic {
				    a_generic,
				    generic_expression   => src_generic_expression,
				    arg_package          => fsig_par_inst, 

				    arg_expression       => param_expression,
				    depth                => depth', 

				    module_stamp_or_null => NULL,
				    module_path_context  => epc::init_context /* ? ZHONG */,

				    inverse_path         => ip::empty,

				    symbol_table,
				    source_code_region,
				    compile_info
				};
			    };

			# Matching the result package against the body api

			fsig_body_sig_dictionary
			    =
			    td::set (
				typechecker_dictionary,
				fsig_param_variable,
				PACKAGE_ENTRY fsig_par_typechecked_package
			    );

			my  { result_declaration         =>  result_declaration2,
			      result_package             =>  result_package2,
			      coerced_package_expression =>  result_expression2
			    }
			    = 
			    {   rp = ip::INVERSE_PATH [ s::make_package_symbol "<GenericResult>" ];

				thin_package  { constraining_api       =>  fsig_body_sig,
						constrained_package    =>  result_package1,

						package_expression     =>  result_expression1,
						module_stamp_or_null   => NULL,

						depth                  => depth',
						typechecker_dictionary => fsig_body_sig_dictionary,
						inverse_path           => rp, 

						symbol_table,
						source_code_region,
						compile_info
					      };
			    };

			# Construct the Type_Constructor_Path for the resulting generic:
			#
			result_tps
			    = 
			    case result_package2 

				 m::A_PACKAGE { an_api, typechecked_package, ... }
				     =>
				     gxs::get_packages_type_constructor_paths
					 {
					   typechecker_dictionary  => fsig_body_sig_dictionary, 
					   an_api,
					   typechecked_package,
					   compile_info
					 };

				_ => [];
			    esac;

			# Construct the resulting coerced generic:
			#
			result_generic
			    =
			    {   result_expression3
				    =
				    m::PACKAGE_LET
                                      {

                                        declaration
                                            =>
					    m::GENERIC_DECLARATION (
						uncoerced,
						m::CONSTANT_GENERIC typechecked_generic
					    ), 

					expression
					    =>
					    result_expression2
				      };

				result_closure
				    =
				    GENERIC_CLOSURE {

					parameter_module_stamp =>  param_id,
					body_package_expression            =>  result_expression3,
					typechecker_dictionary
				    };

				tps = t::TYPCONPATH_GENERIC (param_tps, result_tps);

				result_typechecked_package
				    =
				    {   stamp                 =>  typechecked_generic.stamp,	# ** DAVE ? XXX BUGGO FIXME **
					generic_closure       =>  result_closure,

					type_constructor_path =>  THE tps,
					property_list         =>  property_list::make_property_list (),
					stub                  =>  NULL,

					inverse_path
				    };

				m::GENERIC { a_generic_api       =>  spec_api,
					     typechecked_generic =>  result_typechecked_package,
					     var_home            =>  vh::make_var_home  make_var,
					     inlining_info       =>  inlining_information::NULL
					   };
			    };

			# The resulting generic deep_syntax_tree
			#
			fdec = {   body_abs
				       =
				       deep::PACKAGE_LET
                                         {
					   declaration =>  deep::SEQUENTIAL_DECLARATIONS [ result_declaration1, result_declaration2 ],
					   expression  =>  deep::PACKAGE_BY_NAME result_package2
				         };

				   generic_expression
				       =
				       deep::GENERIC_DEFINITION {

					   parameter       =>  fsig_par_inst,
					   parameter_types =>  param_tps,
					   definition      =>  body_abs
				       };

				    deep::GENERIC_DECLARATIONS [

					deep::NAMED_GENERIC {

					    name_symbol => anonymous_generic_symbol,
					    a_generic   => result_generic,
					    definition  => generic_expression
					}
				    ];
			       };

			# ** the generic typechecked_package expression **

			generic_expression
			    = 
			    m::LET_GENERIC (

				m::GENERIC_DECLARATION (uncoerced, uncoerced_generic), 

				m::LAMBDA_TP {

				    parameter =>  param_id,
				    body      =>  result_expression2,
				    an_api    =>  spec_api
				}
			    );

			(fdec, result_generic, generic_expression);

		    }
		    except
			MATCH
			    =
			    (   deep::SEQUENTIAL_DECLARATIONS [],
				ERRONEOUS_GENERIC,
				bogus_generic_expression
			    )
		);

	     # This is intended to handle only the two left-hand side 
	     # occurrences of PACKAGE { ... } above, and is very crude. 
	     # It should be replaced by case-expressions on the results of 
	     # match etc.    XXX BUGGO FIXME


	    match_generic1 _
                =>
                (deep::SEQUENTIAL_DECLARATIONS [], ERRONEOUS_GENERIC, bogus_generic_expression);

        end 				# fun match_generic1


	####################################################################################
	#
	# my match_generic
	#
	####################################################################################

	also
	fun match_generic
	    {
	      an_api:                  module::Generic_Api,
	      a_generic:               module::Generic,
	      generic_expression:      module::Generic_Expression,
	      depth:                   debruijn_index::Depth,
	      typechecker_dictionary:  module::Typechecker_Dictionary,
	      inverse_path:            inverse_path::Inverse_Path, 
	      symbol_table:            symbol_table::Symbol_Table,
	      source_code_region:      source_map::Source_Code_Region,
	      compile_info:            typecheck_stuff::Compile_Info
	    }
            :
            { result_declaration:      deep_syntax::Declaration,
              result_generic:          module::Generic,
              result_expression:       module::Generic_Expression
            } 
            = 
	    {   if_debugging_say "match_generic/TOP";

		my (result_declaration, result_generic, result_expression)
                    = 
		    match_generic1 (
                        an_api,
                        a_generic,
                        anonymous_generic_symbol,
                        depth,
                        typechecker_dictionary,
                        generic_expression,
                        inverse_path, 
			symbol_table,
                        source_code_region,
                        compile_info
                    );

		if_debugging_say "match_generic/BOT";


                { result_declaration,
                  result_generic,
                  result_expression
                };
	    }
	    except td::UNBOUND
                   =
                   {   if_debugging_say "@@@matchGeneric";
                       raise exception td::UNBOUND;
                   }


	##########################################################################
	#
	# Packing a package against a api.
        #
	##########################################################################

	also
	fun cast_package'
                (
                  # Constrained package:
                  #
		  m::A_PACKAGE { var_home              =>  constrained_package_var_home,
				 typechecked_package =>  { typechecker_dictionary => constrained_package_typechecker_dictionary, ... },
				 inlining_info       =>  constrained_package_inlining_info,
				 ...
			       }
                      :
                      Package,

                  constraining_api
                      as
                      m::API { elements => api_elements, ... }
                      :
                      Api,

		  result_typechecked_package
                      as
                      { typechecker_dictionary => result_typechecker_dictionary, ... }
                      :
                      Typechecked_Package,

		  abstract_type_constructors:  ts::Type_Constructor_Set,
		  package_name:                s::Symbol,
		  depth:                       Int,
		  typechecker_dictionary:      Typechecker_Dictionary,
		  inverse_path:                ip::Inverse_Path,
		  symbol_table:                symbol_table::Symbol_Table,
		  source_code_region:          source_map::Source_Code_Region, 

		  compile_info
                      as
                      { make_highcode_variable=>make_var, error_fn, ... }
                      :
                      tcs::Compile_Info 
	        ) 
		:
		( deep_syntax::Declaration,
		  m::Package
		)

	        =>
		{   fun type_in_result (kind, type)
			= 
			(ms::translate_type
                           result_typechecker_dictionary
                           type
                        ) 
			except
			    td::UNBOUND
			    =
			    {   debug_print  debugging  (kind, unparse_type::unparse_type  symbol_table, type);
				raise exception td::UNBOUND;
			    };



		    fun type_in_source (kind, type)
			= 
			(ms::translate_type
                           constrained_package_typechecker_dictionary
                           type
                        ) 
			except
			    td::UNBOUND
			    =
			    {   debug_print  debugging  (kind, unparse_type::unparse_type  symbol_table, type);
				raise exception td::UNBOUND;
			    };



		    fun cast_api_elements ([], typechecker_dictionary, declarations, symbol_table_entries)
			    =>
			    ( reverse declarations,
			      reverse symbol_table_entries
			    );

			cast_api_elements
                            ( (symbol, api_element) ! remaining_api_elements,
                              typechecker_dictionary,
                              declarations,
                              symbol_table_entries
                            )
			    => 
			    {   if_debugging_say "cast_api_elements/TOP";

				case api_element

				     PACKAGE_IN_API
					 {
					   an_api       => this_spec_api,
					   module_stamp,
					   slot,
					   ...
					 }
					 =>
					 case ( td::find_entry_by_module_stamp (result_typechecker_dictionary,  module_stamp),
						td::find_entry_by_module_stamp (constrained_package_typechecker_dictionary,  module_stamp)
					      )  

					      ( m::PACKAGE_ENTRY result_typechecked_package,
						m::PACKAGE_ENTRY source_typechecked_package
					      )
						  =>
						  {   source_package
							  =
							  m::A_PACKAGE {
							      an_api              => this_spec_api,
							      typechecked_package => source_typechecked_package,

							      var_home            => vh::select_var_home          (constrained_package_var_home,      slot),
							      inlining_info       => inlining_information::select (constrained_package_inlining_info, slot)
							  };

						      inverse_path'
							  =
							  ip::extend (inverse_path, symbol);

						      my (thinned_declaration, thinned_package)
							  = 
							  cast_package' (

							      source_package,
							      this_spec_api,

							      result_typechecked_package,
							      abstract_type_constructors,
							      symbol,
							      depth,
							      typechecker_dictionary,
							      inverse_path',
							      symbol_table, 
							      source_code_region,
							      compile_info
							  );

						      typechecker_dictionary'
							  = 
							  {   typechecked_package
								  = 
								  case thinned_package

								       m::A_PACKAGE { typechecked_package, ... } => typechecked_package;
								       _                                         => m::bogus_typechecked_package;
								  esac;

							      td::set (
								  typechecker_dictionary,
                                                                  module_stamp,
								  m::PACKAGE_ENTRY typechecked_package
							      );
							  };

						      declarations'         = thinned_declaration                  ! declarations;
						      symbol_table_entries' = (ste::NAMED_PACKAGE thinned_package) ! symbol_table_entries;

						      cast_api_elements (remaining_api_elements, typechecker_dictionary', declarations', symbol_table_entries');
						  };

					      _   =>
                                                  # Missing element, error situation -- do nothing:
						  #
					          cast_api_elements (remaining_api_elements, typechecker_dictionary, declarations, symbol_table_entries);
					 esac;

				     GENERIC_IN_API {   a_generic_api => this_spec_api,   module_stamp,   slot }
					 => 
					 case ( td::find_entry_by_module_stamp (result_typechecker_dictionary, module_stamp),
					        td::find_entry_by_module_stamp (constrained_package_typechecker_dictionary, module_stamp)
					      )

					      ( m::GENERIC_ENTRY result_typechecked_generic,
						m::GENERIC_ENTRY source_typechecked_generic
					      )
						  =>
						  {   src_generic
							  =
							  m::GENERIC {
                                                              a_generic_api       =>  this_spec_api,
							      typechecked_generic =>  source_typechecked_generic,
							      var_home            =>  vh::select_var_home          (constrained_package_var_home,      slot),
							      inlining_info       =>  inlining_information::select (constrained_package_inlining_info, slot)
							  };

						      inverse_path'
							  =
							  ip::extend (inverse_path, symbol);

						      my (thinned_declaration, thinned_g)
							  = 
							  pack_generic1 (
                                                              this_spec_api,
							      result_typechecked_generic,
							      src_generic,
							      abstract_type_constructors,
							      symbol,
							      depth,
							      typechecker_dictionary,
							      inverse_path',
							      symbol_table,
							      source_code_region,
							      compile_info
							  );

						      typechecker_dictionary'
							  = 
							  {   typechecked_generic
								  = 
								  case thinned_g
								       m::GENERIC { typechecked_generic, ... } =>  typechecked_generic;
								      _                                        =>  m::bogus_typechecked_generic;
                                                                  esac;

							      td::set (typechecker_dictionary, module_stamp, m::GENERIC_ENTRY typechecked_generic);
							  };

						      declarations'         = thinned_declaration            ! declarations;
						      symbol_table_entries' = (ste::NAMED_GENERIC thinned_g) ! symbol_table_entries;

						      cast_api_elements (remaining_api_elements, typechecker_dictionary', declarations', symbol_table_entries');
						  };

					     _   =>
                                                 cast_api_elements (remaining_api_elements, typechecker_dictionary, declarations, symbol_table_entries);

					 esac;

				     VALUE_IN_API { type => spec_type,   slot }
					 => 
					 {   result_type = type_in_result ("@@@spec-resty (cast_package-my)", spec_type);
					     source_type = type_in_source ("@@@spec-srcty (cast_package-my)", spec_type);

					     var_home      = vh::select_var_home          (constrained_package_var_home,      slot);
					     inlining_info = inlining_information::select (constrained_package_inlining_info, slot);

					     my (types, bound_typevar_refs, type, result_unified_with_source_type)
						 = 
						 try_unifying_pkg_with_api_type (result_type, source_type, inlining_info);

					     path  = sp::SYMBOL_PATH [symbol];

					     srcvar
						 =
						 ORDINARY_VARIABLE {

						     path,
						     var_type => REF source_type,
						     var_home,
						     inlining_info
						 };

					     my (declarations', named_variable)
						 =
						 if result_unified_with_source_type
						      (declarations, srcvar);
						 else
						     var_home = vh::named_var_home (symbol, make_var);

						      result_variable
							  = 
							  ORDINARY_VARIABLE
                                                            { path,
							      var_type      => REF result_type,
							      inlining_info => inlining_information::NULL,
							      var_home
							    };

						      ntycs
							  =
							  ts::filter_type_constructor_set (

							      type,
							      abstract_type_constructors
							  );

						      expression
							  = 
							  deep::PACK_EXPRESSION (

							      deep::VARIABLE_IN_EXPRESSION (REF srcvar, types),
							      type,
							      ntycs
							  );

						      if (*debugging and ((list::length bound_typevar_refs) > 0))
							  printf "api-match-g.pkg: Creating deep::NAMED_VALUE node with length(bound_typevar_refs) d=%d  (III)\n" (list::length bound_typevar_refs);
						      fi;

						      named_value
							  =
							  deep::NAMED_VALUE {

							      pattern              => (deep::VARIABLE_IN_PATTERN result_variable),
							      ref_typevar_refs     => REF [],
							      expression,
							      bound_typevar_refs
							  };

						      ( (deep::VALUE_DECLARATIONS [named_value])   !   declarations,
							 result_variable
						      );
						 fi;


					     symbol_table_entries'
						 =
						 (ste::NAMED_VARIABLE named_variable)
						 !
						 symbol_table_entries;

					     cast_api_elements (

						 remaining_api_elements,
						 typechecker_dictionary,
						 declarations',
						 symbol_table_entries'
					     );
					 };


				     ENUM_CONSTRUCTOR_IN_API {

					     a_datatype => ENUM_CONSTRUCTOR {

							     symbol,
							     constructor_type,
							     representation,
							     const,
							     signature,
							     is_lazy
							 },
					     slot
					 }
					 =>
					 {   symbol_table_entries'
						 =
						 case slot 

						      NULL => symbol_table_entries; 

						      THE s 
							  => 
							  {   result_type
								  =
								  type_in_result ("@@@spec-resty (cast_package-con)", constructor_type);

							      var_home =  vh::select_var_home (constrained_package_var_home, s);

							      con = ENUM_CONSTRUCTOR {   constructor_type => result_type,
											 representation   => exception_representation (representation, var_home),
											 symbol,

											 is_lazy,
											 const,

											 signature
										     };

							      (ste::NAMED_CONSTRUCTOR (con)) ! symbol_table_entries;
							  };
						 esac;

					     cast_api_elements
                                               (
                                                 remaining_api_elements,
                                                 typechecker_dictionary,
                                                 declarations,
                                                 symbol_table_entries'
                                               );
					 };


				     TYPE_CONSTRUCTOR_IN_API { type_constructor => type_per_api,   module_stamp,   is_a_replica,   scope }
					 =>
					 {   typechecker_dictionary'
						 =
						 td::set (
						     typechecker_dictionary,
						     module_stamp,
						     td::find_entry_by_module_stamp (result_typechecker_dictionary, module_stamp)
						 );

					     cast_api_elements
                                               (
                                                 remaining_api_elements,
                                                 typechecker_dictionary',
                                                 declarations,
                                                 symbol_table_entries
                                               );
					 };

				esac;

			    };
		    end;			#  function cast_api_elements 


		    my  ( abstract_declarations,
                          symbol_table_entries
                        )
			=
			cast_api_elements (
                            api_elements,
                            typechecker_dictionary,
                            [],				# declarations accumulator.
                            []				# symbol_table_entries accumulator.
                        );

		    result_package
			=
			m::A_PACKAGE {
                            typechecked_package  =>  result_typechecked_package,

			    an_api        =>  constraining_api,
			    var_home      =>  vh::make_var_home  make_var,
			    inlining_info =>  inlining_information::LIST (map  ms::extract_inlining_info  symbol_table_entries)
			};

		    result_declaration
			= 
			deep::PACKAGE_DECLARATIONS [

			    deep::NAMED_PACKAGE {

				name_symbol =>  package_name,
				a_package   =>  result_package,

				definition
				    =>
				    deep::PACKAGE_LET
                                      {
					declaration =>  deep::SEQUENTIAL_DECLARATIONS  abstract_declarations,
					expression  =>  deep::PACKAGE_DEFINITION       symbol_table_entries
				      }
			    }
			];

		    ( result_declaration,
		      result_package
		    );
		};

	    cast_package' _
		=>
		( deep::SEQUENTIAL_DECLARATIONS [],
		  ERRONEOUS_PACKAGE
		);
        end 				# fun cast_package'


	########################################################################################
	# Abstraction matching of a package against a api.
	#
	# INVARIANT: The base api for pkg should be exactly an_api; in other
	#            words, a_package should have been matched against an_api before
	#            being packed against an_api.
	#
        # This gets invoked (only) from
        #     src/lib/compiler/frontend/typechecker/typecheck/typecheck-package-language-g.pkg
	#
	########################################################################################

	also
	fun cast_package
	    {
	      constrained_package:    module::Package,
	      constraining_api:       module::Api,

	      package_expression:     module::Package_Expression,
	      depth:                  debruijn_index::Depth,
	      typechecker_dictionary: module::Typechecker_Dictionary,
	      inverse_path:           inverse_path::Inverse_Path, 
	      symbol_table:           symbol_table::Symbol_Table,
	      source_code_region:     source_map::Source_Code_Region,
	      compile_info:           typecheck_stuff::Compile_Info 
	    }
            :
	    { result_declaration:     deep_syntax::Declaration,
	      result_package:         module::Package,
	      result_expression:      module::Package_Expression  
	    } 
            = 
	    {   if_debugging_say "cast_package/TOP";

		my  { typechecked_package        =>  result_typechecked_package,
                      abstract_type_constructors,

                      type_constructor_module_paths =>  _
                    }
                    = 
		    {   source_typechecked_package
                            =
                            case constrained_package

                                 m::A_PACKAGE { typechecked_package, ... }
				     =>
				     typechecked_package;

			         _   => m::bogus_typechecked_package;
                            esac;


                        gxs::instantiate_package_abstractions {

                            an_api => constraining_api,
                            typechecker_dictionary,
                            source_typechecked_package,

			    inverse_path,
                            source_code_region,
                            compile_info
                        };
		    };

                if_debugging_say "cast_package - processing done";

		abstract_type_constructors'
                    =
                    fold_right
                        ts::insert_type_constructor_into_set
                        (ts::make_type_constructor_set())
                        abstract_type_constructors;

		my (result_declaration, result_package)
                    = 
		    cast_package'
                      (
                        constrained_package,
                        constraining_api,

                        result_typechecked_package,
                        abstract_type_constructors',
                        anonymous_package_symbol,
                        depth,
		        typechecker_dictionary,
                        inverse_path,
                        symbol_table,
                        source_code_region,
                        compile_info
                      );

		if_debugging_say "cast_package - cast_package' done";

		result_expression
                    =
                    m::ABSTRACT_PACKAGE (
                        constraining_api,
                        package_expression
                    );

		if_debugging_say "cast_package/BOT";


                { result_declaration,
                  result_package,
                  result_expression
                };
	    }						# fun cast_package


	############################################################################
	# 
	# fun pack_generic1:  Packing a generic package against a generic api.
	#
	############################################################################

	also
	fun pack_generic1
            ( spec_api
                  as GENERIC_API { parameter_api, parameter_variable, body_api, ... }
                  :  Generic_Api,

	      result_typechecked_generic:  Typechecked_Generic,

	      src_generic
                  as GENERIC { typechecked_generic => source_typechecked_generic, ... }
                  :  Generic,

	      abstract_type_constructors1:   type_stuff::Type_Constructor_Set,
	      generic_name:                  s::Symbol,
	      depth:                         debruijn_index::Depth,
	      typechecker_dictionary:        Typechecker_Dictionary,
	      inverse_path:                  ip::Inverse_Path,
	      symbol_table:                  symbol_table::Symbol_Table,
	      source_code_region:            source_map::Source_Code_Region,

	      compile_info
                  as { make_stamp, make_highcode_variable=>make_var, error_fn, ... }
                  :  tcs::Compile_Info
	    )
	    :
            ( deep_syntax::Declaration,
              m::Generic
            )
		=> 
		{   my  { typechecked_package        =>  param_typechecked_package,
			  type_constructor_paths =>  param_tps
			}
			=
			gxs::do_generic_parameter_api {

			    an_api              =>  parameter_api,
			    typechecker_dictionary,
			    inverse_path        =>  ip::INVERSE_PATH [generic_api_parameter_typechecked_package_symbol],
			    depth,
			    source_code_region,
			    compile_info
			};

		    depth'
			=
			debruijn_index::next depth;

		    parameter_package
			= 
			{   param_var_home
				=
				vh::make_var_home  make_var;

			    m::A_PACKAGE { an_api               => parameter_api,
					   typechecked_package  => param_typechecked_package,

					   var_home             => param_var_home,
					   inlining_info      => inlining_information::NULL
					 };
			};

		    my  { result_declaration => rdec1,
			  result_package     => body_package,
			  result_expression  => _
			}
			= apply_generic { a_generic            => src_generic,
					  generic_expression   => CONSTANT_GENERIC source_typechecked_generic,
					  arg_package          => parameter_package, 

					  arg_expression       =>  CONSTANT_PACKAGE param_typechecked_package,
					  depth                =>  depth', 
					  inverse_path         =>  ip::empty,

					  module_stamp_or_null =>  NULL,
					  module_path_context  =>  epc::init_context,                     #  ? ZHONG 

					  symbol_table,
					  source_code_region,
					  compile_info
				        };

		    #  typechecked_body = expand_generic::expand_generic (srcGenericMacroExpansion, paramMacroExpansion, depth', module_path_context, compile_info) ;
		    #
		    typechecked_body
			= 
			case body_package

			     m::A_PACKAGE { typechecked_package, ... } => typechecked_package;
			    _ => m::bogus_typechecked_package;
			esac;

		    my  {  typechecked_package              => result_typechecked_package,
			   abstract_type_constructors   => abstract_type_constructors2,
			   type_constructor_module_paths => _
			}
			= 
			{   typechecker_dictionary'
				= 
				td::mark (  make_stamp,
					    td::set (typechecker_dictionary, parameter_variable, PACKAGE_ENTRY param_typechecked_package)
					 );

			    gxs::instantiate_package_abstractions {

				an_api                     =>  body_api,
				typechecker_dictionary     =>  typechecker_dictionary',
				source_typechecked_package =>  typechecked_body,
				inverse_path,
				source_code_region,
				compile_info
			    };
			};

		    abstract_type_constructors
			=
			fold_right
			    ts::insert_type_constructor_into_set
			    abstract_type_constructors1
			    abstract_type_constructors2;

		    my (rdec2, result_package)
			= 
			{   inverse_path'
				=
				ip::INVERSE_PATH
				    [ s::make_package_symbol "<GenericResult>" ];

			    cast_package' (

				body_package,
				body_api,

				result_typechecked_package,
				abstract_type_constructors,
				anonymous_package_symbol,
				depth',
				typechecker_dictionary,
				inverse_path',
				symbol_table,
				source_code_region,
				compile_info
			    );
			};

		    result_generic
			= 
			{   result_var_home
				=
				vh::make_var_home  make_var;

			    m::GENERIC {   a_generic_api       =>  spec_api,
					   typechecked_generic =>  result_typechecked_generic,
					   var_home            =>  result_var_home,
					   inlining_info       =>  inlining_information::NULL
				       };
			};

		    result_declaration
			= 
			{   body
				=
				deep::PACKAGE_LET
                                  {
				    declaration => rdec1,

                                    expression
                                        =>
				        deep::PACKAGE_LET {
					  declaration => rdec2,
					  expression  => deep::PACKAGE_BY_NAME result_package
				        }
				  };

			    generic_expression
				=
				deep::GENERIC_DEFINITION {
				    parameter       => parameter_package,
				    parameter_types => param_tps,
				    definition      => body
				};

			    deep::GENERIC_DECLARATIONS [
                                deep::NAMED_GENERIC {
                                  name_symbol => generic_name,
				  a_generic   => result_generic,
				  definition => generic_expression
				}
			    ];
			};


		    ( result_declaration,
		      result_generic
		    );

		};

	    pack_generic1 _
                =>
                (deep::SEQUENTIAL_DECLARATIONS [], ERRONEOUS_GENERIC);

        end 		#  function pack_generic1 


        #################################################################################
	#
	# fun apply_generic:
	#
	# Match and coerce the argument, then do the generic application.
	# Return the result package, the result typechecked_package expression,
	# and the result abstract syntax declaration of result_package.
	#
	# The argument matching takes place in the Typechecker_Dictionary stored in the
	# generic closure; this is where the parameter_api must be interpreted.
	#
        #################################################################################

	also
	fun apply_generic
            {
              a_generic
                  as
                  GENERIC { a_generic_api   =>  GENERIC_API { parameter_api, body_api, ... },
			    typechecked_generic,
                            ...
                          },

	      generic_expression:     module::Generic_Expression,
	      arg_package:            module::Package,
	      arg_expression:         module::Package_Expression,

	      depth:                  debruijn_index::Depth,
	      symbol_table:           symbol_table::Symbol_Table,
	      inverse_path:           inverse_path::Inverse_Path,
	      source_code_region:     source_map::Source_Code_Region,

	      module_stamp_or_null:   Null_Or( module_path::Module_Stamp ),
	      module_path_context:    module_path_context::Context,

	      compile_info
                  as
                  { make_stamp,
		    make_highcode_variable => make_var,
		    ...
		  }
                  : typecheck_stuff::Compile_Info
	    }
            :
            { result_declaration:  deep_syntax::Declaration,
              result_package:      module::Package,
              result_expression:   module::Package_Expression
            }
		=>
		{   my { generic_closure => GENERIC_CLOSURE { typechecker_dictionary => generic_typechecker_dictionary, ... }, ... }
			=
			typechecked_generic;

		    if_debugging_say "apply_generic/TOP";



		    # Step #1: match the argument package against parameter_api
		    #
		    my { result_declaration         => arg_declaration1,
			 result_package             => arg_package1,
			 coerced_package_expression => arg_expression1		# Coerced version of supplied package_expression argument.
			}
			=
			thin_package {
			    constraining_api       =>  parameter_api,
			    constrained_package    =>  arg_package,

			    package_expression     =>  arg_expression,
			    typechecker_dictionary =>  generic_typechecker_dictionary,
			    inverse_path           =>  ip::INVERSE_PATH []                 /* ?DAVE XXX BUGGO FIXME */, 

			    module_stamp_or_null,

			    depth,
			    symbol_table,

			    source_code_region,
			    compile_info
			};



		    # ** step #2: do the generic application **

		    typechecked_argument
			=
			case arg_package1

			     m::A_PACKAGE { typechecked_package, ... } =>   typechecked_package;
			     _                                         =>   m::bogus_typechecked_package;
			esac;

		    typechecked_body
			=
			expand_generic::expand_generic (

			    typechecked_generic,
			    typechecked_argument,
			    depth,
			    module_path_context,
			    inverse_path,
			    compile_info
			);

		    result_package
			= 
			{   body_var_home
				=
				vh::named_var_home (anonymous_package_symbol, make_var);

			    m::A_PACKAGE { an_api              => body_api,
					   typechecked_package => typechecked_body,
					   var_home            => body_var_home,
					   inlining_info       => inlining_information::NULL
					 };
			};

		    result_declaration
			= 
			{   parameter_types
				=
				gxs::get_packages_type_constructor_paths {

				    an_api                 => parameter_api,
				    typechecked_package    => typechecked_argument,
				    typechecker_dictionary => generic_typechecker_dictionary,
				    compile_info
				};

			    expression
				=
				deep::COMPUTED_PACKAGE {

				    generic_argument => arg_package1,
				    a_generic,
				    parameter_types
				};

			    result_abs
				=
				deep::PACKAGE_LET { declaration => arg_declaration1, expression };


			    deep::PACKAGE_DECLARATIONS [

				deep::NAMED_PACKAGE {

				    name_symbol =>  anonymous_package_symbol,
				    a_package   =>  result_package,
				    definition  =>  result_abs
				}
			    ];
			};

		    result_expression
			=
			m::APPLY (generic_expression, arg_expression1);

		    if_debugging_say "apply_generic/BOT";

		    { result_declaration,
		      result_package,
		      result_expression
		    };
		};

	    apply_generic { a_generic => ERRONEOUS_GENERIC, ... }
		=> 
		{ result_declaration =>  deep::PACKAGE_DECLARATIONS [],
		  result_package     =>  m::ERRONEOUS_PACKAGE, 
		  result_expression  =>  m::CONSTANT_PACKAGE  m::bogus_typechecked_package
		};

	    apply_generic _
                =>
                bug "apply_generic: bad generic package";

        end;		# fun apply_generic

	# top level wrappers: used for profiling the compilation time 

#	thin_package
#            = 
#	    compile_statistics::do_phase (compile_statistics::make_phase "Compiler 034 1-thin_package") thin_package
#
#	match_generic
#            = 
#	    compile_statistics::do_phase (compile_statistics::make_phase "Compiler 034 2-match_generic") match_generic
#
#	cast_package
#            = 
#	   compile_statistics::do_phase (compile_statistics::make_phase "Compiler 034 3-cast_package") cast_package
#
#	apply_generic
#            = 
#	    compile_statistics::do_phase (compile_statistics::make_phase "Compiler 034 4-apply_generic") apply_generic


    end;			# stipulate

};				# package api_match







##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## Copyright 1996 by AT&T Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
