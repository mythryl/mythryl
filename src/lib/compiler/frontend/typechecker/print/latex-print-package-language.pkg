## latex-print-package-language.pkg 
## Copyright 2003 by The SML/NJ Fellowship 

# Compiled by:
#     src/lib/compiler/frontend/typechecker/typecheck.make6

# Invoked from  src/lib/compiler/frontend/typecheck-stuff/symbol-table/latex-print-symbol-table.pkg

# This is a clone of unparse-package-language.pkg
# specialized to produce LaTeX output intended to be
# run through Hevea to produce online HTML docs of
# our interfaces.
#

#  modified to use Lib7 Lib pp. [dbm, 7/30/03]) 

api Latex_Print_Package_Language {

    latex_print_api
        :
        prettyprint::Stream 
	->
        ( module::Api,
          symbol_table::Symbol_Table,
          Int,				# Max prettyprint recursion depth
          Ref( List( String ) )		# index_entries -- a return value list of strings like "(backslash)index[fun]{foo}" her
        )
        ->
        Void;


    latex_print_package
        :
        prettyprint::Stream
	->
        ( module::Package,
          symbol_table::Symbol_Table,
          Int,				# Max prettyprint recursion depth
          Ref( List( String ) )		# index_entries -- a return value list of strings like "(backslash)index[fun]{foo}" her
        )
        ->
        Void;


    latex_print_open
        :
        prettyprint::Stream
	->
        ( symbol_path::Symbol_Path,
          module::Package,
          symbol_table::Symbol_Table,
          Int,				# Max prettyprint recursion depth
          Ref( List( String ) )		# index_entries -- a return value list of strings like "(backslash)index[fun]{foo}" her
        )
        ->
        Void;


    latex_print_package_name
        :
        prettyprint::Stream
	->
        ( module::Package,
          symbol_table::Symbol_Table
        )
        ->
        Void;


    latex_print_generic
        :
        prettyprint::Stream
        ->
        ( module::Generic,
          symbol_table::Symbol_Table,
          Int,				# Max prettyprint recursion depth
          Ref( List( String ) )		# index_entries -- a return value list of strings like "(backslash)index[fun]{foo}" her
        )
        ->
        Void;


    latex_print_generic_api
        :
        prettyprint::Stream
        ->
        ( module::Generic_Api,
	  symbol_table::Symbol_Table,
          Int,				# Max prettyprint recursion depth
          Ref( List( String ) )		# index_entries -- a return value list of strings like "(backslash)index[fun]{foo}" her
        )
	->
        Void;


    latex_print_naming
        :
        prettyprint::Stream 
        ->
        ( symbol::Symbol,
          symbol_table_entry::Symbol_Table_Entry,
          symbol_table::Symbol_Table,
          Int,				# Max prettyprint recursion depth
          Ref( List( String ) )		# index_entries -- a return value list of strings like "(backslash)index[fun]{foo}" her
        )
	->
        Void;


    latex_print_dictionary
        :
        prettyprint::Stream
	->
        ( symbol_table::Symbol_Table,
	  symbol_table::Symbol_Table,
	  Int,
	  Null_Or( List( symbol::Symbol ) ),
          Ref( List( String ) )		# index_entries -- a return value list of strings like "(backslash)index[fun]{foo}" her
        )
	->
        Void;



    #  module internals 


    latex_print_elements
        :
	(  symbol_table::Symbol_Table,
	   Int,
	   Null_Or( module::Typechecker_Dictionary ),
           Ref( List( String ) )		# index_entries -- a return value list of strings like "(backslash)index[fun]{foo}" her
	)
	-> prettyprint::Stream
	-> module::Elements
        -> Void;


    latex_print_typechecked_package
        :
        prettyprint::Stream
	->
        ( module::Typechecker_Dictionary_Entry,
          symbol_table::Symbol_Table,
          Int
        )
	->
        Void;


    latex_print_typechecker_dictionary
        :
        prettyprint::Stream
	->
        ( module::Typechecker_Dictionary,
	  symbol_table::Symbol_Table,
	  Int
        )
	->
        Void;

};


package latex_print_package_language: (weak)  Latex_Print_Package_Language {

    stipulate

        package s  = symbol;				# symbol			is from   src/lib/compiler/frontend/basics/mlcomp/symbol.pkg
	package sp = symbol_path;			# symbol_path			is from   src/lib/compiler/frontend/typecheck-stuff/basics/symbol-path.pkg
	package ip = inverse_path;			# inverse_path			is from   src/lib/compiler/frontend/typecheck-stuff/basics/symbol-path.pkg
	package a  = var_home;				# var_home			is from   src/lib/compiler/frontend/typecheck-stuff/basics/var-home.pkg
     #  package ii = inlining_info 
	package t  = types;				# types				is from   src/lib/compiler/frontend/typecheck-stuff/types/types.pkg
	package tu = type_stuff;			# type_stuff			is from   src/lib/compiler/frontend/typecheck-stuff/types/type-stuff.pkg
	package bt = type_types;			# type_types			is from   src/lib/compiler/frontend/typechecker/types/type-types.pkg
	package v  = variables_and_constructors;	# variables_and_constructors	is from   src/lib/compiler/frontend/typecheck-stuff/deep-syntax/variables-and-constructors.pkg
	package m  = module;				# module			is from   src/lib/compiler/frontend/typecheck-stuff/modules/module.pkg
	package mu = module_stuff;			# module_stuff			is from   src/lib/compiler/frontend/typecheck-stuff/modules/module-stuff.pkg
	package b  = symbol_table_entry;		# symbol_table_entry		is from   src/lib/compiler/frontend/typecheck-stuff/symbol-table/symbol-table-entry.pkg
	package st = symbol_table;			# symbol_table			is from   src/lib/compiler/frontend/typecheck-stuff/symbol-table/symbol-table.pkg
	package ee = typechecker_dictionary;		# typechecker_dictionary	is from   src/lib/compiler/frontend/typecheck-stuff/modules/typechecker-dictionary.pkg
	package lu = find_in_symbol_table;		# find_in_symbol_table		is from   src/lib/compiler/frontend/typecheck-stuff/symbol-table/find-in-symbol-table.pkg
	package pp = prettyprint;			# prettyprint			is from   src/lib/prettyprint/src/prettyprint.pkg

	include prettyprint;
	include unparse_stuff;

    herein 

							# typechecking_control		is from   src/lib/compiler/frontend/typechecker/basics/typechecking-control.pkg

	internals
            =
            typechecking_control::internals;

	fun bug msg
            =
            error_message::impossible("latex_print_package_language: " + msg);

	fun by f x y
            =
            f y x;

	pps = pp::string;

	latex_print_some_type   =  latex_print_type::latex_print_some_type;
	latex_print_type        =  latex_print_type::latex_print_type;

	latex_print_type_scheme =  latex_print_type::latex_print_type_scheme;
	latex_print_formals     =  latex_print_type::latex_print_formals;

	backslash_latex_special_chars =  latex_print_value::backslash_latex_special_chars;

	result_id
            =
            s::make_package_symbol  "<result_package>";


	fun str_to_dictionary  ( m::API { elements, ... },  entities)
		=>
		{   fun bind_element ((symbol, spec), symbol_table)
			=
			case spec
			  
			     m::TYPE_CONSTRUCTOR_IN_API { module_stamp, ... }
				 => 
				 {   type_constructor
                                         =
                                         ee::find_type_constructor_by_module_stamp (entities, module_stamp);

				     st::bind (symbol, b::NAMED_TYPE type_constructor, symbol_table );
				 };

			     m::PACKAGE_IN_API { module_stamp, an_api, ... }
				 =>
				 {   typechecked_package
					 =
					 ee::find_package_by_module_stamp (entities, module_stamp);

				     st::bind (
					 symbol,
					 b::NAMED_PACKAGE (
					     m::A_PACKAGE {
						 an_api,
						 typechecked_package,
						 var_home        => a::null_var_home,
						 inlining_info => inlining_information::NULL
					     }
					 ),
					 symbol_table
				     );
				 };

			     m::ENUM_CONSTRUCTOR_IN_API { a_datatype, ... }
				 =>
				 st::bind (symbol, b::NAMED_CONSTRUCTOR a_datatype, symbol_table);

			     _   =>
				 symbol_table;
		    esac;


		    fold_left  bind_element  st::empty  elements;
		};

	    str_to_dictionary _
                =>
                st::empty;
        end;


	fun api_to_symbol_table ( m::API { elements, ... } )
		=>
		{   fun bind_element ((symbol, spec), symbol_table)
			=
			case spec
			  
			    m::TYPE_CONSTRUCTOR_IN_API { type_constructor, ... }
				=>
				st::bind (symbol, b::NAMED_TYPE type_constructor, symbol_table);

			    m::PACKAGE_IN_API { an_api, slot, definition, module_stamp=>ev }
				=>
				st::bind (
				    symbol,
				    b::NAMED_PACKAGE (
					m::PACKAGE_API {
					    an_api,
					    module_path   => [ev]
					}
				    ),
				    symbol_table
				);

			    m::ENUM_CONSTRUCTOR_IN_API { a_datatype, ... }
				=>
				st::bind (symbol, b::NAMED_CONSTRUCTOR a_datatype, symbol_table);

			    _   =>
				symbol_table;
			esac;

		    fold_left  bind_element  st::empty  elements;
		};

	    api_to_symbol_table _
                =>
                bug "api_to_symbol_table";
        end;


	# Support for a hack to make sure that non-visible ConNamings don't
	# cause spurious blank lines when latex_print-ing apis.

	fun is_latex_printable_data_constructor_naming (t::ENUM_CONSTRUCTOR { representation=>a::EXCEPTION _, ... }, _)
		=>
		TRUE;

	    is_latex_printable_data_constructor_naming (con, symbol_table)
		=> 
		{   exception HIDDEN;

		    visible_dcon_type_constructor
			=
			{   type_constructor
                                =
                                tu::datatype_constructor_to_type_constructor con;

			    (   tu::type_constructor_equality
				(   lu::find_type_constructor_via_symbol_path
				    (   symbol_table,
					sp::SYMBOL_PATH [ ip::last (tu::type_constructor_path type_constructor) ],
					fn _ = raise exception HIDDEN
				    ),
				    type_constructor
				)
				except
                                    HIDDEN = FALSE
			    );
			};

		    (   *internals        or
			not visible_dcon_type_constructor
		    );
		};
        end;


	fun all_latex_printable_namings alist symbol_table
            = 
	    list::filter
                fn (name, b::NAMED_CONSTRUCTOR con)
                        =>
                        is_latex_printable_data_constructor_naming (con, symbol_table);

		    b   =>
                        TRUE;
                end
		alist;


	fun latex_print_lty stream ( /* lambdaty, depth */ )
            =
            pps stream "<lambdaty>";


	fun latex_print_typechecked_package_variable stream module_stamp
            = 
	    pps stream (module_path::module_stamp_to_string module_stamp);


	fun latex_print_module_path stream module_path
            = 
	    pps stream (module_path::module_path_to_string module_path);

	/*    prettyprintClosedSequence ppstream 
	      { front=(fn stream => pps stream "["),
	       sep=(fn stream => (pps stream ", "; break stream { spaces=0, indent_on_wrap=0 } )),
	       back=(fn stream => pps stream "]"),
	       style=INCONSISTENT,
	       pr=prettyprintMacroExpansionVariable }
	*/

	fun latex_print_type_constructor_expression  stream  (type_constructor_expression, depth)
            =
	    if (depth <= 0) 
                pps stream "<typeConstructorExpression>";
            else
		case type_constructor_expression

		    m::TYPE_VARIABLE_TYPE_CONSTRUCTOR ep
			=>
			{   pps stream "te::V:";
                            break stream { spaces=>1, indent_on_wrap=>1 };
			    latex_print_module_path stream ep;
			};

		    m::CONSTANT_TYPE_CONSTRUCTOR type_constructor
			=> 
			{   pps stream "te::C:";
                            break stream { spaces=>1, indent_on_wrap=>1 };
			    latex_print_type st::empty stream type_constructor;
			};

		    m::FORMAL_TYPE_CONSTRUCTOR type_constructor
			=>
			{   pps stream "te::FM:";
                            break stream { spaces=>1, indent_on_wrap=>1 };
			    latex_print_type st::empty stream type_constructor;
			};
		esac;
            fi;

	fun latex_print_package_name stream (str, symbol_table)
            =
	    {   inverse_path
                    =
		    case str
		      
			m::A_PACKAGE { typechecked_package, ... }
			    =>
			    typechecked_package.inverse_path;

			_ => bug "latex_print_package_name";
                    esac;


		fun get a
                    =
                    lu::find_package_via_symbol_path (
                        symbol_table,
                        a,
                        (fn _ =  raise exception symbol_table::UNBOUND)
                    );


		fun check str'
                    =
                    mu::eq_origin (str', str);


		my (syms, found)
                    =
                    find_path (inverse_path, check, get);
	    
                pps stream (     found   ??   sp::to_string (sp::SYMBOL_PATH syms)
			                 ::   "?" + (sp::to_string (sp::SYMBOL_PATH syms))
                           );
	    };

	fun latex_print_variable  stream
            =
	    {   (en_pp stream)
                    ->
                    { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, ... };


		fun latex_print_v ( v::ORDINARY_VARIABLE { path, var_home, var_type, inlining_info },
                                    symbol_table: symbol_table::Symbol_Table
                                  )
			=> 
			{   begin_horizontal_else_vertical_box 0;
			    pps (sp::to_string path);

			    if *internals
                                latex_print_value::latex_print_var_home stream var_home;
			    fi;

			    pps " : ";
                            latex_print_some_type  symbol_table  stream  *var_type;
			    end_box ();
		        };

		    latex_print_v (v::OVERLOADED_IDENTIFIER { name, alternatives, type_scheme=>t::TYPE_SCHEME { body, ... } }, symbol_table)
			=>
			{   begin_horizontal_else_vertical_box 0;
			    unparse_symbol stream (name);
                            pps " : ";
                            latex_print_some_type  symbol_table  stream  body; 
			    pps " as ";
			    unparse_sequence stream
			      { sep   =>  by prettyprint::break { spaces=>1, indent_on_wrap=>0 },
				pr    =>  (fn stream = fn { variant, ... } = latex_print_v (variant, symbol_table)),
				style =>  CONSISTENT
			      }
			      *alternatives;
			    end_box ();
			};

		    latex_print_v (v::ERRORVAR, _)
                        =>
                        pps "<ERRORVAR>";
                end;
	    
                latex_print_v;
	    };


	fun latex_print_con_naming stream
            =
	    {   (en_pp  stream)
                    ->
                    { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, ... };
                    

		fun latex_print_con (t::ENUM_CONSTRUCTOR { symbol, constructor_type, representation=>a::EXCEPTION _, ... }, symbol_table)
			=>
			{  begin_wrap_box 4;
			   pps "exception "; unparse_symbol  stream  symbol; 

			   if   (type_types::is_arrow_type  constructor_type)
			       
#			        pps " of ";
			        pps " ";
                                latex_print_some_type  symbol_table  stream  (type_types::domain  constructor_type);
			   fi;

			   end_box ();
			};

		    latex_print_con (con as t::ENUM_CONSTRUCTOR { symbol, constructor_type, ... }, symbol_table)
			=> 
			if *internals
			    begin_wrap_box 4;
			    pps "Constructor ";
			    unparse_symbol  stream  symbol;
			    pps " : ";
			    latex_print_some_type  symbol_table  stream  constructor_type;
			    end_box ();
			fi;
                end;
	    
                latex_print_con;
	    };

	fun latex_print_package stream (pkg, symbol_table, depth, index_entries)
            =
	    {   (en_pp stream)
                    ->
                    { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, break, newline };
                    
	    
                case pkg
		  
		     m::A_PACKAGE { an_api, typechecked_package as { typechecker_dictionary, ... }, ... }
			 =>
			 if *internals 

			     begin_horizontal_else_vertical_box 2;
			     pps "A_PACKAGE";
			     newline_indent stream 2;
			     begin_horizontal_else_vertical_box 0;
			     pps "an_api:";
			     break { spaces=>1, indent_on_wrap=>2 };
			     latex_print_api0 stream (an_api, symbol_table, depth - 1, THE typechecker_dictionary, index_entries);
			     newline();
			     pps "typechecked_package:";
			     break { spaces=>1, indent_on_wrap=>2 };
			     latex_print_generics_expansion stream (typechecked_package, symbol_table, depth - 1);
			     end_box ();
			     end_box ();
			 else
			     case an_api

				 m::API { name => THE symbol, ... }
				     =>
				     (   (   if (mu::apis_equal (
						    an_api,
						    lu::find_api_by_symbol (
							symbol_table,
							symbol,
							(fn _ = raise exception st::UNBOUND)
						    )
						 )
					       )
						  unparse_symbol stream symbol;
					     else unparse_symbol stream symbol;
						  pps "?";
					     fi
					 )
					 except
					     st::UNBOUND
					     =
					     {   unparse_symbol stream symbol;
						 pps "?";
					     }
				     );

				 m::API { name => NULL, ... }
				     => 
				     if (depth <= 1)
					 pps "<sig>";
				     else
                                         latex_print_api0 stream
					     (an_api, symbol_table, depth - 1, THE typechecker_dictionary, index_entries);
				     fi;

				 m::ERRONEOUS_API
				     =>
				     pps "<error sig>";
			     esac;
			 fi;


		    m::PACKAGE_API _   =>   pps   "<pkg api>";
		    m::ERRONEOUS_PACKAGE     =>   pps   "<error str>";
                esac;
	    }        

	also
	fun latex_print_elements (symbol_table, depth, typechecked_package_env_op, index_entries) stream elements
            =
	    {   fun pr first (symbol, spec)
                    =
		    case spec

			m::PACKAGE_IN_API { an_api, module_stamp, definition, slot }
			    =>
			    {   if (not first)
				    newline stream;
				fi;

				begin_horizontal_else_vertical_box stream;
				pps stream "package ";
				unparse_symbol stream symbol;
				pps stream " :";
				break stream { spaces=>1, indent_on_wrap=>2 };
				begin_horizontal_else_vertical_box stream;

				case typechecked_package_env_op

				     NULL
					 =>
					 latex_print_api0
					     stream
					     (   an_api,
						 symbol_table,
						 depth - 1,
						 NULL,
						 index_entries
					     );

				     THE eenv 
					 =>
					 {   my { typechecker_dictionary, ... }
						 =
						 case (ee::find_entry_by_module_stamp (eenv, module_stamp))

						     m::PACKAGE_ENTRY e
							 =>
							 e;

						     _ => bug "latex_print_elements: PACKAGE_ENTRY";
						 esac;

					     latex_print_api0 stream (an_api, symbol_table, depth - 1, THE typechecker_dictionary, index_entries);
					 };
				esac;

				if *internals

				     newline stream;
				     pps stream "module_stamp: ";
				     pps stream (module_path::module_stamp_to_string module_stamp);

				fi;

				pps stream ";";

				end_box stream;
				end_box stream;
			    };

			m::GENERIC_IN_API { a_generic_api, module_stamp, slot }
			    => 
			    {   if (not first)
				    newline stream;
				fi;

				begin_horizontal_else_vertical_box stream;
				pps stream "generic package ";
				unparse_symbol stream symbol; pps stream " :";
				break stream { spaces=>1, indent_on_wrap=>2 };
				begin_horizontal_else_vertical_box stream;
				latex_print_generic_api stream (a_generic_api, symbol_table, depth - 1, index_entries);

				if *internals
				    newline stream;
				    pps stream "module_stamp: ";
				    pps stream (module_path::module_stamp_to_string module_stamp);
				fi;

				pps stream ";";

				end_box  stream;
				end_box  stream;
			    };

			m::TYPE_CONSTRUCTOR_IN_API { type_constructor=>spec, module_stamp, is_a_replica, scope }
			    => 
			    {   if (not first)
				    newline stream;
				fi;

				begin_horizontal_else_vertical_box stream;

				case typechecked_package_env_op

				    NULL
					=>
					if   is_a_replica      latex_print_replicate_naming      stream (spec, symbol_table);
					else                   latex_print_type_constructor_bind stream (spec, symbol_table);
					fi;

				    THE eenv
					=>
					case (ee::find_entry_by_module_stamp (eenv, module_stamp))

					    m::TYPE_CONSTRUCTOR_ENTRY type_constructor
						=> 
						if is_a_replica

						     latex_print_replicate_naming    stream (type_constructor, symbol_table);
						else
						     latex_print_type_constructor_bind stream (type_constructor, symbol_table);
						fi;

					    m::ERRONEOUS_ENTRY
						=>
						pps stream "<ERRONEOUS_ENTRY>";

					    _   =>
						bug "latex_print_elements: TYPE_CONSTRUCTOR_ENTRY";
					esac;

				esac;

				if *internals
				    newline stream;
				    pps stream "module_stamp: ";
				    pps stream (module_path::module_stamp_to_string module_stamp);
				    newline stream;
				    pps stream "scope: ";
				    pps stream (int::to_string scope);
				fi;

				pps stream ";";

				end_box  stream;
			    };

			m::VALUE_IN_API { type, ... }
			    =>
			    {   if   first      ();
				else            newline stream;
				fi;

				begin_indented_wrap_box stream (pp::CURSOR_RELATIVE 4);
				pps stream /*2007-12-08CrT:"my "*/"";
				unparse_symbol stream symbol; pps stream " : ";
				latex_print_some_type  symbol_table  stream  (type);
				pps stream ";";

				# Add an appropriate TeX index entry for the value,
				# for our html manual.  We break the string up a
				# bit to avoid irritating Mythryl or HeVea with
				# apparent keywords in their respective syntaxes:
				#
				index_entries
				    :=
				    ( (string::cat [ "\\inde", "x[fu", "n]{", (backslash_latex_special_chars (symbol::name symbol)), "}\n" ])
					  !
					  (*index_entries)
				    );

				end_box stream;
			    };

			m::ENUM_CONSTRUCTOR_IN_API {

			    a_datatype => dcon as t::ENUM_CONSTRUCTOR {

					    representation => a::EXCEPTION _,
					    ...
					},
			    ...
			}
			    =>
			    {   if (not first)
				    newline stream;
				fi;

				latex_print_con_naming stream (dcon, symbol_table);
				pps stream ";";
			    };

			m::ENUM_CONSTRUCTOR_IN_API { a_datatype, ... }
			    => 
			    if *internals

				if (not first)
				    newline  stream;
				fi;

				latex_print_con_naming stream (a_datatype, symbol_table);
				pps stream ";";

			    fi;    #  Ordinary data constructor -- don't print. 
		    esac;
	    
                begin_horizontal_else_vertical_box stream;

		case elements

		    NIL          =>  ();

		    first ! rest =>  {   pr TRUE first;
					 apply (pr FALSE) rest;
				     };
                esac;

		end_box stream;
	    }

	also
	fun latex_print_api0 stream (an_api, symbol_table, depth, typechecked_package_env_op, index_entries)
            = 
	    {   my { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, break, newline }
                    =
                    en_pp stream;

		symbol_table = st::atop (
                                    case typechecked_package_env_op
				      
					NULL
					    =>
					    api_to_symbol_table an_api;

					THE typechecker_dictionary
					    =>
					    str_to_dictionary (an_api, typechecker_dictionary);
                                    esac,

				    symbol_table
                                );

		fun latex_print_constraints (variety, constraints:  List( m::Share_Spec ))
                    = 
		    {   begin_horizontal_else_vertical_box  0;

			ppvseq stream 0 ""
			    (fn stream =
                             fn paths =
				{ begin_wrap_box 2;
				  pps "sharing "; pps variety;
				  unparse_sequence stream 
				   { sep=>(fn stream =  { pps " ="; break { spaces=>1, indent_on_wrap=>0 }; }),
				     pr=>unparse_symbol_path,
				     style=>INCONSISTENT
                                   }
				  paths;
				  end_box ();
                                }
                            )
			    constraints;

		        end_box ();
                    };

		some_print = REF FALSE;
	    
                if (depth <= 0)
		    pps "<api>;";
		else
		    case an_api

			m::API { stamp, name, elements, type_sharing, package_sharing, ... }
			    =>
			    if *internals

				begin_horizontal_else_vertical_box 0;
				pps "BEGIN_API:";
				newline_indent stream 2;
				begin_horizontal_else_vertical_box 0;
				pps "stamp: "; pps (stamp::to_short_string stamp);
				newline();
				pps "name: ";

				case name

				     NULL  =>  pps "ANONYMOUS";
				     THE p =>  {   pps "NAMED ";
						   unparse_symbol stream p;
					       };
				esac;

				case elements

				     NIL => ();
				     _   => {   newline();
						pps "elements:";
						newline_indent stream 2;
						latex_print_elements (symbol_table, depth, typechecked_package_env_op, index_entries) stream elements;
					    };
				esac;

				case package_sharing

				     NIL => ();
				     _   => {   newline();
						pps "package_sharing:";
						newline_indent stream 2;
						latex_print_constraints("", package_sharing);
					    };
				esac;

				case type_sharing

				     NIL => ();
				     _   => {   newline();
						pps "tycsharing:";
						newline_indent stream 2;
						latex_print_constraints(/*2007-12-07CrT"type "*/"", type_sharing);
					    };
				esac;

				pps ";";
				end_box ();
				end_box ();

			    else
				#  not *internals 
				begin_horizontal_else_vertical_box 0;
				pps "api {";
				newline();		# 2008-01-03 CrT: Was:  break { spaces=>1, indent_on_wrap=>2 };
				begin_horizontal_else_vertical_box 0;
				pps "    ";

				case elements

				    NIL => ();
				    _   => {   latex_print_elements (symbol_table, depth, typechecked_package_env_op, index_entries) stream elements;
					       some_print := TRUE;
					   };
				esac;

				case package_sharing

				    NIL => ();
				    _   => {   if *some_print      newline();  fi;
					       latex_print_constraints("", package_sharing);
					       some_print := TRUE;
					   };
				esac;

				case type_sharing

				    NIL => ();
				    _   => {   if   *some_print      newline();  fi;
					       latex_print_constraints(/*2007-12-07CrT"type "*/"", type_sharing);
					       some_print := TRUE;
					   };
				esac;

				end_box ();

				if *some_print

				     newline();
#                                       break { spaces => 1,   indent_on_wrap => 0 };
				fi;

				pps "};";
				end_box ();
			    fi;

			m::ERRONEOUS_API
			    =>
			    pps "<error api>;";
		    esac;
                fi;
	    }


	also
	fun latex_print_generic_api stream (an_api, symbol_table, depth, index_entries)
	    =
	    {   my { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, break, newline }
                    =
                    en_pp stream;

		fun true_body_sig (orig as m::API { elements => [(symbol, m::PACKAGE_IN_API { an_api, ... } )],
						       ... 
                                                     }
                                )
			=>
			if (symbol::eq (symbol, result_id))    an_api; 
			else                                   orig;
                        fi;

		    true_body_sig orig
			=>
			orig;
                end;

	    
                if (depth <= 0)
                    
                    pps "<fctsig>";
		else
		    case an_api

			m::GENERIC_API { parameter_api, parameter_variable, parameter_symbol, body_api, ... }
			    => 
			    if *internals

				begin_horizontal_else_vertical_box 0;
				pps "GENERIC_API:";
				newline_indent stream 2;
				begin_horizontal_else_vertical_box 0;
				pps "psig: ";
				latex_print_api0 stream (parameter_api, symbol_table, depth - 1, NULL, index_entries);
				newline();
				pps "pvar: ";
				pps (module_path::module_stamp_to_string parameter_variable);
				newline();
				pps "psym: ";

				case parameter_symbol
				    NULL => pps "<anonymous>";
				    THE symbol => unparse_symbol stream symbol;
                                esac;

				newline();
				pps "bsig: ";
				latex_print_api0 stream (body_api, symbol_table, depth - 1, NULL, index_entries);
				end_box ();
				end_box ();
			    else
				begin_horizontal_else_vertical_box 0;
				pps "(";

				case parameter_symbol

				     THE x =>  pps (s::name x);
				     _     =>  pps "<parameter>";
				esac;

				pps ": ";
				latex_print_api0 stream (parameter_api, symbol_table, depth - 1, NULL, index_entries);
				pps ") :";
				break { spaces=>1, indent_on_wrap=>0 };
				latex_print_api0 stream (true_body_sig body_api, symbol_table, depth - 1, NULL, index_entries);
				end_box ();

			    fi;

			m::ERRONEOUS_GENERIC_API
			    =>
			    pps "<error fsig>";
		    esac;
                fi;
	    }


	also
	fun latex_print_generics_expansion stream (e, symbol_table, depth)
            =
	    {   e ->  { stamp, typechecker_dictionary, property_list, inverse_path, stub };

		my { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, break, newline }
                    =
                    en_pp  stream;
	    
                if (depth <= 1) 
                    pps "<package typechecked_package>";
		else
		    begin_horizontal_else_vertical_box 0;
		    pps "Typechecked_Package:";
		    newline_indent stream 2;
		    begin_horizontal_else_vertical_box 0;
		    pps "inverse_path: ";
		    pps (ip::to_string inverse_path);
		    newline();
		    pps "stamp: ";
		    pps (stamp::to_short_string stamp);
		    newline();
		    pps "typechecker_dictionary:";
		    newline_indent stream 2;
		    latex_print_typechecker_dictionary stream (typechecker_dictionary, symbol_table, depth - 1);
		    newline();
		    pps "lambdaty:";
		    newline_indent stream 2;
		    latex_print_lty stream ( /* ModulePropLists::packageMacroExpansionLambdatype e, depth - 1 */);
		    end_box ();
		    end_box ();
                fi;
	    }

	also
	fun latex_print_typechecked_generic stream (e, symbol_table, depth)
            =
	    {   e ->    { stamp, generic_closure, property_list, type_constructor_path, inverse_path, stub };

		(en_pp stream) ->   { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, break, newline };
	    
                if (depth <= 1) 
                    pps "<generic typechecked_package>";
		else
		    begin_horizontal_else_vertical_box 0;
		    pps "Typechecked_Generic:";
		    newline_indent stream 2;
		    begin_horizontal_else_vertical_box 0;
		    pps "inverse_path: ";
		    pps (ip::to_string inverse_path);
		    newline();
		    pps "stamp: ";
		    pps (stamp::to_short_string stamp);
		    newline();
		    pps "generic_closure:";
		    break { spaces=>1, indent_on_wrap=>2 };
		    latex_print_closure stream (generic_closure, depth - 1);
		    newline();
		    pps "lambdaty:";
		    break { spaces=>1, indent_on_wrap=>2 };
		    latex_print_lty stream ( /* ModulePropLists::genericMacroExpansionLty e, depth - 1 */ );
		    pps "type_constructor_path:";
		    break { spaces=>1, indent_on_wrap=>2 };
		    pps "--printing of Type_Constructor_Path not implemented yet--";
		    end_box ();
		    end_box ();
                fi;
	    }

	also
	fun latex_print_generic stream
            =
	    {   (en_pp stream)
                    ->
                    { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, break, newline };

		fun latex_print_f (m::GENERIC { a_generic_api,  typechecked_generic, ... }, symbol_table, depth, index_entries)
                    =>
		    if (depth <= 1) 
		        
                        pps "<generic package>";
		    else
			begin_horizontal_else_vertical_box 0;
			pps "a_generic_api:";
			newline_indent stream 2;
			latex_print_generic_api stream (a_generic_api, symbol_table, depth - 1, index_entries);
			newline();
			pps "typechecked_generic:";
			newline_indent stream 2;
			latex_print_typechecked_generic stream (typechecked_generic, symbol_table, depth - 1);
			end_box ();
                    fi;

		    latex_print_f (m::ERRONEOUS_GENERIC, _, _, _)
			=>
			pps "<error generic package>";
                end;
	    
                latex_print_f;
	    }

	also
	fun latex_print_type_constructor_bind stream (type_constructor, symbol_table)
            =
	    {   (en_pp stream)
                    ->
                    { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, break, newline };


		fun visible_dcons (type_constructor, dcons)
                    =
		    {   fun check_con (v::CONSTRUCTOR c) => c;
			    check_con _ => raise exception st::UNBOUND;
                        end;

			fun find ((actual as { name, representation, domain } ) ! rest)
                                =>
			        {   found
                                        = 
				        check_con (lu::find_value_by_symbol
						(symbol_table, name,
						 fn _ = raise exception st::UNBOUND));
			      
                                    # Test whether the datatypes of actual and
				    # found constructor agree:

				    case (tu::datatype_constructor_to_type_constructor found)
				      
					type_constructor1 as t::PRIMITIVE_TYPE_CONSTRUCTOR _
					    =>
					    # The expected form in packages 
					    if (tu::type_constructors_are_equal (type_constructor, type_constructor1))
						 found ! find rest;
					    else find rest;fi;

					t::TYPE_CONSTRUCTOR_BY_MODULE_PATH _
					    => 
					    /* the expected form in apis;
					       we won't check visibility [dbm] */
					    found ! find rest;

					d_found
					    =>
					    #  something's weird 
					    {   old_internals = *internals;

						internals := TRUE;
						begin_horizontal_else_vertical_box 0;
						pps "latex_print_type_constructor_bind failure: ";
						newline();
						latex_print_type symbol_table stream type_constructor;
						newline();
						latex_print_type symbol_table stream d_found;
						newline();
						end_box ();
						internals := old_internals;
						find rest;
					    };
                                    esac;
			        }
			        except
                                    st::UNBOUND =  find rest;

			    find []
                                =>
                                [];
                        end;

                        find  dcons;
		    };			# fun visible_dcons


		fun strip_poly (t::TYPE_SCHEME_TYPE { type_scheme => t::TYPE_SCHEME { body, ... }, ... } )
                        =>
                        body;

		    strip_poly type
                        =>
                        type;
                end;


		fun latex_print_dcon (t::ENUM_CONSTRUCTOR { symbol, constructor_type, ... } )
                    =
		    {   unparse_symbol  stream  symbol; 

			constructor_type =  strip_poly  constructor_type;

			if (bt::is_arrow_type  constructor_type)

#		            pps " of ";
			    pps " ";
			    latex_print_some_type  symbol_table  stream  (bt::domain  constructor_type);
			fi;
                    };
	    
                if *internals 
		    begin_horizontal_else_vertical_box 0;
		    pps /*2007-12-07CrT"type "*/"";
                    latex_print_type symbol_table stream type_constructor;
		    end_box ();
		else
		    case type_constructor

			t::PRIMITIVE_TYPE_CONSTRUCTOR { path, arity, eq, kind, ... }
			    =>
			    case (*eq, kind)

				 (t::EQ_ABSTRACT, _)
				     =>
				     #  Abstype 
				     {   begin_horizontal_else_vertical_box 0;
					 pps /*2007-12-07CrT"type "*/"";
					 unparse_symbol stream (ip::last path);
					 pps " ";
					 latex_print_formals stream arity; 
					 end_box ();
				     };

				 (_, t::DATATYPE { index, family => { members, ... }, ... } )
				     =>
				     #  ordinary enum 
				     {   my { constructor_list, ... }
					     =
					     vector::get (members, index);

					 visdcons = visible_dcons (type_constructor, constructor_list);

					 incomplete = length visdcons < length constructor_list;

					 begin_horizontal_else_vertical_box 0;
#					   pps "enum";
					 unparse_symbol stream (ip::last path);
					 pps " ";
					 latex_print_formals stream arity;

					 case visdcons

					      NIL
						  =>
						  pps " = ...";

					      first ! rest
						  =>
						  {   break { spaces=>1, indent_on_wrap=>2 };
						      begin_horizontal_else_vertical_box 0;
						      pps "= "; latex_print_dcon first;

						      apply (fn d = {   break { spaces=>1, indent_on_wrap=>0 };
                                                                        pps "| ";
                                                                        latex_print_dcon d;
                                                                    }
                                                            )
							    rest;

						      if incomplete
							   break { spaces=>1, indent_on_wrap=>0 };
							   pps "... ";
						      fi;

						      end_box ();
						  };
					 esac;
					 end_box ();
				     };

				 _   =>
				     {   begin_horizontal_else_vertical_box 0;

					 if (eq_types::is_equality_tycon type_constructor)
					      pps "eqtype "; 
					 else pps /*2007-12-07CrT"type "*/"";
                                         fi;

					 unparse_symbol stream (ip::last path);
					 pps " ";
					 latex_print_formals stream arity; 
					 end_box ();
				     };
			    esac;

			t::DEFINED_TYPE_CONSTRUCTOR { path, type_scheme => t::TYPE_SCHEME { arity, body }, ... }
			    =>
			    {   begin_wrap_box 2;
				pps /*2007-12-07CrT"type "*/""; 
				unparse_symbol stream (inverse_path::last path); 
				break { spaces=>1, indent_on_wrap=>0 };
				latex_print_formals stream arity; 
				pps " ="; 
				break { spaces=>1, indent_on_wrap=>0 };
				latex_print_some_type  symbol_table  stream  body;
				end_box ();
			    };

			type_constructor
			    =>
			    {   pps "strange type_constructor: ";
				latex_print_type symbol_table stream type_constructor;
			    };
		    esac;
                fi;
	    }                          # fun  latex_print_type_constructor_bind stream

	also
	fun latex_print_replicate_naming
                stream
	        (   t::DEFINED_TYPE_CONSTRUCTOR {
                        type_scheme => t::TYPE_SCHEME {
                                           body => t::CONSTRUCTOR_TYPE (right_type_constructor, _),
                                           ...
                                       },
                        path,
                        ...
                    },
                    symbol_table
                )
		=>
		{   (en_pp stream)
			->
			{ begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, break, newline };

		    begin_wrap_box 2;
#		    pps "enum";                                      break { spaces => 1, indent_on_wrap => 0 };
		    unparse_symbol stream (ip::last path);
		    pps " =";                                        break { spaces => 1, indent_on_wrap => 0 };
#		    pps "enum";                                      break { spaces => 1, indent_on_wrap => 0 };
		    latex_print_type symbol_table stream right_type_constructor;
		    end_box ();
		};

	    latex_print_replicate_naming _ _
		=>
		error_message::impossible "latex_print_replicate_naming";
        end 

	also
	fun latex_print_typechecked_package stream (typechecked_package, symbol_table, depth)
            =
	    case typechecked_package
	      
		m::TYPE_CONSTRUCTOR_ENTRY type_constructor
		    =>
		    latex_print_type      symbol_table stream type_constructor;

		m::PACKAGE_ENTRY typechecked_package
		    =>
		    latex_print_generics_expansion stream (typechecked_package, symbol_table, depth - 1);

		m::GENERIC_ENTRY typechecked_generic
		    =>
		    latex_print_typechecked_generic   stream (typechecked_generic, symbol_table, depth - 1);

		m::ERRONEOUS_ENTRY
		    =>
		    pps                        stream "ERRONEOUS_ENTRY";
            esac


	also
	fun latex_print_typechecker_dictionary stream (typechecker_dictionary, symbol_table, depth)
            =
	    if (depth <= 1) 
	        
                pps stream "<typechecker_dictionary>";
	    else
                (ppvseq
                    stream 2 ""
		    (fn stream =
                     fn (module_stamp, typechecked_package)
                        =
			{   (en_pp stream)
                                ->
                                { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, break, newline };
				 
			    begin_horizontal_else_vertical_box 2;
			    pps (module_path::module_stamp_to_string module_stamp);
			    pps ":";
			    newline_indent stream 2;
			    latex_print_typechecked_package stream (typechecked_package, symbol_table, depth - 1);
			    newline();
			    end_box ();
			}
                    )
		    (ee::to_list typechecker_dictionary));
            fi

	also
	fun latex_print_module_declaration stream (module_declaration, depth)
            =
	    if (depth <= 0)
                pps stream "<module_declaration>";
	    else
		case module_declaration

		    m::TYPE_CONSTRUCTOR_DECLARATION ( module_stamp, type_constructor_expression )
			=>
			{   pps stream "ed::T: ";
			    latex_print_typechecked_package_variable stream module_stamp;
			    break stream { spaces=>1, indent_on_wrap=>1 };
			    latex_print_type_constructor_expression stream (type_constructor_expression, depth - 1);
			};

		    m::PACKAGE_DECLARATION (module_stamp, package_expression, symbol)
			=>
			{   pps stream "ed::S: ";
			    latex_print_typechecked_package_variable stream module_stamp;
			    break stream { spaces=>1, indent_on_wrap=>1 };
			    latex_print_package_expression stream (package_expression, depth - 1);
			    break stream { spaces=>1, indent_on_wrap=>1 };
			    unparse_symbol stream symbol;
			};

		    m::GENERIC_DECLARATION (module_stamp, generic_expression)
			=>
			{   pps stream "ed::F: ";
			    latex_print_typechecked_package_variable stream module_stamp;
			    break stream { spaces=>1, indent_on_wrap=>1 };
			    latex_print_generic_expression stream (generic_expression, depth - 1);
			};

		    m::SEQUENTIAL_DECLARATIONS typechecked_package_decs
			=>
			ppvseq stream 0 ""
			    (fn stream =
			     fn module_declaration =
				latex_print_module_declaration stream (module_declaration, depth)
			    )
			    typechecked_package_decs;

		    m::LOCAL_DECLARATION (typechecked_package_dec_l, typechecked_package_dec_b)
			=>
			pps stream "ed::L:";

		    m::ERRONEOUS_ENTRY_DECLARATION
			=>
			pps stream "ed::ER:";

		    m::EMPTY_GENERIC_EVALUATION_DECLARATION
			=>
			pps stream "ed::EM:";
		esac;
            fi

	also
	fun latex_print_package_expression stream (package_expression, depth)
            =
	    if (depth <= 0)
                pps stream "<packageexpression>";
            else
		case package_expression

		    m::VARIABLE_PACKAGE ep
			=>
			{   pps stream "st::V:";
			    break stream { spaces=>1, indent_on_wrap=>1 }; 
			    latex_print_module_path stream ep;
			};

		    m::CONSTANT_PACKAGE { stamp, inverse_path, ... }
			=>
			{   pps stream "st::C:"; break stream { spaces=>1, indent_on_wrap=>1 };
			    unparse_inverse_path stream inverse_path;
			};

		    m::PACKAGE { stamp, module_declaration }
			=>
			{   pps stream "st::S:";
			    break stream { spaces=>1, indent_on_wrap=>1 };
			    latex_print_module_declaration stream (module_declaration, depth - 1);
			};

		    m::APPLY (generic_expression, package_expression)
			=>
			{   begin_horizontal_else_vertical_box stream;
			    pps stream "st::AP:"; break stream { spaces=>1, indent_on_wrap=>1 };
			    begin_horizontal_else_vertical_box stream;
			    pps stream "fct:"; latex_print_generic_expression stream (generic_expression, depth - 1);
			    break stream { spaces=>1, indent_on_wrap=>0 };
			    pps stream "arg:"; latex_print_package_expression stream (package_expression, depth - 1);
			    end_box stream;
			    end_box stream;
			};

		    m::PACKAGE_LET { declaration => module_declaration, expression => package_expression }
			=> 
			{   begin_horizontal_else_vertical_box stream;
			    pps stream "st::L:"; break stream { spaces=>1, indent_on_wrap=>1 };
			    begin_horizontal_else_vertical_box stream;
			    pps stream "stipulate:"; latex_print_module_declaration stream (module_declaration, depth - 1);
			    break stream { spaces=>1, indent_on_wrap=>0 };
			    pps stream "herein:"; latex_print_package_expression stream (package_expression, depth - 1);
			    end_box stream;
			    end_box stream;
			};

		    m::ABSTRACT_PACKAGE (an_api, package_expression)
			=> 
			{   begin_horizontal_else_vertical_box stream;
			    pps stream "st::AB:"; break stream { spaces=>1, indent_on_wrap=>1 };
			    begin_horizontal_else_vertical_box stream;
			    pps stream "an_api: <omitted>"; 
			    break stream { spaces=>1, indent_on_wrap=>0 };
			    pps stream "sexp:"; latex_print_package_expression stream (package_expression, depth - 1);
			    end_box stream;
			    end_box stream;
			};

		    m::COERCED_PACKAGE { boundvar, raw, coercion }
			=> 
			{   begin_horizontal_else_vertical_box stream;
			    pps stream "st::CO:"; break stream { spaces=>1, indent_on_wrap=>1 };
			    begin_horizontal_else_vertical_box stream;
			    latex_print_typechecked_package_variable stream boundvar; break stream { spaces=>1, indent_on_wrap=>1 };
			    pps stream "src:"; latex_print_package_expression stream (raw, depth - 1);
			    break stream { spaces=>1, indent_on_wrap=>0 };
			    pps stream "tgt:"; latex_print_package_expression stream (coercion, depth - 1);
			    end_box stream;
			    end_box stream;
			};

		    m::FORMAL_PACKAGE (an_api)
			=>
			pps stream "st::FM:";
		esac;
            fi

	also
	fun latex_print_generic_expression stream (generic_expression, depth)
            =
	    if (depth <= 0)
                pps stream "<genericexpression>";
            else
		case generic_expression

		    m::VARIABLE_GENERIC ep
			=>
			{   pps stream "fe::V:";
			    latex_print_module_path stream ep;
			};

		    m::CONSTANT_GENERIC { inverse_path, ... }
			=>
			{   pps stream "fe::C:";
			    unparse_inverse_path stream inverse_path;
			};

		    m::LAMBDA_TP { parameter, body, ... }
			=>
			{   begin_horizontal_else_vertical_box stream;
			    pps stream "fe::LP:"; break stream { spaces=>1, indent_on_wrap=>1 };
			    begin_horizontal_else_vertical_box stream;
			    pps stream "par:"; latex_print_typechecked_package_variable stream parameter;
			    break stream { spaces=>1, indent_on_wrap=>0 };
			    pps stream "bod:"; latex_print_package_expression stream (body, depth - 1);
			    end_box stream;
			    end_box stream;
			};    

		    m::LAMBDA { parameter, body }
			=>
			{   begin_horizontal_else_vertical_box stream;
			    pps stream "fe::L:"; break stream { spaces=>1, indent_on_wrap=>1 };
			    begin_horizontal_else_vertical_box stream;
			    pps stream "par:"; latex_print_typechecked_package_variable stream parameter;
			    break stream { spaces=>1, indent_on_wrap=>0 };
			    pps stream "bod:"; latex_print_package_expression stream (body, depth - 1);
			    end_box stream;
			    end_box stream;
			};    

		    m::LET_GENERIC (module_declaration, generic_expression)
			=> 
			{   begin_horizontal_else_vertical_box stream;
			    pps stream "fe::LT:"; break stream { spaces=>1, indent_on_wrap=>1 };
			    begin_horizontal_else_vertical_box stream;
			    pps stream "stipulate:"; latex_print_module_declaration stream (module_declaration, depth - 1);
			    break stream { spaces=>1, indent_on_wrap=>0 };
			    pps stream "herein:"; latex_print_generic_expression stream (generic_expression, depth - 1);
			    end_box stream;
			    end_box stream;
			};
		esac;
            fi    

	/*
	also prettyprintBodyExpression stream (bodyExpression, depth) =
	    if depth <= 0 then pps stream "<bodyExpression>" else
	    case bodyExpression
	      of m::FLEX an_api => pps stream "be::F:"
	       | m::OPAQ (an_api, packageexpression) =>
		   (begin_horizontal_else_vertical_box stream;
		     pps stream "be::O:"; break stream { spaces=1, indent_on_wrap=1 };
		     prettyprintPackageexpression stream (packageexpression, depth - 1);
		    end_box stream)
	       | m::TNSP (an_api, packageexpression) =>
		   (begin_horizontal_else_vertical_box stream;
		     pps stream "be::T:"; break stream { spaces=1, indent_on_wrap=1 };
		     prettyprintPackageexpression stream (packageexpression, depth - 1);
		    end_box stream)

	*/

	also
	fun latex_print_closure stream (m::GENERIC_CLOSURE {   parameter_module_stamp    => parameter,
                                                             body_package_expression => body,
                                                             typechecker_dictionary       => symbol_table
                                                         },
                                                         depth
                                      )
	    =
	    {   (en_pp stream)
                    ->
                    { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, newline, break, ... };
	    
                begin_horizontal_else_vertical_box 0;
		pps "CL:"; break { spaces=>1, indent_on_wrap=>1 };
		begin_horizontal_else_vertical_box 0;
		pps "parameter: ";
                latex_print_typechecked_package_variable stream parameter;
                newline();
		pps "body: ";
                latex_print_package_expression stream (body, depth - 1);
                newline();
		pps "dictionary: ";
                latex_print_typechecker_dictionary stream (symbol_table, st::empty, depth - 1);
		end_box ();
		end_box ();
	    }

	#  Assumes no newline is needed before latex-printing: 
	also
	fun latex_print_naming stream (name, naming: b::Symbol_Table_Entry, symbol_table: st::Symbol_Table, depth: Int, index_entries)
            =
	    case naming

		b::NAMED_VARIABLE var
		    =>
		    {    pps stream /*2007-12-08CrT:"my "*/"";
			 latex_print_variable stream (var, symbol_table);
		    };

		b::NAMED_CONSTRUCTOR con
		    =>
		    latex_print_con_naming stream (con, symbol_table);

		b::NAMED_TYPE type_constructor
		    =>
		    latex_print_type_constructor_bind stream (type_constructor, symbol_table);

		b::NAMED_API an_api
		    =>
		    {   (en_pp stream)
			    ->
			    { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, break, ... };

			begin_horizontal_else_vertical_box 0;
			pps "api ";
			unparse_symbol stream name;
			pps " =";
			break { spaces=>1, indent_on_wrap=>2 };
			latex_print_api0 stream (an_api, symbol_table, depth, NULL, index_entries);
			end_box ();
		    };

		b::NAMED_GENERIC_API fs
		    =>
		    {   my { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, ... } = en_pp stream;

			begin_horizontal_else_vertical_box 2;
			pps "funsig ";
			unparse_symbol stream name; 
			latex_print_generic_api stream (fs, symbol_table, depth, index_entries);
			end_box ();
		    };

		b::NAMED_PACKAGE str
		    =>
		    {   (en_pp stream)
			    ->
			    { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, break, ... };

			begin_horizontal_else_vertical_box 0;
			pps "packageX ";
			unparse_symbol stream name;
			pps " :";
			break { spaces=>1, indent_on_wrap=>2 };
			latex_print_package stream (str, symbol_table, depth, index_entries);
			end_box ();
		    };

		b::NAMED_GENERIC fct
		    =>
		    {   (en_pp stream)
			    ->
			    { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, ... };

			begin_horizontal_else_vertical_box 0;
			pps "generic package ";
			unparse_symbol stream name;
			pps " : <sig>";  #  David B MacQueen -- should print the api  XXX BUGGO FIXME
			end_box ();
		    };

		b::NAMED_FIXITY fixity
		    =>
		    {   pps stream (fixity::fixity_to_string fixity);
			unparse_symbol stream name;
		    };
            esac

	# latex_print_dictionary: latex-print a symbol table
        # in the context of the top-level symbol table.
	# The symbol table must either be for a api or be absolute (i.e.
	# all types and packages have been interpreted)

	# Note: I made a preliminary pass over namings to remove
	# invisible con_namings -- Konrad.
	# and invisible packages too -- PC

	also
	fun latex_print_dictionary stream (symbol_table, topenv, depth, boundsyms, index_entries)
            =
	    {   namings
                    = 
		    case boundsyms
		      
			NULL  =>  st::to_sorted_list  symbol_table;

			THE l =>  fold_right
				      (fn (x, bs)
					  =
					  (x, st::get (symbol_table, x)) ! bs
					  except
					      st::UNBOUND = bs
				      )
				      []
				      l;
                    esac;

		pp_env =  symbol_table::atop (symbol_table, topenv);

                unparse_sequence stream
		  {   sep   => newline,
		      style => CONSISTENT,
		      pr    => (fn stream =
                                fn (name, naming)
                                    =
                                    latex_print_naming stream (name, naming, pp_env, depth, index_entries)
                               )
                  }
		  (all_latex_printable_namings namings pp_env);
	    };

	fun latex_print_open stream (path, pkg, symbol_table, depth, index_entries)
            =
	    {   my  { begin_horizontal_else_vertical_box, begin_wrap_box, end_box, pps, break, newline }
                    =
                    en_pp stream;

                begin_horizontal_else_vertical_box 0;
		begin_horizontal_else_vertical_box 2;
		pps "including ";
		unparse_symbol_path stream path;

		if   (depth >= 1)
                    
		     case pkg
		       
			 m::A_PACKAGE { an_api, typechecked_package as { typechecker_dictionary, ... }, ... }
			     =>
			     case an_api

				 m::API { elements => [], ... }
				     =>
				     ();

				 m::API { elements, ... }
				     => 
				     {   newline ();		       
					 begin_horizontal_else_vertical_box 0;

					 latex_print_elements
					    (   st::atop (api_to_symbol_table an_api, symbol_table),
						depth,
						THE typechecker_dictionary,
						index_entries
					    )
					    stream
					    elements;

					 end_box ();
				     };

				 m::ERRONEOUS_API
				     =>
				     ();
			     esac;

			 m::ERRONEOUS_PACKAGE => ();
			 m::PACKAGE_API _ => bug "latex_print_open";
                     esac;
                fi;
		end_box ();
		newline ();
		end_box ();
	    };


	fun latex_print_api  stream (an_api, symbol_table, depth, index_entries)
            = 
	    latex_print_api0 stream (an_api, symbol_table, depth, NULL, index_entries);

    end;					# stipulate

};						# package latex_print_package_language 








##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## Copyright 1996 by AT&T Bell Laboratories 
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
