#
# The new unpickler (based on the new generic unpickling facility).
#
# The unpickler embeds a "Module_Tree" into the unpickled dictionary.
# The Module_Tree allows for very rapid construction of modmaps so that
# modmaps do not have to be stored permanently but can be built on-demand.
# (Permanently stored modmaps incur space problems: one has to be careful
# that they don't hang on to namings that no longer exist, and because
# of sharing there can be significant overlap--and space overhead--in what
# each such map points to.  Modtrees do not have these problems.)
#
# The embedding of modtrees into symbol tables follows the example
# of the control-flow in the original "cmstatenv.sml" module.  This means
# that not all possible branches of the dictionary data package are
# explored when building modmaps.  I dearly hope that the original code
# was correct in its assumptions...
#
# March 2000, Matthias Blume

# Compiled by:
#     src/lib/compiler/core.make6



api Unpickle_Module {

    Unpickling_Context
        =
        Null_Or ((Int, symbol::Symbol)) -> module_map::Module_Map;


    unpickle_symboltable
        :
        Unpickling_Context
	->
        ( picklehash::Picklehash,
          unt8_vector::Vector
        )
	->
        symbol_table::Symbol_Table;



    unpickle_highcode
	:
	unt8_vector::Vector
	->
	Null_Or( anormal::Program );



    # 'make_unpicklers' is intended to be used by Make7's
    # library-freezing mechanism.
    #
    # The symbol table unpickler resulting from "make_unpicklers"
    # cannot be used for "original" symbol tables that come out of
    # the typechecker. For those, continue to use "unpickle_symboltable".

    make_unpicklers
        :
        { session:    unpickle_utilities::Session,
	  stringlist: unpickle_utilities::Reader(  List(  String ) )
        }
        ->
        Unpickling_Context
        ->
        { inlining_table:  unpickle_utilities::Reader( inlining_table::Dictionary ),
	  symbol_table:    unpickle_utilities::Reader( symbol_table::Symbol_Table ),
	  symbol:          unpickle_utilities::Reader( symbol::Symbol ),
	  symbollist:      unpickle_utilities::Reader(  List( symbol::Symbol ) )
        };
};



package unpickle_module: (weak)  Unpickle_Module				# Unpickle_Module	is from   src/lib/compiler/frontend/semantic/pickle/unpickle-module.pkg

{

    Unpickling_Context
        =
        Null_Or ((Int, symbol::Symbol)) -> module_map::Module_Map;


    package a  =  var_home;			# var_home			is from   src/lib/compiler/frontend/typecheck-stuff/basics/var-home.pkg
    package di =  debruijn_index;		# debruijn_index		is from   src/lib/compiler/frontend/typechecker/basics/de-bruijn-index.pkg
    package lt =  highcode_type;		# highcode_type			is from   src/lib/compiler/backend/upper/highcode/highcode-type.pkg
    package lk =  highcode_guts;		# highcode_guts			is from   src/lib/compiler/backend/upper/highcode/highcode-guts.pkg
    package f  =  anormal;			# anormal			is from   src/lib/compiler/backend/upper/anormal/anormal.pkg
    package t  =  types;			# types				is from   src/lib/compiler/frontend/typecheck-stuff/types/types.pkg
    package sp =  symbol_path;			# symbol_path			is from   src/lib/compiler/frontend/typecheck-stuff/basics/symbol-path.pkg
    package ip =  inverse_path;			# inverse_path			is from   src/lib/compiler/frontend/typecheck-stuff/basics/symbol-path.pkg
    package mi =  module_map;			# module_map			is from   src/lib/compiler/frontend/typecheck-stuff/modules/module-map.pkg
    package ii =  inlining_info;		# inlining_info			is from   src/lib/compiler/frontend/semantic/basics/inlining-info.pkg
    package uu =  unpickle_utilities;		# unpickle_utilities		is from   src/lib/compiler/src/library/unpickle-utilities.pkg
    package p  =  highcode_primitive_op;	# highcode_primitive_op		is from   src/lib/compiler/backend/upper/highcode/highcode-primitive-op.pkg
    package m  =  module;			# module			is from   src/lib/compiler/frontend/typecheck-stuff/modules/module.pkg

    package pt =  highcode_data_representation;	# highcode_data_representation	is from   src/lib/compiler/backend/upper/highcode/highcode-data-representation.pkg
    package v  =  variables_and_constructors;	# variables_and_constructors	is from   src/lib/compiler/frontend/typecheck-stuff/deep-syntax/variables-and-constructors.pkg
    package ed =  module_path::module_stamp_map;# module_path			is from   src/lib/compiler/frontend/typecheck-stuff/modules/module-path.pkg
    package b  =  symbol_table_entry;		# symbol_table_entry		is from   src/lib/compiler/frontend/typecheck-stuff/symbol-table/symbol-table-entry.pkg


    exception FORMAT = uu::FORMAT;



    # The order of the entries in the following tables
    # must be coordinated with pickmod!

    primop_table
        =
	#[p::MKETAG,
	  p::WRAP,
	  p::UNWRAP,
	  p::SUBSCRIPT,
	  p::SUBSCRIPTV,
	  p::INLSUBSCRIPT,
	  p::INLSUBSCRIPTV,
	  p::INLMKARRAY,

	  p::PTREQL,
	  p::PTRNEQ,
	  p::POLYEQL,
	  p::POLYNEQ,
	  p::BOXED,
	  p::UNBOXED,
	  p::LENGTH,
	  p::CHUNKLENGTH,
	  p::CAST,
	  p::GETRUNVEC,
	  p::MARKEXN,
	  p::GETHANDLER,
	  p::SETHANDLER,
	  p::GET_CURRENT_THREAD_REGISTER,
	  p::SET_CURRENT_THREAD_REGISTER,
	  p::GETPSEUDO,
	  p::SETPSEUDO,
	  p::SETMARK,
	  p::DISPOSE,
	  p::MAKEREF,
	  p::CALLCC,
	  p::CAPTURE,
	  p::THROW,
	  p::DEREF,
	  p::ASSIGN,
	  p::UPDATE,
	  p::INLUPDATE,
	  p::BOXED_SET,
	  p::UNBOXED_SET,

	  p::GETTAG,
	  p::MAKE_SPECIAL,
	  p::SETSPECIAL,
	  p::GETSPECIAL,
	  p::USELVAR,
	  p::DEFLVAR,
	  p::INLNOT,
	  p::INLCOMPOSE,
	  p::INLBEFORE,
	  p::INLINE_ARRAY,
	  p::INLINE_VECTOR,
	  p::ISOLATE,
	  p::WCAST,
	  p::NEW_ARRAY0,
	  p::GET_SEQ_DATA,
	  p::SUBSCRIPT_REC,
	  p::SUBSCRIPT_RAW64,
	  p::UNBOXEDASSIGN,
	  p::RAW_CCALL NULL,
	  p::INLIGNORE,
	  p::INLIDENTITY,
	  p::CVT64
        ];


    compare_op_table
        =
        #[p::GT, p::GE, p::LT, p::LE, p::LEU, p::LTU, p::GEU, p::GTU, p::EQL, p::NEQ];


    arithmetic_op_table
        =
	#[p::ADD, p::SUBTRACT, p::MULTIPLY, p::DIVIDE, p::NEGATE, p::ABS, p::LSHIFT, p::RSHIFT, p::RSHIFTL,
	  p::BITWISEAND, p::BITWISEOR, p::BITWISEXOR, p::BITWISENOT, p::FSQRT, p::FSIN, p::FCOS, p::FTAN,
	  p::REM, p::DIV, p::MOD];


    equality_property_table
        =
	#[ t::YES,
           t::NO,
           t::INDETERMINATE,
           t::CHUNK,
           t::DATA,
           t::EQ_ABSTRACT,
           t::UNDEF
        ];


    c_type_table
        =
	#[ctypes::C_VOID,
	  ctypes::C_FLOAT,
	  ctypes::C_DOUBLE,
	  ctypes::C_LONG_DOUBLE,
	  ctypes::C_UNSIGNED ctypes::I_CHAR,
	  ctypes::C_UNSIGNED ctypes::I_SHORT,
	  ctypes::C_UNSIGNED ctypes::I_INT,
	  ctypes::C_UNSIGNED ctypes::I_LONG,
	  ctypes::C_UNSIGNED ctypes::I_LONG_LONG,
	  ctypes::C_SIGNED ctypes::I_CHAR,
	  ctypes::C_SIGNED ctypes::I_SHORT,
	  ctypes::C_SIGNED ctypes::I_INT,
	  ctypes::C_SIGNED ctypes::I_LONG,
	  ctypes::C_SIGNED ctypes::I_LONG_LONG,
	  ctypes::C_PTR];


    fun &&& c (x, t)
        =
        (c x, t);


    fun branch l
        =
        { fun loop ([], [x]) => x;
	       loop ([], l)   => m::MODTREE_BRANCH l;

	       loop (m::MODTREE_BRANCH  [] ! t, l)   =>   loop (t, l);
	       loop (m::MODTREE_BRANCH [x] ! t, l)   =>   loop (t, x ! l); #  never occurs! 
	       loop (x ! t, l)                      =>   loop (t, x ! l); end;
	
	    loop (l, []);
	};


    notree
        =
        m::MODTREE_BRANCH [];


    fun make_shared_stuff (session, highcode_variable)
        =
        {   fun share m f
                =
                uu::share session m f;


	    fun nonshare f
                =
                uu::nonshare session f;


	    int  =  uu::read_int   session;
	    bool =  uu::read_bool  session;

	    fun list   m r = uu::read_list   session m r;
	    fun option m r = uu::read_option session m r;

	    string = uu::read_string session;
	    symbol = unpickle_symbol_picklehash::read_symbol (session, string);


	    # These maps will all acquire different
            # types by being used in different contexts...

	    acc_m = uu::make_map ();
	    cr_m  = uu::make_map ();

	    cs_m               =  uu::make_map ();
	    nk_m               =  uu::make_map ();
	    po_m               =  uu::make_map ();
	    bool_list_m        =  uu::make_map ();
	    bool_option_m      =  uu::make_map ();
	    tkind_m            =  uu::make_map ();
	    tkind_list_m       =  uu::make_map ();
	    ctype_m            =  uu::make_map ();
	    ctype_list_m       =  uu::make_map ();
	    ccalltype_list_m   =  uu::make_map ();
	    ccalltype_option_m =  uu::make_map ();
	    cci_m              =  uu::make_map ();
	    io_m               =  uu::make_map ();

	    boollist   =  list bool_list_m bool;
	    booloption =  option bool_option_m bool;
	    intoption  =  option io_m int;

	    pid =  unpickle_symbol_picklehash::read_picklehash (session, string);


	    fun var_home ()
                =
                {   fun a 'A' =>   highcode_variable (int ());
			a 'B' =>   a::EXTERN (pid ());
			a 'C' =>   a::PATH (var_home (), int ());
			a 'D' =>   a::NO_VAR_HOME;
			a _   =>   raise exception FORMAT;
		    end;
		
		    share  acc_m  a;
		};


	    fun datatype_constructor_representation ()
                =
                {   fun cr 'A' =>   a::UNTAGGED;
			cr 'B' =>   a::TAGGED (int ());
			cr 'C' =>   a::TRANSPARENT;
			cr 'D' =>   a::CONSTANT (int ());
			cr 'E' =>   a::REF_REP;
			cr 'F' =>   a::EXCEPTION (var_home ());
			cr 'G' =>   a::LISTCONS;
			cr 'H' =>   a::LISTNIL;
			cr 'I' =>   a::SUSP NULL;
			cr 'J' =>   a::SUSP (THE (var_home (), var_home ()));
			cr _   =>   raise exception FORMAT;
                    end;
		
		    share cr_m cr;
		};


	    fun constructor_signature ()
                =
	        share  cs_m  cs
                where
                    fun cs 'S'   =>   a::CONSTRUCTOR_SIGNATURE (int (), int ());
		        cs 'N'   =>   a::NULLARY_CONSTRUCTOR;
		        cs _     =>   raise exception FORMAT;
                    end;
		end;


	    fun type_kind ()
                =
                {   fun tk 'A'   =>   lt::tkc_mono;
			tk 'B'   =>   lt::tkc_box;
			tk 'C'   =>   lt::tkc_seq (tkindlist ());
			tk 'D'   =>   lt::tkc_fun (tkindlist (), type_kind ());
			tk _     =>   raise exception FORMAT;
                    end;
		
		    share  tkind_m  tk;
		}


	    also
	    fun tkindlist ()
                =
               list  tkind_list_m  type_kind  ();


	    fun numkind ()
                =
                {   fun nk 'A'   =>   p::INT   (int ());
			nk 'B'   =>   p::UINT  (int ());
			nk 'C'   =>   p::FLOAT (int ());
			nk _     =>   raise exception FORMAT;
                    end;
		
		    share nk_m nk;
		};


	    fun arithop ()
                =
                {   fun ao c
                        =
                        vector::get (arithmetic_op_table, char::to_int c)
			except
                            (exceptions::SUBSCRIPT|exceptions::INDEX_OUT_OF_BOUNDS) = raise exception FORMAT;
		
		    nonshare ao;
		};


	    fun cmpop ()
                =
                {   fun co c
                        =
                        vector::get (compare_op_table, char::to_int c)
			except
                            (exceptions::SUBSCRIPT|exceptions::INDEX_OUT_OF_BOUNDS) =  raise exception FORMAT;
		
		    nonshare  co;
		};


	    fun ctype ()
                =
                {   fun ct '\020' =>   ctypes::C_ARRAY (ctype (), int ());
			ct '\021' =>   ctypes::C_STRUCT (ctypelist ());
			ct '\022' =>   ctypes::C_UNION  (ctypelist ());
			ct c      =>   vector::get (c_type_table, char::to_int c)
				       except
                                           (exceptions::SUBSCRIPT|exceptions::INDEX_OUT_OF_BOUNDS) =  raise exception FORMAT;
                    end;
		
		    share  ctype_m  ct;
		}


	    also
	    fun ctypelist ()
                =
                list  ctype_list_m  ctype  ();


	    fun ccalltype ()
                =
                {   fun ct '\000' =>   p::CCI32;
			ct '\001' =>   p::CCI64;
			ct '\002' =>   p::CCR64;
			ct '\003' =>   p::CCML;
			ct _      =>   raise exception FORMAT;
                    end;
		
                    nonshare  ct;
		}

	    also
	    fun ccalltypelist ()
                =
                list  ccalltype_list_m  ccalltype  ()


	    also
	    fun ccalltypeoption ()
                =
                option  ccalltype_option_m  ccalltype  ();


	    fun ccall_info ()
                =
                {   fun cp 'C'
                        =>
			{   c_prototype => {   calling_convention => string (),
				             return_type        => ctype (),
				             parameter_types    => ctypelist ()
                                         },
			    ml_argument_representations => ccalltypelist (),
			    ml_result_representation    => ccalltypeoption (),
			    is_reentrant               => bool ()
                        };

		        cp _   =>   raise exception FORMAT;
                    end;
		
		    share  cci_m  cp;
		};


	    fun primitive_operation ()
                =
                {   fun po '\100' =>   p::ARITH { oper => arithop (), overflow => bool (), kind => numkind () };
			po '\101' =>   p::CMP   { oper => cmpop (),                       kind => numkind () };
			po '\102' =>   p::TEST   (int (), int ());
			po '\103' =>   p::TESTU  (int (), int ());
			po '\104' =>   p::TRUNC  (int (), int ());
			po '\105' =>   p::EXTEND (int (), int ());
			po '\106' =>   p::COPY   (int (), int ());
			po '\107' =>   p::INLLSHIFT  (numkind ());
			po '\108' =>   p::INLRSHIFT  (numkind ());
			po '\109' =>   p::INLRSHIFTL (numkind ());
			po '\110' =>   p::ROUND { floor => bool (), fromkind => numkind (), tokind => numkind () };
			po '\111' =>   p::REAL                   { fromkind => numkind (), tokind => numkind () };
			po '\112' =>   p::NUMSUBSCRIPT { kind => numkind (), checked => bool (), immutable => bool () };
			po '\113' =>   p::NUMUPDATE { kind => numkind (), checked => bool () };
			po '\114' =>   p::INLINE_MONOARRAY (numkind ());
			po '\115' =>   p::INLINE_MONOVECTOR (numkind ());
			po '\116' =>   p::RAW_LOAD (numkind ());
			po '\117' =>   p::RAW_STORE (numkind ());
			po '\118' =>   p::RAW_CCALL (THE (ccall_info ()));
			po '\119' =>   p::RAW_RECORD { fblock => bool () };
			po '\120' =>   p::INLMIN (numkind ());
			po '\121' =>   p::INLMAX (numkind ());
			po '\122' =>   p::INLABS (numkind ());
			po '\123' =>   p::TEST_INF (int ());
			po '\124' =>   p::TRUNC_INF (int ());
			po '\125' =>   p::EXTEND_INF (int ());
			po '\126' =>   p::COPY_INF (int ());
			po c      =>   vector::get (primop_table, char::to_int c)
				       except
                                           (exceptions::SUBSCRIPT|exceptions::INDEX_OUT_OF_BOUNDS) =  raise exception FORMAT;
                    end;
		  
  		    share  po_m  po;
		};

	
	    { pid,
	      string,
	      symbol,
	      var_home,
	      datatype_constructor_representation,
	      constructor_signature,
	      primitive_operation,
	      boollist,
	      intoption,
	      type_kind,
	      tkindlist
	    };
	};


    fun make_symboltable_unpickler extra_info session_info unpickling_context
        =
        {   my { global_pid, symbollist, shared_stuff, lib }
                =
                extra_info;

	    my { session, stringlist }
                =
                session_info;

	    stipulate

		fun get lk (m, i)
                    =
		    case (lk (unpickling_context m, i))
                      
		         THE x => x;

		         NULL
                             =>
                             {   error_message::impossible "unpickle_module: stub lookup failed";
			         raise exception FORMAT;
                             };
                    esac;

	    herein

		find_type_constructor_via_symbol_path =  get mi::find_type_constructor_via_symbol_path;
		find_api_by_symbol                    =  get mi::find_api_by_symbol;
		find_package_via_symbol_path          =  get mi::find_package_via_symbol_path;
		find_generic_via_symbol_path          =  get mi::find_generic_via_symbol_path;
		find_typechecked_package              =  get mi::find_typechecked_package;
            end;

	    fun list   m r =   uu::read_list   session m r;
	    fun option m r =   uu::read_option session m r;

	    bool = uu::read_bool session;

	    fun pair m fp p
                =
                uu::read_pair session m fp p;

	    int = uu::read_int session;

	    fun share m  f =   uu::share session m f;
	    fun nonshare f =   uu::nonshare session f;

	    # The following maps acquire different types
	    # by being used in different contexts:
	    stamp_m           = uu::make_map ();
	    str_id_m          = uu::make_map ();
	    generic_id_m      = uu::make_map ();
	    stamp_option_m    = uu::make_map ();
	    stamp_list_m      = uu::make_map ();
	    symbol_option_m   = uu::make_map ();
	    symbol_list_m     = uu::make_map ();
	    spath_list_m      = uu::make_map ();
	    spath_list_list_m = uu::make_map ();
	    datacon_m         = uu::make_map ();
	    tk_m              = uu::make_map ();
	    dti_m             = uu::make_map ();
	    dtf_m             = uu::make_map ();
	    dtmember_m        = uu::make_map ();
	    dtm_list_m        = uu::make_map ();
	    nrd_m             = uu::make_map ();
	    nrd_list_m        = uu::make_map ();
	    tycon_m           = uu::make_map ();
	    tycon_list_m      = uu::make_map ();
	    ty_m              = uu::make_map ();
	    ty_option_m       = uu::make_map ();
	    ty_list_m         = uu::make_map ();
	    ii_m              = uu::make_map ();
	    v_m               = uu::make_map ();
	    sd_m              = uu::make_map ();
	    sig_m             = uu::make_map ();
	    fsig_m            = uu::make_map ();
	    sp_m              = uu::make_map ();
	    en_m              = uu::make_map ();
	    fctc_m            = uu::make_map ();
	    str_m             = uu::make_map ();
	    generic_m         = uu::make_map ();
	    ste_m             = uu::make_map ();
	    tce_m             = uu::make_map ();
	    stre_m            = uu::make_map ();
	    fe_m              = uu::make_map ();
	    ee_m              = uu::make_map ();
	    ed_m              = uu::make_map ();
	    eenv_m            = uu::make_map ();
	    sen_m             = uu::make_map ();
	    fen_m             = uu::make_map ();
	    fx_m              = uu::make_map ();
	    b_m               = uu::make_map ();
	    elements_m        = uu::make_map ();
	    beps_lm           = uu::make_map ();
	    beps_om           = uu::make_map ();
	    sp_def_m          = uu::make_map ();
	    ii_list_m         = uu::make_map ();
	    overld_m          = uu::make_map ();
	    ol_list_m         = uu::make_map ();
	    ed_list_m         = uu::make_map ();
	    eenv_bind_m       = uu::make_map ();
	    env_m             = uu::make_map ();
	    spath_m           = uu::make_map ();
	    ipath_m           = uu::make_map ();
	    sym_spec_pm       = uu::make_map ();
	    ep_tk_pm          = uu::make_map ();
	    sd_int_pm         = uu::make_map ();
	    ev_typechecked_package_pm     = uu::make_map ();
	    sym_bind_pm       = uu::make_map ();
	    pid_option_m      = uu::make_map ();
	    lms_opt_m         = uu::make_map ();
	    lms_pair_m        = uu::make_map ();


            shared_stuff
                ->
	        { pid,
                  string,
                  symbol,
                  var_home,
                  datatype_constructor_representation,
                  constructor_signature,
                  intoption,
		  primitive_operation,
                  boollist,
                  type_kind,
                  tkindlist
                };


	    fun lib_mod_spec ()
                =
                option  lms_opt_m  (pair  lms_pair_m  (int, symbol))  ();


	    fun stamp ()
                =
		share  stamp_m  st
                where

                    fun st 'A'   =>   stamp::global {   picklehash => global_pid (),
					                count      => int ()
                                                    };
		        st 'B'   =>   stamp::global {   picklehash => pid (),
						        count      => int ()
                                                    };
		        st 'C'   =>   stamp::special (string ());

		        st _     =>   raise exception FORMAT;
                    end;
		end;    

	    type_identifier =   stamp;
	    api_identifier  =   stamp;


	    fun package_identifier ()
		=
		share  str_id_m  si
                where

		    fun si 'D' =>  { an_api              =>  stamp (),
				     typechecked_package =>  stamp ()
				    };
		        si _   =>  raise exception FORMAT;
                    end;
		end;


	    fun generic_identifier ()
		=
		share  generic_id_m  fifi
                where

		    fun fifi 'E' => { parameter_api       => stamp (),
				      body_api            => stamp (),
				      typechecked_package => stamp ()
				    };
		        fifi _ => raise exception FORMAT;
                    end;
		end;


	    dictionary_identifier = stamp;

	    stamplist   =   list stamp_list_m stamp;
	    stampoption =   option stamp_option_m stamp;
	    pidoption   =   option pid_option_m pid;

	    module_stamp    =   stamp;
	    typechecked_package_var_option   =   stampoption;
	    module_path     =   stamplist;

	    symbollist     =   list symbol_list_m symbol;
	    symboloption   =   option symbol_option_m symbol;


	    fun spath ()
                =
		share  spath_m  sp
                where

                    fun sp 's'   =>   sp::SYMBOL_PATH (symbollist ());
		        sp _     =>   raise exception FORMAT;
                    end;
		end;


	    fun ipath ()
                =
		share  ipath_m  ip
                where
                    fun ip 'i'   =>   ip::INVERSE_PATH (symbollist ());
		        ip _     =>   raise exception FORMAT;
                    end;
		end;


	    spathlist       =   list spath_list_m spath;
	    spathlistlist   =   list spath_list_list_m spathlist;

	    label       =   symbol;
	    labellist   =   symbollist;


	    fun equality_property ()
                =
		nonshare  eqp
                where
                    fun eqp c
                        =
			vector::get (equality_property_table, char::to_int c)
			except
                            (exceptions::SUBSCRIPT|exceptions::INDEX_OUT_OF_BOUNDS) =  raise exception FORMAT;
		end;


	    fun datatype_constructor' ()
                =
                {   fun d 'c'
                        =>
			{   name  =  symbol ();
			    const =  bool ();

			    my (constructor_type, ttr)
                                =
                                type' ();

			    representation =  datatype_constructor_representation ();
			    signature      =  constructor_signature ();
			    is_lazy        =  bool ();
			
			    (  t::ENUM_CONSTRUCTOR
                                   {
                                     symbol         => name,
                                     const,
                                     constructor_type,
				     representation,
                                     signature,
                                     is_lazy
                                   },
			       ttr
                            );
			};

		       d _ => raise exception FORMAT;
                    end;
		
		    share datacon_m d;
		}

	    also
	    fun type_constructor_kind ()
                =
                {   fun tk 'a'
                            =>
                            t::PRIMITIVE (int ());

			tk 'b'
			    =>
			    {   index = int ();
				root  = typechecked_package_var_option ();

				my (stamps, family, free_type_constructors)
                                    =
                                    dtype_info ();

				t::DATATYPE
                                    {
                                      index,
				      root,
				      stamps,
				      family,
				      free_type_constructors
				    };
			    };

			tk 'c'   =>   t::ABSTRACT (type_constructor ());
			tk 'd'   =>   t::FORMAL;
			tk 'e'   =>   t::TEMP;
			tk _     =>   raise exception FORMAT;
                     end;
		
		    share tk_m tk;
		}

	    also
	    fun dtype_info ()
                =
		share  dti_m  dti
                where
                    fun dti 'a'
			    =>
			    (vector::from_list (stamplist ()), dt_family (), tyconlist ());

		        dti _
                            =>
                            raise exception FORMAT;
                    end;
		end


	    also
	    fun dt_family ()
                =
		share  dtf_m  dtf
                where
                    fun dtf 'b'
                        =>
			{   mkey          =>  stamp (),
			    members       =>  vector::from_list (dtmemberlist ()),
			    property_list =>  property_list::make_property_list ()
                        };

		       dtf _   =>   raise exception FORMAT;
                    end;
		end


	    also
	    fun datatype_member ()
                =
		share  dtmember_m  d
                where
                    fun d 'c'
                        =>
                        {   type_constructor_name => symbol (),
                            constructor_list => nrdlist (),
			    arity => int (),
                            eq => REF (equality_property ()),
			    is_lazy => bool (),
                            an_api => constructor_signature ()
                        };

		        d _ => raise exception FORMAT;
                    end;
		end


	    also
	    fun dtmemberlist ()
                =
                list  dtm_list_m  datatype_member  ()


	    also
	    fun name_representation_domain ()
                =
		share  nrd_m  n
                where
                    fun n 'd'
                        =>
			{   name => symbol (),
                            representation => datatype_constructor_representation (),
                            domain => tyoption ()
                        };

		       n _ => raise exception FORMAT;
                    end;
		end


	    also
	    fun nrdlist ()
                =
                list  nrd_list_m  name_representation_domain ()


	    also
	    fun type_constructor ()
		=
		share  tycon_m  typeconstructor
                where
		    fun typeconstructor 'A'
                            =>
                            t::PRIMITIVE_TYPE_CONSTRUCTOR
                                (find_type_constructor_via_symbol_path
                                    ( lib_mod_spec (),
                                      type_identifier ()
                                    )
                                );

		        typeconstructor 'B'
                            =>
                            t::PRIMITIVE_TYPE_CONSTRUCTOR
                                {
                                  stamp => stamp (),
				  arity => int (),
				  eq => REF (equality_property ()),
				  kind => type_constructor_kind (),
				  path => ipath (),
				  stub => THE { owner => if lib  pid ();
						         else    global_pid ();
                                                         fi,
						lib
                                              }
                                };

		        typeconstructor 'C'
                            =>
                            t::DEFINED_TYPE_CONSTRUCTOR
                                {
                                  stamp => stamp (),
				  type_scheme => t::TYPE_SCHEME { arity => int (),
								   body => type ()
								 },
				  strict => boollist (),
				  path => ipath ()
				};

		        typeconstructor 'D'
                            =>
                            t::TYPE_CONSTRUCTOR_BY_MODULE_PATH
                                {
                                  arity      => int (),
				  module_path => module_path (),
				  path       => ipath ()
				};

		        typeconstructor 'E' =>  t::RECORD_TYPE_CONSTRUCTOR (labellist ());
		        typeconstructor 'F' =>  t::RECURSIVE_TYPE (int ());
		        typeconstructor 'G' =>  t::FREE_TYPE (int ());
		        typeconstructor 'H' =>  t::ERRONEOUS_TYPE_CONSTRUCTOR;
		        typeconstructor _   =>  raise exception FORMAT;
                    end;
		
		end


	    also
	    fun type_constructor' ()
                =
                {   typeconstructor
                        =
                        type_constructor ();

		    tree
                        =
                        case typeconstructor
		          
		             t::PRIMITIVE_TYPE_CONSTRUCTOR r
                                 =>
                                 m::TYPE_CONSTRUCTOR_MODTREE_NODE r;

			     _   =>
                                 notree;
                        esac;

		
		    (typeconstructor, tree);
		}


	    also
	    fun tyconlist ()
                =
                list tycon_list_m type_constructor ()


	    also
	    fun type' ()
                =
		share  ty_m  t
                where

                    fun t 'a'
                        =>
			{   my (type_constructor, tyctr)
                                =
                                type_constructor' ();

			    my (tyl,             tyltr)
                                =
                                tylist' ();
			
                            (   t::CONSTRUCTOR_TYPE (type_constructor, tyl),
                                branch [tyctr, tyltr]
                            );
			};

			t 'b'   =>   (t::TYPE_SCHEME_ARG_I (int ()), notree);
			t 'c'   =>   (t::WILDCARD_TYPE, notree);

			t 'd'
			    =>
			    {   s   =   boollist ();
				ar  =  int ();

				my (b, btr)   =   type' ();

				(   t::TYPE_SCHEME_TYPE {
					type_scheme_arg_eq_properties => s,
					type_scheme                         => t::TYPE_SCHEME { arity => ar,
												 body => b
											       }
					     },
				    btr
				);
			    };

		        t 'e' =>   (t::UNDEFINED_TYPE, notree);
		        t _   =>   raise exception FORMAT;
                    end;
		end


	    also
	    fun type ()
                =
                #1 (type' ())


	    also
	    fun tyoption ()
                =
                option  ty_option_m  type  ()


	    also
	    fun tylist' ()
                =
                {   my (l, trl)
                        =
                        paired_lists::unzip
                            (list  ty_list_m  type' ());
	       
		   (l, branch trl);
	        }

	    also
	    fun inlining_info ()
                =
		share  ii_m  ii
                where
                    fun ii 'A'   =>   ii::inline_primitive (primitive_operation (), type ());
			ii 'B'   =>   ii::inline_package (iilist ());
			ii 'C'   =>   ii::inline_nothing;
			ii _     =>   raise exception FORMAT;
                    end;
		end


	    also
	    fun iilist ()
                =
                list  ii_list_m  inlining_info ()


	    also
	    fun var' ()
                =
		share  v_m  v
                where
                    fun v '1'
			    =>
			    {   a =  var_home ();
				i =  inlining_info ();
				p =  spath ();

				my (t, tr)
				    =
				    type' ();

				( v::ORDINARY_VARIABLE { var_home => a, inlining_info => i, path => p, var_type => REF t },
				  tr
				);
			    };

		        v '2'
			    =>
			    {   name = symbol ();
				my (alternatives, oltr) = overloaded_identifier_list' ();
				arity = int ();
				my (body, btr) = type' ();

				( v::OVERLOADED_IDENTIFIER
                                    { name,
				      alternatives => REF alternatives,
				      type_scheme  => t::TYPE_SCHEME { arity, body }
                                    },

				  branch [oltr, btr]
                                );
			    };

			v '3'   =>   (v::ERRORVAR, notree);
			v _     =>   raise exception FORMAT;
                    end;
		end

	    also
	    fun overld' ()
                =
		share  overld_m  ov
                where

                    fun ov 'o'
			    =>
			    {   my (t, ttr) = type' ();
				my (v, vtr) = var' ();

				( { indicator => t, variant => v },
				 branch [ttr, vtr]);
			    };

		        ov _ => raise exception FORMAT;
                    end;
		end


	    also
	    fun overloaded_identifier_list' ()
                =
                {   my (l, trl)
                        =
                        paired_lists::unzip
                            (list  ol_list_m  overld' ());
		
		    (l, branch trl);
		};


	    fun package_definition ()
                =
		share sd_m sd
                where

                    fun sd 'C'   =>   m::CONSTANT_PACKAGE_DEFINITION (a_package ());
		        sd 'V'   =>   m::VARIABLE_PACKAGE_DEFINITION (an_api (), module_path ());
		        sd _     =>   raise exception FORMAT;
                    end;
		end


	    also
	    fun an_api' ()
                =
		share  sig_m  sg
                where

                    fun sg 'A' => (m::ERRONEOUS_API, notree);

		        sg 'B'
			    =>
			    {   sr = find_api_by_symbol (lib_mod_spec (), api_identifier ());

				(m::API sr, m::API_MODTREE_NODE sr);
			    };

			sg 'C'
			    =>
			    {   s  = stamp ();
				n  = symboloption ();
				c  = bool ();
				ff = bool ();
				sl = symbollist ();

				my (el, eltrl)
				    =
				    paired_lists::unzip
					(map (fn (symbol, (sp, tr)) =  ((symbol, sp), tr))
					     (list elements_m
					      (pair sym_spec_pm (symbol, spec')) ()));

				beps = option beps_om
						  (list beps_lm
							(pair ep_tk_pm (module_path, type_kind))) ();

				ts = spathlistlist ();
				ss = spathlistlist ();

				r = { stamp  => s,
				      name   => n,
				      closed => c,

				      contains_generic  => ff,
				      symbols  => sl,
				      elements => el,

				      property_list => property_list::make_property_list (),
				      #  Boundeps = REF beps, 
				      #  lambdaty = REF NULL, 
				      type_sharing => ts,
				      package_sharing => ss,
				      stub => THE {   module_tree => branch eltrl,
						      lib,
						      owner      => if (lib)         pid ();
								    else      global_pid ();
                                                                    fi
						  } 

					};

				package_property_lists::set_api_bound_generic_evaluation_paths (r, beps);
				(m::API r, m::API_MODTREE_NODE r);
			    };

		        sg _ => raise exception FORMAT;
                    end;
		end


	    also
	    fun an_api ()   =   #1 (an_api' ())

	    also
	    fun generic_api' ()
                =
                {
		fun fsg 'a' => (m::ERRONEOUS_GENERIC_API, notree);
		   fsg 'c'
                    =>
		    { k = symboloption ();
			my (ps, pstr) = an_api' ();
			pv  = module_stamp ();
			psy = symboloption ();
			my (bs, bstr) = an_api' ();
		    
			(   m::GENERIC_API {   kind => k,
                                       parameter_api => ps,
				       parameter_variable => pv,
                                       parameter_symbol => psy,
				       body_api => bs
                                   },
			    branch [pstr, bstr]
                        );
		    };

		    fsg _ => raise exception FORMAT;
                end;
	    
		share fsig_m fsg;
	    }

	    also
	    fun spec' ()
                =
                { fun sp '1'
                        =>
			{ my (type_constructor, ttr) = type_constructor' ();
			
			    (   m::TYPE_CONSTRUCTOR_IN_API {   type_constructor,
                                                                    module_stamp => module_stamp (),
					                            is_a_replica       => bool (),
                                                                    scope            => int ()
                                                                },
			        ttr
                            );
			};

		       sp '2'
                        =>
			{ my (s, str) = an_api' ();
			
			    (   m::PACKAGE_IN_API {   an_api  => s,
                                                             slot        => int (),
					                     definition  => option sp_def_m (pair sd_int_pm (package_definition, int)) (),
					                     module_stamp => module_stamp ()
                                                         },
			        str
                            );
			};

		       sp '3'
                        =>
			{ my (f, ftr) = generic_api' ();
			
			    (   m::GENERIC_IN_API { a_generic_api => f,
                                                    slot          => int (),
                                                    module_stamp => module_stamp ()
                                                  },
			        ftr
                            );
			};

		       sp '4'
                        =>
			{ my (type, ttr) = type' ();
			
			    (m::VALUE_IN_API { type, slot => int () }, ttr);
			};

		       sp '5'
                        =>
			{ my (d, dtr) = datatype_constructor' ();
			
			    (m::ENUM_CONSTRUCTOR_IN_API { a_datatype => d, slot => intoption () }, dtr);
			};

		       sp _   =>   raise exception FORMAT;
                    end;
		
		    share sp_m sp;
		}

	    also
	    fun typechecker_dictionary_entry' ()
                =
                {   fun en 'A'   =>   &&& m::TYPE_CONSTRUCTOR_ENTRY (typechecked_type_constructor' ());
			en 'B'   =>   &&& m::PACKAGE_ENTRY (typechecked_package' ());
			en 'C'   =>   &&& m::GENERIC_ENTRY (typechecked_generic' ());
			en 'D'   =>   (m::ERRONEOUS_ENTRY, notree);
			en _     =>   raise exception FORMAT;
                    end;
		
		    share en_m en;
		}

	    also
	    fun generic_closure' ()
                =
                {   fun f 'f'
                        =>
			{ p = module_stamp ();
			    my (b, btr) = package_expression' ();
			    my (e, etr) = typechecked_package_dictionary' ();
			
			    (   m::GENERIC_CLOSURE {   parameter_module_stamp    => p,
                                                      body_package_expression => b,
                                                      typechecker_dictionary       => e
                                                  },
			        branch [btr, etr]
                            );
			};

		        f _ => raise exception FORMAT;
                    end;
		
		    share fctc_m f;
		}

	    # The construction of the PACKAGE_MODTREE_NODE in the Module_Tree deserves some
	    # comment:  Even though it contains the whole Package_Record, it does
	    # _not_ take care of the an_api contained therein.  The reason
	    # why PACKAGE_MODTREE_NODE has the whole Package_Record and not just the Typechecked_Package that
	    # it really guards is that the identity of the Typechecked_Package is not
	    # fully recoverable without also having access to the an_api.
	    # The same situation occurs in the case of GENERIC_MODTREE_NODE.

	    also
	    fun a_package' ()
                =
                {   fun str 'A'
                        =>
			{ my (s, str) = an_api' ();
			
			    (m::PACKAGE_API { an_api => s, module_path => module_path () }, str);
			};

		       str 'B' => (m::ERRONEOUS_PACKAGE, notree);
		       str 'C'
                        =>
			{ my (s, str) = an_api' ();

			    r = { an_api              => s,
				  typechecked_package => find_package_via_symbol_path (lib_mod_spec (), package_identifier ()),
				  var_home              => var_home (),
				  inlining_info       => inlining_info ()
                                };
			
			    (m::A_PACKAGE r, branch [str, m::PACKAGE_MODTREE_NODE r]);
			};

		       str 'D'
                        =>
			{   my (s, str) = an_api' ();

			    r = { an_api  => s,
				  typechecked_package => typechecked_package (),
				  var_home      => var_home (),
				  inlining_info  => inlining_info ()
                                };
			
			    (m::A_PACKAGE r, branch [str, m::PACKAGE_MODTREE_NODE r]);
			};

		       str _ => raise exception FORMAT;
                    end;
		
		    share str_m str;
		}

	    also
	    fun a_package ()   =   #1 (a_package' ())

	    # See the comment about PACKAGE_MODTREE_NODE, Package_Record, an_api, and Typechecked_Package
	    # in front of a_package'.  The situation for GENERIC_MODTREE_NODE, Generic_Record,
	    # generic_api, and Typechecked_Generic is analogous.
	    also
	    fun a_generic' ()
                =
                {   fun fct 'E' => (m::ERRONEOUS_GENERIC, notree);
			fct 'F'
			 =>
			 { my (s, str) = generic_api' ();

			     r = { a_generic_api           => s,
				   typechecked_generic => find_generic_via_symbol_path (lib_mod_spec (), generic_identifier ()),
				   var_home                  => var_home (),
				   inlining_info           => inlining_info ()
				 };

			     (m::GENERIC r, branch [str, m::GENERIC_MODTREE_NODE r]);
			 };

			fct 'G'
			 =>
			 { my (a_generic_api, a_package) = generic_api' ();

			     r = { a_generic_api,
				   typechecked_generic => typechecked_generic (),
				   var_home                  => var_home (),
				   inlining_info           => inlining_info ()
				 };

			     (m::GENERIC r, branch [a_package, m::GENERIC_MODTREE_NODE r]);
			 };

		        fct _ => raise exception FORMAT;
                    end;
		
		    share generic_m fct;
		}

	    also
	    fun stamp_expression ()
                =
                {   fun ste 'b'   =>   m::GET_STAMP (package_expression ());
		        ste 'c'   =>   m::MAKE_STAMP;
		        ste _     =>   raise exception FORMAT;
                    end;
		
		    share ste_m ste;
		}

	    also
	    fun type_constructor_expression' ()
                =
                {   fun tce 'd'   =>   &&& m::CONSTANT_TYPE_CONSTRUCTOR (type_constructor' ());
			tce 'e'   =>   (m::FORMAL_TYPE_CONSTRUCTOR (type_constructor ()), notree); #  ? 
			tce 'f'   =>   (m::TYPE_VARIABLE_TYPE_CONSTRUCTOR (module_path ()), notree);
			tce _     =>   raise exception FORMAT;
                    end;
		
		    share tce_m tce;
		}

	    also
	    fun type_constructor_expression ()   =   #1 (type_constructor_expression' ())

	    also
	    fun package_expression' ()
                =
                {   fun stre 'g' => (m::VARIABLE_PACKAGE (module_path ()), notree);
			stre 'h' => &&& m::CONSTANT_PACKAGE (typechecked_package' ());

			stre 'i'
			    =>
			    { s = stamp_expression ();
				my (d, dtr) = module_declaration' ();

				(m::PACKAGE { stamp => s, module_declaration => d }, dtr);
			    };

			stre 'j'
				 =>
			 { my (f, ftr) = generic_expression' ();
			     my (s, str) = package_expression' ();

			     (m::APPLY (f, s), branch [ftr, str]);
			 };

			stre 'k'
			    =>
			    {   my (declaration, dtr) = module_declaration' ();
				my (expression,  str) = package_expression' ();

				(m::PACKAGE_LET { declaration, expression }, branch [dtr, str]);
			    };

			stre 'l'
			    =>
			    { my (s, str) = an_api' ();
				my (e, etr) = package_expression' ();

				(m::ABSTRACT_PACKAGE (s, e), branch [str, etr]);
			    };

			stre 'm'
			    =>
			    {   bv = module_stamp ();
				my (r, rtr) = package_expression' ();
				my (c, ctr) = package_expression' ();

				(m::COERCED_PACKAGE { boundvar => bv, raw => r, coercion => c },
				 branch [rtr, ctr]);
			    };

			stre 'n' => &&& m::FORMAL_PACKAGE (generic_api' ());
			stre _   => raise exception FORMAT;
                    end;
		
		    share stre_m stre;
		}

	    also
	    fun package_expression ()   =   #1 (package_expression' ())

	    also
	    fun generic_expression' ()
                =
                {   fun fe 'o' => (m::VARIABLE_GENERIC (module_path ()), notree);
			fe 'p' => &&& m::CONSTANT_GENERIC (typechecked_generic' ());

			fe 'q'
			 =>
			 { p = module_stamp ();
			     my (b, btr) = package_expression' ();

			     (m::LAMBDA { parameter => p, body => b }, btr);
			 };

			fe 'r'
			 =>
			 { p = module_stamp ();
			     my (b, btr) = package_expression' ();
			     my (s, str) = generic_api' ();

			     (m::LAMBDA_TP { parameter => p, body => b, an_api => s },
			      branch [btr, str]);
			 };

			fe 's'
			 =>
			 { my (d, dtr) = module_declaration' ();
			     my (f, ftr) = generic_expression' ();

			     (m::LET_GENERIC (d, f), branch [dtr, ftr]);
			 };

			fe _ => raise exception FORMAT;
                    end;
		
		    share fe_m fe;
		}

	    also
	    fun generic_expression ()   =   #1 (generic_expression' ())

	    also
	    fun module_expression ()
                =
                {   fun ee 't'   =>   m::TYPE_CONSTRUCTOR_EXPRESSION (type_constructor_expression ());
			ee 'u'   =>   m::PACKAGE_EXPRESSION (package_expression ());
			ee 'v'   =>   m::GENERIC_EXPRESSION (generic_expression ());

			ee 'w'   =>   m::ERRONEOUS_ENTRY_EXPRESSION;
			ee 'x'   =>   m::DUMMY_GENERIC_EVALUATION_EXPRESSION;
			ee _     =>   raise exception FORMAT;
                    end;
		
		    share ee_m ee;
		}

	    also
	    fun module_declaration' ()
                =
                {   fun ed 'A'
                        =>
			{ v = module_stamp ();
			    my (e, etr) = type_constructor_expression' ();
			
			    (m::TYPE_CONSTRUCTOR_DECLARATION (v, e), etr);
			};

			ed 'B'
			 =>
			 { v = module_stamp ();
			     my (e, etr) = package_expression' ();
			     s = symbol ();

			     (m::PACKAGE_DECLARATION (v, e, s), etr);
			 };

			ed 'C'
			 =>
			 { v = module_stamp ();
			     my (e, etr) = generic_expression' ();

			     (m::GENERIC_DECLARATION (v, e), etr);
			 };

			ed 'D' => &&& m::SEQUENTIAL_DECLARATIONS (typechecked_package_dec_list' ());

			ed 'E' =>
			 { my (d1, d1tr) = module_declaration' ();
			     my (d2, d2tr) = module_declaration' ();

			     (m::LOCAL_DECLARATION (d1, d2), branch [d1tr, d2tr]);
			 };

			ed 'F'   =>   (m::ERRONEOUS_ENTRY_DECLARATION, notree);
			ed 'G'   =>   (m::EMPTY_GENERIC_EVALUATION_DECLARATION, notree);
			ed _     =>   raise exception FORMAT;
                    end;
		
		    share ed_m ed;
		}

	    also
	    fun typechecked_package_dec_list' ()
                =
                {   my (l, trl) = paired_lists::unzip (list ed_list_m module_declaration' ());
		
		    (l, branch trl);
		}

	    also
	    fun typechecked_package_dictionary' ()
                =
                {   fun eenv 'A'
			    =>
			    {   l = list eenv_bind_m (pair ev_typechecked_package_pm (module_stamp, typechecker_dictionary_entry')) ();

				l' =   map   (fn (v, (e, tr)) =  ((v, e), tr))   l;

				my (l'', trl) = paired_lists::unzip l';

				fun set ((v, e), z)
				    =
				    ed::set (z, v, e);

				ed = fold_right set ed::empty l'';
				my (e, etr) = typechecked_package_dictionary' ();

				(m::NAMED_TYPECHECKER_DICTIONARY (ed, e), branch (etr ! trl));
			    };

			eenv 'B' => (m::NULL_TYPECHECKER_DICTIONARY, notree);
			eenv 'C' => (m::ERRONEOUS_ENTRY_DICTIONARY, notree);

			eenv 'D'
			    =>
			    { r = find_typechecked_package (lib_mod_spec (), dictionary_identifier ());

				(m::MARKED_TYPECHECKER_DICTIONARY r, m::TYPECHECKER_DICTIONARY_MODTREE_NODE r);
			    };

			eenv 'E'
			    =>
			    {   s = stamp ();

				my (e, etr) = typechecked_package_dictionary' ();

				r = { stamp               => s,
				      typechecker_dictionary => e,
				      stub                => THE {   module_tree => etr,
								     lib,
								     owner      => if lib         pid ();
										   else    global_pid ();
										   fi
								 }

				    };

				( m::MARKED_TYPECHECKER_DICTIONARY        r,
				  m::TYPECHECKER_DICTIONARY_MODTREE_NODE  r
				);
			    };

			eenv _ => raise exception FORMAT;
                    end;
		
		    share eenv_m eenv;
		}

	    also
	    fun typechecked_package' ()
                =
                {   fun s 's'
                        =>
			{ s = stamp ();
			    my (e, etr) = typechecked_package_dictionary' ();
			
			    (  {   stamp               => s,
			           typechecker_dictionary => e,
			           inverse_path        => ipath (),
			           property_list       => property_list::make_property_list (),

			           stub => THE {   module_tree => etr,
					           lib,
                                                   owner      => if lib  pid ();
						                       else global_pid ();fi
                                               }
					           
                               },
			       etr
                            );
			};

		        s _ => raise exception FORMAT;
                    end;
		
		    share sen_m s;
		}

	    also
	    fun typechecked_package ()   =   #1 (typechecked_package' ())

	    also
	    fun typechecked_generic' ()
                =
                {   fun f 'f'
                        =>
			{ s = stamp ();
			    my (c, ctr) = generic_closure' ();
			
			    (   {   stamp => s,
				    generic_closure => c,
				    inverse_path    => ipath (),
				    property_list   => property_list::make_property_list (),
				    #  lambdaty = REF NULL, 
				    type_constructor_path => NULL,
				    stub => THE {   module_tree => ctr,
						    lib,
                                                    owner      => if lib        pid ();
							          else   global_pid ();  fi
						}  
                                },
			        ctr
                            );
			};

		        f _ => raise exception FORMAT;
                    end;
		
		    share fen_m f;
		}

	    also
	    fun typechecked_generic ()   =   #1 (typechecked_generic' ())

	    also
	    fun typechecked_type_constructor' ()   =   type_constructor' ();

	    fun fixity ()
                =
                {   fun fx 'N'   =>   fixity::NONFIX;
			fx 'I'   =>   fixity::INFIX (int (), int ());
			fx _     =>   raise exception FORMAT;
                    end;
		
		    share fx_m fx;
		};

	    fun naming' ()
                =
                {   fun b '1'   =>   &&& b::NAMED_VARIABLE       (var'                  ());
			b '2'   =>   &&& b::NAMED_CONSTRUCTOR    (datatype_constructor' ());
			b '3'   =>   &&& b::NAMED_TYPE           (type_constructor'     ());
			b '4'   =>   &&& b::NAMED_API            (an_api'               ());
			b '5'   =>   &&& b::NAMED_PACKAGE        (a_package'            ());
			b '6'   =>   &&& b::NAMED_GENERIC_API    (generic_api'          ());
			b '7'   =>   &&& b::NAMED_GENERIC        (a_generic'            ());

			b '8'   =>   (b::NAMED_FIXITY (fixity ()), notree);
			b _     =>   raise exception FORMAT;
                    end;
		
		    share b_m b;
		};

	    fun symbol_table ()
                =
                { bindlist = list env_m (pair sym_bind_pm (symbol, naming')) ();

		    fun bind ((s, (b, t)), e) = symbol_table::bind0 (s, (b, THE t), e);
		
		    symbol_table::consolidate (fold_left bind symbol_table::empty bindlist);
		};
	
	    symbol_table;
	};            #  fun make_symboltable_unpickler 


    fun unpickle_symboltable unpickling_context (hash, pickle)
        =
        {   session = uu::make_session (uu::string_getter (byte::bytes_to_string pickle));

	    fun an_import i = a::PATH (a::EXTERN hash, i);

	    sl_m  = uu::make_map ();
	    slo_m = uu::make_map ();
	    syl_m = uu::make_map ();

	    shared_stuff = make_shared_stuff (session, an_import);

	    stringlist  = uu::read_list session sl_m  shared_stuff.string;
	    symbollist  = uu::read_list session syl_m shared_stuff.symbol;

	    extra_info   = {   global_pid => fn () => hash; end ,
			       symbollist,
			       shared_stuff,
			       lib => FALSE
                           };

	    session_info = { session, stringlist };
	    unpickle    = make_symboltable_unpickler extra_info session_info unpickling_context;

	    unpickle ();
	};


    fun make_highcode_unpickler (session, shared_stuff)
        =
        {   fun share  m r = uu::share       session m r;
	    fun list   m r = uu::read_list   session m r;
	    fun option m r = uu::read_option session m r;

	    fun pair m fp p = uu::read_pair session m fp p;

	    int    = uu::read_int   session;
	    int32  = uu::read_int32  session;
	    word   = uu::read_word   session;
	    word32 = uu::read_word32 session;
	    bool   = uu::read_bool  session;

            shared_stuff
                ->
	        {   pid,
                    string,
                    symbol,
                    var_home,
                    datatype_constructor_representation,
                    constructor_signature,
		    primitive_operation,
                    boollist,
                    type_kind,
                    tkindlist,
                    intoption
                };

	    lty_m        = uu::make_map ();
	    lty_list_m    = uu::make_map ();
	    tyc_m        = uu::make_map ();
	    tyc_list_m    = uu::make_map ();
	    value_m      = uu::make_map ();
	    con_m        = uu::make_map ();
	    dcon_m       = uu::make_map ();
	    dictionary_m       = uu::make_map ();
	    fprim_m      = uu::make_map ();
	    lexp_m       = uu::make_map ();
	    fkind_m      = uu::make_map ();
	    rkind_m      = uu::make_map ();
	    ltylo_m      = uu::make_map ();
	    dictionary_table_m  = uu::make_map ();
	    dictionary_option_m = uu::make_map ();
	    value_list_m  = uu::make_map ();
	    lvar_list_m   = uu::make_map ();
	    fundec_list_m = uu::make_map ();
	    con_list_m    = uu::make_map ();
	    lexp_option_m = uu::make_map ();
	    fundec_m     = uu::make_map ();
	    tfundec_m    = uu::make_map ();
	    lv_lt_pm      = uu::make_map ();
	    lv_lt_plm     = uu::make_map ();
	    lv_tk_pm      = uu::make_map ();
	    lv_tk_plm     = uu::make_map ();
	    tyc_lv_pm     = uu::make_map ();

	    fun lambda_type ()
                =
                {   fun lt 'A' => lt::ltc_tyc (type_constructor ());
			lt 'B' => lt::ltc_str (ltylist ());
			lt 'C' => lt::ltc_fct (ltylist (), ltylist ());
			lt 'D' => lt::ltc_poly (tkindlist (), ltylist ());
			lt _   => raise exception FORMAT;
                    end;

		    share lty_m lt;
		}

	    also
	    fun ltylist ()
                =
                list lty_list_m lambda_type ()

	    also
	    fun type_constructor ()
                =
                {   fun tc 'A'   =>   lt::tcc_var (di::di_fromint (int ()), int ());
			tc 'B'   =>   lt::tcc_nvar (int ());
			tc 'C'   =>   lt::tcc_prim (pt::prim_type_con_from_int (int ()));
			tc 'D'   =>   lt::tcc_g (tkindlist (), type_constructor ());
			tc 'E'   =>   lt::tcc_app (type_constructor (), tyclist ());
			tc 'F'   =>   lt::tcc_seq (tyclist ());
			tc 'G'   =>   lt::tcc_proj (type_constructor (), int ());
			tc 'H'   =>   lt::tcc_sum (tyclist ());
			tc 'I'   =>   lt::tcc_fix ((int (), type_constructor (), tyclist ()), int ());
			tc 'J'   =>   lt::tcc_abs (type_constructor ());
			tc 'K'   =>   lt::tcc_box (type_constructor ());
			tc 'L'   =>   lt::tcc_tuple (tyclist ());
			tc 'M'   =>   lt::tcc_arrow (lt::ffc_var (bool (), bool ()), tyclist (), tyclist ());
			tc 'N'   =>   lt::tcc_arrow (lt::ffc_fixed, tyclist (), tyclist ());
			tc 'O'   =>   lk::type_constructor_inject (lk::TC_EXTENSIBLE_TOKEN (lk::token_key (int ()), type_constructor ()));
			tc _     =>   raise exception FORMAT;
                    end;

		    share tyc_m tc;
		}

	    also
	    fun tyclist ()   =   list tyc_list_m type_constructor ();

	    highcode_variable   =   int;
	    lvarlist          =   list lvar_list_m highcode_variable;

	    fun value ()
                =
                {   fun v 'a' => f::VAR (highcode_variable ());
			v 'b' => f::INT (int ());
			v 'c' => f::INT32 (int32 ());
			v 'd' => f::WORD (word ());
			v 'e' => f::WORD32 (word32 ());
			v 'f' => f::REAL (string ());
			v 'g' => f::STRING (string ());
			v _   => raise exception FORMAT;
                    end;

		    share  value_m  v;
		};

	    valuelist
                =
                list  value_list_m  value;

	    fun con ()
                =
		share  con_m  c
                where

                    fun c '1'
			    =>
			    {   my (dc, ts) = dcon ();

				(   f::DATACON (dc, ts, highcode_variable ()),
				    lambda_expression ()
				);
			    };

			c '2'   =>   (f::INTCON    (int ()),    lambda_expression ());
			c '3'   =>   (f::INT32CON  (int32 ()),  lambda_expression ());
			c '4'   =>   (f::WORDCON   (word ()),   lambda_expression ());
			c '5'   =>   (f::WORD32CON (word32 ()), lambda_expression ());
			c '6'   =>   (f::REALCON   (string ()), lambda_expression ());
			c '7'   =>   (f::STRINGCON (string ()), lambda_expression ());
			c '8'   =>   (f::VLENCON (int ()),      lambda_expression ());
			c _     =>   raise exception FORMAT;
                    end;
		end


	    also
	    fun conlist ()
                =
                list  con_list_m  con  ()


	    also
	    fun dcon ()
                =
		share  dcon_m  d
                where

                    fun d 'x'   =>   ((symbol (), datatype_constructor_representation (), lambda_type ()), tyclist ());
		        d _     =>   raise exception FORMAT;
                    end;
		end


	    also
	    fun dictionary ()
                =
		share  dictionary_m  d
                where
                    fun d 'y'
                        =>
			{   default => highcode_variable (),
			    table   => list dictionary_table_m (pair tyc_lv_pm (tyclist, highcode_variable)) ()
                        };

		        d _ => raise exception FORMAT;
                    end;
		end

	    also
	    fun fprim ()
                =
		share  fprim_m  f
                where

                    fun f 'z' => (option dictionary_option_m dictionary (),
				  primitive_operation (), lambda_type (), tyclist ());
		        f _ => raise exception FORMAT;
                    end;
		end


	    also
	    fun lambda_expression ()
                =
		share  lexp_m  e
                where

                    fun e 'j'   =>   f::RET (valuelist ());
			e 'k'   =>   f::LET (lvarlist (), lambda_expression (), lambda_expression ());
			e 'l'   =>   f::MUTUALLY_RECURSIVE_FNS (fundeclist (), lambda_expression ());
			e 'm'   =>   f::APPLY (value (), valuelist ());
			e 'n'   =>   f::TYPE_FN (tfundec (), lambda_expression ());
			e 'o'   =>   f::TYPE_APPLY (value (), tyclist ());
			e 'p'   =>   f::SWITCH (value (), constructor_signature (), conlist (),
						lexpoption ());
			e 'q'
			 =>
			 {
			     my (dc, ts) = dcon ();

			     f::CONSTRUCTOR (dc, ts, value (), highcode_variable (), lambda_expression ());
			 };

			e 'r'   =>   f::RECORD (record_kind (), valuelist (), highcode_variable (), lambda_expression ());
			e 's'   =>   f::SELECT (value (), int (), highcode_variable (), lambda_expression ());
			e 't'   =>   f::RAISE (value (), ltylist ());
			e 'u'   =>   f::EXCEPT (lambda_expression (), value ());
			e 'v'   =>   f::BRANCH (fprim (), valuelist (), lambda_expression (), lambda_expression ());
			e 'w'   =>   f::PRIMOP (fprim (), valuelist (), highcode_variable (), lambda_expression ());
			e _     =>   raise exception FORMAT;
                    end;
		end


	    also
	    fun lexpoption ()
                =
                option  lexp_option_m  lambda_expression  ()


	    also
	    fun function_declaration ()
                =
		share fundec_m  f
                where
                    fun f 'a'
                        =>
			(fkind (), highcode_variable (),
			 list lv_lt_plm (pair lv_lt_pm (highcode_variable, lambda_type)) (),
			 lambda_expression ());

		        f _ => raise exception FORMAT;
                    end;
		end

	    also
	    fun fundeclist ()
                =
               list  fundec_list_m  function_declaration  ()

	    also
	    fun tfundec ()
                =
		share  tfundec_m  t
                where
                    fun t 'b'
                        =>
                        (   {   inlining_hint => f::INLINE_IF_SIZE_SAFE   },
                            highcode_variable (),
			    list lv_tk_plm (pair lv_tk_pm (highcode_variable, type_kind)) (),
			    lambda_expression ()
                        );

		        t _ => raise exception FORMAT;
                    end;
		end


	    also
	    fun fkind ()
                =
		share  fkind_m  fk
                where

                    fun aug_unknown x
                        =
                        (x, f::OTHER_LOOP);

		    fun inlflag TRUE => f::INLINE_WHENEVER_POSSIBLE;
		        inlflag FALSE => f::INLINE_IF_SIZE_SAFE;
                    end;

		    fun fk '2' => { is_recursive => NULL, calling_convention => f::CALLING_CONVENTION_GENERIC,
				    all_call_sites_known => FALSE, inlining_hint => f::INLINE_IF_SIZE_SAFE };

			fk '3' => { is_recursive => null_or::map aug_unknown (ltylistoption ()),
				     calling_convention => f::CALLING_CONVENTION_FUNCTION (lt::ffc_var (bool (), bool ())),
				     all_call_sites_known => bool (),
				     inlining_hint => inlflag (bool ()) };

			fk '4' => { is_recursive => null_or::map aug_unknown (ltylistoption ()),
				     calling_convention => f::CALLING_CONVENTION_FUNCTION lt::ffc_fixed,
				     all_call_sites_known => bool (),
				     inlining_hint => inlflag (bool ()) };

			fk _ => raise exception FORMAT;
                    end;
		end


	    also
	    fun ltylistoption ()
                =
                option ltylo_m ltylist ()

	    also
	    fun record_kind ()
                =
		share  rkind_m  rk
                where

                    fun rk '5'   =>   f::RK_VECTOR (type_constructor ());
			rk '6'   =>   f::RK_STRUCT;
			rk '7'   =>   anormal_stuff::rk_tuple;
			rk _     => raise exception FORMAT;
                    end;
		end;

	    function_declaration;
	};


    fun unpickle_highcode pickle
        =
        {   session        =   uu::make_session (uu::string_getter (byte::bytes_to_string pickle));
	    shared_stuff   =   make_shared_stuff (session, a::HIGHCODE_VARIABLE);

	    highcode       =   make_highcode_unpickler (session, shared_stuff);
	    fo_m            =   uu::make_map ();

	    uu::read_option session fo_m highcode ();
	};


    fun make_unpicklers session_info unpickling_context
        =
        {   my { session, stringlist } = session_info;

	    shared_stuff = make_shared_stuff (session, a::HIGHCODE_VARIABLE);

	    my { symbol, pid, ... } = shared_stuff;

	    syl_m         =   uu::make_map ();
	    symbollist   =   uu::read_list session syl_m symbol;

	    extra_info = {   global_pid   =>  fn () => raise exception FORMAT; end ,
			        symbollist,
			        shared_stuff,
			        lib         => TRUE
                            };

	    symbol_table = make_symboltable_unpickler extra_info session_info unpickling_context;

	    highcode      =   make_highcode_unpickler (session, shared_stuff);
	    pid_highcode_pm =   uu::make_map ();

	    symbind    =   uu::read_pair session pid_highcode_pm (pid, highcode);
	    sbl_m       =   uu::make_map ();
	    sbl        =   uu::read_list session sbl_m symbind;

	    fun inlining_table ()
                =
                inlining_table::from_listi (sbl ());

	    {   inlining_table,
                symbol_table,

	        symbol,
                symbollist
            };
	};


    unpickle_symboltable
        =
	fn c
           =
           compile_statistics::do_phase
               (compile_statistics::make_phase "Compiler 087 unpickle_symboltable")
	       (unpickle_symboltable c);
};





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################
