## primitives-symbol-table.pkg

# Compiled by:
#     src/lib/compiler/core.make6



# This module defines various foundation-of-the-universe things
# like 'Bool' which must be predefined in order to bootstrap
# everything else.
#
# There is special logic in
#
#     src/app/make7/bootstrap/build-initial-dependency-graph.sml
#
# to make primitives_symbol_table available to
# any module flagged with "primitive" in
#
#     src/lib/core/init/init.cmi
#
# Actually implementing this is done in
#
#     src/app/make7/compile/make-compile-traversal-fn.sml
#
# using the 'extra_static_compile_dictionary' parameter
# hacked in specifically for the purpose.



###                       "I have struck a city -- a real
###                        city -- and they call it Chicago...
###                        I urgently desire never to see it again.
###                        It is inhabited by savages."
###
###                                         -- Rudyard Kipling



api Primitives_Symbol_Table {

    primitives_symbol_table:  symbol_table::Symbol_Table;
};


package primitives_symbol_table

: (weak)  Primitives_Symbol_Table		# Primitives_Symbol_Table	is from   src/lib/compiler/frontend/semantic/symbol-table/primitives-symbol-table.pkg

{
    stipulate
	package s= symbol;			# symbol			is from   src/lib/compiler/frontend/basics/mlcomp/symbol.pkg
	package m= module;			# module			is from   src/lib/compiler/frontend/typecheck-stuff/modules/module.pkg
	package b= symbol_table_entry;		# symbol_table_entry		is from   src/lib/compiler/frontend/typecheck-stuff/symbol-table/symbol-table-entry.pkg
	package sp= symbol_path;		# symbol_path			is from   src/lib/compiler/frontend/typecheck-stuff/basics/symbol-path.pkg
	package ip= inverse_path;		# inverse_path			is from   src/lib/compiler/frontend/typecheck-stuff/basics/symbol-path.pkg
	package se= symbol_table;		# symbol_table			is from   src/lib/compiler/frontend/typecheck-stuff/symbol-table/symbol-table.pkg
	package ee= typechecker_dictionary;	# typechecker_dictionary	is from   src/lib/compiler/frontend/typecheck-stuff/modules/typechecker-dictionary.pkg

	package bt= type_types;			# type_types			is from   src/lib/compiler/frontend/typechecker/types/type-types.pkg
	package t= types;			# types				is from   src/lib/compiler/frontend/typecheck-stuff/types/types.pkg
	package tu= type_stuff;			# type_stuff			is from   src/lib/compiler/frontend/typecheck-stuff/types/type-stuff.pkg
	package mu= module_stuff;		# module_stuff			is from   src/lib/compiler/frontend/typecheck-stuff/modules/module-stuff.pkg
	package p= highcode_primitive_op;	# highcode_primitive_op		is from   src/lib/compiler/backend/upper/highcode/highcode-primitive-op.pkg

	package st= stamp;			# stamp				is from   src/lib/compiler/frontend/typecheck-stuff/basics/stamp.pkg
	package v= variables_and_constructors;	# variables_and_constructors	is from   src/lib/compiler/frontend/typecheck-stuff/deep-syntax/variables-and-constructors.pkg

	package a= var_home;			# var_home			is from   src/lib/compiler/frontend/typecheck-stuff/basics/var-home.pkg
	package ii= inlining_info;		# inlining_info			is from   src/lib/compiler/frontend/semantic/basics/inlining-info.pkg

    herein

	fun make_type_constructor_element (name: String, type_constructor)
            = 
	    (    s::make_type_symbol name,

                 m::TYPE_CONSTRUCTOR_IN_API {

                     module_stamp => st::special name,
                     type_constructor,
                     is_a_replica       => FALSE,
		     scope            => 0
                 }
            );

	# Note: this function only applies to constructors but not exceptions;
	# exceptions will have a non-trivial slot number 

	fun make_constructor_element (name, d)
            = 
	    (   s::make_value_symbol name,
                m::ENUM_CONSTRUCTOR_IN_API {
                    a_datatype => d,
                    slot      => NULL
                }
            );

	# Below there is a bunch of very long list literals which would create
	# huge register pressure on the compiler.  We construct them backwards
	# using an alternative "cons" that takes its two arguments in opposite
	# order.  This effectively puts the lists' ends to the left and alleviates
	# this effect. (Stupid ML trick No. 21b) (Blume, 1/2001)

	infix val  :-: ;				#  inverse . 

	fun l :-: e
            =
            e ! l;

	#  primTypes package 

	prim_types
            =
	    {   prim_tycs
                    =
		    [] :-:
			("Bool",              bt::bool_tycon		) :-:
			("List",              bt::list_tycon		) :-:
			#	
			("Ref",               bt::ref_tycon		) :-:
			("Void",              bt::void_tycon		) :-:
			#	
			("Int",               bt::int_tycon		) :-:
			("Int32",             bt::int32tycon		) :-:
			("Int64",             bt::int64tycon		) :-:
			("Intinf",            bt::intinf_tycon		) :-:
			#	
			("Float",             bt::real_tycon		) :-:
			#	
			("Unt",               bt::word_tycon		) :-:
			("Unt8",              bt::word8tycon		) :-:
			("Unt32",             bt::word32tycon		) :-:
			("Unt64",             bt::word64tycon		) :-:
			#	
			("Fate",		     bt::fate_type	) :-:
			("Control_Fate",      bt::control_fate_type	) :-:
			#	
			("Rw_Vector",         bt::array_tycon		) :-:
			("Vector",            bt::vector_tycon		) :-:
			("Unt8_Rw_Vector",    bt::word8array_tycon	) :-:
			("Float64_Rw_Vector", bt::real64array_tycon	) :-:
			#	
			("Chunk",             bt::chunk_tycon		) :-:
			("Cfunction",         bt::c_function_tycon	) :-:
			#	
			("String",            bt::string_tycon		) :-:
			("Char",              bt::char_tycon		) :-:
			#	
			("Exception",         bt::exn_tycon		) :-:
			#	
			("Spin_Lock",         bt::spinlock_tycon	) :-:
			("Fragment",          bt::frag_tycon		) :-:
			("Suspension",        bt::susp_tycon		)
		;

		prim_cons
                    = 
		    [] :-:
			("TRUE",      bt::true_dcon	) :-:
			("FALSE",     bt::false_dcon	) :-:
			("!",         bt::cons_dcon	) :-:
			#	
			("NIL",       bt::nil_dcon	) :-:
			("REF",       bt::ref_dcon	) :-:
			#	
			("QUOTE",     bt::quotedcon	) :-:
			("ANTIQUOTE", bt::antiquotedcon	) :-:
			("@@@",       bt::dollar_dcon	)
		;

		    # To do:
		    #
		    # At some point it would be nice to have
		    # Ro_Ref -- a read-only version of Ref where
		    #
		    #     *ref
		    #
		    # is allowed but not
		    #
		    #     ref := ... ;
		    #
		    # In concurrent code, this would allow us to publish stuff
		    # via an Ro_Ref while having typesafe assurance that the
		    # the single thread retaining a Ref version of the refcell
		    # is the only one entitled to modify it.  This would provide
		    # essentially a lighter weight alternative to Maildrop.
		    # 
		    # Presumably we would do this by doing
		    #     Ro_Ref = Ref;	# Probably at a higher level than this file
		    # and then exporting Ro_Ref as opaque plus
		    # exporting a Ref -> Ro_Ref cast operator
		    # together with dereference ops on both types
		    # and finally making prefix '*' overloaded on both deref ops...?
		    # 
		    # XXX BUGGO FIXME.



		tyc_elements   =   map make_type_constructor_element prim_tycs;
		con_elements   =   map make_constructor_element      prim_cons;

		all_elements   =   tyc_elements @ con_elements;
		all_symbols    =   map #1 all_elements;

		typechecker_dictionary
                    =
                    { fun f ((_, m::TYPE_CONSTRUCTOR_IN_API { type_constructor, module_stamp, is_a_replica, scope } ), r)
                            =>
			    ee::set (r, module_stamp, m::TYPE_CONSTRUCTOR_ENTRY type_constructor);

			   f _
                            =>
                            error_message::impossible "primTypes: typechecker_dictionary";
                       end;
		    
		       fold_right f ee::empty tyc_elements;
		    };

		typechecker_dictionary
                    =
                    typechecker_dictionary::mark (fn _ => st::special"primMacroExpansionDict"; end, typechecker_dictionary);

		api_record
		    = 
		    {   stamp  =>   st::special "Primitive_Types_Apig",
			name   =>   THE (s::make_api_symbol "Primitive_Types"), closed=>TRUE,


			symbols     =>  all_symbols,
                        elements    =>  all_elements,

			contains_generic  => FALSE,
			type_sharing      =>  NIL,
                        package_sharing   =>  NIL,

			property_list  =>  property_list::make_property_list (),
			stub           =>  NULL
		    };

									     
		package_property_lists::set_api_bound_generic_evaluation_paths (api_record, THE []);

		package_record
		    =
		    {   an_api => m::API api_record,
		        var_home       => a::null_var_home,
		        inlining_info   => ii::make_package_info [],

		        typechecked_package  => { stamp           => st::special "primitive_types_package",
					         stub             => NULL,
					         typechecker_dictionary,

					         property_list    => property_list::make_property_list (),
					         inverse_path     => ip::INVERSE_PATH [s::make_package_symbol "primitive_types"]
				               }
		    };
	    
		m::A_PACKAGE package_record;

	    }; #  primTypes 


	/**************************************************************************
	 *                 BUILDING A COMPLETE LIST OF PRIMOPS                    *
	 **************************************************************************/

	stipulate

	    fun bits size oper   =   p::ARITH { oper, overflow=>FALSE, kind=>p::INT size };
	    bits31 = bits 31;		
	    bits32 = bits 32;		

	    fun int size oper    =   p::ARITH { oper, overflow=>TRUE, kind=>p::INT size };
	    int31 = int 31;
	    int32 = int 32;

	    fun word size oper   =   p::ARITH { oper, overflow=>FALSE, kind=>p::UINT size };
	    word32 = word 32;
	    word31 = word 31;
	    word8  = word 8;

	    fun purefloat size oper   =   p::ARITH { oper, overflow=>FALSE, kind=>p::FLOAT size };
	    purefloat64 = purefloat 64;	

	    fun cmp kind oper   =   p::CMP { oper, kind };
	    int31cmp = cmp (p::INT 31);
	    int32cmp = cmp (p::INT 32);

	    word32cmp = cmp (p::UINT 32);
	    word31cmp = cmp (p::UINT 31);
	    word8cmp  = cmp (p::UINT 8);

	    float64cmp = cmp (p::FLOAT 64);

	    v1 = t::TYPE_SCHEME_ARG_I 0;
	    v2 = t::TYPE_SCHEME_ARG_I 1;
	    v3 = t::TYPE_SCHEME_ARG_I 2;

	    tu = bt::tuple_type;
	    fun arrow (t1, t2) = bt::(-->) (t1, t2);

	    fun ap (tc, l) = t::CONSTRUCTOR_TYPE (tc, l);
	    fun count t      = t::CONSTRUCTOR_TYPE (bt::fate_type,   [t]);
	    fun ccnt t     = t::CONSTRUCTOR_TYPE (bt::control_fate_type,  [t]);

	    fun rf t      = t::CONSTRUCTOR_TYPE (bt::ref_tycon,    [t]);
	    fun ay t      = t::CONSTRUCTOR_TYPE (bt::array_tycon,  [t]);
	    fun vct t     = t::CONSTRUCTOR_TYPE (bt::vector_tycon, [t]);

	    u   = bt::void_type;
	    bo  = bt::bool_type;
	    i   = bt::int_type;

	    i32 = bt::int32type;
	    i64 = bt::int64type;
	    inf = bt::big_int_type;

	    w8  = bt::word8type;
	    w   = bt::word_type;
	    w32 = bt::word32type;

	    w64 = bt::word64type;
	    f64 = bt::real_type;
	    s   = bt::string_type;

	    fun p0  t   =   t;

	    fun p1 t
                =
                t::TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties => [FALSE],             type_scheme=>t::TYPE_SCHEME { arity=>1, body=>t }};

	    fun ep1 t
                =
                t::TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties => [TRUE],              type_scheme=>t::TYPE_SCHEME { arity=>1, body=>t }};

	    fun p2 t
                =
                t::TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties => [FALSE, FALSE],       type_scheme=>t::TYPE_SCHEME { arity=>2, body=>t }};

	    fun p3 t
                =
                t::TYPE_SCHEME_TYPE { type_scheme_arg_eq_properties => [FALSE, FALSE, FALSE], type_scheme=>t::TYPE_SCHEME { arity=>3, body=>t }};

	    fun sub kind        =  p::NUMSUBSCRIPT { kind, checked=>FALSE, immutable=>FALSE };
	    fun check_sub kind    =  p::NUMSUBSCRIPT { kind, checked=>TRUE,  immutable=>FALSE };

	    fun subv kind       =  p::NUMSUBSCRIPT { kind, checked=>FALSE, immutable=>TRUE };
	    fun check_subv kind   =  p::NUMSUBSCRIPT { kind, checked=>TRUE,  immutable=>TRUE };

	    fun update kind     =  p::NUMUPDATE { kind, checked=>FALSE };
	    fun check_update kind =  p::NUMUPDATE { kind, checked=>TRUE  };

	    num_sub_type   =   p2 (arrow (tu [v1, i],    v2));
	    num_upd_type   =   p2 (arrow (tu [v1, i, v2], u ));

	    fun unf     t = p0 (arrow (t, t));
	    fun binf    t = p0 (arrow (tu [t, t], t));
	    fun binp    t = p0 (arrow (tu [t, t], bo));
	    fun shifter t = p0 (arrow (tu [t, w], t));

	    w32_i32  = p0 (arrow (w32, i32));
	    w32_f64  = p0 (arrow (w32, f64));
	    w32w32_u = p0 (arrow (tu [w32, w32], u));
	    w32i32_u = p0 (arrow (tu [w32, i32], u));
	    w32f64_u = p0 (arrow (tu [w32, f64], u));

	    i_x       = p1 (arrow (i, v1));
	    xw32_w32  = p1 (arrow (tu [v1, w32], w32));
	    xw32_i32  = p1 (arrow (tu [v1, w32], i32));
	    xw32_f64  = p1 (arrow (tu [v1, w32], f64));
	    xw32w32_u = p1 (arrow (tu [v1, w32, w32], u));
	    xw32i32_u = p1 (arrow (tu [v1, w32, i32], u));
	    xw32f64_u = p1 (arrow (tu [v1, w32, f64], u));

	    b_b = unf bo;

	    f64_i = p0 (arrow (f64, i));
	    i_f64 = p0 (arrow (i, f64));
	    i32_f64 = p0 (arrow (i32, f64));

	    w32_i = p0 (arrow (w32, i));
	    i32_i = p0 (arrow (i32, i));

	    i_i32 = p0 (arrow (i, i32));
	    i_w32 = p0 (arrow (i, w32));

	    w32_w = p0 (arrow (w32, w));
	    i32_w = p0 (arrow (i32, w));

	    w_w32 = p0 (arrow (w, w32));
	    w_i32 = p0 (arrow (w, i32));

	    w_i = p0 (arrow (w, i));
	    i_w = p0 (arrow (i, w));

	    w32_i32 = p0 (arrow (w32, i32));
	    i32_w32 = p0 (arrow (i32, w32));

	    i_i  = unf i;
	    ii_i = binf i;
	    ii_b = binp i;
	    iw_i = shifter i;

	    w_w  = unf w;
	    ww_w = binf w;
	    ww_b = binp w;

	    i32_i32    = unf i32;
	    i32i32_i32 = binf i32;
	    i32i32_b   = binp i32;

	    w32_w32    = unf w32;
	    w32w32_w32 = binf w32;
	    w32w32_b   = binp w32;
	    w32w_w32   = shifter w32;

	    w8_w8   = unf w8;
	    w8w8_w8 = binf w8;
	    w8w8_b  = binp w8;
	    w8w_w8  = shifter w8;

	    f64_f64    = unf f64;
	    f64f64_f64 = binf f64;
	    f64f64_b   = binp f64;

	    w8_i   = p0 (arrow (w8, i));
	    w8_i32 = p0 (arrow (w8, i32));
	    w8_w32 = p0 (arrow (w8, w32));
	    i_w8   = p0 (arrow (i, w8));
	    i32_w8 = p0 (arrow (i32, w8));
	    w32_w8 = p0 (arrow (w32, w8));

	    inf_i   = p0 (arrow (inf, i));
	    inf_i32 = p0 (arrow (inf, i32));
	    inf_i64 = p0 (arrow (inf, i64));
	    inf_w8  = p0 (arrow (inf, w8));
	    inf_w   = p0 (arrow (inf, w));
	    inf_w32 = p0 (arrow (inf, w32));
	    inf_w64 = p0 (arrow (inf, w64));
	    i_inf   = p0 (arrow (i, inf));
	    i32_inf = p0 (arrow (i32, inf));
	    i64_inf = p0 (arrow (i64, inf));
	    w8_inf  = p0 (arrow (w8, inf));
	    w_inf   = p0 (arrow (w, inf));
	    w32_inf = p0 (arrow (w32, inf));
	    w64_inf = p0 (arrow (w64, inf));

	    w64_pw32 = p0 (arrow (w64, tu [w32, w32]));
	    pw32_w64 = p0 (arrow (tu [w32, w32], w64));
	    i64_pw32 = p0 (arrow (i64, tu [w32, w32]));
	    pw32_i64 = p0 (arrow (tu [w32, w32], i64));

	    cc_b = binp bt::char_type;

	    # The type of the RAW_CCALL primitive_operation is
	    # (so far as the type checker is concerned):
	    #
	    #    word32 * X * Y -> W
	    #
	    # However, the primitive_operation cannot be used without having X, Y, and Z
	    # monomorphically macro expanded.  In particular, X will be the type of the
	    # ML argument list, Z will be the type of the result, and Y
	    # will be a type of a fake arguments.  The idea is that Y will be
	    # macro expanded with some ML type that encodes the type of the actual
	    # C function in order to be able to generate code according to the C
	    # calling convention.
	    # (In other words, Y will be a completely ad-hoc encoding of a CTypes.c_proto
	    # value in ML types.  The encoding also contains information about
	    # calling conventions and reentrancy.)
	    #
	    rcc_type = p3 (arrow (tu [w32, v1, v2], v3));

	herein

	    # I made an effort to eliminate the cases where type info for primops
	    # is left NULL because this is, in fact, incorrect.  (As long as they
	    # are left at NULL, there are correct ML programs that trigger internal
	    # compiler errors.)
            # 
	    #                                    - Matthias Blume (1/2001)


	    all_primops 
                =
		[] :-:
		   ("callcc",	 p::CALLCC,     	p1 (arrow (arrow (count (v1), v1), v1))) :-:
		   ("throw",	 p::THROW,      	p2 (arrow (count (v1), arrow (v1, v2)))) :-:
		   ("capture",	 p::CAPTURE,    	p1 (arrow (arrow (ccnt (v1), v1), v1))) :-:
		   ("isolate",	 p::ISOLATE,    	p1 (arrow (arrow (v1, u), count (v1)))) :-:
		   ("cthrow",	 p::THROW,      	p2 (arrow (ccnt (v1), arrow (v1, v2)))) :-:
		   (":=",	 p::ASSIGN,     	p1 (arrow (tu [rf (v1), v1], u))) :-:
		   ("deref",	 p::DEREF,      	p1 (arrow (rf (v1), v1))) :-:
		   ("makeref",	 p::MAKEREF,    	p1 (arrow (v1, rf (v1)))) :-:
		   ("boxed",	 p::BOXED,      	p1 (arrow (v1, bo))) :-:
		   ("unboxed",	 p::UNBOXED,    	p1 (arrow (v1, bo))) :-:
		   ("cast",	 p::CAST,      		p2 (arrow (v1, v2))) :-:
		   ("==",	 p::POLYEQL,    	ep1 (arrow (tu [v1, v1], bo))) :-:
		   ("!=",	 p::POLYNEQ,    	ep1 (arrow (tu [v1, v1], bo))) :-:
		   ("ptreql",	 p::PTREQL,     	p1 (arrow (tu [v1, v1], bo))) :-:
		   ("ptrneq",	 p::PTRNEQ,     	p1 (arrow (tu [v1, v1], bo))) :-:

		   ("get_current_thread_register",	p::GET_CURRENT_THREAD_REGISTER,     p1 (arrow (u, v1))) :-:			# Get threadkit's reserved 'current thread' register (see src/lib/compiler/codegen/x86/x86-fps-registers.pkg)
		   ("set_current_thread_register",	p::SET_CURRENT_THREAD_REGISTER,     p1 (arrow (v1, u))) :-:			# Set threadkit's reserved 'current thread' register (see src/lib/compiler/codegen/x86/x86-fps-registers.pkg)

		   ("setpseudo", p::SETPSEUDO,  	p1 (arrow (tu [v1, i], u))) :-:
		   ("getpseudo", p::GETPSEUDO,  	p1 (arrow (i, v1))) :-:
		   ("make_special", p::MAKE_SPECIAL,	p2 (arrow (tu [i, v1], v2))) :-:
		   ("getspecial", p::GETSPECIAL, 	p1 (arrow (v1, i))) :-:
		   ("setspecial", p::SETSPECIAL, 	p1 (arrow (tu [v1, i], u))) :-:
		   ("gethandler",	 p::GETHANDLER,    p1 (arrow (u, count (v1)))) :-:
		   ("sethandler",	 p::SETHANDLER,    p1 (arrow (count (v1), u))) :-:
		   ("gettag", 	 p::GETTAG,     p1 (arrow (v1, i))) :-:
		   ("setmark",	 p::SETMARK,    p1 (arrow (v1, u))) :-:
		   ("dispose",	 p::DISPOSE,    p1 (arrow (v1, u))) :-:
		   ("compose",	 p::INLCOMPOSE, p3 (arrow (tu [arrow (v2, v3), arrow (v1, v2)], arrow (v1, v3)))) :-:
		   ("before",	 p::INLBEFORE,  p2 (arrow (tu [v1, v2], v1))) :-:
		   ("ignore",    p::INLIGNORE,  p1 (arrow (v1, u))) :-:
		   ("identity",  p::INLIDENTITY, p1 (arrow (v1, v1))) :-:


		   ("length",	   p::LENGTH,     	p1 (arrow (v1, i))) :-:
		   ("chunklength", p::CHUNKLENGTH,	p1 (arrow (v1, i))) :-:

		   # I believe the following five primops should not be exported into
		   # the inline package. (ZHONG) 

		   # So we take them out... (Matthias)

#		   ("boxedupdate",	 p::BOXED_SET,   ?) :-:
#		   ("getrunvec",	 p::GETRUNVEC,     ?) :-:
#		   ("uselvar",		 p::USELVAR,       ?) :-:
#		   ("deflvar",		 p::DEFLVAR,       ?) :-:




		   # I put this one back in so tprof can find it in _Core
		   # instead of having to construct it ... (Matthias)


		   ("unboxed_set", p::UNBOXED_SET, p1 (arrow (tu [ay (v1), i, v1], u))) :-:



		   ("inlnot",	     p::INLNOT,      	        b_b) :-:
		   ("floor",         p::ROUND { floor=>TRUE,
					   fromkind=>p::FLOAT 64,
					   tokind=>p::INT 31 },      	f64_i) :-:
		   ("round",         p::ROUND { floor=>FALSE, 
					   fromkind=>p::FLOAT 64,
					   tokind=>p::INT 31 },      	f64_i) :-:
		   ("real",          p::REAL { fromkind=>p::INT 31,
					  tokind=>p::FLOAT 64 },      	i_f64) :-:
		   ("real32",        p::REAL { fromkind=>p::INT 32,
					    tokind=>p::FLOAT 64 },     i32_f64) :-:

		   ("ordof",         p::NUMSUBSCRIPT { kind=>p::INT 8,
						  checked=>FALSE,
						  immutable=>TRUE },  num_sub_type) :-:
		   ("store",         p::NUMUPDATE { kind=>p::INT 8,
					       checked=>FALSE },      num_upd_type) :-:
		   ("inlbyteof",     p::NUMSUBSCRIPT { kind=>p::INT 8,
						  checked=>TRUE,
						  immutable=>FALSE }, num_sub_type) :-:
		   ("inlstore",      p::NUMUPDATE { kind=>p::INT 8,
					       checked=>TRUE },      	num_upd_type) :-:
		   ("inlordof",      p::NUMSUBSCRIPT { kind=>p::INT 8,
						  checked=>TRUE,
						  immutable=>TRUE },  num_sub_type) :-:

		   # Polymorphic rw_vector and vector:
		   #
		   ("mkarray",           p::INLMKARRAY,         p1 (arrow (tu [i, v1], ay (v1)))) :-:
		   ("rw_vec_get", 	 p::SUBSCRIPT,      	p1 (arrow (tu [ay (v1), i], v1))) :-:
		   ("safe_rw_vec_get",	 p::INLSUBSCRIPT,      	p1 (arrow (tu [ay (v1), i], v1))) :-:
		   ("vec_get",	 	 p::SUBSCRIPTV,      	p1 (arrow (tu [vct (v1), i], v1))) :-:
		   ("safe_vec_get",	 p::INLSUBSCRIPTV,     	p1 (arrow (tu [vct (v1), i], v1))) :-:
		   ("rw_vec_set",	 p::UPDATE,      	p1 (arrow (tu [ay (v1), i, v1], u))) :-:
		   ("safe_rw_vec_set",   p::INLUPDATE,      	p1 (arrow (tu [ay (v1), i, v1], u))) :-:

		   # New rw_vector representations:
		   #
		   ("new_array0",	p::NEW_ARRAY0,		p1 (arrow (u, v1))) :-:
		   ("get_seq_data",	p::GET_SEQ_DATA,	p2 (arrow (v1, v2))) :-:
		   ("record_get",	p::SUBSCRIPT_REC,	p2 (arrow (tu [v1, i], v2))) :-:
		   ("raw64_get",	p::SUBSCRIPT_RAW64,	p1 (arrow (tu [v1, i], f64))) :-:

		   # Conversion primops.
		   # There are certain duplicates for the same
                   # primitive_operation (but with different types).
                   # In such a case, the "canonical" name of the
                   # primitive_operation has been extended using
		   # a simple suffix scheme:
		   #
		   ("test_32_31_w",  p::TEST (32, 31),  	w32_i) :-:
		   ("test_32_31_i",  p::TEST (32, 31),  	i32_i) :-:

		   ("testu_31_31",   p::TESTU (31, 31),      w_i) :-:

		   ("testu_32_31",   p::TESTU (32, 31),      w32_i) :-:

		   ("testu_32_32",   p::TESTU (32, 32),   	w32_i32) :-:

		   ("copy_32_32_ii", p::COPY (32, 32),   	i32_i32) :-:
		   ("copy_32_32_wi", p::COPY (32, 32),   	w32_i32) :-:
		   ("copy_32_32_iw", p::COPY (32, 32),   	i32_w32) :-:
		   ("copy_32_32_ww", p::COPY (32, 32),   	w32_w32) :-:

		   ("copy_31_31_ii", p::COPY (31, 31),   	i_i) :-:
		   ("copy_31_31_wi", p::COPY (31, 31),   	w_i) :-:
		   ("copy_31_31_iw", p::COPY (31, 31),   	i_w) :-:

		   ("copy_31_32_i",  p::COPY (31, 32),   	w_i32) :-:
		   ("copy_31_32_w",  p::COPY (31, 32),   	w_w32) :-:

		   ("copy_8_32_i",   p::COPY (8, 32),     	w8_i32) :-:
		   ("copy_8_32_w",   p::COPY (8, 32),     	w8_w32) :-:

		   ("copy_8_31",     p::COPY (8, 31),     	w8_i) :-:

		   ("extend_31_32_ii", p::EXTEND (31, 32), 	i_i32) :-:
		   ("extend_31_32_iw", p::EXTEND (31, 32), 	i_w32) :-:
		   ("extend_31_32_wi", p::EXTEND (31, 32), 	w_i32) :-:
		   ("extend_31_32_ww", p::EXTEND (31, 32), 	w_w32) :-:

		   ("extend_8_31",   p::EXTEND (8, 31),   	w8_i) :-:

		   ("extend_8_32_i", p::EXTEND (8, 32), 	w8_i32) :-:
		   ("extend_8_32_w", p::EXTEND (8, 32), 	w8_w32) :-:

		   ("trunc_32_31_i", p::TRUNC (32, 31),   	i32_w) :-:
		   ("trunc_32_31_w", p::TRUNC (32, 31),   	w32_w) :-:

		   ("trunc_31_8",    p::TRUNC (31, 8),   	i_w8) :-:

		   ("trunc_32_8_i",  p::TRUNC (32, 8),   	i32_w8) :-:
		   ("trunc_32_8_w",  p::TRUNC (32, 8),   	w32_w8) :-:

		   #  Conversion primops involving intinf 
		   ("test_inf_31",   p::TEST_INF 31,         inf_i)   :-:
		   ("test_inf_32",   p::TEST_INF 32,         inf_i32) :-:
		   ("test_inf_64",   p::TEST_INF 64,         inf_i64) :-:
		   ("copy_8_inf",    p::COPY_INF 8,          w8_inf)  :-:
		   ("copy_8_inf_w",  p::COPY_INF 8,          w8_inf)  :-:
		   ("copy_31_inf_w", p::COPY_INF 31,         w_inf)   :-:
		   ("copy_32_inf_w", p::COPY_INF 32,         w32_inf) :-:
		   ("copy_64_inf_w", p::COPY_INF 64,         w64_inf) :-:
		   ("copy_31_inf_i", p::COPY_INF 31,         i_inf)   :-:
		   ("copy_32_inf_i", p::COPY_INF 32,         i32_inf) :-:
		   ("copy_64_inf_i", p::COPY_INF 64,         i64_inf) :-:
		   ("extend_8_inf",  p::EXTEND_INF 8,        w8_inf)  :-:
		   ("extend_8_inf_w",  p::EXTEND_INF 8,      w8_inf)  :-:
		   ("extend_31_inf_w", p::EXTEND_INF 31,     w_inf) :-:
		   ("extend_32_inf_w", p::EXTEND_INF 32,     w32_inf) :-:
		   ("extend_64_inf_w", p::EXTEND_INF 64,     w64_inf) :-:
		   ("extend_31_inf_i", p::EXTEND_INF 31,     i_inf) :-:
		   ("extend_32_inf_i", p::EXTEND_INF 32,     i32_inf) :-:
		   ("extend_64_inf_i", p::EXTEND_INF 64,     i64_inf) :-:
		   ("trunc_inf_8",   p::TRUNC_INF 8,         inf_w8)  :-:
		   ("trunc_inf_31",  p::TRUNC_INF 31,        inf_w) :-:
		   ("trunc_inf_32",  p::TRUNC_INF 32,        inf_w32) :-:
		   ("trunc_inf_64",  p::TRUNC_INF 64,        inf_w64) :-:

		   # Primops to go between abstract and concrete
		   # representations of 64-bit ints and words:
		   #
		   ("w64p",          p::CVT64,               w64_pw32) :-:
		   ("p64w",          p::CVT64,               pw32_w64) :-:
		   ("i64p",          p::CVT64,               i64_pw32) :-:
		   ("p64i",          p::CVT64,               pw32_i64) :-:

		   # Integer 31 primops.
		   #   Many of the i31 primops are being abused for different types
		   #   (mostly unt8::word and also for char).  In these cases
		   #   there are suffixed alternative versions of the primitive_operation
		   #   (i.e., same primitive_operation, different type).
		   #
		   ("i31add", 	 int31 p::ADD,      	ii_i) :-:
		   ("i31add_8", 	 int31 p::ADD,      	w8w8_w8) :-:

		   ("i31sub",	 int31 p::SUBTRACT,      	ii_i) :-:
		   ("i31sub_8",	 int31 p::SUBTRACT,      	w8w8_w8) :-:

		   ("i31mul",	 int31 p::MULTIPLY,      	ii_i) :-:
		   ("i31mul_8",	 int31 p::MULTIPLY,      	w8w8_w8) :-:

		   ("i31div",	 int31 p::DIV,      	ii_i) :-:
		   ("i31div_8",	 int31 p::DIV,      	w8w8_w8) :-:

		   ("i31mod",        int31 p::MOD,      	ii_i) :-:
		   ("i31mod_8",      int31 p::MOD,           w8w8_w8) :-:

		   ("i31quot",	 int31 p::DIVIDE,      	ii_i) :-:

		   ("i31rem",	 int31 p::REM,      	ii_i) :-:

		   ("i31orb",	 bits31 p::BITWISEOR,      	ii_i) :-:
		   ("i31orb_8",	 bits31 p::BITWISEOR,      	w8w8_w8) :-:

		   ("i31andb",	 bits31 p::BITWISEAND,      	ii_i) :-:
		   ("i31andb_8",	 bits31 p::BITWISEAND,      	w8w8_w8) :-:

		   ("i31xorb",	 bits31 p::BITWISEXOR,      	ii_i) :-:
		   ("i31xorb_8",	 bits31 p::BITWISEXOR,      	w8w8_w8) :-:

		   ("i31notb",	 bits31 p::BITWISENOT,      	i_i) :-:
		   ("i31notb_8",	 bits31 p::BITWISENOT,      	w8_w8) :-:

		   ("i31neg",	 int31 p::NEGATE,      	i_i) :-:
		   ("i31neg_8",	 int31 p::NEGATE,      	w8_w8) :-:

		   ("i31lshift",	 bits31 p::LSHIFT,      	ii_i) :-:
		   ("i31lshift_8",	 bits31 p::LSHIFT,      	w8w_w8) :-:

		   ("i31rshift",	 bits31 p::RSHIFT,      	ii_i) :-:
		   ("i31rshift_8",	 bits31 p::RSHIFT,      	w8w_w8) :-:

		   ("i31lt",	 int31cmp p::LT,		ii_b) :-:
		   ("i31lt_8",	 int31cmp p::LT,		w8w8_b) :-:
		   ("i31lt_c",	 int31cmp p::LT,		cc_b) :-:

		   ("i31le",	 int31cmp p::LE,		ii_b) :-:
		   ("i31le_8",	 int31cmp p::LE,		w8w8_b) :-:
		   ("i31le_c",	 int31cmp p::LE,		cc_b) :-:

		   ("i31gt",	 int31cmp p::GT,		ii_b) :-:
		   ("i31gt_8",	 int31cmp p::GT,		w8w8_b) :-:
		   ("i31gt_c",	 int31cmp p::GT,		cc_b) :-:

		   ("i31ge", 	 int31cmp p::GE,		ii_b) :-:
		   ("i31ge_8", 	 int31cmp p::GE,		w8w8_b) :-:
		   ("i31ge_c", 	 int31cmp p::GE,		cc_b) :-:

		   ("i31ltu",	 word31cmp p::LTU,      	ii_b) :-:
		   ("i31geu",	 word31cmp p::GEU,      	ii_b) :-:
		   ("i31eq",	 int31cmp p::EQL,      	ii_b) :-:
		   ("i31ne",	 int31cmp p::NEQ,      	ii_b) :-:

		   ("i31min",	 p::INLMIN (p::INT 31),  	ii_i) :-:
		   ("i31min_8",	 p::INLMIN (p::INT 31),  	w8w8_w8) :-:
		   ("i31max",	 p::INLMAX (p::INT 31),  	ii_i) :-:
		   ("i31max_8",	 p::INLMAX (p::INT 31),  	w8w8_w8) :-:

		   ("i31abs",	 p::INLABS (p::INT 31), 	i_i) :-:

		   # Integer 32 primops.
		   #
		   ("i32mul",        int32 p::MULTIPLY,      	i32i32_i32) :-:
		   ("i32div",        int32 p::DIV,      	i32i32_i32) :-:
		   ("i32mod",        int32 p::MOD,      	i32i32_i32) :-:
		   ("i32quot",       int32 p::DIVIDE,      	i32i32_i32) :-:
		   ("i32rem",        int32 p::REM,      	i32i32_i32) :-:
		   ("i32add",        int32 p::ADD,      	i32i32_i32) :-:
		   ("i32sub",        int32 p::SUBTRACT,      	i32i32_i32) :-:
		   ("i32orb",        bits32 p::BITWISEOR,      	i32i32_i32) :-:
		   ("i32andb",       bits32 p::BITWISEAND,      	i32i32_i32) :-:
		   ("i32xorb",       bits32 p::BITWISEXOR,      	i32i32_i32) :-:
		   ("i32lshift",     bits32 p::LSHIFT,      	i32i32_i32) :-:
		   ("i32rshift",     bits32 p::RSHIFT,      	i32i32_i32) :-:
		   ("i32neg",        int32 p::NEGATE,      	i32_i32) :-:
		   ("i32lt",         int32cmp p::LT,		i32i32_b) :-:
		   ("i32le",         int32cmp p::LE,		i32i32_b) :-:
		   ("i32gt",         int32cmp p::GT,		i32i32_b) :-:
		   ("i32ge",         int32cmp p::GE,		i32i32_b) :-:
		   ("i32eq",         int32cmp p::EQL,		i32i32_b) :-:
		   ("i32ne",         int32cmp p::NEQ,		i32i32_b) :-:

		   ("i32min",	 p::INLMIN (p::INT 32),  	i32i32_i32) :-:
		   ("i32max",	 p::INLMAX (p::INT 32),  	i32i32_i32) :-:
		   ("i32abs",	 p::INLABS (p::INT 32), 	i32_i32) :-:

		   # Float 64 primops:
		   #
		   ("f64add", 	 purefloat64 (p::ADD ),   	f64f64_f64) :-:
		   ("f64sub",	 purefloat64 (p::SUBTRACT ),	f64f64_f64) :-:
		   ("f64div", 	 purefloat64 (p::DIVIDE),	f64f64_f64) :-:
		   ("f64mul",	 purefloat64 (p::MULTIPLY),	f64f64_f64) :-:
		   ("f64neg",	 purefloat64 p::NEGATE,		f64_f64) :-:
		   ("f64ge",	 float64cmp (p::GE),		f64f64_b) :-:
		   ("f64gt",	 float64cmp (p::GT),		f64f64_b) :-:
		   ("f64le",	 float64cmp (p::LE),		f64f64_b) :-:
		   ("f64lt",	 float64cmp (p::LT),		f64f64_b) :-:
		   ("f64eq",	 float64cmp p::EQL,		f64f64_b) :-:
		   ("f64ne",	 float64cmp p::NEQ,		f64f64_b) :-:
		   ("f64abs",	 purefloat64 p::ABS,		f64_f64) :-:

		   ("f64sin",	 purefloat64 p::FSIN,		f64_f64) :-:
		   ("f64cos",	 purefloat64 p::FCOS,		f64_f64) :-:
		   ("f64tan",	 purefloat64 p::FTAN,		f64_f64) :-:
		   ("f64sqrt",	 purefloat64 p::FSQRT,		f64_f64) :-:

		   ("f64min",	 p::INLMIN (p::FLOAT 64),	f64f64_f64) :-:
		   ("f64max",	 p::INLMAX (p::FLOAT 64),	f64f64_f64) :-:

		   # Float64 rw_vector:
		   #
		   ("f64_sub",	 sub (p::FLOAT 64),       num_sub_type) :-:
		   ("f64chk_sub",	 check_sub (p::FLOAT 64),    num_sub_type) :-:
		   ("f64_update",	 update (p::FLOAT 64),    num_upd_type) :-:
		   ("f64chk_update",  check_update (p::FLOAT 64), num_upd_type) :-:

		   # ** word8 primops **


		   # In the long run, we plan to represent WRAPPED word8 tagged, and 
		   # UNWRAPPED untagged. But right now, we represent both of them 
		   # tagged, with 23 high-order zero bits and 1 low-order 1 bit.
		   # In this representation, we can use the comparison and (some of 
		   # the) bitwise operators of word31; but we cannot use the shift 
		   # and arithmetic operators.
		   #
		   # WARNING: THIS IS A TEMPORARY HACKJOB until all the word8 primops 
		   # are correctly implemented.	XXX BUGGO FIXME
		   #
		   # ("w8mul",	word8 (p::MULTIPLY),      	w8w8_w8) :-:
		   # ("w8div",	word8 (p::DIVIDE),      	w8w8_w8) :-:
		   # ("w8add",	word8 (p::ADD ),      	w8w8_w8) :-:
		   # ("w8sub",	word8 (p::SUBTRACT ),      	w8w8_w8) :-:
		   #		
		   # ("w8notb",	word31 p::BITWISENOT,      	w8_w8) :-:
		   # ("w8rshift",	word8 p::RSHIFT,      	w8w_w8) :-:
		   # ("w8rshiftl",	word8 p::RSHIFTL,      	w8w_w8) :-:
		   # ("w8lshift",	word8 p::LSHIFT,      	w8w_w8) :-:
		   #
		   # ("w8toint",   p::ROUND { floor=TRUE, 
		   #                     fromkind=p::UINT 8, 
		   #                     tokind=p::INT 31 },   w8_i) :-:
		   # ("w8fromint", p::REAL { fromkind=p::INT 31,
		   #                    tokind=p::UINT 8 },    i_w8) :-:


		   ("w8orb",	word31 p::BITWISEOR,      	w8w8_w8) :-:
		   ("w8xorb",	word31 p::BITWISEXOR,      	w8w8_w8) :-:
		   ("w8andb",	word31 p::BITWISEAND,      	w8w8_w8) :-:

		   ("w8gt",	        word8cmp p::GT,           w8w8_b) :-:
		   ("w8ge",	        word8cmp p::GE,          w8w8_b) :-:
		   ("w8lt",	        word8cmp p::LT,           w8w8_b) :-:
		   ("w8le",		word8cmp p::LE,          w8w8_b) :-:
		   ("w8eq",		word8cmp p::EQL,      	w8w8_b) :-:
		   ("w8ne",		word8cmp p::NEQ,      	w8w8_b) :-:

		   # ** word8 rw_vector and vector **
		   ("w8_sub",	sub (p::UINT 8),      	num_sub_type) :-:
		   ("w8chk_sub",	check_sub (p::UINT 8),      num_sub_type) :-:
		   ("w8subv",	subv (p::UINT 8),        num_sub_type) :-:
		   ("w8chk_subv",	check_subv (p::UINT 8),     num_sub_type) :-:
		   ("w8update",	update (p::UINT 8),      num_upd_type) :-:
		   ("w8chk_update",  check_update (p::UINT 8),   num_upd_type) :-:

		   #  word31 primops 
		   ("w31mul",	word31 (p::MULTIPLY),      	ww_w) :-:
		   ("w31div",	word31 (p::DIVIDE),      	ww_w) :-:
		   ("w31mod",	word31 (p::REM),      	ww_w) :-:
		   ("w31add",	word31 (p::ADD ),      	ww_w) :-:
		   ("w31sub",	word31 (p::SUBTRACT ),      	ww_w) :-:
		   ("w31orb",	word31 p::BITWISEOR,      	ww_w) :-:
		   ("w31xorb",	word31 p::BITWISEXOR,      	ww_w) :-:
		   ("w31andb",	word31 p::BITWISEAND,      	ww_w) :-:
		   ("w31notb",	word31 p::BITWISENOT,      	w_w) :-:
		   ("w31neg",       word31 p::NEGATE,             w_w) :-:
		   ("w31rshift",	word31 p::RSHIFT,        ww_w) :-:
		   ("w31rshiftl",   word31 p::RSHIFTL,       ww_w) :-:
		   ("w31lshift",	word31 p::LSHIFT,        ww_w) :-:
		   ("w31gt",	word31cmp (p::GT),        ww_b) :-:
		   ("w31ge",	word31cmp (p::GE),       ww_b) :-:
		   ("w31lt",	word31cmp (p::LT),        ww_b) :-:
		   ("w31le",	word31cmp (p::LE),       ww_b) :-:
		   ("w31eq",	word31cmp p::EQL,        ww_b) :-:
		   ("w31ne",	word31cmp p::NEQ,        ww_b) :-:
		   ("w31_check_rshift", p::INLRSHIFT (p::UINT 31), ww_w) :-:
		   ("w31_check_rshiftl", p::INLRSHIFTL (p::UINT 31), ww_w) :-:
		   ("w31_check_lshift", p::INLLSHIFT (p::UINT 31), ww_w) :-:

		   ("w31min",	p::INLMIN (p::UINT 31), 	ww_w) :-:
		   ("w31max",	p::INLMAX (p::UINT 31), 	ww_w) :-:

		   #  (pseudo-)word8 primops 
		   ("w31mul_8",	word31 (p::MULTIPLY),      	w8w8_w8) :-:
		   ("w31div_8",	word31 (p::DIVIDE),      	w8w8_w8) :-:
		   ("w31mod_8",	word31 (p::REM),      	w8w8_w8) :-:
		   ("w31add_8",	word31 (p::ADD ),      	w8w8_w8) :-:
		   ("w31sub_8",	word31 (p::SUBTRACT ),      	w8w8_w8) :-:
		   ("w31orb_8",	word31 p::BITWISEOR,      	w8w8_w8) :-:
		   ("w31xorb_8",	word31 p::BITWISEXOR,      	w8w8_w8) :-:
		   ("w31andb_8",	word31 p::BITWISEAND,      	w8w8_w8) :-:
		   ("w31notb_8",	word31 p::BITWISENOT,      	w8_w8) :-:
		   ("w31neg_8",     word31 p::NEGATE,             w8_w8) :-:
		   ("w31rshift_8",	word31 p::RSHIFT,        w8w_w8) :-:
		   ("w31rshiftl_8", word31 p::RSHIFTL,       w8w_w8) :-:
		   ("w31lshift_8",	word31 p::LSHIFT,        w8w_w8) :-:
		   ("w31gt_8",	word31cmp (p::GT),        w8w8_b) :-:
		   ("w31ge_8",	word31cmp (p::GE),       w8w8_b) :-:
		   ("w31lt_8",	word31cmp (p::LT),        w8w8_b) :-:
		   ("w31le_8",	word31cmp (p::LE),       w8w8_b) :-:
		   ("w31eq_8",	word31cmp p::EQL,        w8w8_b) :-:
		   ("w31ne_8",	word31cmp p::NEQ,        w8w8_b) :-:
		   ("w31_check_rshift_8", p::INLRSHIFT (p::UINT 31), w8w_w8) :-:
		   ("w31_check_rshiftl_8", p::INLRSHIFTL (p::UINT 31), w8w_w8) :-:
		   ("w31_check_lshift_8", p::INLLSHIFT (p::UINT 31), w8w_w8) :-:

		   ("w31min_8",	p::INLMIN (p::UINT 31), 	w8w8_w8) :-:
		   ("w31max_8",	p::INLMAX (p::UINT 31), 	w8w8_w8) :-:

		   # ** word32 primops **
		   ("w32mul",	word32 (p::MULTIPLY),      	w32w32_w32) :-:
		   ("w32div",	word32 (p::DIVIDE),      	w32w32_w32) :-:
		   ("w32mod",	word32 (p::REM),      	w32w32_w32) :-:
		   ("w32add",	word32 (p::ADD ),      	w32w32_w32) :-:
		   ("w32sub",	word32 (p::SUBTRACT ),      	w32w32_w32) :-:
		   ("w32orb",	word32 p::BITWISEOR,      	w32w32_w32) :-:
		   ("w32xorb",	word32 p::BITWISEXOR,      	w32w32_w32) :-:
		   ("w32andb",	word32 p::BITWISEAND,      	w32w32_w32) :-:
		   ("w32notb",	word32 p::BITWISENOT,      	w32_w32) :-:
		   ("w32neg",	word32 p::NEGATE,      	w32_w32) :-:
		   ("w32rshift",	word32 p::RSHIFT,     	w32w_w32) :-:
		   ("w32rshiftl",   word32 p::RSHIFTL,    	w32w_w32) :-:
		   ("w32lshift",	word32 p::LSHIFT,     	w32w_w32) :-:
		   ("w32gt",	word32cmp (p::GT),        w32w32_b) :-:
		   ("w32ge",	word32cmp (p::GE),       w32w32_b) :-:
		   ("w32lt",	word32cmp (p::LT),        w32w32_b) :-:
		   ("w32le",	word32cmp (p::LE),       w32w32_b) :-:
		   ("w32eq",	word32cmp p::EQL,     	w32w32_b) :-:
		   ("w32ne",	word32cmp p::NEQ,     	w32w32_b) :-:
		   ("w32_check_rshift", p::INLRSHIFT (p::UINT 32), w32w_w32) :-:
		   ("w32_check_rshiftl", p::INLRSHIFTL (p::UINT 32), w32w_w32) :-:
		   ("w32_check_lshift", p::INLLSHIFT (p::UINT 32), w32w_w32) :-:

		   ("w32min",	 p::INLMIN (p::UINT 32), 	w32w32_w32) :-:
		   ("w32max",	 p::INLMAX (p::UINT 32), 	w32w32_w32) :-:

		   #  experimental C FFI primops 
		   ("raww8l",       p::RAW_LOAD (p::UINT 8),    w32_w32) :-:
		   ("rawi8l",       p::RAW_LOAD (p::INT 8),     w32_i32) :-:
		   ("raww16l",      p::RAW_LOAD (p::UINT 16),   w32_w32) :-:
		   ("rawi16l",      p::RAW_LOAD (p::INT 16),    w32_i32) :-:
		   ("raww32l",      p::RAW_LOAD (p::UINT 32),   w32_w32) :-:
		   ("rawi32l",      p::RAW_LOAD (p::INT 32),    w32_i32) :-:
		   ("rawf32l",      p::RAW_LOAD (p::FLOAT 32),  w32_f64) :-:
		   ("rawf64l",      p::RAW_LOAD (p::FLOAT 64),  w32_f64) :-:
		   ("raww8s",       p::RAW_STORE (p::UINT 8),   w32w32_u) :-:
		   ("rawi8s",       p::RAW_STORE (p::INT 8),    w32i32_u) :-:
		   ("raww16s",      p::RAW_STORE (p::UINT 16),  w32w32_u) :-:
		   ("rawi16s",      p::RAW_STORE (p::INT 16),   w32i32_u) :-:
		   ("raww32s",      p::RAW_STORE (p::UINT 32),  w32w32_u) :-:
		   ("rawi32s",      p::RAW_STORE (p::INT 32),   w32i32_u) :-:
		   ("rawf32s",      p::RAW_STORE (p::FLOAT 32), w32f64_u) :-:
		   ("rawf64s",      p::RAW_STORE (p::FLOAT 64), w32f64_u) :-:
		   ("rawccall",     p::RAW_CCALL NULL,         rcc_type) :-:

		      # Support for direct construction of C chunks on ML heap.
		      # rawrecord builds a record holding C chunks on the heap.
		      # rawselectxxx index on this record.  They are of type:
		      #    X * unt32::word -> unt32::word
		      # The X is to guarantee that the compiler will treat
		      # the record as a ML chunk, in case it passes thru a gc boundary.
		      # rawupdatexxx writes to the record.

		   ("rawrecord",    p::RAW_RECORD { fblock => FALSE }, i_x) :-:
		   ("rawrecord64",  p::RAW_RECORD { fblock => TRUE }, i_x) :-:

		   ("rawselectw8",  p::RAW_LOAD (p::UINT 8), xw32_w32) :-:
		   ("rawselecti8",  p::RAW_LOAD (p::INT 8), xw32_i32) :-:
		   ("rawselectw16", p::RAW_LOAD (p::UINT 16), xw32_w32) :-:
		   ("rawselecti16", p::RAW_LOAD (p::INT 16), xw32_i32) :-:
		   ("rawselectw32", p::RAW_LOAD (p::UINT 32), xw32_w32) :-:
		   ("rawselecti32", p::RAW_LOAD (p::INT 32), xw32_i32) :-:
		   ("rawselectf32", p::RAW_LOAD (p::FLOAT 32), xw32_f64) :-:
		   ("rawselectf64", p::RAW_LOAD (p::FLOAT 64), xw32_f64) :-:

		   ("rawupdatew8",  p::RAW_STORE (p::UINT 8), xw32w32_u) :-:
		   ("rawupdatei8",  p::RAW_STORE (p::INT 8), xw32i32_u) :-:
		   ("rawupdatew16", p::RAW_STORE (p::UINT 16), xw32w32_u) :-:
		   ("rawupdatei16", p::RAW_STORE (p::INT 16), xw32i32_u) :-:
		   ("rawupdatew32", p::RAW_STORE (p::UINT 32), xw32w32_u) :-:
		   ("rawupdatei32", p::RAW_STORE (p::INT 32), xw32i32_u) :-:
		   ("rawupdatef32", p::RAW_STORE (p::FLOAT 32), xw32f64_u) :-:
		   ("rawupdatef64", p::RAW_STORE (p::FLOAT 64), xw32f64_u); 

	end; #  local 

	#  uList package 
	u_list
            =
	    {   ev = st::special "uListVariable";

		all_elements
                    = 
		    [   (   s::make_type_symbol "List",

                            m::TYPE_CONSTRUCTOR_IN_API {

                                type_constructor => bt::ulist_tycon,
                                module_stamp     => ev,
			        is_a_replica     => FALSE,
                                scope            => 0
                            }
                        ),

			make_constructor_element ("NIL", bt::unil_dcon),
			make_constructor_element ("!",   bt::ucons_dcon)
                    ];

		all_symbols   =   map #1 all_elements;

		api_record
                    =
                    {   stamp  => st::special "uListApi",
			name   => NULL,
                        closed => TRUE, 

			contains_generic => FALSE,
                        package_sharing  => NIL,

		        symbols      => all_symbols,
                        elements     => all_elements,
			type_sharing => NIL,

		        property_list=> property_list::make_property_list (),
			stub         => NULL
                    };

		                                                          
                package_property_lists::set_api_bound_generic_evaluation_paths
                    (   api_record,
                        THE []
                    );

	    
                m::A_PACKAGE {

                    an_api        => m::API api_record,
		    var_home        => a::null_var_home,
                    inlining_info => ii::make_package_info [],

		    typechecked_package => { stamp => st::special "uListPackage",
			                     stub  => NULL,

					     typechecker_dictionary => ee::set (ee::empty, ev, m::TYPE_CONSTRUCTOR_ENTRY bt::ulist_tycon),
					     property_list          => property_list::make_property_list (),
					     inverse_path           => ip::INVERSE_PATH [s::make_package_symbol "uList"]
					 }
                };
	    };

	# 'inline' package:
	#
	inline
            =
	    {   bottom
                    =
                    t::TYPE_SCHEME_TYPE {

                        type_scheme_arg_eq_properties => [FALSE], 
		        type_scheme                             => t::TYPE_SCHEME { arity=>1, body=>t::TYPE_SCHEME_ARG_I 0 }
                    };

		fun make_variable_element ( (name, p, type),   (symbols, elements, dacc, offset))
                    =
		    {   s    =   s::make_value_symbol name;
			sp   =   m::VALUE_IN_API { type, slot=>offset };
			d    =   ii::make_primitive_info (p, type);
		    
                        (   s ! symbols,
                           (s, sp) ! elements,
                           d ! dacc,
                           offset+1
                        );
		    };

		my (all_symbols, all_elements, inf_list, _)
                    = 
		    fold_left make_variable_element ([],[],[], 0) all_primops;

		my (all_symbols, all_elements, inf_list)
                    = 
		    (   reverse all_symbols,
                        reverse all_elements,
                        reverse inf_list
                    );

		api_record
                    =
                    {   stamp  => st::special "Inline_Api",
			name   => NULL,
                        closed => TRUE, 

		        contains_generic => FALSE,

		        symbols  => all_symbols,
                        elements => all_elements,

		        type_sharing    => NIL,
                        package_sharing => NIL,

			property_list => property_list::make_property_list (),
			stub => NULL
                    };

		                                                                        
                package_property_lists::set_api_bound_generic_evaluation_paths
                    (   api_record,
                        THE []
                    );
	    
                m::A_PACKAGE {

                    an_api   => m::API api_record,
		    var_home       => a::null_var_home,
                    inlining_info   => ii::make_package_info inf_list,

		    typechecked_package
                        =>
                        {   stamp                  =>  st::special "inline_package",
			    stub                   =>  NULL,
			    typechecker_dictionary =>  ee::empty,

			    property_list          =>  property_list::make_property_list (),
			    inverse_path           =>  ip::INVERSE_PATH [ s::make_package_symbol "inline" ]
			}
                };
	    };

	# Priming packages: primitive_types and inline:
	#
	nameof_pt =   s::make_package_symbol "primitive_types";
	nameof_ul =   s::make_package_symbol "unrolled_list";
	nameof_il =   s::make_package_symbol "inline";

	primitives_symbol_table
            =
	    se::bind (
                nameof_il,
                b::NAMED_PACKAGE inline,
		se::bind (
                    nameof_ul,
                    b::NAMED_PACKAGE u_list,
		    se::bind (
                        nameof_pt,
                        b::NAMED_PACKAGE prim_types,
			mu::include_package (se::empty, prim_types)
                    )
                )
            );

	primitives_symbol_table
	    =
	    {   my { picklehash, pickle, ... }
		    =
		    pickle_module::pickle_symbol_table
                        (pickle_module::INITIAL  module_map::empty_module_map)
                        primitives_symbol_table;
	    
		unpickle_module::unpickle_symboltable (fn _ => module_map::empty_module_map; end ) (picklehash, pickle);
	    };

    end;	#  stipulate

};		#  package primitives_symbol_table 


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Copyright 1996 by AT&T Bell Laboratories
## Subsequent changes by Jeff Prothero Copyright (c) 2010,
## released under Gnu Public Licence version 3.
