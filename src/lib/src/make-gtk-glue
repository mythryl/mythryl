#!/usr/bin/mythryl

# To minimize code redundancy and consequent
# reliability and maintainance headaches in
#
#     mythryl-gtk-slave.c 
#
# we synthesize simple repetitive functions
# directly from their
#
#     gtk.api
#
# type declarations.
#
# The specifications for these functions and
# related declarations and docs are in
#
#     src/lib/src/gtk-glue.config
#
# (See top-of-file comments there.)
#
# We are invoked by doing
# 
#     make gtk-glue
#
# At the top level.  This is not done as part
# of a normal build;  I run it by hand after
# I've updated (say) gtk-glue.config


# The list of files which we patch:
#
config_file_path             =  "src/lib/src/gtk-glue.config";
gtk_api_path                 =  "src/lib/src/gtk.api";
gtk_g_pkg_path               =  "src/lib/src/gtk-g.pkg";
gtk_driver_api_path          =  "src/lib/src/gtk-driver.api";
gtk_via_pipe_driver_pkg_path =  "src/lib/src/gtk-via-pipe-driver.pkg";
gtk_driver_pkg_path          =  "src/lib/src/gtk-driver.pkg";
mythryl_gtk_slave_c_path     =  "src/runtime/gtk/mythryl-gtk-slave.c";
cfun_list_h_path             =  "src/runtime/c-libs/lib7-gtk/cfun-list.h";
gtk_driver_c_path            =  "src/runtime/c-libs/lib7-gtk/gtk-driver.c";
libref_tex_path              =  "doc/tex/section-libref-gtk.tex";

gtk_driver_plain_fns_autogenerated    =  REF 0;
gtk_driver_callback_fns_autogenerated =  REF 0;

gtk_slave_plain_fns_autogenerated     =  REF 0;
gtk_slave_callback_fns_autogenerated  =  REF 0;

gtk_g_pkg_plain_fns_handgenerated     =  REF 0;
gtk_g_pkg_plain_fns_autogenerated     =  REF 0;

gtk_g_pkg_callback_fns_handgenerated  =  REF 0;
gtk_g_pkg_callback_fns_autogenerated  =  REF 0;


# Lists of synthesized code strings to
# be inserted in the above files.  Most
# files have just one such insertion point
# ("intron") but some have two, for example
# one for synthesized type declarations
# and one for synthesized functions.
#
# These will all be in reverse
# order while being contructed:
#
gtk_driver_api_intron           =  REF ([]: List(String));
gtk_via_pipe_driver_pkg_intron  =  REF ([]: List(String));
gtk_driver_pkg_intron           =  REF ([]: List(String));
gtk_api_funs_intron             =  REF ([]: List(String));
gtk_api_types_intron            =  REF ([]: List(String));
gtk_g_pkg_funs_intron           =  REF ([]: List(String));
gtk_g_pkg_types_intron          =  REF ([]: List(String));
mythryl_gtk_slave_c_funs_intron =  REF ([]: List(String));
mythryl_gtk_slave_c_trie_intron =  REF ([]: List(String));
cfun_list_h_intron              =  REF ([]: List(String));
gtk_driver_c_intron             =  REF ([]: List(String));
libref_tex_table1_intron        =  REF ([]: List(String));
libref_tex_table2_intron        =  REF ([]: List(String));


# Little functions to prepend
# strings to the above lists:
#
fun to_gtk_driver_api           string =   gtk_driver_api_intron           :=  string !  *gtk_driver_api_intron;
fun to_gtk_via_pipe_driver_pkg  string =   gtk_via_pipe_driver_pkg_intron  :=  string !  *gtk_via_pipe_driver_pkg_intron;
fun to_gtk_driver_pkg           string =   gtk_driver_pkg_intron           :=  string !  *gtk_driver_pkg_intron;
fun to_gtk_g_pkg_funs           string =   gtk_g_pkg_funs_intron           :=  string !  *gtk_g_pkg_funs_intron;
fun to_gtk_g_pkg_types          string =   gtk_g_pkg_types_intron          :=  string !  *gtk_g_pkg_types_intron;
fun to_gtk_api_funs             string =   gtk_api_funs_intron             :=  string !  *gtk_api_funs_intron;
fun to_gtk_api_types            string =   gtk_api_types_intron            :=  string !  *gtk_api_types_intron;
fun to_mythryl_gtk_slave_c_funs string =   mythryl_gtk_slave_c_funs_intron :=  string !  *mythryl_gtk_slave_c_funs_intron;
fun to_mythryl_gtk_slave_c_trie string =   mythryl_gtk_slave_c_trie_intron :=  string !  *mythryl_gtk_slave_c_trie_intron;
fun to_cfun_list_h              string =   cfun_list_h_intron              :=  string !  *cfun_list_h_intron;
fun to_gtk_driver_c             string =   gtk_driver_c_intron             :=  string !  *gtk_driver_c_intron;
fun to_libref_table1_tex        string =   libref_tex_table1_intron        :=  string !  *libref_tex_table1_intron;
fun to_libref_table2_tex        string =   libref_tex_table2_intron        :=  string !  *libref_tex_table2_intron;



# We divide the files we patch into exons and introns
# according to the scheme
#
#        exon
#        # Do not edit this or following lines -- they are autogenerated by make-gtk-glue./)
#        intron
#        # Do not edit this or preceding lines -- they are autogenerated by make-gtk-glue./)
#        exon
#        
# where the exons are literal program text provided by the
# programmer whereas the introns are literal program text
# which we synthesize.  (The shown 'do not edit' lines are
# considered part of the exons.)
#
# We represent such a file in memory as a list of file
# segments (that is, exons and introns) where each segment
# is in turn a list of lines represented as strings:
#
File_Segment = EXON   List(String)
             | INTRON List(String)
             ;

Patchable_File
    =
    PATCHABLE_FILE {
        filename:  String,
        contents:  List(File_Segment)
    };


# Read and return a Patchable_File:
#
fun read_patchable_file  filename
    =
    {   fd = file::open_for_read filename
             except
                io_exceptions::IO _
		    =
                    {   fprintf stderr "Fatal: Unable to open input file '%s'" filename;
			exit(1);
		    };
	contents
            =
            read_exon ([], [])
            where
		fun read_exon (segments, lines)
                    =
                    case (file::read_line fd)

			NULL => reverse ((EXON (reverse lines)) ! segments);

                        THE line
                            =>
			    if (line =~ ./ Do not edit this or following lines -- they are autogenerated by make-gtk-glue./)

				read_intron ((EXON (reverse (line ! lines))) ! segments, []);
			    else
				read_exon (segments, line ! lines);
                            fi;	
                    esac

                also
		fun read_intron (segments, lines)
                    =
                    case (file::read_line fd)

			NULL =>
                            {   fprintf stderr "Fatal: Missing 'Do not edit this or preceding lines' line in %s" filename;
				exit(1);
			    };
			
                        THE line
                            =>
			    if (line =~ ./ Do not edit this or preceding lines -- they are autogenerated by make-gtk-glue./)

				read_exon ((INTRON (reverse lines)) ! segments, [ line ]);
			    else
				read_intron (segments, line ! lines);
                            fi;	
                    esac;
            end;

        file::close_input fd;   

	PATCHABLE_FILE { filename, contents };
    };

# Write a patchable file back into the filesystem.
#
fun write_patchable_file
    (PATCHABLE_FILE { filename, contents })
    introns
    =
    {   intron_lines_written = REF 0;

        tmp_filename = filename + "~";

        fd = file::open_for_write  tmp_filename
             except
                io_exceptions::IO _
		    =
                    {   fprintf stderr "Fatal: Unable to open output file '%s'" tmp_filename;
			exit(1);
		    };


	fun write_exon_lines  [] => ();

	    write_exon_lines  (line ! rest)
                =>
		{   file::write (fd, line);
		    write_exon_lines rest;
		};
	end;


	fun write_intron_lines  [] => ();

	    write_intron_lines  (line ! rest)					# Actually 'line' may be just a string (i.e., line fragment).
                =>
		{   file::write (fd, line);
		    intron_lines_written := *intron_lines_written + 1;		# This is the only difference between us and write_exon_lines.
		    write_intron_lines rest;
		};
	end;


	write_exon (contents, introns)
	where
	    fun write_exon (((EXON lines) ! rest), introns)
		    =>
		    {
		        write_exon_lines lines;
			write_intron (rest, introns);
		    };

		write_exon _
                    =>
                    raise exception FAIL "Internal bug";
	    end

            also
	    fun write_intron ((INTRON _) ! exons, (INTRON lines) ! introns)
		    =>
		    {
		        write_intron_lines lines;
			write_exon (exons, introns);
		    };

	        write_intron ([], [])
		    =>
		    ();

		write_intron _
                    =>
                    raise exception FAIL "Internal bug";
	    end;
	end;	

        file::close_output fd;   

        winix::file::remove_file  filename;

        winix::file::rename_file { from => tmp_filename, to => filename };

	printf "Successfully patched %4d lines in %s\n"  *intron_lines_written  filename;
    };





# Field is a contiguous sequence of lines
# all with the same linetype field:
#
#    foo:  this
#    foo:  that
#
# Most fields will be single-line, but this format
# supports conveniently including blocks of code,
# such as complete function definitions.
#
# We treat a field as a single string containing
# embedded newlines, stripped of the linetype field
# and the colon.  
#
Field = { string:  Ref(String),
          line_1:  Ref(Int),
          line_n:  Ref(Int),
	  used:    Ref(Bool)
        };

State = { line_number:  Ref(Int),

	  fd:           file::Input_Stream,

	  fields:       Ref( string_map::Map( Field ))
	};

#
fun field_location (field: Field)
    =
    *field.line_1 == *field.line_n  ??  sprintf "line %d" *field.line_1
				    ::  sprintf "lines %d-%d" *field.line_1 *field.line_n;

#
fun maybe_get_field (state: State, field_name)
    =
    case (string_map::get (*state.fields, field_name))
	#
	THE field => { field.used := TRUE;  THE *field.string; };
	NULL      => NULL;
    esac;

#
fun get_field (state: State, field_name)
    =
    case (string_map::get (*state.fields, field_name))
	#
	THE field => { field.used := TRUE; 
                      *field.string;
                     };

	NULL      => die (sprintf "Required field %s missing at line %d\n"  field_name  *state.line_number);
    esac;

#
fun get_field_location (state: State, field_name)
    =
    case (string_map::get (*state.fields, field_name))
	#
	THE field => { field.used := TRUE;  field_location field; };
	#
	NULL      => die (sprintf "Required field %s missing at line %d\n"  field_name  *state.line_number);
    esac;

#
fun clear_state (state: State)
    =
    {   foreach (string_map::keyvals_list *state.fields) .{

	    #pair -> (field_name, field);

	    if (not *field.used)
		die (sprintf "Field %s at %s unsupported.\n"
                             field_name
                             (field_location field)
                    );
	    fi;
        }; 

	state.fields :=  (string_map::empty: string_map::Map( Field ));
    };




# lowcode contains embedded arguments like w0, i1, f2, b3, s4.
#
# The argument letter gives us the argument type:
#
#    w == widget
#    i == int
#    f == double  (Mythryl "Float")
#    b == bool
#    s == string
#
# The argument digit gives us the argument order:
#
#    0 == first arg
#    1 == second arg
#    ...

# Get list of above args, sorting by trailing digit
# and dropping duplicates:
#
fun get_args  lowcode
    =
    {   # Compare "w0" and "b1" as "0" and "1":
	#
        fun compare_fn (xn, yn)
	    =
            {   xn' = string::extract (xn, 1, NULL);
                yn' = string::extract (yn, 1, NULL);

                string::compare (xn', yn');
	    };

        raw_list    =  regex::find_all  ./\b[bfisw][0-9]\b/  lowcode;

        cooked_list =  uniquesort  compare_fn  raw_list;

	cooked_list;
    };        

# Count number of arguments.
# We need this for check_argc():
#
fun count_args  lowcode
    =
    list::length (get_args  lowcode);

#
fun get_nth_arg_type (n, lowcode)
    =
    {   arg_list =  get_args  lowcode;

        if (n <   0
        or  n >=  list::length  arg_list
        )
	    raise exception FAIL (sprintf "get_nth_arg_type: No %d-th arg in '%s'!" n lowcode);
        fi;

	arg = list::nth (arg_list, n);		# Fetch "w0" or "i0" or such.

	string::extract (arg, 0, THE 1);	# Convert "w0" to "w" or "i0" to "i" &tc.
    };

#
fun arg_types_are_all_unique  lowcode
    =
    {   # Get the list of parameters,
	# something like [ "w0", "i1", "i2" ]:
	#
        args  =  get_args  lowcode;

	# Turn parameter list into type list,
	# something like [ 'w', 'i', 'i' ]:
	#
        types =  map   .{ string::get (#string,0); }   args;

	# Eliminate duplicate types from above:
	#
	types =   uniquesort  char::compare  types;

	# If 'args' is same length as 'types' then
	# all types are unique:
	#
	list::length args  ==  list::length types;
    };

#
fun gtk_driver_api_type (lowcode, result_type)
    =
    {
	input_type =  REF "(Session";

	arg_count = count_args  lowcode;

	for (a = 0;  a < arg_count;  ++a) {

	    t = get_nth_arg_type( a, lowcode );

	    case t
		"b" =>     input_type :=  *input_type  +  ", Bool";
		"i" =>     input_type :=  *input_type  +  ", Int";
		"f" =>     input_type :=  *input_type  +  ", Float";
		"s" =>     input_type :=  *input_type  +  ", String";
		"w" =>     input_type :=  *input_type  +  ", Int/*Widget*/";

		 _  =>     raise exception FAIL (sprintf "Unsupported arg type '%s'" t);
	    esac;
	};

	input_type :=  *input_type  +  ")";


        output_type
	    =
            case result_type

		"new Widget" =>  "Int /*new Widget*/";
		"Bool"       =>  "Bool";
		"Float"      =>  "Float";
		"Int"        =>  "Int";
		"Widget"     =>  "Int /*Widget*/";
		"Void"       =>  "Void";

	         _           => raise exception FAIL ("gtk_driver_api_type: Unsupported result type: " + result_type);
	    esac;

        (*input_type, output_type);
    };
#        
stipulate

    line_count = REF 2;

herein

    fun write_gtk_driver_api_function  (fn_name, lowcode, result_type)
	=
	{
	    # Add a blank line every three declarations:
	    #
	    line_count := *line_count + 1;

	    if ((*line_count % 3) == 0)

		to_gtk_driver_api  "\n";
	    fi;

	    to_gtk_driver_api  (sprintf  "    %-40s"  (fn_name + ":"));


	    my (input_type, output_type)
                =
                gtk_driver_api_type (lowcode, result_type);


	    to_gtk_driver_api (sprintf "%-40s -> %s;\n"  input_type output_type);
	};
end;






#
fun write_do_command (do_command, fn_name, lowcode, result_prefix, result_expression)
    =
    {
	if (result_expression != "")
	     to_gtk_via_pipe_driver_pkg ("        {   result = " + do_command + " (session");
	else to_gtk_via_pipe_driver_pkg ("        " + do_command + " (session");
	fi;

	if (result_prefix != "") 
	    to_gtk_via_pipe_driver_pkg  (.', "' + result_prefix + .'"');
	fi;

	to_gtk_via_pipe_driver_pkg  (.', "' + fn_name + .'"');

	prefix = .' + " " +';

	arg_count = count_args lowcode;

	for (a = 0;  a < arg_count;  ++a) {

	    t = get_nth_arg_type( a, lowcode );

	    case t
		"b" =>   to_gtk_via_pipe_driver_pkg   (sprintf  "%s bool_to_string %s%d"    prefix t a);
		"f" =>   to_gtk_via_pipe_driver_pkg   (sprintf  "%s float::to_string %s%d"  prefix t a);
		"i" =>   to_gtk_via_pipe_driver_pkg   (sprintf  "%s int::to_string %s%d"    prefix t a);
		"s" =>   to_gtk_via_pipe_driver_pkg   (sprintf  "%s string_to_string %s%d"  prefix t a);
		"w" =>   to_gtk_via_pipe_driver_pkg   (sprintf  "%s widget_to_string %s%d"  prefix t a);
		 _  =>   raise exception FAIL ("Unsupported arg type '" + t + "'");
	    esac;
	};

	to_gtk_via_pipe_driver_pkg ");\n";


	if (result_expression != "")

	    to_gtk_via_pipe_driver_pkg "\n";
	    to_gtk_via_pipe_driver_pkg ("            " + result_expression + "\n");
	    to_gtk_via_pipe_driver_pkg "        };\n\n\n";
	else
	    to_gtk_via_pipe_driver_pkg "\n\n";
	fi;
    };

# Generate a function for   src/lib/src/gtk-via-pipe-driver.pkg
# looking like
#
#    fun make_status_bar_context_id (session, w0, s1)	# Int
#        =
#        do_int_command (session, "make_status_bar_context_id", "make_status_bar_context_id" + " " + widget_to_string w0 + " " + string_to_string s1);
#
fun write_gtk_via_pipe_driver_pkg_function (fn_name, lowcode, result_type)
    =
    {
	to_gtk_via_pipe_driver_pkg ("    fun " + fn_name + " (session");

	arg_count = count_args( lowcode );

	for (a = 0;  a < arg_count;  ++a) {

	    arg_type = get_nth_arg_type( a, lowcode );

	    to_gtk_via_pipe_driver_pkg  (sprintf ", %s%d" arg_type a);
	};

	to_gtk_via_pipe_driver_pkg (")\t# " + result_type + "\n");
	to_gtk_via_pipe_driver_pkg ("        =\n");

	if   (result_type == "new Widget")   write_do_command ("do_int_command",    fn_name, lowcode, fn_name, "");
	elif (result_type == "Widget")       write_do_command ("do_int_command",    fn_name, lowcode, fn_name, "");
	elif (result_type == "Int")          write_do_command ("do_int_command",    fn_name, lowcode, fn_name, "");
	elif (result_type == "Bool")         write_do_command ("do_string_command", fn_name, lowcode, fn_name, "the (int::from_string result) != 0;");
	elif (result_type == "Float")        write_do_command ("do_string_command", fn_name, lowcode, fn_name, "the (float::from_string result);");
	elif (result_type == "Void")         write_do_command ("do_void_command",   fn_name, lowcode, "", "");
	else
	    raise exception FAIL ("Unsupported result type: " + result_type);
	fi;
    };

#
fun n_blanks n
    =
    n_blanks' (n, "")
    where
        fun n_blanks' (0, string) => string;
            n_blanks' (i, string) => n_blanks' (i - 1, " " + string);
        end;
    end;

# Generate a function for   src/lib/src/gtk-driver.pkg
# looking like
#
# NEED TO WORK OUT APPROPRIATE VARIATION FOR THIS
#
#    fun make_status_bar_context_id (session, w0, s1)	# Int
#        =
#        do_int_command (session, "make_status_bar_context_id", "make_status_bar_context_id" + " " + widget_to_string w0 + " " + string_to_string s1);
#
fun write_gtk_driver_pkg_function (fn_name, fn_name2, fn_type, lowcode, result_type)
    =
    {
        # Construct gtk-driver.pkg level type for this function.
        # The gtk-g.pkg level type may involve records or tuples,
	# but at this level we always have tuples:
	#
	my (input_type, output_type)
	    =
	    gtk_driver_api_type (lowcode, result_type);

        to_gtk_driver_pkg "\n";
        to_gtk_driver_pkg
            (sprintf "    #      %-80s   # gtk.api type\n"
		     ( (n_blanks (string::length fn_name))
                     + (fn_type =~ ./^\(/ ?? "" :: " ")			   # If type starts with a paren exdent it one space.
		     +  fn_type
	             )
            );

        to_gtk_driver_pkg
            (sprintf "    my %s:   %s%s -> %s\n"
		      fn_name2
                     (input_type =~ ./^\(/ ?? "" :: " ")		   # If type starts with a paren exdent it one space.
                      input_type
                      output_type
            );

        to_gtk_driver_pkg "        =\n";

        to_gtk_driver_pkg
            (sprintf "        unsafe::c_interface::c_function \"Lib7-Gtk\" \"%s\";\n"
		      fn_name2
            );

        to_gtk_driver_pkg "\n";


#	to_gtk_driver_pkg ("#    fun " + fn_name + " (session");
#
#	arg_count = count_args( lowcode );
#
#	for (a = 0;  a < arg_count;  ++a) {
#
#	    arg_type = get_nth_arg_type( a, lowcode );
#
#	    to_gtk_driver_pkg  (sprintf ", %s%d" arg_type a);
#	};
#
#	to_gtk_driver_pkg (")\t# " + result_type + "\n");
#	to_gtk_driver_pkg ("#        =\n");


#	if   (result_type == "new Widget")   write_do_command ("do_int_command",    fn_name, lowcode, fn_name, "");
#	elif (result_type == "Widget")       write_do_command ("do_int_command",    fn_name, lowcode, fn_name, "");
#	elif (result_type == "Int")          write_do_command ("do_int_command",    fn_name, lowcode, fn_name, "");
#	elif (result_type == "Bool")         write_do_command ("do_string_command", fn_name, lowcode, fn_name, "the (int::from_string result) != 0;");
#	elif (result_type == "Float")        write_do_command ("do_string_command", fn_name, lowcode, fn_name, "the (float::from_string result);");
#	elif (result_type == "Void")         write_do_command ("do_void_command",   fn_name, lowcode, "", "");
#	else
#	    raise exception FAIL ("Unsupported result type: " + result_type);
#	fi;
    };


# Convert .|gtk_foo| to .|gtk\_foo|
# to protect it from TeX's ire:
#
fun slash_underlines  string
    =
    {
        regex::replace_all ./_/ .|\_| string;
    };


# Write a trie line into file  src/runtime/gtk/mythryl-gtk-slave.c
#
fun write_trie_entry_for_gtk_slave_c  name
    =
    {
        to_mythryl_gtk_slave_c_trie
	   (sprintf
		"    set_trie( trie, %-46s%-46s);\n"
		(.'"'  + name + .'",')
		("do_" + name));
    };	

# Write a line like
#
#     CFUNC("init",	_lib7_Gtk_gtk_init,		"Void -> Void")
#
# into file   src/runtime/c-libs/lib7-gtk/cfun-list.h
#
fun write_cfun_list_h_entry (fn_name, fn_type)
    =
    {    to_cfun_list_h (sprintf "CFUNC(%-44s%-54s%s%s)\n"
                                 ("\""         + fn_name + "\",")
                                 ("_lib7_Gtk_" + fn_name + ",")
                                 (fn_type =~ ./^\(/ ?? "" :: " ")			   # If type starts with a paren exdent it one space.
                                 ("\""         + fn_type + "\"")
                        );
    };

Doc_Entry
    =
    { fn_name:  String,
      lowcode: String,
      url:      String,
      fn_type:  String
    };

doc_entries
    =
    REF ([]: List( Doc_Entry ));

# Note a tex documentation table
# line for file  section-libref-gtk.tex.
#
# We delay writing these until the
# entire specfile has been processed
# so as to be able to sort the doc
# table entries alphabetically:
#
fun note_libref_tex_entry
    { state,
      fn_name,		# E.g. "make_window"
      lowcode,		# E.g. "gtk_table_set_col_spacing( GTK_TABLE(/*table*/w0), /*col*/i1, /*spacing*/i2)"
      url,		# E.g. "http://library.gnome.org/devel/gtk/stable/GtkTable.html#gtk-table-set-col-spacing"
      fn_type		# E.g. "Session -> Widget"
    }
    =
    {
	# Get name of the C Gtk function/var
	# wrapped by this Mythryl function:
	#
        lowcode
            =
	    case (maybe_get_field(state,"doc-fn"))

                THE field => field;	# doc-fn is a manual override used when lowcode is unusable for documentation.

                NULL =>
		    {   # lowcode is something like   gtk_widget_set_size_request( GTK_WIDGET(/*widget*/w0), /*wide*/i1, /*high*/i2)
			# but all we want here is the
			# initial function name:
			#
			lowcode =  regex::find_first ./[A-Za-z0-9_']+/ lowcode
                                   except
                                       NOT_FOUND = "";

			# If lowcode does not begin with [Gg], it
			# is probably not useful in this context:
			#
			lowcode =  (lowcode =~ ./^[Gg]/)  ??  lowcode
							  ::  "";

			lowcode;
		    };	
            esac;


	fn_name =  slash_underlines  fn_name;
	lowcode =  slash_underlines  lowcode;
	url     =  slash_underlines  url;		# Probably not needed.
	fn_type =  slash_underlines  fn_type;

        doc_entries
	    :=
	    { fn_name, lowcode, url, fn_type } ! *doc_entries;
    };

# Write tex documentation table into file  section-libref-gtk.tex:
#
fun write_libref_tex_table
    ( field1: Doc_Entry -> String,
      field2: Doc_Entry -> String,
      to_section: String -> Void
    )
    =
    {
	# Define the sort order for the table:
	#
	fun compare_fn
            ( a: Doc_Entry,
              b: Doc_Entry
            )
	    =
	    {   a1 = field1 a;    a2 = field2 a;
	        b1 = field1 b;    b2 = field2 b;

		# If primary keys are equal,
		# sort on the secondary keys:
		#
	        if (a1 != b1)   a1 > b1;
		else            a2 > b2;
		fi;
	    };

	entries =  list_mergesort::sort  compare_fn  *doc_entries;

	foreach entries .{

            #entry -> { fn_name, lowcode, url, fn_type };

	    entry1 = field1 #entry;
	    entry2 = field2 #entry;

	    if (entry1 != "")
		to_section
		    (sprintf "%s & %s & %s & %s \\\\ \\hline\n"
			entry1
			entry2
			(url == "" ?? ""
				   :: (.|\ahref{\url{| + url + "}}{doc}"))
			fn_type
		    );
	    fi;
	};
    };

#
fun generate_mythryl_gtk_slave_c_fun_header (fn_name, args)
    =
    {
	to_mythryl_gtk_slave_c_funs   "\n";
	to_mythryl_gtk_slave_c_funs  "static void\n";
	to_mythryl_gtk_slave_c_funs ("do_" + fn_name + "( int argc, unsigned char** argv )\n");
	to_mythryl_gtk_slave_c_funs  "{\n";
	to_mythryl_gtk_slave_c_funs (sprintf "    check_argc( \"do_%s\", %d, argc );\n" fn_name args);
	to_mythryl_gtk_slave_c_funs  "\n";
	to_mythryl_gtk_slave_c_funs  "    {\n";
    };


# Generate C code
# to fetch all the arguments
# out of argc/argv:
#
fun generate_mythryl_gtk_slave_c_fun_arg_loads (fn_name, args, lowcode)
    =
    {
	for (a = 0;   a < args;  ++a) {

	    # Remember type of this arg,
	    # which will be one of:
	    #   w (widget),
	    #   i (int),
	    #   b (bool)
	    #   s (string)
	    #   f (double):
	    #
	    arg_type = get_nth_arg_type( a, lowcode );

	    if   (arg_type == "b")    to_mythryl_gtk_slave_c_funs (sprintf  "        int               b%d =                        bool_arg( argc, argv, %d );\n"  a a);
	    elif (arg_type == "f")    to_mythryl_gtk_slave_c_funs (sprintf  "        double            f%d =                      double_arg( argc, argv, %d );\n"  a a);
	    elif (arg_type == "i")    to_mythryl_gtk_slave_c_funs (sprintf  "        int               i%d =                         int_arg( argc, argv, %d );\n"  a a);
	    elif (arg_type == "s")    to_mythryl_gtk_slave_c_funs (sprintf  "        char*             s%d =                      string_arg( argc, argv, %d );\n"  a a);
	    elif (arg_type == "w")

		# Usually we fetch a widget as just
		#
		#    GtkWidget* widget    =  widget_arg( argc, argv, 0 );
		#
		# or such, but in a few cases we must cast to
		# another type:
		#  o If we see   GTK_ADJUSTMENT(w0)    we must do   GtkAdjustment*  w0 =  (GtkAdjustment*)   widget_arg( argc, argv, 0 );
		#  o If we see   GTK_SCALE(w0)         we must do   GtkScale*       w0 =  (GtkScale*)        widget_arg( argc, argv, 0 );
		#  o If we wee   GTK_RADIO_BUTTON(w0)  we must do   GtkRadioButton* w0  =  (GtkRadioButton*) widget_arg( argc, argv, 0 );

		widget_type = REF "GtkWidget";

		if   (lowcode =~ (sprintf   "GTK_ADJUSTMENT\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkAdjustment";
		elif (lowcode =~ (sprintf        "GTK_SCALE\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkScale";
		elif (lowcode =~ (sprintf "GTK_RADIO_BUTTON\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkRadioButton";
		fi;

		to_mythryl_gtk_slave_c_funs (sprintf  "        %-14s    w%d =    %-16s  widget_arg( argc, argv, %d );\n" (*widget_type + "*") a  ("(" + *widget_type + "*)") a);

	    else
		raise exception FAIL ("Bug: unsupported arg type '" + arg_type + "' #" + int::to_string a + " from lowcode '" + lowcode + "\n");
	    fi;

	};
    };

# Synthesize a function for   mythryl-gtk-slave.c  like
# 
#    static void
#    do_set_adjustment_value( int argc, unsigned char** argv )
#    {
#        check_argc( "do_make_label", 2, argc );
#    
#        {   GtkAdjustment* w0 =  (GtkAdjustment*) widget_arg( argc, argv, 0 );
#            double         f1 =                   double_arg( argc, argv, 1 );
#
#    	     gtk_adjustment_set_value( GTK_ADJUSTMENT(w0), /*value*/f1);
#        }
#    }
#    
fun write_mythryl_gtk_slave_c_plain_fun
    ( state: State,
      fn_name,			# E.g., "make_window2"
      fn_type,			# E.g., "Session -> Widget".
      lowcode,			# E.g., "gtk_window_new( GTK_WINDOW_TOPLEVEL )".
      result			# E.g., "Float"
    )
    =
    {
	arg_count = count_args( lowcode );

	generate_mythryl_gtk_slave_c_fun_header    (fn_name, arg_count);
	generate_mythryl_gtk_slave_c_fun_arg_loads (fn_name, arg_count, lowcode);

	case result

            "Void"
                =>
                {   # Now we just print
		    # the supplied gtk call
		    # and wrap up:
		    #
		    to_mythryl_gtk_slave_c_funs "\n";
		    to_mythryl_gtk_slave_c_funs ("        " + lowcode + ";\n");
		    to_mythryl_gtk_slave_c_funs "    }\n";
		    to_mythryl_gtk_slave_c_funs "}\n";
		    to_mythryl_gtk_slave_c_funs "/* Above fn generated by write_mythryl_gtk_slave_c_plain_fun. */\n";
		};

	    "new Widget"
		=>
		{   to_mythryl_gtk_slave_c_funs "\n";
		    to_mythryl_gtk_slave_c_funs "        int slot = find_free_widget_slot ();\n";
		    to_mythryl_gtk_slave_c_funs "\n";
		    to_mythryl_gtk_slave_c_funs("        widget[slot] = " + lowcode + ";\n");
		    to_mythryl_gtk_slave_c_funs "\n";
		    to_mythryl_gtk_slave_c_funs("         printf(             \"" + fn_name + "%d\\n\", slot);      fflush( stdout );\n");
		    to_mythryl_gtk_slave_c_funs("        fprintf(log_fd, \"SENT:" + fn_name + "%d\\n\", slot);      fflush( log_fd );\n");
		    to_mythryl_gtk_slave_c_funs "    }\n";
		    to_mythryl_gtk_slave_c_funs "}\n";
		    to_mythryl_gtk_slave_c_funs "/* Above fn generated by write_mythryl_gtk_slave_c_plain_fun. */\n";
		};

	    "Widget"
		=>
		{   to_mythryl_gtk_slave_c_funs "\n";
		    to_mythryl_gtk_slave_c_funs("        GtkWidget* widget = (GtkWidget*) " + lowcode + ";\n");
		    to_mythryl_gtk_slave_c_funs "\n";
		    to_mythryl_gtk_slave_c_funs "        int slot = get_widget_id( widget );\n";
		    to_mythryl_gtk_slave_c_funs "\n";
		    to_mythryl_gtk_slave_c_funs("         printf(              \"" + fn_name + "%d\\n\", slot);      fflush( stdout );\n");
		    to_mythryl_gtk_slave_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%d\\n\", slot);      fflush( log_fd );\n");
		    to_mythryl_gtk_slave_c_funs "    }\n";
		    to_mythryl_gtk_slave_c_funs "}\n";
		    to_mythryl_gtk_slave_c_funs "/* Above fn generated by write_mythryl_gtk_slave_c_plain_fun. */\n";
		};

	    "Bool"
		=>
		{   to_mythryl_gtk_slave_c_funs "\n";
		    to_mythryl_gtk_slave_c_funs("        int result = " + lowcode + ";\n");
		    to_mythryl_gtk_slave_c_funs "\n";
		    to_mythryl_gtk_slave_c_funs("         printf(              \"" + fn_name + "%d\\n\", result);      fflush( stdout );\n");
		    to_mythryl_gtk_slave_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%d\\n\", result);      fflush( log_fd );\n");
		    to_mythryl_gtk_slave_c_funs "    }\n";
		    to_mythryl_gtk_slave_c_funs "}\n";
		    to_mythryl_gtk_slave_c_funs "/* Above fn generated by write_mythryl_gtk_slave_c_plain_fun. */\n";
		};

	    "Float"
		=>
		{   to_mythryl_gtk_slave_c_funs "\n";
		    to_mythryl_gtk_slave_c_funs("        double result = " + lowcode + ";\n");
		    to_mythryl_gtk_slave_c_funs "\n";
		    to_mythryl_gtk_slave_c_funs("         printf(              \"" + fn_name + "%f\\n\", result);      fflush( stdout );\n");
		    to_mythryl_gtk_slave_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%f\\n\", result);      fflush( log_fd );\n");
		    to_mythryl_gtk_slave_c_funs "    }\n";
		    to_mythryl_gtk_slave_c_funs "}\n";
		    to_mythryl_gtk_slave_c_funs "/* Above fn generated by write_mythryl_gtk_slave_c_plain_fun. */\n";

		};

	    "Int"
		=>
		{   to_mythryl_gtk_slave_c_funs "\n";
		    to_mythryl_gtk_slave_c_funs("        int result = " + lowcode + ";\n");
		    to_mythryl_gtk_slave_c_funs "\n";
		    to_mythryl_gtk_slave_c_funs("         printf(              \"" + fn_name + "%d\\n\", result);      fflush( stdout );\n");
		    to_mythryl_gtk_slave_c_funs("        fprintf(log_fd, \"SENT: " + fn_name + "%d\\n\", result);      fflush( log_fd );\n");
		    to_mythryl_gtk_slave_c_funs "    }\n";
		    to_mythryl_gtk_slave_c_funs "}\n";
		    to_mythryl_gtk_slave_c_funs "/* Above fn generated by write_mythryl_gtk_slave_c_plain_fun. */\n";
		};

	    _   =>  raise exception FAIL (sprintf "Unsupported result type '%s' at line %d" result *state.line_number);

	esac;

	gtk_slave_plain_fns_autogenerated
            :=
	    *gtk_slave_plain_fns_autogenerated
            + 1;
    };

#
fun generate_gtk_driver_c_fun_header (fn_name, fn_type, args, lowcode, result_type)
    =
    {
	my (input_type, output_type)
            =
       	    gtk_driver_api_type (lowcode, result_type);

        # C comments don't nest, so we must change
	# any C comments in input_type or output_type:
	#
	input_type  = regex::replace_all   .|/\*|   "(*"    input_type;
	input_type  = regex::replace_all   .|\*/|   "*)"    input_type;
	#
	output_type = regex::replace_all   .|/\*|   "(*"   output_type;
	output_type = regex::replace_all   .|\*/|   "*)"   output_type;


	to_gtk_driver_c ("/* _lib7_Gtk_" + fn_name + "\n");
	to_gtk_driver_c  " *\n";
	to_gtk_driver_c (" * gtk.api        type:   " + (   fn_type =~ ./^\(/ ?? "" :: " ") + fn_type + "\n");
	to_gtk_driver_c (" * gtk-driver.api type:   " + (input_type =~ ./^\(/ ?? "" :: " ") + input_type + " -> " + output_type + "\n");
	to_gtk_driver_c  " */\n";
	to_gtk_driver_c  "lib7_val_t\n";
	to_gtk_driver_c  "\n";
	to_gtk_driver_c ("_lib7_Gtk_" + fn_name + "   (lib7_state_t *lib7_state, lib7_val_t arg)\n");
	to_gtk_driver_c  "{\n";
	to_gtk_driver_c  "#if (HAVE_GTK_2_0_GTK_GTK_H || HAVE_GTK_GTK_H)\n";
	to_gtk_driver_c  "\n";
    };

#
fun generate_gtk_driver_c_fun_trailer ()
    =
    {
	to_gtk_driver_c  "#else\n";
	to_gtk_driver_c  "    extern char* no_gtk_support_in_runtime;\n";
	to_gtk_driver_c  "    return RAISE_ERROR(lib7_state, no_gtk_support_in_runtime);\n";
	to_gtk_driver_c  "#endif\n";
	to_gtk_driver_c  "}\n";
	to_gtk_driver_c "/* Above fn generated by write_gtk_driver_c_plain_fun. */\n";
	to_gtk_driver_c  "\n";
	to_gtk_driver_c  "\n";
    };


# Generate C code
# to fetch all the arguments
# out of argc/argv:
#
fun generate_gtk_driver_c_fun_arg_loads (fn_name, fn_type, args, lowcode)
    =
    {
	case args
	    0 => ();

#            Having just one argument used to be a special case
#            because then we passed the argument directly rather
#            than packed within a tuple.  But the first argument
#            to a gtk-driver.pkg function is always a Session,
#            and it is more efficient to pass on the tuple from
#            that layer to the gtk-driver.c layer rather than
#            unpacking and repacking just to get rid of the Session
#            argument, consequently if we have any arguments of
#            interest (i.e., non-Session arguments) at this point
#            we will always have a tuple, eliminating the special
#	     case.  I've left this code here, commented out, just
#            in case this situation changes and it is needed again:
#
#
#            1 => {  arg_type = get_nth_arg_type( 0, lowcode );
#
#		    if   (arg_type == "b")    to_gtk_driver_c "    int    b0 = INT_LIB7toC(arg) == LIB7_true;\n";
#		    elif (arg_type == "f")    to_gtk_driver_c "    double f0 = *(PTR_LIB7toC(double, arg));\n";
#		    elif (arg_type == "i")    to_gtk_driver_c "    int    i0 = INT_LIB7toC(arg);\n";
#		    elif (arg_type == "s")    to_gtk_driver_c "    char*  s0 = STR_LIB7toC(arg);\n";
#		    elif (arg_type == "w")
#
#			# Usually we fetch a widget as just
#			#
#			#    GtkWidget* widget    =  widget[ INT_LIB7toC(arg) ];
#			#
#			# or such, but in a few cases we must cast to
#			# another type:
#			#  o If we see   GTK_ADJUSTMENT(w0)    we must do   GtkAdjustment*  w0 =  (GtkAdjustment*)  widget[ INT_LIB7toC(arg) ];
#			#  o If we see   GTK_SCALE(w0)         we must do   GtkScale*       w0 =  (GtkScale*)       widget[ INT_LIB7toC(arg) ];
#			#  o If we wee   GTK_RADIO_BUTTON(w0)  we must do   GtkRadioButton* w0 =  (GtkRadioButton*) widget[ INT_LIB7toC(arg) ];
#
#			widget_type = REF "GtkWidget";
#
#			if   (lowcode =~   ./GTK_ADJUSTMENT\(\s*w0\s*\)/)   widget_type := "GtkAdjustment";
#			elif (lowcode =~        ./GTK_SCALE\(\s*w0\s*\)/)   widget_type := "GtkScale";
#			elif (lowcode =~ ./GTK_RADIO_BUTTON\(\s*w0\s*\)/)   widget_type := "GtkRadioButton";
#			fi;
#
#			to_gtk_driver_c (sprintf  "    %-14s    w0 =    %-16s  widget[ INT_LIB7toC(arg) ];\n"
#                                                  (*widget_type + "*")
#                                                  ("(" + *widget_type + "*)")
#                                        );
#
#		    else
#			raise exception FAIL ("Bug: unsupported arg type '" + arg_type + "' #0 from lowcode '" + lowcode + "\n");
#		    fi;
#		};

            _ => {  if (args < 0)  die "generate_gtk_driver_c_fun_arg_loads: Negative 'args' value not supported.";  fi;

		    for (a = 0;   a < args;  ++a) {

			# Remember type of this arg,
			# which will be one of:
			#   w (widget),
			#   i (int),
			#   b (bool)
			#   s (string)
			#   f (double):
			#
			arg_type = get_nth_arg_type( a, lowcode );

			if   (arg_type == "b")    to_gtk_driver_c (sprintf  "    int               b%d =                              REC_SEL(    arg, %d) == LIB7_true;\n"   a (a+1));		# +1 because first arg is always Session.
			elif (arg_type == "f")    to_gtk_driver_c (sprintf  "    double            f%d =        *(PTR_LIB7toC(double, REC_SEL(    arg, %d)));\n"              a (a+1));
			elif (arg_type == "i")    to_gtk_driver_c (sprintf  "    int               i%d =                              REC_SELINT( arg, %d);\n"                a (a+1));
			elif (arg_type == "s")    to_gtk_driver_c (sprintf  "    char*             s%d =                 STR_LIB7toC (REC_SEL(    arg, %d));\n"               a (a+1));
			elif (arg_type == "w")

			    # Usually we fetch a widget as just
			    #
			    #    GtkWidget* widget    =  widget[ REC_SELINT (arg, i) ];
			    #
			    # or such, but in a few cases we must cast to
			    # another type:
			    #  o If we see   GTK_ADJUSTMENT(w0)    we must do   GtkAdjustment*  w0 =  (GtkAdjustment*)   widget[ REC_SELINT( arg, i) ];
			    #  o If we see   GTK_SCALE(w0)         we must do   GtkScale*       w0 =  (GtkScale*)        widget[ REC_SELINT( arg, i) ];
			    #  o If we wee   GTK_RADIO_BUTTON(w0)  we must do   GtkRadioButton* w0  =  (GtkRadioButton*) widget[ REC_SELINT( arg, i) ];

			    widget_type = REF "GtkWidget";

			    if   (lowcode =~ (sprintf   "GTK_ADJUSTMENT\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkAdjustment";
			    elif (lowcode =~ (sprintf        "GTK_SCALE\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkScale";
			    elif (lowcode =~ (sprintf "GTK_RADIO_BUTTON\\(\\s*w%d\\s*\\)" a))   widget_type := "GtkRadioButton";
			    fi;

			    to_gtk_driver_c (sprintf  "    %-14s    w%d =    %-16s  widget[ REC_SELINT( arg, %d) ];\n"
                                                      (*widget_type + "*")
                                                      a
                                                      ("(" + *widget_type + "*)")
                                                      (a+1)				# +1 because first arg is always Session.
                                            );

			else
			    raise exception FAIL ("Bug: unsupported arg type '" + arg_type + "' #" + int::to_string a + " from lowcode '" + lowcode + "\n");
			fi;

		    };
		};
	esac;
    };
#
fun generate_gtk_driver_c_fun_body
    ( state: State,
      fn_name,			# E.g., "make_window2"
      fn_type,			# E.g., "Session -> Widget".
      lowcode,			# E.g., "gtk_window_new( GTK_WINDOW_TOPLEVEL )".
      result_type		# E.g., "Float"
    )
    =
    {
	case result_type

            "Void"
                =>
                {   # Now we just print
		    # the supplied gtk call
		    # and wrap up:
		    #
		    to_gtk_driver_c "\n";
		    to_gtk_driver_c ("    " + lowcode + ";\n");
		    to_gtk_driver_c "\n";
		    to_gtk_driver_c  "    return LIB7_void;\n";
		};

	    "new Widget"
		=>
		{   to_gtk_driver_c  "\n";
		    to_gtk_driver_c  "    int slot = find_free_widget_slot ();\n";
		    to_gtk_driver_c  "\n";
		    to_gtk_driver_c ("    widget[slot] = " + lowcode + ";\n");
		    to_gtk_driver_c  "\n";
		    to_gtk_driver_c  "    return INT_CtoLib7(slot);\n";
		};

	    "Widget"
		=>
		{   to_gtk_driver_c  "\n";
		    to_gtk_driver_c ("    GtkWidget* widget = (GtkWidget*) " + lowcode + ";\n");
		    to_gtk_driver_c  "\n";
		    to_gtk_driver_c  "    int slot = get_widget_id( widget );\n";
		    to_gtk_driver_c  "\n";
		    to_gtk_driver_c  "    return INT_CtoLib7(slot);\n";
		};

	    "Bool"
		=>
		{   to_gtk_driver_c  "\n";
		    to_gtk_driver_c ("    int result = " + lowcode + ";\n");
		    to_gtk_driver_c  "\n";
		    to_gtk_driver_c  "    return  result ? LIB7_true : LIB7_false;\n";
		};

	    "Float"
		=>
		{   to_gtk_driver_c  "\n";
		    to_gtk_driver_c ("    double d = " + lowcode + ";\n");
		    to_gtk_driver_c  "\n";
		    to_gtk_driver_c  "    lib7_val_t               result;\n";
		    to_gtk_driver_c  "    REAL64_ALLOC(lib7_state, result, d);\n";
		    to_gtk_driver_c  "    return                   result;\n";
		};

	    "Int"
		=>
		{   to_gtk_driver_c  "\n";
		    to_gtk_driver_c ("    int result = " + lowcode + ";\n");
		    to_gtk_driver_c  "\n";
		    to_gtk_driver_c  "    return INT_CtoLib7(result);\n";
		};

	    _   =>  raise exception FAIL (sprintf "Unsupported result type '%s' at line %d"  result_type  *state.line_number);

	esac;
    };

# Synthesize a function for   gtk-driver.c  like
# 
#   /* _lib7_Gtk_gtk_init : Void -> Void
#    *
#    *
#    */
#   lib7_val_t
#   
#   _lib7_Gtk_gtk_init (lib7_state_t *lib7_state, lib7_val_t arg)
#   {
#   #if (HAVE_GTK_2_0_GTK_GTK_H || HAVE_GTK_GTK_H)
#   
#       int y         = INT32_LIB7toC( REC_SELINT(arg, 0) );
#       char *symname = STR_LIB7toC(   REC_SEL   (arg, 1) );
#       int lazy      =                REC_SEL   (arg, 2) == LIB7_true;
#
#       int result = move( y, x );
#   
#       if (result == ERR)     return RAISE_ERROR(lib7_state, "move");
#   
#       return LIB7_void;
#   #else
#       extern char* no_gtk_support_in_runtime;
#       return RAISE_ERROR(lib7_state, no_gtk_support_in_runtime);
#   #endif
#   }
#    
#    
#    
# Cheatsheet:
#    
#   Accepting a lone float arg:
#      double d = *(PTR_LIB7toC(double, arg));		# Example in src/runtime/c-libs/lib7-math/cos64.c
#
#   Accepting a lone int arg:
#      int socket = INT_LIB7toC(arg);			# Example in src/runtime/c-libs/lib7-socket/accept.c
#
#   Accepting a lone string arg:			# Example in src/runtime/c-libs/posix-filesys/readlink.c
#      char* path = STR_LIB7toC(arg);
#
#   Accepting a lone Null_Or( Tuple ) arg:		# Example in src/runtime/c-libs/lib7-socket/getprotbyname.c
#       
#   Accepting a Bool from a tuple:      		# Example in src/runtime/c-libs/dl/dlopen.c
#     int lazy = REC_SEL (arg, 1) == LIB7_true;
#
#   Accepting an Int from a tuple:			# Example in src/runtime/c-libs/posix-filesys/fchown.c
#     int fd =  REC_SELINT (arg, 0);
#
#   Accepting a String from a tuple:			# Example in src/runtime/c-libs/dl/dlsym.c
#     char *symname = STR_LIB7toC (REC_SEL (arg, 1));
#       
#   Accepting a Float from a tuple:			# THIS IS MY OWN GUESS!
#     double d =  *(PTR_LIB7toC(double, REC_SEL(arg,%d)));
#
#   Accepting a Null_Or(String) from a tuple:   	# Example in src/runtime/c-libs/dl/dlopen.c
#       
#       
#   Returning
#
#     Void:    return LIB7_void;			# Defined in src/runtime/include/runtime-values.h
#     TRUE:    return LIB7_true;			# Defined in src/runtime/include/runtime-values.h
#     FALSE:   return LIB7_false;			# Defined in src/runtime/include/runtime-values.h
#     Int:     return INT_CtoLib7(size);		# Defined in src/runtime/include/runtime-values.h
#     NULL:    return OPTION_NONE;			# Defined in src/runtime/include/runtime-heap.h    Example in src/runtime/machine-dependent/unix-signal.c
#     THE foo: lib7_val_t result;
#              OPTION_SOME(lib7_state, result, foo);	# Defined in src/runtime/include/runtime-heap.h
#              return result;				# Example in src/runtime/machine-dependent/unix-signal.c
#
#   Returning a float:
#         lib7_val_t		   result;
#         REAL64_ALLOC(lib7_state, result, cos(d));	# Defined in src/runtime/include/runtime-heap.h
#         return                   result;
#
#   Returning a string:
#       lib7_val_t result = LIB7_AllocString(lib7_state, size);
#	strncpy (STR_LIB7toC(result), buf, size);
#	return result;
#    
#   Returning a tuple:					# Example from src/runtime/c-libs/lib7-date/gmtime.c
#
#       LIB7_AllocWrite(lib7_state, 0, MAKE_DESC(DTAG_record, 9));
#       LIB7_AllocWrite(lib7_state, 1, INT_CtoLib7(tm->tm_sec));
#       ...
#       LIB7_AllocWrite(lib7_state, 9, INT_CtoLib7(tm->tm_isdst));
#
#       return LIB7_Alloc(lib7_state, 9);
#    
#    
#     Return functions which check ERR
#     and optionally raise an exception:             src/runtime/c-libs/lib7-c.h
#
#	CHK_RETURN_VAL(lib7_state, status, val)	Check status for an error (< 0); if okay,
#					then return val.  Otherwise raise
#					SYSTEM_ERROR with the appropriate system
#					error message.
#
#	CHK_RETURN(lib7_state, status)	Check status for an error (< 0); if okay,
#					then return it as the result (after
#					converting to an Lib7 int).
#
#	CHK_RETURN_UNIT(lib7_state, status)	Check status for an error (< 0); if okay,
#					then return Void.
#
#     REC_SEL &Co        are from:  src/runtime/include/runtime-values.h
#     LIB7_AllocString    is from:  src/runtime/include/runtime-heap.h
#     CHK_RETURN_VAL &Co are from:  src/runtime/c-libs/lib7-c.h
#
fun write_gtk_driver_c_plain_fun
    ( state: State,
      fn_name,			# E.g., "make_window2"
      fn_type,			# E.g., "Session -> Widget".
      lowcode,			# E.g., "gtk_window_new( GTK_WINDOW_TOPLEVEL )".
      result_type		# E.g., "Float"
    )
    =
    {
	arg_count = count_args( lowcode );

	generate_gtk_driver_c_fun_header    (       fn_name, fn_type, arg_count, lowcode, result_type);
	generate_gtk_driver_c_fun_arg_loads (       fn_name, fn_type, arg_count, lowcode);
	generate_gtk_driver_c_fun_body      (state, fn_name, fn_type, lowcode, result_type);

	generate_gtk_driver_c_fun_trailer ();

	gtk_driver_plain_fns_autogenerated
            :=
	    *gtk_driver_plain_fns_autogenerated
            + 1;
    };

# Given a lowcode like      "gtk_foo( /*bar_to_int bar*/i0, /*zot*/i1 )"
# and a parameter name like  "i0" or "i1"
# return nickname like       "bar_to_int bar" or "zot"
# if available, else         "i0" or "i1":
#
fun arg_name (arg, lowcode)
    =
    {   regex = .|/\*([A-Za-z0-9_' ]+)\*/| + arg;	# Something like:   /*([A-Za-z0-9_' ]+)*/f0

	(regex::find_first_group 1 regex lowcode)
        except
            NOT_FOUND = arg;
    };

# Given a lowcode like      "gtk_foo( /*bar_to_int bar*/i0, /*zot*/i1 )"
# and a parameter name like  "i0" or "i1"
# return nickname like       "bar" or "zot"
# if available, else         "i0" or "i1":
#
fun param_name (arg, lowcode)
    =
    {   regex = .|/\*([A-Za-z0-9_' ]+)\*/| + arg;	# Something like:   /*([A-Za-z0-9_' ]+)*/f0

        {
	    name = regex::find_first_group 1 regex lowcode;

	    # If 'name' contains blanks, we want
	    # only the part after the last blank:
	    # 
	    name = (regex::find_first_group 1 .|^[:A-Za-z0-9_' ]+ ([A-Za-z0-9_']+)$| name)
                   except
                       NOT_FOUND = name;

	    name;
        }
        except NOT_FOUND = arg;
    };

# Synthesize a function for   gtk-g.pkg  like
# 
#	 #
#        fun make_vertical_scale_with_range (session: Session, min, max, step)
#            =
#	    d::make_vertical_scale_with_range (session.subsession, min, max, step);
#
fun write_gtk_g_pkg_plain_fun( state: State,  fn_name, lowcode)
    =
    case (maybe_get_field (state, "code"))

        THE field
            =>
            {   to_gtk_g_pkg_funs  "        #\n";
                to_gtk_g_pkg_funs  field;
		to_gtk_g_pkg_funs  "            \n";
		to_gtk_g_pkg_funs  "            # Above function handgenerated via write_gtk_pkg_plain_fun.\n";
                to_gtk_g_pkg_funs  "\n";

		gtk_g_pkg_plain_fns_handgenerated
                    :=
                    *gtk_g_pkg_plain_fns_handgenerated + 1;
	    };

	NULL =>
	    {
		arg_count = count_args( lowcode );

		fun make_args get_name		# get_name will be arg_name or param_name.
		    =
		    for (a = 0; a < arg_count; ++a) {

			# Remember type of this arg,
			# which will be one of:
			#   w (widget),
			#   i (int),
			#   b (bool)
			#   s (string)
			#   f (double):
			#
			arg_type = get_nth_arg_type( a, lowcode );

			arg = sprintf "%s%d" arg_type a;

			to_gtk_g_pkg_funs (sprintf ", %s" (get_name (arg, lowcode)));
		    }; 

		# Select between  foo  (session.subsession, bar, zot);
                #                 foo { session.subsession, bar, zot };
		#
		my (lparen, rparen)
		    =
		    # It is a poor idea to have gtk-g.pkg functions
		    # with multiple arguments of the same type use
		    # argument tuples, because it is too easy to
		    # mis-order such arguments, and the compiler
		    # type checking won't flag it -- in such cases
		    # it is better to use argument records:
		    #
		    arg_types_are_all_unique  lowcode
			??  ( "(" ,  ")" )
			::  ( "{ ", " }" );

		to_gtk_g_pkg_funs "\n";
		to_gtk_g_pkg_funs "        #\n";
		to_gtk_g_pkg_funs "        fun ";
		to_gtk_g_pkg_funs fn_name;


		to_gtk_g_pkg_funs (sprintf " %ssession: Session"  lparen);
		make_args  param_name;
		to_gtk_g_pkg_funs (sprintf "%s\n" rparen);


		# Select between  d::foo   session.subsession;
                #                 d::foo  (session.subsession, bar, zot);
		#
		my (lparen, rparen)
		    =
		    arg_count == 0
			??  (" ", "" )
			::  ("(", ")");

		fn_name =   regex::replace_all ./'/ "2" fn_name;		# Primes don't work in C!

		to_gtk_g_pkg_funs          "            =\n";
		to_gtk_g_pkg_funs (sprintf "            d::%s %ssession.subsession" fn_name lparen);
		make_args  arg_name;
		to_gtk_g_pkg_funs (sprintf "%s;\n" rparen);

		to_gtk_g_pkg_funs "            \n";
		to_gtk_g_pkg_funs "            # Above function autogenerated by write_gtk_pkg_plain_fun.\n";
		to_gtk_g_pkg_funs "\n";


		gtk_g_pkg_plain_fns_autogenerated
		    :=
		    *gtk_g_pkg_plain_fns_autogenerated
		    + 1;
	    };
    esac;

# Synthesize a function for   gtk-g.pkg  like
# 
#	 #
#	 fun set_clicked_callback  s w c = set_void_callback (s, c, d::set_clicked_callback (s.subsession, w));	# Handle "clicked" signal.
#
fun write_gtk_g_pkg_callback_fun
    ( state: State,
      fn_name,			# E.g. "set_foo_callback"
      callback_type		# E.g. "Void_Callback"
    )
    =
    case (maybe_get_field (state, "code"))

        THE field
            =>
            {   to_gtk_g_pkg_funs  "        #\n";
                to_gtk_g_pkg_funs  field;
		to_gtk_g_pkg_funs  "            \n";
		to_gtk_g_pkg_funs  "            # Above function handgenerated via write_gtk_pkg_callback_fun.\n";
                to_gtk_g_pkg_funs  "\n";

		gtk_g_pkg_callback_fns_handgenerated
                    :=
                    *gtk_g_pkg_callback_fns_handgenerated + 1;
	    };

	NULL =>
	    {
		signal_name
                    =
                    (regex::find_first_group 1 ./^set_(.*)_callback$/  fn_name)
                    except
                        NOT_FOUND
                            =
                            die (sprintf "write_gtk_g_pkg_callback_fun: fn_name '%s' does not have form set_foo_callback for any foo\n" fn_name);

		note_callback_fn = "note_" + (tolower callback_type);		# "Void_Callback" -> "note_void_callback"

                to_gtk_g_pkg_funs
                    (    sprintf "    fun %-36s s w c = %-28s (s, c, d::%-36s (s.subsession, w));\t# Handle '%s' signal\n"
                                 fn_name
                                 note_callback_fn
                                 fn_name
                                 signal_name
                    );

		gtk_g_pkg_callback_fns_autogenerated
		    :=
		    *gtk_g_pkg_callback_fns_autogenerated
		    + 1;
	    };
    esac;


# Synthesize a function for   mythryl-gtk-slave.c  like
#
#    static void
#    do_set_foo_callback( int argc, unsigned char** argv )
#    {
#	check_argc( "do_foo_callback", 1, argc );
#
#	{   GtkWidget* widget    =  widget_arg( argc, argv, 0 );
#
#	    int id   =  find_free_callback_id ();
#
#	    g_signal_connect( G_OBJECT(widget), "foo", G_CALLBACK( run_foo_callback ), (void*)id );
#
#	    printf(               "set_foo_callback%d\n", id );	fflush( stdout );
#	    fprintf(log_fd, "SENT: set_foo_callback%d\n", id );	fflush( log_fd );
#	}
#    }
#
fun write_gtk_slave_c_set_callback_fun (callback_name, lowtype)
    =
    {
	to_mythryl_gtk_slave_c_funs "\n";
	to_mythryl_gtk_slave_c_funs "static void\n";
	to_mythryl_gtk_slave_c_funs("do_set_" + callback_name + "_callback( int argc, unsigned char** argv )\n");
	to_mythryl_gtk_slave_c_funs "{\n";
	to_mythryl_gtk_slave_c_funs("    check_argc( \"do_set_" + callback_name + "_callback\", 1, argc );\n");
	to_mythryl_gtk_slave_c_funs "\n";
	to_mythryl_gtk_slave_c_funs "    {   GtkWidget* widget    =  widget_arg( argc, argv, 0 );\n";
	to_mythryl_gtk_slave_c_funs "\n";
	to_mythryl_gtk_slave_c_funs "        int id   =  find_free_callback_id ();\n";
	to_mythryl_gtk_slave_c_funs "\n";
	to_mythryl_gtk_slave_c_funs("        g_signal_connect( " + lowtype + "(widget), \"" + callback_name + "\", G_CALLBACK( run_" + callback_name + "_callback ), (void*)id );\n");
	to_mythryl_gtk_slave_c_funs "\n";
	to_mythryl_gtk_slave_c_funs("         printf(              \"set_" + callback_name + "_callback%d\\n\", id );      fflush( stdout );\n");
	to_mythryl_gtk_slave_c_funs("        fprintf(log_fd, \"SENT: set_" + callback_name + "_callback%d\\n\", id );      fflush( log_fd );\n");
	to_mythryl_gtk_slave_c_funs "    }\n";
	to_mythryl_gtk_slave_c_funs "}\n";
	to_mythryl_gtk_slave_c_funs "/* Above fn generated by write_gtk_slave_c_set_callback_fun. */\n";

	gtk_slave_callback_fns_autogenerated
            :=
	    *gtk_slave_callback_fns_autogenerated
            + 1;
    };

# Synthesize a function for   gtk-driver.c  like
#
#   /* _lib7_Gtk_set_foo_callback : Session -> Widget -> Void_Callback -> Void;
#    */
#   lib7_val_t
#   
#   _lib7_Gtk_set_foo_callback (lib7_state_t *lib7_state, lib7_val_t arg)
#   {
#   #if (HAVE_GTK_2_0_GTK_GTK_H || HAVE_GTK_GTK_H)
#   
#       GtkWidget*        w0 =    (GtkWidget*)      widget[ INT_LIB7toC(arg) ];
#
#       int id   =  find_free_callback_id ();
#
#       g_signal_connect( G_OBJECT(widget), "clicked", G_CALLBACK( run_clicked_callback ), (void*)id );
#
#       return INT_CtoLib7(id);
#   #else
#       extern char* no_gtk_support_in_runtime;
#       return RAISE_ERROR(lib7_state, no_gtk_support_in_runtime);
#   #endif
#   }
#    
fun write_gtk_driver_c_set_callback_fun
    ( callback_name,
      fn_type,			# E.g., "Session -> Widget -> Void_Callback -> Void".
      lowtype
    )
    =
    {
	to_gtk_driver_c "\n";
	to_gtk_driver_c "\n";
	to_gtk_driver_c("/*  _lib7_Gtk_set_" + callback_name + "_callback : " + fn_type + "\n");
	to_gtk_driver_c " */\n";
	to_gtk_driver_c "lib7_val_t\n";
	to_gtk_driver_c "\n";
	to_gtk_driver_c("_lib7_Gtk_set_" + callback_name + "_callback (lib7_state_t *lib7_state, lib7_val_t arg)\n");
	to_gtk_driver_c "{\n";
	to_gtk_driver_c  "#if (HAVE_GTK_2_0_GTK_GTK_H || HAVE_GTK_GTK_H)\n";
	to_gtk_driver_c  "\n";
	to_gtk_driver_c  "    GtkWidget*        w0 =    (GtkWidget*)      widget[ INT_LIB7toC(arg) ];\n";
	to_gtk_driver_c  "\n";
	to_gtk_driver_c "    int id   =  find_free_callback_id ();\n";
	to_gtk_driver_c "\n";
	to_gtk_driver_c("    g_signal_connect( " + lowtype + "(widget), \"" + callback_name + "\", G_CALLBACK( run_" + callback_name + "_callback ), (void*)id );\n");
	to_gtk_driver_c "\n";
	to_gtk_driver_c "    return INT_CtoLib7(id);\n";
	to_gtk_driver_c  "#else\n";
	to_gtk_driver_c  "    extern char* no_gtk_support_in_runtime;\n";
	to_gtk_driver_c  "    return RAISE_ERROR(lib7_state, no_gtk_support_in_runtime);\n";
	to_gtk_driver_c  "#endif\n";
	to_gtk_driver_c  "}\n";
	to_gtk_driver_c "/* Above fn generated by write_gtk_driver_c_set_callback_fun. */\n";
	to_gtk_driver_c  "\n";
	to_gtk_driver_c  "\n";

	gtk_driver_callback_fns_autogenerated
            :=
	    *gtk_driver_callback_fns_autogenerated
            + 1;
    };

# Synthesize a gtk.api line like
#
#      make_window:    Session -> Widget;
#
stipulate

    line_count = REF 2;

herein

    #
    fun write_gtk_api_function_declaration (fn_name, fn_type)
	=
	{
	    # Add a blank line every three declarations:
	    #
	    line_count := *line_count + 1;

	    if ((*line_count % 3) == 0)

		to_gtk_api_funs  "\n";
	    fi;

	    # The 'if' here is just to exdent by one char
            # types starting with a paren, so that we get
            #
            #     foo:    Session -> Void;
            #     bar:   (Session, Widget) -> Void;
            #
            # rather than the slightly rattier looking  
            #
            #     foo:    Session -> Void;
            #     bar:    (Session, Widget) -> Void;
            #
	    if (fn_type =~ ./^\(/)	to_gtk_api_funs (sprintf "    %-40s%s;\n"  (fn_name + ":")  fn_type);
	    else			to_gtk_api_funs (sprintf "    %-41s%s;\n"  (fn_name + ":")  fn_type);
            fi;
	};
end;

#
fun update_field (state: State, field_name, field_line)
    =
    {
	case (string_map::get (*state.fields, field_name))

	    THE field
		=>
		{   field.string := *field.string + field_line;
		    field.line_n := *state.line_number;

		    string_map::set (*state.fields, field_name, field);

		    ();
		};

	    NULL =>
		{   field = { string =>  REF field_line,
			      line_1 =>  REF *state.line_number,
			      line_n =>  REF *state.line_number,
			      used   =>  REF FALSE
			    };

		    state.fields
                        :=
                        string_map::set (*state.fields, field_name, field);

		    ();
		};
	esac;
    };

#
fun make_callback_function (state: State)
    =
    {
	fn_name  =  get_field(state, "fn-name");		# "set_foo_callback"
	fn_type  =  get_field(state, "fn-type");		# "Session -> Widget -> Foo_Callback -> Void"
	lowtype  =  get_field(state, "lowtype");		# "G_OBJECT"

	callback_name
	    =
	    (regex::find_first_group 1 ./^set_(.*)_callback$/  fn_name)
            except
                NOT_FOUND
                    =
		    die (sprintf "%s: callback-fn fn-name '%s' does not have form 'set_foo_callback' for any 'foo'\n"
                                 (get_field_location (state, "fn-name"))
                                 fn_name
                        );

	callback_type		# E.g., "Void_Callback"
	    =
	    (regex::find_first_group 1 ./^Session\s+->\s+Widget\s+->\s+(\S+)\s+->\s+Void$/ fn_type)
            except
                NOT_FOUND
                    =
		    die (sprintf "%s: callback-fn fn-type '%s' does not have form 'Session -> Widget -> Foo_Callback -> Void' for any 'foo'\n"
                                 (get_field_location (state, "fn-type"))
                                 fn_type
                        );

	callback_name
	    =
	    regex::replace_all ./'/ "2" callback_name;		# Primes don't work in C!

	fn_name2 = "set_" + callback_name + "_callback";

	write_gtk_slave_c_set_callback_fun( callback_name, lowtype );
	write_gtk_driver_c_set_callback_fun( callback_name, fn_type, lowtype );

        write_cfun_list_h_entry          (fn_name2, fn_type);
	write_trie_entry_for_gtk_slave_c( fn_name2 );

	url =   case (maybe_get_field(state,"url"))
		    THE field => field;
		    NULL      => "http://library.gnome.org/devel/gobject/unstable/gobject-Signals.html#g-signal-connect";
		esac;

	note_libref_tex_entry { state, fn_name, url, fn_type, lowcode => "g_signal_connect" };

	lowcode    = "w0";		# Give arg counts and types to the following two functions.
	result_type = "Int";		# Give result information   to the following two functions.

	write_gtk_driver_api_function          (fn_name2, lowcode, result_type);
	write_gtk_via_pipe_driver_pkg_function (fn_name2, lowcode, result_type);
	write_gtk_driver_pkg_function          (fn_name, fn_name2, fn_type, lowcode, result_type);
        write_gtk_api_function_declaration     (fn_name, fn_type);
        write_gtk_g_pkg_callback_fun(    state, fn_name, callback_type);
    };

#
fun make_plain_function (state: State)
    =
    {	
	url   = case (maybe_get_field(state,"url"))
		    #	
                    THE field => field;
                    NULL      => "";
                esac;

	fn_name =  get_field(state, "fn-name");	# E.g., "make_window".
	fn_type =  get_field(state, "fn-type");	# E.g., "Session -> Widget".
	lowcode =  get_field(state, "lowcode");	# E.g., "gtk_window_new( GTK_WINDOW_TOPLEVEL )".

	fn_name2 =  regex::replace_all  ./'/  "2"  fn_name;

	# result_type can be "Int", "String", "Bool", "Float" or "Void".
	#
        # It can also be "Widget" or "new Widget", the difference being
	# that in the former case the mythryl-gtk-slave.c logic can merely
	# fetch it out of its array  widget[],  whereas in the latter a
	# new entry is being created in  widget[].
	#
	# We can usually deduce the difference:  If fn_name starts with
	# "make_" then we have the "new Widget" case, otherwise we have
	# the "Widget" case:
	#
	result_type
	    =
	    case (maybe_get_field (state, "result"))
		#
		THE string => string;
		#
		NULL =>
		    # Pick off terminal  " -> Void"
                    # or whatever from fn_type
		    # and switch on it:
		    #
		    case (regex::find_first_group 1 ./->\s*([A-Za-z_']+)\s*$/ fn_type)
			 "Bool"   => "Bool";
			 "Float"  => "Float";
			 "Int"    => "Int";
			 "String" => "String";
			 "Void"   => "Void";

			 "Widget"
			    =>
			    if (fn_name =~ ./^make_/)   "new Widget";
			    else                            "Widget";
			    fi;

			 other =>  die (sprintf "Unsupported result fn-type %s in type %s at %s..\n"
						other
						fn_type
					       (get_field_location (state, "fn-type"))
				      );
		    esac
                    except
                        NOT_FOUND
                            =
			    die (sprintf "Unsupported result fn-type %s at %s..\n"
					 fn_type
					 (get_field_location (state, "fn-type"))
                                );
	    esac;

	write_mythryl_gtk_slave_c_plain_fun (state, fn_name2, fn_type, lowcode, result_type);
	write_gtk_driver_c_plain_fun        (state, fn_name2, fn_type, lowcode, result_type);
        write_cfun_list_h_entry                    (fn_name2, fn_type);

	write_trie_entry_for_gtk_slave_c( fn_name2 );

	note_libref_tex_entry { state, fn_name, lowcode, url, fn_type };

	write_gtk_driver_api_function           (fn_name2, lowcode, result_type);
	write_gtk_via_pipe_driver_pkg_function  (fn_name2, lowcode, result_type);

	write_gtk_driver_pkg_function           (fn_name, fn_name2, fn_type, lowcode, result_type);
        write_gtk_api_function_declaration      (fn_name, fn_type);

        write_gtk_g_pkg_plain_fun( state, fn_name, lowcode);
    };


#
fun make_function_doc (state: State)
    =
    {	
	url    = case (maybe_get_field(state,"url"))
		     #	
                     THE field => field;
                     NULL      => "";
                 esac;

	fn_name  =  get_field(state, "fn-name");	# "make_window" or such.
	fn_type  =  get_field(state, "fn-type");	# "Session -> Widget" or such.

	note_libref_tex_entry { state, fn_name, lowcode => "", url, fn_type };
    };


#
fun make_mythryl_type (state: State)
    =
    {	
	type     =  get_field(state, "type");

	to_gtk_api_types    type;
	to_gtk_g_pkg_types  type;
    };

fun make_mythryl_code (state: State)
    =
    {	
	code     =  get_field(state, "code");

	to_gtk_g_pkg_funs  code;
    };


#
fun handle_fieldset (state: State)
    =
    {
	if (not  (string_map::is_empty  *state.fields))
	    #
	    case (trim (get_field (state, "make")))
		#
		"callback-fn"  =>  make_callback_function  state;
		"plain-fn"     =>  make_plain_function     state;
		"fn-doc"       =>  make_function_doc       state;
		"mythryl-type" =>  make_mythryl_type       state;
		"mythryl-code" =>  make_mythryl_code       state;

		other => die (sprintf "Unsupported 'make' field value '%s' at %s\n" other (get_field_location (state, "make")));
	    esac;

	    clear_state  state;
	fi;
    };    

# Scan src/lib/src/gtk-glue.config
# digesting the blank-line-delimited
# config info paragraphs, then
# synthesize code accordingly:
# 
fun process_config_file ()
    =
    {   fun loop  (state: State)
	    =
	    case (file::read_line  state.fd)
		#
		NULL => handle_fieldset  state;			# Done.
		#
		THE input_line
		    =>
		    {   state.line_number :=  *state.line_number + 1;

			if   (input_line =~ ./^\s*#/)

			    # Ignore comment lines:
			    #
                            loop  state;

                        elif (input_line =~ ./^\s*$/)

			    # Empty line marks the end of a field cluster,
			    # so process any fields we have in hand:
			    #
			    handle_fieldset  state;

			else

			    # Line format should be  "line-type: rest".
			    # Split it into two strings at the ':' and
			    # dispatch on the line type:
			    #
			    case (regex::find_first_groups_all ./^([^:]+):(.*\n)$/ input_line)
				#
				[ line_type, line_contents ]
				    =>
				    {   # Drop leading and trailing whitespace:
					#
				        line_type
                                            =
                                            trim  line_type;

					line_contents
                                            =
					    case line_type
                                                "type"      =>       line_contents;	# Contains raw indented code, so leave whitespace in place and restore dropped newline.
                                                "code"      =>       line_contents;	# Contains raw indented code, so leave whitespace in place and restore dropped newline.
                                                _           => trim  line_contents;	# Drop leading and trailing whitespace.
                                            esac;

					update_field (state,  line_type,  line_contents);
				    };

				_
				    =>
				    die ("make-gtk-glue: UNRecognized gtk-glue.config line: '" + (chomp input_line) + "'\n");
			    esac
                            except
                                NOT_FOUND
				    =
				    die (sprintf "make-gtk-glue: Unrecognized gtk-glue.config line %d: '%s'\n" *state.line_number (chomp input_line));

			fi;

			loop  state;				# Scan rest of file.
		    };
	    esac;

        config_file_in =  file::open_for_read  config_file_path;

	loop { line_number =>  REF 0,
               fd          =>  config_file_in,
               fields      =>  REF (string_map::empty: string_map::Map( Field ))
             };

	file::close_input  config_file_in;
    };


gtk_driver_api          =  read_patchable_file   gtk_driver_api_path;
gtk_via_pipe_driver_pkg =  read_patchable_file   gtk_via_pipe_driver_pkg_path;
gtk_driver_pkg          =  read_patchable_file   gtk_driver_pkg_path;
gtk_g_pkg               =  read_patchable_file   gtk_g_pkg_path;
gtk_api                 =  read_patchable_file   gtk_api_path;
mythryl_gtk_slave_c     =  read_patchable_file   mythryl_gtk_slave_c_path;
cfun_list_h             =  read_patchable_file   cfun_list_h_path;
gtk_driver_c            =  read_patchable_file   gtk_driver_c_path;



process_config_file    ();



printf "%4d   plain     functions autogenerated for gtk-driver.c\n"         *gtk_driver_plain_fns_autogenerated;
printf "%4d   callback  functions autogenerated for gtk-driver.c\n"         *gtk_driver_callback_fns_autogenerated;

printf "%4d   plain     functions autogenerated for mythryl-gtk-slave.c\n"  *gtk_slave_plain_fns_autogenerated;
printf "%4d   callback  functions autogenerated for mythryl-gtk-slave.c\n"  *gtk_slave_callback_fns_autogenerated;

printf "%4d   plain     functions autogenerated for gtk-g.pkg\n"            *gtk_g_pkg_plain_fns_autogenerated;
printf "%4d   plain     functions handgenerated for gtk-g.pkg\n"            *gtk_g_pkg_plain_fns_handgenerated;

printf "%4d   callback  functions autogenerated for gtk-g.pkg\n"            *gtk_g_pkg_callback_fns_autogenerated;
printf "%4d   callback  functions handgenerated for gtk-g.pkg\n"            *gtk_g_pkg_callback_fns_handgenerated;



write_patchable_file  gtk_driver_api           [ INTRON (reverse *gtk_driver_api_intron)          ];
write_patchable_file  gtk_via_pipe_driver_pkg  [ INTRON (reverse *gtk_via_pipe_driver_pkg_intron) ];
write_patchable_file  gtk_driver_pkg           [ INTRON (reverse *gtk_driver_pkg_intron)          ];
write_patchable_file  gtk_api                  [ INTRON (reverse *gtk_api_types_intron),
                                                 INTRON (reverse *gtk_api_funs_intron)
                                               ];
write_patchable_file  gtk_g_pkg                [ INTRON (reverse *gtk_g_pkg_types_intron),
                                                 INTRON (reverse *gtk_g_pkg_funs_intron)
                                               ];
write_patchable_file  mythryl_gtk_slave_c      [ INTRON (reverse *mythryl_gtk_slave_c_funs_intron),
                                                 INTRON (reverse *mythryl_gtk_slave_c_trie_intron)
                                               ];
write_patchable_file  cfun_list_h              [ INTRON (reverse *cfun_list_h_intron)             ];
write_patchable_file  gtk_driver_c             [ INTRON (reverse *gtk_driver_c_intron)            ];



if (-F libref_tex_path)

    libref_tex =  read_patchable_file   libref_tex_path;

    write_libref_tex_table  (.fn_name, .lowcode, to_libref_table1_tex);
    write_libref_tex_table  (.lowcode, .fn_name, to_libref_table2_tex);

    write_patchable_file  libref_tex           [ INTRON (reverse *libref_tex_table1_intron),
                                                 INTRON (reverse *libref_tex_table2_intron)
                                               ];
fi;



exit(0);



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################



## Code by Jeff Prothero: Copyright (c) 2010,
## released under Gnu Public Licence version 3.
