# gtk-driver.pkg

# Compiled by:
#     src/lib/std/standard.lib

# This file handles the Mythryl side
# of the Mythryl <-> C interface
# layer for the Mythryl in-process
# Gtk binding.  The C side
# is implemented by
#
#     src/c/lib/gtk/gtk-driver.c
#
# Our alternative sub-process implementation is
#     src/lib/src/gtk-via-pipe-driver.pkg

# Immediate TODO list:
#   o Hack gtk-driver.pkg so all binding fns theoretically work.
#   o Figure out what happens when GTK_ADJUSTMENT() and such throw an error and how to trap and handle it.
#   o Hack make-gtk-glue to process pending callbacks at end of each binding fn.
#   o Hack both drivers to use decomposed outer loop.
#         http://www.gtk.org/api/2.6/glib/glib-The-Main-Event-Loop.html
#   o Hack gtk-via-driver-unit-test.pkg to use decomposed loop and actually press its button.

stipulate
    package imp =  int_red_black_map;					# int_red_black_map			is from   src/lib/src/int-red-black-map.pkg
herein

    package gtk_driver: Gtk_Driver  {					# Gtk_Driver				is from   src/lib/src/gtk-driver.api
	#
	package ci = unsafe::mythryl_callable_c_library_interface;	# unsafe				is from   src/lib/std/src/unsafe/unsafe.pkg
									# mythryl_callable_c_library_interface	is from   src/lib/std/src/unsafe/mythryl-callable-c-library-interface.pkg
	include gtk_event;						# gtk_event				is from   src/lib/src/gtk-event.pkg


	Session
	    =
	    { void_callback_map:              Ref (imp::Map( Void            -> Void )),
	      bool_callback_map:              Ref (imp::Map( Bool            -> Void )),
	      float_callback_map:             Ref (imp::Map( Float           -> Void )),
	      button_event_callback_map:      Ref (imp::Map( Button_Event    -> Void )),
	      motion_event_callback_map:      Ref (imp::Map( Motion_Event    -> Void )),
	      key_event_callback_map:         Ref (imp::Map( Key_Event       -> Void )),
	      expose_event_callback_map:      Ref (imp::Map( Expose_Event    -> Void )),
	      configure_event_callback_map:   Ref (imp::Map( Configure_Event -> Void ))
	    };



	# Define the different types of
	# callback queue entries supported.
	#
	# WARNING! Must be kept in sync
	# with matching declarations in
	#
	#     src/c/lib/gtk/gtk-driver.c
	#
	my          queued_void_callback = 1;
	my          queued_bool_callback = 2;
	my         queued_float_callback = 3;
	my  queued_button_press_callback = 4;
	my     queued_key_press_callback = 5;
	my queued_motion_notify_callback = 6;
	my        queued_expose_callback = 7;
	my     queued_configure_callback = 8;

	my init:   Void -> Void
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "init" };

	#################################################################################################
	# These functions are our interface to the
	#     callback_queue[]
	# in
	#     src/c/lib/gtk/gtk-driver.c
	# 
	my  callback_queue_is_empty:   Void -> Bool
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "callback_queue_is_empty" };

	# 
	my  number_of_queued_callbacks:   Void -> Int
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "number_of_queued_callbacks" };

	# 
	my  type_of_next_queued_callback:   Void -> Int
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "type_of_next_queued_callback" };

	# 
	my  get_queued_void_callback:   Void -> Int
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_void_callback" };

	# 
	my  get_queued_bool_callback:   Void -> (Int, Bool)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_bool_callback" };

	# 
	my  get_queued_float_callback:   Void -> (Int, Float)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_float_callback" };

	# 
	my  get_queued_button_press_callback:   Void -> (Int, Int, Int, Float, Float, Int, Int)	# Void -> (callback_number, widget_id, button, x, y, time, modifiers)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_button_press_callback" };

	# 
	my  get_queued_key_press_callback:   Void -> (Int, Int, Int, Int, Int)			# Void -> (callback_number, key, keycode, time, modifiers)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_key_press_callback" };

	# 
	my  get_queued_motion_notify_callback:   Void -> (Int, Int, Int, Float, Float, Int, Bool)	# Void -> (callback_number, widget_id, time, x, y, modifiers, is_hint)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_motion_notify_callback" };

	# 
	my  get_queued_expose_callback:   Void -> (Int, Int, Int, Int, Int, Int, Int)		# Void -> (callback_number, widget, count, area_x, area_y, area_wide, area_high)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_expose_callback" };

	# 
	my  get_queued_configure_callback:   Void -> (Int, Int, Int, Int, Int, Int)			# Void -> (callback_number, widget, x,    y,    wide, high)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_queued_configure_callback" };



	#################################################################################################
	# These functions are too irregular to fit into our
	# usual code autogeneration scheme:

	# 
	my do_get_widget_allocation:  Int -> (Int, Int, Int, Int)					# Widget -> (x, y, wide, high)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_widget_allocation" };

	# 
	my do_get_window_pointer:  Int -> (Int, Int, Int)						# Widget -> (x, y, modifiers)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "get_window_pointer" };

	# 
	my do_make_dialog:  Void -> (Int, Int, Int)							# Void -> (dialog, vbox, action_area)
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "make_dialog" };

	# 
	my do_unref_object:  Int -> Void								# Widget -> Void
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "unref_object" };

	# 
	my do_run_eventloop_once:  Bool -> Bool							# Bool -> Bool
	    =
	    unsafe::mythryl_callable_c_library_interface::find_c_function { lib_name => "gtk", fun_name => "run_eventloop_once" };


	# A line like
	#     "CALLBACK17"
	# means to execute callback 17
	# in our callback_map.
	#
	# A line like
	#     "BOOL_CALLBACK17 TRUE"
	# means to execute callback 17
	# in our bool_callback_map with an argument of TRUE.
	#
	# A line like
	#     "FLOAT_CALLBACK17 2.3"
	# means to execute callback 17
	# in our float_callback_map with an argument of 2.3.
	#
	# A line like
	#     "BUTTON_CALLBACK17 1 23.3 52.9"
	# means to tell callback 17 that mouse button 1 was clicked at x,y of (23.3, 52.9)
	# ...
	# and so forth. :)
	#
	fun run_pending_callbacks  (session: Session): Void
	    =
	    # Check how many callbacks are currently
	    # in the gtk-driver.c callback_queue[]
	    # and then process that many.
	    #
	    # Note that more callbacks may get entered
	    # into that queue as we do so:  We
	    # deliberately do not process any such
	    # added callbacks in order to avoid the
	    # risk of getting into a loop that might
	    # cycle-starve other computations:
	    #
	    loop (number_of_queued_callbacks ())
	    where
		fun loop 0 => ();

		    loop i
			=>
			{   run_one_callback();
			    loop (i - 1);
			};
		end

		also
		fun run_one_callback ()
		    =
		    {   callback_type = type_of_next_queued_callback ();
			#
			if (callback_type == queued_void_callback)
			    #
			    callback_id = get_queued_void_callback ();

			    case (imp::get (*session.void_callback_map, callback_id))
				#
				THE callback =>  callback ();
				NULL         =>  (); 
			    esac;

			elif (callback_type == queued_bool_callback)
			    #
			    (get_queued_bool_callback ())
				->
			        (callback_id, bool);

			    case (imp::get (*session.bool_callback_map, callback_id))
				#
				THE callback =>  callback bool;
				NULL         =>  (); 
			    esac;

			elif (callback_type == queued_float_callback)
			    #
			    (get_queued_float_callback ())
				->
			        (callback_id, float);

			    case (imp::get (*session.float_callback_map, callback_id))
				#
				THE callback =>  callback float;
				NULL         =>  (); 
			    esac;

			elif (callback_type == queued_button_press_callback)
			    #
			    (get_queued_button_press_callback ())
				->
			        (callback_id, window, button, x, y, time, modifiers);


			    # Args are:
			    #     window receiving the event
			    #     button pressed;
			    #     pointer x-coord;
			    #     pointer y-coord;
			    #     event time in milliseconds; and
			    #     bitbag of modifier keys.

			    args = { window, button, x, y, time, modifiers =>  int_to_modifier_list modifiers };

			    case (imp::get (*session.button_event_callback_map, callback_id))
				#
				THE callback =>  callback args;
				NULL         =>  (); 
			    esac;

			elif (callback_type == queued_key_press_callback)
			    #
			    (get_queued_key_press_callback ())
				->
			        (callback_id, key, keycode, time, modifiers);


			    # Args are:
			    #     key;
			    #     keycode;
			    #     millisecond time;
			    #     modifiers.

			    args = { key, keycode, time, modifiers => int_to_modifier_list modifiers };

			    case (imp::get (*session.key_event_callback_map, callback_id))
				#
				THE callback =>  callback args;
				NULL         =>  (); 
			    esac;

			elif (callback_type == queued_motion_notify_callback)
			    #
			    (get_queued_motion_notify_callback())
				->
			        (callback_id, window, time, x, y, modifiers, is_hint);


			    # Args are:
			    #     window which received the event;
			    #     millisecond-accurate sample time;
			    #     pointer x-coord; and
			    #     pointer y-coord.

			    args = { window,
				     time,
				     x,
				     y,
				     modifiers =>  int_to_modifier_list  modifiers,
				     is_hint
				   };

			    case (imp::get (*session.motion_event_callback_map, callback_id))
				#
				THE callback =>  callback args;
				NULL         =>  (); 
			    esac;

			elif (callback_type == queued_expose_callback)
			    #
			    (get_queued_expose_callback ())
				->
			        (callback_id, window, count, x, y, wide, high);


			    # 'count' is count of following expose events.

			    args = { window, count, x, y, wide, high };

			    case (imp::get (*session.expose_event_callback_map, callback_id))
				#
				THE callback =>  callback args;
				NULL         =>  (); 
			    esac;


			elif (callback_type == queued_configure_callback)
			    #
			    (get_queued_configure_callback ())
				->
			        (callback_id, window, x, y, wide, high);

			    args = { window, x, y, wide, high };

			    case (imp::get (*session.configure_event_callback_map, callback_id))
				#
				THE callback =>  callback args;
				NULL         =>  (); 
			    esac;

			else
			    raise exception FAIL (sprintf "run_one_callback: Internal error: unsupported callback_type %d" callback_type);
			fi;
		    };			 	# fun run_one_callback
	    end;					# where



	#################################################################################################
	# Autogenerated code specified in   src/lib/src/gtk-glue.config
	# 
    # Do not edit this or following lines -- they are autogenerated by make-gtk-glue.

	#                  Session -> Widget                                                      # gtk.api type
	my make_window:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_window" };


	#                (Session, String) -> Widget                                              # gtk.api type
	my make_label:   (Session, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_label" };


	#                                (Session, Widget, String) -> Int                         # gtk.api type
	my make_status_bar_context_id:   (Session, Int/*Widget*/, String) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_status_bar_context_id" };


	#                Session -> Widget                                                        # gtk.api type
	my make_menu:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_menu" };


	#                       Session -> Widget                                                 # gtk.api type
	my make_option_menu:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_option_menu" };


	#                    Session -> Widget                                                    # gtk.api type
	my make_menu_bar:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_menu_bar" };


	#                     Session -> Widget                                                   # gtk.api type
	my make_combo_box:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_combo_box" };


	#                          Session -> Widget                                              # gtk.api type
	my make_text_combo_box:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_text_combo_box" };


	#                (Session, String) -> Widget                                              # gtk.api type
	my make_frame:   (Session, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_frame" };


	#                  Session -> Widget                                                      # gtk.api type
	my make_button:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_button" };


	#                            (Session, String) -> Widget                                  # gtk.api type
	my make_button_with_label:   (Session, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_button_with_label" };


	#                               (Session, String) -> Widget                               # gtk.api type
	my make_button_with_mnemonic:   (Session, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_button_with_mnemonic" };


	#                         Session -> Widget                                               # gtk.api type
	my make_toggle_button:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_toggle_button" };


	#                                   (Session, String) -> Widget                           # gtk.api type
	my make_toggle_button_with_label:   (Session, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_toggle_button_with_label" };


	#                                      (Session, String) -> Widget                        # gtk.api type
	my make_toggle_button_with_mnemonic:   (Session, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_toggle_button_with_mnemonic" };


	#                        Session -> Widget                                                # gtk.api type
	my make_check_button:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_check_button" };


	#                                  (Session, String) -> Widget                            # gtk.api type
	my make_check_button_with_label:   (Session, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_check_button_with_label" };


	#                                     (Session, String) -> Widget                         # gtk.api type
	my make_check_button_with_mnemonic:   (Session, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_check_button_with_mnemonic" };


	#                     Session -> Widget                                                   # gtk.api type
	my make_menu_item:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_menu_item" };


	#                               (Session, String) -> Widget                               # gtk.api type
	my make_menu_item_with_label:   (Session, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_menu_item_with_label" };


	#                                  (Session, String) -> Widget                            # gtk.api type
	my make_menu_item_with_mnemonic:   (Session, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_menu_item_with_mnemonic" };


	#                              Session -> Widget                                          # gtk.api type
	my make_first_radio_button:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_first_radio_button" };


	#                            (Session, Widget) -> Widget                                  # gtk.api type
	my make_next_radio_button:   (Session, Int/*Widget*/) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_next_radio_button" };


	#                                        (Session, String) -> Widget                      # gtk.api type
	my make_first_radio_button_with_label:   (Session, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_first_radio_button_with_label" };


	#                                       (Session, Widget, String) -> Widget               # gtk.api type
	my make_next_radio_button_with_label:   (Session, Int/*Widget*/, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_next_radio_button_with_label" };


	#                                           (Session, String) -> Widget                   # gtk.api type
	my make_first_radio_button_with_mnemonic:   (Session, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_first_radio_button_with_mnemonic" };


	#                                          (Session, Widget, String) -> Widget            # gtk.api type
	my make_next_radio_button_with_mnemonic:   (Session, Int/*Widget*/, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_next_radio_button_with_mnemonic" };


	#                (Session, Arrow_Direction, Shadow_Style) -> Widget                       # gtk.api type
	my make_arrow:   (Session, Int, Int) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_arrow" };


	#               (Session, Widget, Arrow_Direction, Shadow_Style) -> Void                  # gtk.api type
	my set_arrow:   (Session, Int/*Widget*/, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_arrow" };


	#                         (Session, Bool, Int)   ->   Widget                              # gtk.api type
	my make_horizontal_box:   (Session, Bool, Int) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_box" };


	#                       (Session, Bool, Int)   ->   Widget                                # gtk.api type
	my make_vertical_box:   (Session, Bool, Int) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_box" };


	#                                 Session -> Widget                                       # gtk.api type
	my make_horizontal_button_box:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_button_box" };


	#                               Session -> Widget                                         # gtk.api type
	my make_vertical_button_box:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_button_box" };


	#                 { session: Session,   rows: Int,   cols: Int,   homogeneous: Bool }   ->   Widget   # gtk.api type
	my make_table:   (Session, Int, Int, Bool) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_table" };


	#                     Session -> Widget                                                   # gtk.api type
	my make_event_box:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_event_box" };


	#                          (Session, String) -> Widget                                    # gtk.api type
	my make_image_from_file:   (Session, String) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_image_from_file" };


	#                                Session -> Widget                                        # gtk.api type
	my make_horizontal_separator:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_separator" };


	#                              Session -> Widget                                          # gtk.api type
	my make_vertical_separator:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_separator" };


	#                            Session -> Widget                                            # gtk.api type
	my make_layout_container:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_layout_container" };


	#                 { session: Session,  layout: Widget,  kid: Widget,  x: Int,  y: Int } -> Void   # gtk.api type
	my layout_put:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "layout_put" };


	#                  { session: Session, layout: Widget,  kid: Widget,  x: Int,  y: Int } -> Void   # gtk.api type
	my layout_move:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "layout_move" };


	#                           Session -> Widget                                             # gtk.api type
	my make_fixed_container:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_fixed_container" };


	#                { session: Session, layout: Widget,  kid: Widget,  x: Int,  y: Int } -> Void   # gtk.api type
	my fixed_put:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "fixed_put" };


	#                 { session: Session, layout: Widget,  kid: Widget,  x: Int,  y: Int } -> Void   # gtk.api type
	my fixed_move:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "fixed_move" };


	#                      { session: Session,   value: Float,   lower: Float,   upper: Float,   step_increment: Float,   page_increment: Float,   page_size: Float }   ->   Widget   # gtk.api type
	my make_adjustment:   (Session, Float, Float, Float, Float, Float, Float) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_adjustment" };


	#                    { session: Session, horizontal_adjustment: Null_Or(Widget), vertical_adjustment: Null_Or(Widget) } -> Widget   # gtk.api type
	my make_viewport:   (Session, Int/*Widget*/, Int/*Widget*/) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_viewport" };


	#                           { session: Session, horizontal_adjustment: Null_Or(Widget), vertical_adjustment: Null_Or(Widget) } -> Widget   # gtk.api type
	my make_scrolled_window:   (Session, Int/*Widget*/, Int/*Widget*/) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_scrolled_window" };


	#                            Session -> Widget                                            # gtk.api type
	my make_horizontal_ruler:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_ruler" };


	#                          Session -> Widget                                              # gtk.api type
	my make_vertical_ruler:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_ruler" };


	#                             (Session, Null_Or(Widget)) -> Widget                        # gtk.api type
	my make_vertical_scrollbar:   (Session, Int/*Widget*/) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_scrollbar" };


	#                               (Session, Null_Or(Widget)) -> Widget                      # gtk.api type
	my make_horizontal_scrollbar:   (Session, Int/*Widget*/) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_scrollbar" };


	#                         (Session, Null_Or(Widget)) -> Widget                            # gtk.api type
	my make_vertical_scale:   (Session, Int/*Widget*/) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_scale" };


	#                           (Session, Null_Or(Widget)) -> Widget                          # gtk.api type
	my make_horizontal_scale:   (Session, Int/*Widget*/) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_scale" };


	#                                     { session: Session, min: Float, max: Float, step: Float } -> Widget   # gtk.api type
	my make_vertical_scale_with_range:   (Session, Float, Float, Float) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_vertical_scale_with_range" };


	#                                       { session: Session, min: Float, max: Float, step: Float } -> Widget   # gtk.api type
	my make_horizontal_scale_with_range:   (Session, Float, Float, Float) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_horizontal_scale_with_range" };


	#                        Session -> Widget                                                # gtk.api type
	my make_drawing_area:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_drawing_area" };


	#                  { session: Session, window: Widget, wide: Int, high: Int } -> Widget   # gtk.api type
	my make_pixmap:   (Session, Int/*Widget*/, Int, Int) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_pixmap" };


	#                      Session -> Widget                                                  # gtk.api type
	my make_status_bar:   (Session) -> Int /*new Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "make_status_bar" };


	#                             (Session, Widget, Int, String) -> Int                       # gtk.api type
	my push_text_on_status_bar:   (Session, Int/*Widget*/, Int, String) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "push_text_on_status_bar" };


	#                             (Session, Widget, Int) -> Void                              # gtk.api type
	my pop_text_off_status_bar:   (Session, Int/*Widget*/, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "pop_text_off_status_bar" };


	#                                  { session: Session,   status_bar: Widget,   context: Int,   message: Int } -> Void   # gtk.api type
	my remove_text_from_status_bar:   (Session, Int/*Widget*/, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "remove_text_from_status_bar" };


	#               { session: Session,   box: Widget,   kid: Widget,   pack: Pack_From,   expand: Bool,   fill: Bool,   padding: Int } -> Void   # gtk.api type
	my pack_box:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Bool, Bool, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "pack_box" };


	#                        { session: Session,   menu: Widget,   kid: Widget } -> Void      # gtk.api type
	my menu_shell_append:   (Session, Int/*Widget*/, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "menu_shell_append" };


	#                      { session: Session,   menu: Widget,   kid: Widget } -> Void        # gtk.api type
	my menu_bar_append:   (Session, Int/*Widget*/, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "menu_bar_append" };


	#                              (Session, Widget, String) -> Void                          # gtk.api type
	my append_text_to_combo_box:   (Session, Int/*Widget*/, String) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "append_text_to_combo_box" };


	#                           { session: Session,   option_menu: Widget,   menu: Widget } -> Void   # gtk.api type
	my set_option_menu_menu:   (Session, Int/*Widget*/, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_option_menu_menu" };


	#                                (Session, Widget, String) -> Void                        # gtk.api type
	my set_text_tooltip_on_widget:   (Session, Int/*Widget*/, String) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_text_tooltip_on_widget" };


	#                      (Session, Widget, Metric) -> Void                                  # gtk.api type
	my set_ruler_metric:   (Session, Int/*Widget*/, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_ruler_metric" };


	#                      { session: Session,   ruler: Widget,   lower: Float,   upper: Float,   position: Float,   max_size: Float } -> Void   # gtk.api type
	my set_ruler_range:   (Session, Int/*Widget*/, Float, Float, Float, Float) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_ruler_range" };


	#                           { session: Session,   window: Widget,   horizontal_scrollbar: Scrollbar_Policy,   vertical_scrollbar: Scrollbar_Policy } -> Void   # gtk.api type
	my set_scrollbar_policy:   (Session, Int/*Widget*/, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_scrollbar_policy" };


	#                     { session: Session,   drawable: Widget,   gcontext: Widget,   filled:	Bool,   x: Int,   y: Int,   wide: Int,   high: Int } -> Void   # gtk.api type
	my draw_rectangle:   (Session, Int/*Widget*/, Int/*Widget*/, Bool, Int, Int, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "draw_rectangle" };


	#                    { session: Session,   drawable: Widget,   gcontext: Widget,   from: Widget,   from_x:	Int,   from_y: Int,   to_x: Int,   to_y: Int,   wide: Int,   high: Int } -> Void   # gtk.api type
	my draw_drawable:   (Session, Int/*Widget*/, Int/*Widget*/, Int/*Widget*/, Int, Int, Int, Int, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "draw_drawable" };


	#                   { session: Session,   widget:	Widget,   x: Int,   y: Int,   wide: Int,   high: Int } -> Void   # gtk.api type
	my queue_redraw:   (Session, Int/*Widget*/, Int, Int, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "queue_redraw" };


	#                  (Session, Widget) -> Void                                              # gtk.api type
	my press_button:   (Session, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "press_button" };


	#                    (Session, Widget) -> Void                                            # gtk.api type
	my release_button:   (Session, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "release_button" };


	#                  (Session, Widget) -> Void                                              # gtk.api type
	my click_button:   (Session, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "click_button" };


	#                  (Session, Widget) -> Void                                              # gtk.api type
	my enter_button:   (Session, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "enter_button" };


	#                  (Session, Widget) -> Void                                              # gtk.api type
	my leave_button:   (Session, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "leave_button" };


	#                 (Session, Widget) -> Void                                               # gtk.api type
	my show_widget:   (Session, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "show_widget" };


	#                      (Session, Widget) -> Void                                          # gtk.api type
	my show_widget_tree:   (Session, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "show_widget_tree" };


	#                    (Session, Widget) -> Void                                            # gtk.api type
	my destroy_widget:   (Session, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "destroy_widget" };


	#                         (Session, Widget)   -> Void                                     # gtk.api type
	my emit_changed_signal:   (Session, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "emit_changed_signal" };


	#                      (Session, Widget)   -> Void                                        # gtk.api type
	my pop_up_combo_box:   (Session, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "pop_up_combo_box" };


	#                        (Session, Widget) -> Void                                        # gtk.api type
	my pop_down_combo_box:   (Session, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "pop_down_combo_box" };


	#                         (Session, Widget, String)   -> Void                             # gtk.api type
	my set_combo_box_title:   (Session, Int/*Widget*/, String) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_combo_box_title" };


	#                      (Session, Widget, String) -> Void                                  # gtk.api type
	my set_window_title:   (Session, Int/*Widget*/, String) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_window_title" };


	#                             (Session, Widget, (Int,Int)) -> Void                        # gtk.api type
	my set_window_default_size:   (Session, Int/*Widget*/, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_window_default_size" };


	#                             (Session, Widget, (Int,Int)) -> Void                        # gtk.api type
	my set_minimum_widget_size:   (Session, Int/*Widget*/, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_minimum_widget_size" };


	#                      (Session, Widget, Int) -> Void                                     # gtk.api type
	my set_border_width:   (Session, Int/*Widget*/, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_border_width" };


	#                              (Session, Widget, Bool) -> Void                            # gtk.api type
	my set_event_box_visibility:   (Session, Int/*Widget*/, Bool) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_event_box_visibility" };


	#                           { session: Session, widget: Widget, x: Float, y: Float } -> Void   # gtk.api type
	my set_widget_alignment:   (Session, Int/*Widget*/, Float, Float) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_widget_alignment" };


	#                       (Session, Widget, List( Event_Mask )) -> Void                     # gtk.api type
	my set_widget_events:   (Session, Int/*Widget*/, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_widget_events" };


	#                     (Session, Widget, String) -> Void                                   # gtk.api type
	my set_widget_name:   (Session, Int/*Widget*/, String) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_widget_name" };


	#                             (Session, Widget, Justification) -> Void                    # gtk.api type
	my set_label_justification:   (Session, Int/*Widget*/, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_label_justification" };


	#                             (Session, Widget, Bool) -> Void                             # gtk.api type
	my set_label_line_wrapping:   (Session, Int/*Widget*/, Bool) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_label_line_wrapping" };


	#                          (Session, Widget, String) -> Void                              # gtk.api type
	my set_label_underlines:   (Session, Int/*Widget*/, String) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_label_underlines" };


	#                              (Session, Widget, Position_Type) -> Void                   # gtk.api type
	my set_scale_value_position:   (Session, Int/*Widget*/, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_scale_value_position" };


	#                          (Session, Widget, Bool) -> Void                                # gtk.api type
	my set_draw_scale_value:   (Session, Int/*Widget*/, Bool) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_draw_scale_value" };


	#                                  (Session, Widget) -> Int                               # gtk.api type
	my get_scale_value_digits_shown:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "get_scale_value_digits_shown" };


	#                                  (Session, Widget, Int)  -> Void                        # gtk.api type
	my set_scale_value_digits_shown:   (Session, Int/*Widget*/, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_scale_value_digits_shown" };


	#                             (Session, Widget, Update_Policy) -> Void                    # gtk.api type
	my set_range_update_policy:   (Session, Int/*Widget*/, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_range_update_policy" };


	#                             (Session, Widget) -> Bool                                   # gtk.api type
	my get_toggle_button_state:   (Session, Int/*Widget*/) -> Bool
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "get_toggle_button_state" };


	#                             (Session, Widget, Bool) -> Void                             # gtk.api type
	my set_toggle_button_state:   (Session, Int/*Widget*/, Bool) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_toggle_button_state" };


	#                          (Session, Widget) -> Float                                     # gtk.api type
	my get_adjustment_value:   (Session, Int/*Widget*/) -> Float
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "get_adjustment_value" };


	#                          (Session, Widget, Float) -> Void                               # gtk.api type
	my set_adjustment_value:   (Session, Int/*Widget*/, Float) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_adjustment_value" };


	#                                (Session, Widget) -> Widget                              # gtk.api type
	my get_white_graphics_context:   (Session, Int/*Widget*/) -> Int /*Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "get_white_graphics_context" };


	#                                (Session, Widget) -> Widget                              # gtk.api type
	my get_black_graphics_context:   (Session, Int/*Widget*/) -> Int /*Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "get_black_graphics_context" };


	#                                             (Session, Widget) -> Widget                 # gtk.api type
	my get_current_foreground_graphics_context:   (Session, Int/*Widget*/) -> Int /*Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "get_current_foreground_graphics_context" };


	#                                             (Session, Widget) -> Widget                 # gtk.api type
	my get_current_background_graphics_context:   (Session, Int/*Widget*/) -> Int /*Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "get_current_background_graphics_context" };


	#                       (Session, Widget) -> Widget                                       # gtk.api type
	my get_widget_window:   (Session, Int/*Widget*/) -> Int /*Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "get_widget_window" };


	#              { session: Session,   mom: Widget,   kid: Widget } -> Void                 # gtk.api type
	my add_kid:   (Session, Int/*Widget*/, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "add_kid" };


	#                              { session: Session,   window: Widget,   kid: Widget } -> Void   # gtk.api type
	my add_scrolled_window_kid:   (Session, Int/*Widget*/, Int/*Widget*/) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "add_scrolled_window_kid" };


	#                    { session: Session,   table: Widget,   kid: Widget,   left: Int,   right: Int,   top: Int,   bottom: Int } -> Void   # gtk.api type
	my add_table_kid:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Int, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "add_table_kid" };


	#                     { session: Session,   table: Widget,   kid: Widget,   left: Int,   right: Int,   top: Int,   bottom: Int,   xoptions: List( Table_Attach_Option ),   yoptions: List( Table_Attach_Option ),   xpadding: Int,   ypadding: Int }   ->   Void   # gtk.api type
	my add_table_kid2:   (Session, Int/*Widget*/, Int/*Widget*/, Int, Int, Int, Int, Int, Int, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "add_table_kid2" };


	#                                      (Session, Widget) -> Widget                        # gtk.api type
	my get_viewport_vertical_adjustment:   (Session, Int/*Widget*/) -> Int /*Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "get_viewport_vertical_adjustment" };


	#                                        (Session, Widget) -> Widget                      # gtk.api type
	my get_viewport_horizontal_adjustment:   (Session, Int/*Widget*/) -> Int /*Widget*/
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "get_viewport_horizontal_adjustment" };


	#                            { session: Session, table: Widget, row: Int, spacing: Int } -> Void   # gtk.api type
	my set_table_row_spacing:   (Session, Int/*Widget*/, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_table_row_spacing" };


	#                            { session: Session, table: Widget, col: Int, spacing: Int } -> Void   # gtk.api type
	my set_table_col_spacing:   (Session, Int/*Widget*/, Int, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_table_col_spacing" };


	#                            (Session, Widget, Int) -> Void                               # gtk.api type
	my set_table_row_spacings:   (Session, Int/*Widget*/, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_table_row_spacings" };


	#                            (Session, Widget, Int) -> Void                               # gtk.api type
	my set_table_col_spacings:   (Session, Int/*Widget*/, Int) -> Void
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_table_col_spacings" };


	#                           Session -> Widget -> Void_Callback -> Void                    # gtk.api type
	my set_clicked_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_clicked_callback" };


	#                           Session -> Widget -> Void_Callback -> Void                    # gtk.api type
	my set_pressed_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_pressed_callback" };


	#                           Session -> Widget -> Void_Callback -> Void                    # gtk.api type
	my set_release_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_release_callback" };


	#                         Session -> Widget -> Void_Callback -> Void                      # gtk.api type
	my set_enter_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_enter_callback" };


	#                         Session -> Widget -> Void_Callback -> Void                      # gtk.api type
	my set_leave_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_leave_callback" };


	#                            Session -> Widget -> Void_Callback -> Void                   # gtk.api type
	my set_activate_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_activate_callback" };


	#                           Session -> Widget -> Void_Callback -> Void                    # gtk.api type
	my set_destroy_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_destroy_callback" };


	#                           Session -> Widget -> Void_Callback -> Void                    # gtk.api type
	my set_realize_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_realize_callback" };


	#                                      Session -> Widget -> Button_Event_Callback -> Void   # gtk.api type
	my set_button_press_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_button_press_event_callback" };


	#                                        Session -> Widget -> Void_Callback -> Void       # gtk.api type
	my set_button_release_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_button_release_event_callback" };


	#                                Session -> Widget -> Void_Callback -> Void               # gtk.api type
	my set_scroll_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_scroll_event_callback" };


	#                                       Session -> Widget -> Motion_Event_Callback -> Void   # gtk.api type
	my set_motion_notify_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_motion_notify_event_callback" };


	#                                Session -> Widget -> Void_Callback -> Void               # gtk.api type
	my set_delete_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_delete_event_callback" };


	#                                Session -> Widget -> Expose_Event_Callback -> Void       # gtk.api type
	my set_expose_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_expose_event_callback" };


	#                                   Session -> Widget -> Key_Event_Callback -> Void       # gtk.api type
	my set_key_press_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_key_press_event_callback" };


	#                                     Session -> Widget -> Void_Callback -> Void          # gtk.api type
	my set_key_release_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_key_release_event_callback" };


	#                                      Session -> Widget -> Void_Callback -> Void         # gtk.api type
	my set_enter_notify_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_enter_notify_event_callback" };


	#                                      Session -> Widget -> Void_Callback -> Void         # gtk.api type
	my set_leave_notify_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_leave_notify_event_callback" };


	#                                   Session -> Widget -> Configure_Event_Callback -> Void   # gtk.api type
	my set_configure_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_configure_event_callback" };


	#                                  Session -> Widget -> Void_Callback -> Void             # gtk.api type
	my set_focus_in_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_focus_in_event_callback" };


	#                                   Session -> Widget -> Void_Callback -> Void            # gtk.api type
	my set_focus_out_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_focus_out_event_callback" };


	#                             Session -> Widget -> Void_Callback -> Void                  # gtk.api type
	my set_map_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_map_event_callback" };


	#                               Session -> Widget -> Void_Callback -> Void                # gtk.api type
	my set_unmap_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_unmap_event_callback" };


	#                                         Session -> Widget -> Void_Callback -> Void      # gtk.api type
	my set_property_notify_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_property_notify_event_callback" };


	#                                         Session -> Widget -> Void_Callback -> Void      # gtk.api type
	my set_selection_clear_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_selection_clear_event_callback" };


	#                                           Session -> Widget -> Void_Callback -> Void    # gtk.api type
	my set_selection_request_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_selection_request_event_callback" };


	#                                          Session -> Widget -> Void_Callback -> Void     # gtk.api type
	my set_selection_notify_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_selection_notify_event_callback" };


	#                                      Session -> Widget -> Void_Callback -> Void         # gtk.api type
	my set_proximity_in_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_proximity_in_event_callback" };


	#                                       Session -> Widget -> Void_Callback -> Void        # gtk.api type
	my set_proximity_out_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_proximity_out_event_callback" };


	#                                Session -> Widget -> Void_Callback -> Void               # gtk.api type
	my set_client_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_client_event_callback" };


	#                                   Session -> Widget -> Void_Callback -> Void            # gtk.api type
	my set_no_expose_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_no_expose_event_callback" };


	#                                      Session -> Widget -> Void_Callback -> Void         # gtk.api type
	my set_window_state_event_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_window_state_event_callback" };


	#                           Session -> Widget -> Bool_Callback -> Void                    # gtk.api type
	my set_toggled_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_toggled_callback" };


	#                                 Session -> Widget -> Float_Callback -> Void             # gtk.api type
	my set_value_changed_callback:   (Session, Int/*Widget*/) -> Int
	    =
	    ci::find_c_function { lib_name => "gtk", fun_name => "set_value_changed_callback" };

    # Do not edit this or preceding lines -- they are autogenerated by make-gtk-glue.


	#
	fun make_session
	    {
	      void_callback_map:              Ref (imp::Map( Void            -> Void )),
	      bool_callback_map:              Ref (imp::Map( Bool            -> Void )),
	      float_callback_map:             Ref (imp::Map( Float           -> Void )),
	      button_event_callback_map:      Ref (imp::Map( Button_Event    -> Void )),
	      motion_event_callback_map:      Ref (imp::Map( Motion_Event    -> Void )),
	      key_event_callback_map:         Ref (imp::Map( Key_Event       -> Void )),
	      expose_event_callback_map:      Ref (imp::Map( Expose_Event    -> Void )),
	      configure_event_callback_map:   Ref (imp::Map( Configure_Event -> Void ))
	    }
	    =
	    {   session
		    =
		    { void_callback_map,
		      bool_callback_map,
		      float_callback_map,
		      button_event_callback_map,
		      motion_event_callback_map,
		      key_event_callback_map,
		      expose_event_callback_map,
		      configure_event_callback_map
		    };

		init ();

		session;
	    };

	#
	fun get_widget_allocation (session, widget)
	    =
	    do_get_widget_allocation widget;

	#
	fun get_window_pointer (session, window)
	    =
	    do_get_window_pointer window;

	#
	fun make_dialog session
	    =
	    do_make_dialog ();

	#
	fun unref_object (session, widget)
	    =
	    do_unref_object widget;

	#
	fun quit_eventloop  session
	    =
	    winix::process::exit
		winix::process::success;

	#
	fun run_eventloop_once  (session, block_until_event)
	    =
	    {   result = do_run_eventloop_once  block_until_event;
		run_pending_callbacks  session;
		result;
	    };

	#
	fun run_eventloop_indefinitely  session
	    =
	    {   # Actually calling
		#
		#     gtk_main();
		#
		# at the gtk-driver.c level won't do
		# because then we have no way to run
		# Mythryl-level callbacks short of
		# implementing calls from C into
		# Mythryl, which is a can of worms
		# best not opened.
		#
		# So instead we loop at this level:
		#
		run_eventloop_once (session, /*block_until_event=*/TRUE);
		run_eventloop_indefinitely  session;
	    };

    };
end;


##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(my \\)"			 		 #
# End:									 #
##########################################################################



## Code by Jeff Prothero: Copyright (c) 2010-2011,
## released under Gnu Public Licence version 3.
