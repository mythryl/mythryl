#
# This module allows you to create ML callable versions of C functions
# dynamically without going thru C-GLUE-MAKER.   The constructed functions
# are probably slightly slower than the ones generated by C-GLUE-MAKER.
#
# Only "light" (no implicit runtime-type info) interface version is provided.  
#
# WARNING: major type tricks ahead.


api Raw_Ccall =
api

    # A handle to a shared library; this is persistent, meaning it'll 
    # persist even when you export an image via { fork|spawn}_to_disk
    # and then restart the image.

    type lib_handle = dynamic_linkage::lib_handle

    #  A handle to a function; this is persistent 
    type fun_handle

     #  path to the library 
    type lib_name = String  

     #  name of c function in the library 
    type fun_name = String 

    #  Load a shared library 
    my LoadLib:  lib_name -> lib_handle

    # Load a function from a library. 
    # A function handle has no type info.  
    # To make use of it, we have to bind a prototype to it.

    my LoadFn:  lib_handle -> fun_name -> fun_handle


    # A prototype is composed of its arguments and return parameters.
    #
    # A argument parameter is a quadruple: 
    #  A_ml   ML representation type,
    #  C    C  calling representation type
    #  X    ML-NLFFILIB witness type (e.g. when accessed thru a pointer)
    #  A_en   the internal encoding needed by the compiler 
    #             (just ignore this)
    #  For technical reasons, (1) and (3) may be different.
    #
    # The return prototype is similarly defined.

    type c_param( A_ml, C, X, A_en )
    type c_arg( A_ml, C, X, A_en ) = c_param( A_ml, C, X, A_en ) 
    type c_ret( A_ml, C, X, A_en ) = c_param( A_ml, C, X, A_en ) 


    # c_ptr and c_fptr are params to pointers and function pointers.

    type c_ptr( T, C )
	= 
       c_param ( c::ptr'( c::obj( T, C ) ),   c_memory::cc_addr, 
		 c::ptr(  c::obj( T, C ) ),   String
	       ) 

    type c_fptr( T )
	=
	c_param( c::fptr'( T ), c_memory::cc_addr, c::fptr( T ), String) 


    # A C prototype represents a combination of c_arg and c_ret.
    #   toC  -- conversion function from ML's rep to C's rep
    #   toML -- conversion function from C's rep to ML's rep
    #   X   -- ML-NLFFILIB witness type (e::g. when accessed thru a pointer)
    #   en   -- prototype encoding needed by the compiler.

    type c_proto( A_to_c, A_to_ml, X, A_en )

    #  Built in parameters (to be extended ...) 
    my schar:   c_param( mlrep::signed::Int,    c_memory::cc_schar,  c::schar,  char )
    my uchar:   c_param( mlrep::unsigned::word, c_memory::cc_uchar,  c::uchar,  unt8::word )
    my sshort:  c_param( mlrep::signed::Int,    c_memory::cc_sshort, c::sshort, List( char ) )
    my ushort:  c_param( mlrep::unsigned::word, c_memory::cc_ushort, c::ushort, List( unt8::word ) )
    my sint:    c_param( mlrep::signed::Int,    c_memory::cc_sint,   c::sint,   tagged_int::int )
    my uint:    c_param( mlrep::unsigned::word, c_memory::cc_uint,   c::uint,   tagged_unt::word )
    my slong:   c_param( mlrep::signed::Int,    c_memory::cc_slong,  c::slong,  int1::Int )
    my ulong:   c_param( mlrep::unsigned::word, c_memory::cc_ulong,  c::ulong,  unt32::word )
    my float:   c_param( mlrep::float::real,    c_memory::cc_float,  c::float,  List( real ) )
    my double:  c_param( mlrep::float::real,    c_memory::cc_double, c::double, real )

    #  Or you can use these combined with signed and unsigned 
    my char:   c_param( mlrep::signed::Int, c_memory::cc_schar,  c::schar, char )          * c_param( mlrep::unsigned::word, c_memory::cc_uchar, c::uchar,  unt8::word )
    my short:  c_param( mlrep::signed::Int, c_memory::cc_sshort, c::sshort, List( char ) ) * c_param( mlrep::unsigned::word, c_memory::cc_ushort, c::ushort, List( unt8::word ) )
    my int:    c_param( mlrep::signed::Int, c_memory::cc_sint,   c::sint, tagged_int::int )     * c_param( mlrep::unsigned::word, c_memory::cc_uint,  c::uint,   tagged_unt::word )
    my long:   c_param( mlrep::signed::Int, c_memory::cc_slong,  c::slong, int1::Int )    * c_param( mlrep::unsigned::word, c_memory::cc_ulong, c::ulong,  unt32::word )

    my signed:    c_param( A,B,C,D ) * c_param( W,X,Y,Z ) -> c_param( A,B,C,D )
    my unsigned:  c_param( W,X,Y,Z ) * c_param( A,B,C,D ) -> c_param( A,B,C,D )

    my string:   c_param( String, c_ext::ml_object, String, Bool )

    # Construct a pointer param from existing param.
    # e.g.
    #   C type                      Param spec
    #
    #    unsigned int *             ptr (unsigned int)
    #    const char *               const (ptr (unsigned char))
    #    char **                    ptr (ptr (unsigned char))
    #
    # Note that the ptr constructor can be nested!

    my ptr:  c_param( A_ml,C,X,A_en ) -> c_ptr( X, c::rw )
    my const:  c_ptr( X,A_const ) -> c_ptr( X, c::ro )

    my charptr:  c_ptr( c::uchar, c::rw )

    # This is an unsafe param for any pointer types.  
    # To use it, you have to provide an explicit type constraint

    my anyptr:  c_ptr( X, A_const ) 

    # We can create a function pointer param from an existing prototype.

    my fptr:  c_proto( A_ml_arg -> A_c_arg, A_c_ret -> A_ml_ret, X -> Y, A_en ) -> 
		  c_fptr( X -> Y ) 

    # This is an unsafe param for any function pointer types.  
    # To use it, you have to provide an explicit type constraint

    my anyfptr:  c_fptr( X -> Y ) 

    my void:     c_ret( Void, Void, Void, Void )
    my voidptr:  c_param( c::voidptr, c::voidptr, c::voidptr, String )

    #  structs/unions (to do ...) 


    # Prototypes are constructed using the following functions:
    #
    #    Fn[number of arguments] : [return] -> [args] -> [prototype]
    #
    # Different versions are needed for different number of arguments.
    #
    # Note that the return argument goes first, like in C.   For example,
    # 
    #    Fn0 void   ()  
    #    Fn1 void   (sint)  
    #    Fn1 sint   (ptr uchar)  
    #    Fn2 double (double, uint)  
    #
    # As an alternative, you can also write:
    #
    #    Fn1 void   (signed int)  
    #    Fn1 (signed int) (charptr)  
    #    Fn2 double (double, unsigned int)  
    #
    # The types of these functions do suck a great deal but
    # they are much easier to use than they look.  See below.

    my Fn0:  c_ret( A_ml,C,X,A_en ) -> 
	      Void ->
	      (Void -> Void, 
	       C -> A_ml, 
		Void -> X,
	       List( Void -> A_en )) c_proto

    my Fn1:  c_ret( A_ml, C, X, A_en ) -> 
	      c_arg( A_ml_1, A_c_1, A_x_1, A_en_1 ) -> 
	      c_proto(A_ml_1 -> A_c_1, 
		  C -> A_ml, 
		  A_x_1 -> X,
		  List( Void * A_en_1 -> A_en ))

    my Fn2:  c_ret( A_ml,C,X,A_en ) -> 
	      c_arg( A_ml_1, A_c_1, A_x_1, A_en_1 ) * 
	      c_arg( A_ml_2, A_c_2, A_x_2, A_en_2 ) -> 
		  c_proto(A_ml_1 * A_ml_2 -> A_c_1 * A_c_2, 
		  C -> A_ml, 
		  A_x_1 * A_x_2 -> X,
		  List( Void * A_en_1 * A_en_2 -> A_en ))

    my Fn3:  c_ret( A_ml,C,X,A_en ) -> 
	      c_arg( A_ml_1, A_c_1, A_x_1, A_en_1 ) * 
	      c_arg( A_ml_2, A_c_2, A_x_2, A_en_2 ) * 
	      c_arg( A_ml_3, A_c_3, A_x_3, A_en_3 ) -> 
		  c_proto(A_ml_1 * A_ml_2 * A_ml_3 -> A_c_1 * A_c_2 * A_c_3, 
		  C -> A_ml, 
		  A_x_1 * A_x_2 * A_x_3 -> X,
		  List( Void * A_en_1 * A_en_2 * A_en_3 -> A_en ))

    my Fn4:  c_ret( A_ml,C,X,A_en ) -> 
	      c_arg( A_ml_1, A_c_1, A_x_1, A_en_1 ) * 
	      c_arg( A_ml_2, A_c_2, A_x_2, A_en_2 ) * 
	      c_arg( A_ml_3, A_c_3, A_x_3, A_en_3 ) * 
	      c_arg( A_ml_4, A_c_4, A_x_4, A_en_4 ) -> 
	      c_proto (A_ml_1 * A_ml_2 * A_ml_3 * A_ml_4 -> A_c_1 * A_c_2 * A_c_3 * A_c_4, 
		  C -> A_ml, 
		  A_x_1 * A_x_2 * A_x_3 * A_x_4 -> X,
		  List( Void * A_en_1 * A_en_2 * A_en_3 * A_en_4 -> A_en ))


    my Fn5:  c_ret( A_ml,C,X,A_en ) -> 
	      c_arg( A_ml_1, A_c_1, A_x_1, A_en_1 ) * 
	      c_arg( A_ml_2, A_c_2, A_x_2, A_en_2 ) * 
	      c_arg( A_ml_3, A_c_3, A_x_3, A_en_3 ) * 
	      c_arg( A_ml_4, A_c_4, A_x_4, A_en_4 ) * 
	      c_arg( A_ml_5, A_c_5, A_x_5, A_en_5 ) -> 
	      c_proto (A_ml_1 * A_ml_2 * A_ml_3 * A_ml_4 * A_ml_5 ->
		  A_c_1 * A_c_2 * A_c_3 * A_c_4 * A_c_5, 
		  C -> A_ml, 
		  A_x_1 * A_x_2 * A_x_3 * A_x_4 * A_x_5 -> X,
		  List( Void * A_en_1 * A_en_2 * A_en_3 * A_en_4 * A_en_5 -> A_en ))


    my Fn6:  c_ret( A_ml,C,X,A_en ) -> 
	      c_arg( A_ml_1, A_c_1, A_x_1, A_en_1 ) * 
	      c_arg( A_ml_2, A_c_2, A_x_2, A_en_2 ) * 
	      c_arg( A_ml_3, A_c_3, A_x_3, A_en_3 ) * 
	      c_arg( A_ml_4, A_c_4, A_x_4, A_en_4 ) * 
	      c_arg( A_ml_5, A_c_5, A_x_5, A_en_5 ) * 
	      c_arg( A_ml_6, A_c_6, A_x_6, A_en_6 ) -> 
	      c_proto (A_ml_1 * A_ml_2 * A_ml_3 * A_ml_4 * A_ml_5 * A_ml_6 ->
		  A_c_1 * A_c_2 * A_c_3 * A_c_4 * A_c_5 * A_c_6, 
		  C -> A_ml, 
		  A_x_1 * A_x_2 * A_x_3 * A_x_4 * A_x_5 * A_x_6 -> X,
		  List (Void * A_en_1 * A_en_2 * A_en_3 * A_en_4 * A_en_5 * A_en_6
			-> A_en))

    my Fn7:  c_ret( A_ml,C,X,A_en ) -> 
	      c_arg( A_ml_1, A_c_1, A_x_1, A_en_1 ) * 
	      c_arg( A_ml_2, A_c_2, A_x_2, A_en_2 ) * 
	      c_arg( A_ml_3, A_c_3, A_x_3, A_en_3 ) * 
	      c_arg( A_ml_4, A_c_4, A_x_4, A_en_4 ) * 
	      c_arg( A_ml_5, A_c_5, A_x_5, A_en_5 ) * 
	      c_arg( A_ml_6, A_c_6, A_x_6, A_en_6 ) * 
	      c_arg( A_ml_7, A_c_7, A_x_7, A_en_7 ) -> 
	      c_proto (A_ml_1 * A_ml_2 * A_ml_3 * A_ml_4 * A_ml_5 * A_ml_6 * A_ml_7 ->
		  A_c_1 * A_c_2 * A_c_3 * A_c_4 * A_c_5 * A_c_6 * A_c_7, 
		  C -> A_ml, 
		  A_x_1 * A_x_2 * A_x_3 * A_x_4 * A_x_5 * A_x_6 * A_x_7 -> X,
		  List (Void * A_en_1 * A_en_2 * A_en_3 * A_en_4 * A_en_5 * A_en_6 * A_en_7
			-> A_en))

    my Fn8:  c_ret( A_ml,C,X,A_en ) -> 
	      c_arg( A_ml_1, A_c_1, A_x_1, A_en_1 ) * 
	      c_arg( A_ml_2, A_c_2, A_x_2, A_en_2 ) * 
	      c_arg( A_ml_3, A_c_3, A_x_3, A_en_3 ) * 
	      c_arg( A_ml_4, A_c_4, A_x_4, A_en_4 ) * 
	      c_arg( A_ml_5, A_c_5, A_x_5, A_en_5 ) * 
	      c_arg( A_ml_6, A_c_6, A_x_6, A_en_6 ) * 
	      c_arg( A_ml_7, A_c_7, A_x_7, A_en_7 ) * 
	      c_arg( A_ml_8, A_c_8, A_x_8, A_en_8 ) -> 
	      c_proto  (A_ml_1 * A_ml_2 * A_ml_3 * A_ml_4 * A_ml_5 * A_ml_6 * A_ml_7 * A_ml_8 ->
		  A_c_1 * A_c_2 * A_c_3 * A_c_4 * A_c_5 * A_c_6 * A_c_7 * A_c_8, 
		  C -> A_ml, 
		  A_x_1 * A_x_2 * A_x_3 * A_x_4 * A_x_5 * A_x_6 * A_x_7 * A_x_8 -> X,
		  List (Void * A_en_1 * A_en_2 * A_en_3 * A_en_4 * 
			 A_en_5 * A_en_6 * A_en_7 * A_en_8
			-> A_en))

    my Fn9:  c_ret( A_ml,C,X,A_en ) -> 
	      c_arg( A_ml_1, A_c_1, A_x_1, A_en_1 ) * 
	      c_arg( A_ml_2, A_c_2, A_x_2, A_en_2 ) * 
	      c_arg( A_ml_3, A_c_3, A_x_3, A_en_3 ) * 
	      c_arg( A_ml_4, A_c_4, A_x_4, A_en_4 ) * 
	      c_arg( A_ml_5, A_c_5, A_x_5, A_en_5 ) * 
	      c_arg( A_ml_6, A_c_6, A_x_6, A_en_6 ) * 
	      c_arg( A_ml_7, A_c_7, A_x_7, A_en_7 ) * 
	      c_arg( A_ml_8, A_c_8, A_x_8, A_en_8 ) * 
	      c_arg( A_ml_9, A_c_9, A_x_9, A_en_9 ) -> 
	       c_proto (A_ml_1 * A_ml_2 * A_ml_3 * A_ml_4 * A_ml_5 * A_ml_6 * A_ml_7 * A_ml_8 
		* A_ml_9 ->
		  A_c_1 * A_c_2 * A_c_3 * A_c_4 * A_c_5 * A_c_6 * A_c_7 * A_c_8 * A_c_9, 
		  C -> A_ml, 
		  A_x_1 * A_x_2 * A_x_3 * A_x_4 * A_x_5 * A_x_6 * A_x_7 * A_x_8 *
		  A_x_9 -> X,
		  List (Void * A_en_1 * A_en_2 * A_en_3 * A_en_4 * 
			 A_en_5 * A_en_6 * A_en_7 * A_en_8 * A_en_9
			-> A_en))

    my Fn10:  c_ret( A_ml,C,X,A_en ) -> 
	      c_arg( A_ml_1, A_c_1, A_x_1, A_en_1 ) * 
	      c_arg( A_ml_2, A_c_2, A_x_2, A_en_2 ) * 
	      c_arg( A_ml_3, A_c_3, A_x_3, A_en_3 ) * 
	      c_arg( A_ml_4, A_c_4, A_x_4, A_en_4 ) * 
	      c_arg( A_ml_5, A_c_5, A_x_5, A_en_5 ) * 
	      c_arg( A_ml_6, A_c_6, A_x_6, A_en_6 ) * 
	      c_arg( A_ml_7, A_c_7, A_x_7, A_en_7 ) * 
	      c_arg( A_ml_8, A_c_8, A_x_8, A_en_8 ) * 
	      c_arg( A_ml_9, A_c_9, A_x_9, A_en_9 ) * 
	      c_arg( A_ml_10 ,A_c_1 0,A_x_ 10,A_en_10 ) -> 
	      c_proto  (A_ml_1 * A_ml_2 * A_ml_3 * A_ml_4 * A_ml_5 * A_ml_6 * A_ml_7 * A_ml_8 
		* A_ml_9 * A_ml_10 ->
		  A_c_1 * A_c_2 * A_c_3 * A_c_4 * A_c_5 * A_c_6 * A_c_7 * A_c_8 * A_c_9
		* A_c_10, 
		  C -> A_ml, 
		  A_x_1 * A_x_2 * A_x_3 * A_x_4 * A_x_5 * A_x_6 * A_x_7 * A_x_8 *
		  A_x_9 * A_x_10 -> X,
		  List (Void * A_en_1 * A_en_2 * A_en_3 * A_en_4 * 
			 A_en_5 * A_en_6 * A_en_7 * A_en_8 * A_en_9 * A_en_10
			-> A_en))




    # A thunk encodes 
    #  1.  The address of the function to be called,
    #  2.  Its argument,
    #  3.  How to reconstruct its return value into a legal ML value, and
    #  4.  Its compiler encoding



    type c_thunk( A_c_arg, A_to_ml, A_en ) 


    # A thunk can be created by combining 
    # a function handle, its function prototype, and its argument.
    # NOTE: a thunk, like all C values, is non-persistent --- 
    #       it does not persist from ML session to ML session.  
    #       A thunk will become invalid once you export an ML session.
    #       The only thing you should do to a thunk is to evaluate it.

    my thunk:  fun_handle * 
		c_proto( A_ml_arg -> A_c_arg, A_c_ret -> A_ml_ret, X, List( A_en ) ) *
		A_ml_arg ->
		c_thunk( A_c_arg, A_c_ret -> A_ml_ret, List( A_en ) )

    #  This version takes a function address 
    my thunk' : c_memory::address * 
		c_proto( A_ml_arg -> A_c_arg, A_c_ret -> A_ml_ret,X, List( A_en ) ) *
		A_ml_arg ->
		c_thunk( A_c_arg, A_c_ret -> A_ml_ret, List( A_en ) )

    # In case you want to hack on the function address explicitly. 
    # You can use these functions.

    my fhandle_addr:   fun_handle -> c_memory::address
    my fptr_addr:      c::fptr( T ) -> c_memory::address
    my fptr'_addr:     c::fptr'( T ) -> c_memory::address


    # A thunk can be evaluated for its result.
    # NOTE: this is the same as raw_mem_inline_t::rawccall and it is 
    #       deep magic.
    #       Don't consider it to be a real function.
    #       In particular, all instantiations of Eval must be typelocked.

    my Eval:  c_thunk( A_c_arg, A_c_ret -> A_ml_ret, A_en ) -> A_c_ret


    # To extract the value of a result, combine the function 
    # prototype with the result.

    my Return:  c_proto( A_ml_arg -> A_c_arg, A_c_ret -> A_ml_ret, X, A_en ) *
		 A_c_ret -> A_ml_ret


    # Okay, all these seem complicated.  But they are quite simple
    # to use.  Here's how:
    #
    # Suppose you have an external C function
    #  
    #   extern float foo (int x, char * y);
    # 
    # in library bar.so.
    #
    # You can do the following to create a
    # Mythryl-callable version of  this function:
    #
    # include raw_c_call;
    # include c;
    #
    # libh = load_lib "bar.so";    # load library handle 
    # fooh = load_g libh "foo";   # load function from library
    #
    # # Declare the prototype of foo:
    # foo_t = Fn2 float (signed int, ptr (unsigned uchar))
    #
    # # Then we write its definition, as follows:
    # fun foo args = Return (foo_t, Eval (Thunk (fooh, foo_t, args)))
    #
    # # This function creates a thunk, evaluates it, and returns its result. 
    #
    # The type of foo is:
    #
    #   my foo:  (mlrep::signed::Int, Ptr'( Uchar, Rw )) -> mlrep::float::Float;
    #
    # You can now call foo like any Mythryl function generated via C-GLUE-MAKER!
    # If a function returns any pointer data structures, you can access them
    # using the interface provided in the C package.
    #
    # Have fun with this! 
    # Allen Leung


end
