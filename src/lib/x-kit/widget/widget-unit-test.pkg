## widget-unit-test.pkg
#
# For the big picture see the imp dataflow diagrams in
#
#     src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
#
# NB: We must compile this locally via
#         xclient-internals.sublib
#     instead of globally via
#         src/lib/test/unit-tests.lib
#     like most unit tests, in order to have
#     access to required library internals.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


# Run by:
#     src/lib/test/all-unit-tests.pkg

stipulate
    include package   unit_test;				# unit_test				is from   src/lib/src/unit-test.pkg
    include package   makelib::scripting_globals;
    include package   threadkit;				# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
    package ap  =  client_to_atom;				# client_to_atom			is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
    package au  =  authentication;				# authentication			is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
    package awx =  guishim_imp_for_x;				# guishim_imp_for_x			is from   src/lib/x-kit/widget/xkit/app/guishim-imp-for-x.pkg
    package cpm =  cs_pixmap;					# cs_pixmap				is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
    package cpt =  cs_pixmat;					# cs_pixmat				is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
    #
    package gd  =  gui_displaylist;				# gui_displaylist			is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg
    #
    package dbx =  sprite_theme_imp;				# sprite_theme_imp			is from   src/lib/x-kit/widget/xkit/theme/sprite/default/default-sprite-theme-for-x.pkg
    package dcx =  object_theme_imp;				# object_theme_imp			is from   src/lib/x-kit/widget/xkit/theme/object/default/default-object-theme-for-x.pkg
    package dtx =  widget_theme_imp;				# widget_theme_imp			is from   src/lib/x-kit/widget/xkit/theme/widget/default/default-widget-theme-for-x.pkg
    #
    package dy  =  display;					# display				is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package w2x =  windowsystem_to_xserver;			# windowsystem_to_xserver		is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xserver.pkg
    package fil =  file__premicrothread;			# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
    package fti =  font_index;					# font_index				is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
    package gtg =  guiboss_to_guishim;				# guiboss_to_guishim			is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg
    package gq  =  guiboss_imp;					# guiboss_imp				is from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
#   package c2g =  client_to_guiboss;				# client_to_guiboss			is from   src/lib/x-kit/widget/gui/client-to-guiboss.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap		is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
    package mtx =  rw_matrix;					# rw_matrix				is from   src/lib/std/src/rw-matrix.pkg
    package r8  =  rgb8;					# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package rgb =  rgb;						# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package rop =  ro_pixmap;					# ro_pixmap				is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
    package rw  =  root_window;					# root_window				is from   src/lib/x-kit/widget/lib/root-window.pkg
    package rwv =  rw_vector;					# rw_vector				is from   src/lib/std/src/rw-vector.pkg
    package sep =  client_to_selection;				# client_to_selection			is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
    package shp =  shade;					# shade					is from   src/lib/x-kit/widget/lib/shade.pkg
    package sj  =  socket_junk;					# socket_junk				is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer			is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
    package ti  =  template_imp;				# template_imp				is from   src/lib/x-kit/xclient/src/wire/template-imp.pkg
    package tem =  template;					# template				is from   src/lib/x-kit/xclient/src/wire/template.pkg
    package tr  =  logger;					# logger				is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
    package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
    package u1  =  one_byte_unt;				# one_byte_unt				is from   src/lib/std/one-byte-unt.pkg
    package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts		is from   src/lib/std/src/vector-of-one-byte-unts.pkg
    package v2w =  value_to_wire;				# value_to_wire				is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
    package wg  =  widget;					# widget				is from   src/lib/x-kit/widget/old/basic/widget.pkg
    package wi  =  window;					# window				is from   src/lib/x-kit/xclient/src/window/window.pkg
    package wme =  window_map_event_sink;			# window_map_event_sink			is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
    package wpp =  client_to_window_watcher;			# client_to_window_watcher		is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
    package wy  =  widget_style;				# widget_style				is from   src/lib/x-kit/widget/lib/widget-style.pkg
    package xc  =  xclient;					# xclient				is from   src/lib/x-kit/xclient/xclient.pkg
    package g2d =  geometry2d;					# geometry2d				is from   src/lib/std/2d/geometry2d.pkg
    package xj  =  xsession_junk;				# xsession_junk				is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
    package xtr =  xlogger;					# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg

    package blk =  blank;					# blank					is from   src/lib/x-kit/widget/leaf/blank.pkg
    package frm =  frame;					# frame					is from   src/lib/x-kit/widget/leaf/frame.pkg
    package ab  =  arrowbutton;					# arrowbutton				is from   src/lib/x-kit/widget/leaf/arrowbutton.pkg
    package bb  =  button;					# button				is from   src/lib/x-kit/widget/leaf/button.pkg
    package cb  =  checkbox;					# checkbox				is from   src/lib/x-kit/widget/leaf/checkbox.pkg
    package db  =  diamondbutton;				# diamondbutton				is from   src/lib/x-kit/widget/leaf/diamondbutton.pkg
    package rb  =  roundbutton;					# roundbutton				is from   src/lib/x-kit/widget/leaf/roundbutton.pkg

    package his =  horizontal_int_slider;			# horizontal_int_slider			is from   src/lib/x-kit/widget/leaf/horizontal-int-slider.pkg
    package hfs =  horizontal_float_slider;			# horizontal_float_slider		is from   src/lib/x-kit/widget/leaf/horizontal-float-slider.pkg

    package vis =  vertical_int_slider;				# vertical_int_slider			is from   src/lib/x-kit/widget/leaf/vertical-int-slider.pkg
    package vfs =  vertical_float_slider;			# vertical_float_slider			is from   src/lib/x-kit/widget/leaf/vertical-float-slider.pkg

    package ten =  textentry;					# textentry				is from   src/lib/x-kit/widget/leaf/textentry.pkg
    package ted =  texteditor;					# texteditor				is from   src/lib/x-kit/widget/edit/texteditor.pkg

    package iul =  issue_unique_look_id;			# issue_unique_look_id			is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

#   package xet =  xevent_types;				# xevent_types				is from   src/lib/x-kit/xclient/src/wire/xevent-types.pkg
#   package e2s =  xevent_to_string;				# xevent_to_string			is from   src/lib/x-kit/xclient/src/to-string/xevent-to-string.pkg
#   package xt  =  xtypes;					# xtypes				is from   src/lib/x-kit/xclient/src/wire/xtypes.pkg
    #
    # The above three are the X-specific versions of the
    # below two platform-independent packages.  X events
    # come to windowsystem-imp-for-x in xet:: encoding.  It	# For the big dataflow diagram see   src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
    # translates them to evt:: encoding and forward them to
    # guiboss_imp, which forwards them to appropriate imps.	# guiboss_imp				is from   src/lib/x-kit/widget/gui/guiboss-imp.pkg
    #
    package gt  =  guiboss_types;				# guiboss_types				is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
    package wt  =  widget_theme;				# widget_theme				is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

    package evt =  gui_event_types;				# gui_event_types			is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
#   package gts =  gui_event_to_string;				# gui_event_to_string			is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    #
    # This one translates from the X to Gui versions:
#   package x2g =  xevent_to_gui_event;				# xevent_to_gui_event			is from   src/lib/x-kit/widget/xkit/app/xevent-to-gui-event.pkg
#   package g2x =  gui_event_to_xevent;				# gui_event_to_xevent			is from   src/lib/x-kit/widget/xkit/app/gui-event-to-xevent.pkg

    package oim =  object_imp;					# object_imp				is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/object-imp.pkg
    package sim =  sprite_imp;					# sprite_imp				is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/sprite-imp.pkg
    package wim =  widget_imp;					# widget_imp				is from   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg



    package hslider =  horizontal_int_slider;			# horizontal_int_slider			is from   src/lib/x-kit/widget/leaf/horizontal-int-slider.pkg
    package hflider =  horizontal_float_slider;			# horizontal_float_slider		is from   src/lib/x-kit/widget/leaf/horizontal-float-slider.pkg

    package vslider =  vertical_int_slider;			# vertical_int_slider			is from   src/lib/x-kit/widget/leaf/vertical-int-slider.pkg
    package vflider =  vertical_float_slider;			# vertical_float_slider			is from   src/lib/x-kit/widget/leaf/vertical-float-slider.pkg


    tracefile   =  "widget-unit-test.trace.log";

#   id =  iui::issue_unique_id;

    nb =  log::note_on_stderr;					# log					is from   src/lib/std/src/log.pkg

# These are crude hacks for force these to compile: 
#
Dummy1 = wim::Widget;
Dummy2 = oim::Object;
Dummy3 = sim::Sprite;
dummy4 = ab::with;
dummy5 = frm::with;
dummy6 = blk::with;
dummy7 = ten::with;
dummy8 = ted::with;

herein

    package widget_unit_test {
	#
	name = "src/lib/x-kit/widget/widget-unit-test.pkg";

	trace =  xtr::log_if  xtr::io_logging 0;		# Conditionally write strings to tracing.log or whatever.


	fun exercise_convex_hull  ()				# Probably should be in a separate geometry2d-unit-text.pkg, but at the moment I'm too lazy to take time to establish one.
	    =
	    {
		points1 = [ { col => 100, row => 100 }, { col => 400, row => 100 }, { col => 400, row => 400 }, { col => 100, row => 400 } ];
		points2 = [ { col => 200, row => 200 }, { col => 300, row => 200 }, { col => 300, row => 300 }, { col => 200, row => 300 } ];
		points3 = points1 @ points2;
		#
		points1' = g2d::convex_hull points1;
		points2' = g2d::convex_hull points2;
		points4  = g2d::convex_hull points3;
		#
		assert (points1' == points1);
		assert (points2' == points2);
		assert (points4  == points1);
		#
		points1' = g2d::convex_hull (reverse points1);
		points2' = g2d::convex_hull (reverse points2);
		points4  = g2d::convex_hull (reverse points3);
		#
		assert (points1' == points1);
		assert (points2' == points2);
		assert (points4  == points1);
	    };

	fun exercise_point_in_polygon ()				# Probably should be in a separate geometry2d-unit-text.pkg, but at the moment I'm too lazy to take time to establish one.
	    =
	    {
		# Basic square, as above
		#
		points = [ { col => 100, row => 100 }, { col => 200, row => 100 }, { col => 200, row => 200 }, { col => 100, row => 200 } ];
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };  	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) ==  TRUE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);




		points = [ { col => 100, row => 200 }, { col => 200, row => 200 }, { col => 200, row => 100 }, { col => 100, row => 100 } ];	# Does vertex order matter?

		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };  	# Middles of the 9 squares of a tic-tac-toe pattern.  
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) ==  TRUE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);




		points = [ { col => 100, row => 100 }, { col => 100, row => 100 },		# Do duplicate vertices matter?
			   { col => 200, row => 100 }, { col => 200, row => 100 },
			   { col => 200, row => 200 }, { col => 200, row => 200 },
                           { col => 100, row => 200 }, { col => 100, row => 200 }
			 ];

		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };    	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) ==  TRUE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);



		# Diamond instead of square:
		# 
		points = [ { col => 100, row => 150 }, { col => 150, row => 200 }, { col => 200, row => 150 }, { col => 150, row => 100 } ];
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) ==  TRUE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);



		# Chevron shape concave down:
		# 
		points = [ { col => 100, row => 150 }, { col => 150, row => 200 }, { col => 200, row => 150 }, { col => 150, row => 190 } ];
		#
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);


		# Chevron shape concave up:
		# 
		points = [ { col => 100, row => 150 }, { col => 150, row => 110 }, { col => 200, row => 150 }, { col => 150, row => 100 } ];
		#
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);


		# Chevron shape concave left:
		# 
		points = [ { col => 190, row => 150 }, { col => 150, row => 200 }, { col => 200, row => 150 }, { col => 150, row => 100 } ];
		#
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);


		# Chevron shape concave right:
		# 
		points = [ { col => 100, row => 150 }, { col => 150, row => 200 }, { col => 110, row => 150 }, { col => 150, row => 100 } ];
		#
		#
		p1 = { col =>   0, row =>   0 };  	p4 = { col =>   0, row => 150 };    	p7 = { col =>   0, row => 250 };      	# Middles of the 9 squares of a tic-tac-toe pattern.
		p2 = { col => 150, row =>   0 };  	p5 = { col => 150, row => 150 };    	p8 = { col => 150, row => 250 };  
		p3 = { col => 250, row =>   0 };  	p6 = { col => 250, row => 150 };    	p9 = { col => 250, row => 250 };    

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);
		assert (g2d::point_in_polygon(p9,points) == FALSE);

		p1 = { col =>   0, row => 100 };											# On the horizontal lines of the tic-tac-toe pattern.
		p2 = { col => 250, row => 100 };
	  	p3 = { col =>   0, row => 200 };
	  	p4 = { col => 250, row => 200 };
		p5 = { col => 100, row =>   0 };											# On the vertical   lines of the tic-tac-toe pattern.
		p7 = { col => 100, row => 250 };
	  	p7 = { col => 200, row =>   0 };
	  	p8 = { col => 200, row => 250 };

		assert (g2d::point_in_polygon(p1,points) == FALSE);
		assert (g2d::point_in_polygon(p2,points) == FALSE);
		assert (g2d::point_in_polygon(p3,points) == FALSE);
		assert (g2d::point_in_polygon(p4,points) == FALSE);
		assert (g2d::point_in_polygon(p5,points) == FALSE);
		assert (g2d::point_in_polygon(p6,points) == FALSE);
		assert (g2d::point_in_polygon(p7,points) == FALSE);
		assert (g2d::point_in_polygon(p8,points) == FALSE);


	    };

	fun next_relief wt::FLAT   => wt::RAISED;	
	    next_relief wt::RAISED => wt::SUNKEN;
	    next_relief wt::SUNKEN => wt::GROOVE;
	    next_relief wt::GROOVE => wt::RIDGE;
	    next_relief wt::RIDGE  => wt::FLAT;
	end;
	fun relief_to_string wt::FLAT   =>  "FLAT";
	    relief_to_string wt::RAISED =>  "RAISED";
	    relief_to_string wt::SUNKEN =>  "SUNKEN";
	    relief_to_string wt::GROOVE =>  "GROOVE";
	    relief_to_string wt::RIDGE  =>  "RIDGE";
	end;


	fun make_three_row_guiplan
	      (
		scrollable_view_size:	    g2d::Size,


		popup_info:	Null_Or( Void ->  { requested_popup_site:		g2d::Box,			# For popup_plan this was:  { row => 200, col => 200, wide => 1200, high => 900 };
						    popup_plan:				gt::Guiplan,			# 
						    read_sites_and_ports:		Void -> Void
						  }
				       ),


		popup_info3:	Null_Or( Void ->  { requested_popup_site:		g2d::Box,			# 
						    popup_plan:				gt::Guiplan,			# 
						    read_sites_and_ports:		Void -> Void
						  }
				       ),

		popup_info1c:	Null_Or( Void ->  { requested_popup_site:		g2d::Box,			# 
						    popup_plan:				gt::Guiplan,			# 
						    read_sites_and_ports:		Void -> Void
						  }
				       ),

		popup_info2c:	Null_Or( Void ->  { requested_popup_site:		g2d::Box,			# 
						    popup_plan:				gt::Guiplan,			# 
						    read_sites_and_ports:		Void -> Void
						  }
				       ),

		popup_info3c:	Null_Or( Void ->  { requested_popup_site:		g2d::Box,			# 
						    popup_plan:				gt::Guiplan,			# 
						    read_sites_and_ports:		Void -> Void
						  }
				       ),

		popup_info4c:	Null_Or( Void ->  { requested_popup_site:		g2d::Box,			# 
						    popup_plan:				gt::Guiplan,			# 
						    read_sites_and_ports:		Void -> Void
						  }
				       )
	      )
	      :	{ guiplan:		gt::Guiplan,
															# Here we return globals which wind up containing the window sites
															# assigned to our various widgets.  Normal application code never
															# needs to know this, but our test code needs this information in
															# order to synthesize fake mouseclicks etc on the buttons.
															#
		  scrollport_scroller:	Ref( Null_Or( gt::Scroller ) ),

		  scroll_state:		Ref( g2d::Point ),

		  widget_sites:   { site1a: Ref (Null_Or(g2d::Box)),							# Row one,   button one.
				    site2a: Ref (Null_Or(g2d::Box)),							# Row one,   button two.
				    site3a: Ref (Null_Or(g2d::Box)),							# Row one,   button three.
				    site4a: Ref (Null_Or(g2d::Box)),							# Row one,   button four. 
															#
				    site1b: Ref (Null_Or(g2d::Box)),							# Row two,   button one.  
				    site2b: Ref (Null_Or(g2d::Box)),							# Row two,   button two.  
				    site3b: Ref (Null_Or(g2d::Box)),							# Row two,   button three.
				    site4b: Ref (Null_Or(g2d::Box)),							# Row two,   button four. 
															#
				    site1c: Ref (Null_Or(g2d::Box)),							# Row three, button one.  
				    site2c: Ref (Null_Or(g2d::Box)),							# Row three, button two.  
				    site3c: Ref (Null_Or(g2d::Box)),							# Row three, button three.
				    site4c: Ref (Null_Or(g2d::Box))							# Row three, button four. 
				  },

		  read_back_sites_and_ports_of_guiplan_widgets:	Void -> Void						# Fills in values of widget_sites
		}
	    =
	    {
		scrollport_scroller	= REF (NULL: Null_Or(gt::Scroller));						# This global tracks the scrollport scroller which will be handed to use by guiboss-imp at GUI startup -- see SCROLLABLE_VIEW below in guiplan.

		scroll_state		= REF { row =>  0, col =>  0 };							# Not currently in use. This global tracks where the middle roll is current scrolled to. We only need this when doing autoscrolling in conjunction with autoscroll_distance above.

		stipulate
		    site1a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row one,   first  button, site notification mailqueue.
		    site2a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row one,   second button, site notification mailqueue.
		    site3a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row one,   third  button, site notification mailqueue.
		    site4a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row one,   fourth button, site notification mailqueue.
															#
		    site1b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row two,   first  button, site notification mailqueue.
		    site2b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row two,   second button, site notification mailqueue.
		    site3b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row two,   third  button, site notification mailqueue.
		    site4b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row two,   fourth button, site notification mailqueue.
															#														                                                     
		    site1c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row three, first  button, site notification mailqueue.
		    site2c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row three, second button, site notification mailqueue.
		    site3c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row three, third  button, site notification mailqueue.
		    site4c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row three, fourth button, site notification mailqueue.


		    port1a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row one,   first  button, port notification mailqueue.
		    port2a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row one,   seond  button, port notification mailqueue.
		    port3a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row one,   third  button, port notification mailqueue.
		    port4a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row one,   fourth button, port notification mailqueue.
		    #	
		    port1b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row two,   first  button, port notification mailqueue.
		    port2b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row two,   second button, port notification mailqueue.
		    port3b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row two,   third  button, port notification mailqueue.
		    port4b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row two,   fourth button, port notification mailqueue.
		    #	
		    port1c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row three, first  button, port notification mailqueue.
		    port2c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row three, second button, port notification mailqueue.
		    port3c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row three, third  button, port notification mailqueue.
		    port4c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row three, fourth button, port notification mailqueue.
		herein														                                                     
															# These globals hold the values read from the above
															# mailops by the later do_one_mailop() calls.
															# They hold the sites (window locations) assigned to
															# our twelve pushbuttons. (We need this information
															# to generate fake mouseclicks on them for test
															# purposes. A normal GUI app wouldn't do this.) 
															#
		    site1a = REF (NULL: Null_Or(g2d::Box));								# Row one,   button one.
		    site2a = REF (NULL: Null_Or(g2d::Box));								# Row one,   button two.
		    site3a = REF (NULL: Null_Or(g2d::Box));								# Row one,   button three.
		    site4a = REF (NULL: Null_Or(g2d::Box));								# Row one,   button four. 
															#
		    site1b = REF (NULL: Null_Or(g2d::Box));								# Row two,   button one.  
		    site2b = REF (NULL: Null_Or(g2d::Box));								# Row two,   button two.  
		    site3b = REF (NULL: Null_Or(g2d::Box));								# Row two,   button three.
		    site4b = REF (NULL: Null_Or(g2d::Box));								# Row two,   button four. 
															#
		    site1c = REF (NULL: Null_Or(g2d::Box));								# Row three, button one.  
		    site2c = REF (NULL: Null_Or(g2d::Box));								# Row three, button two.  
		    site3c = REF (NULL: Null_Or(g2d::Box));								# Row three, button three.
		    site4c = REF (NULL: Null_Or(g2d::Box));								# Row three, button four. 

		    port1a = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row one,   button one.
		    port2a = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row one,   button two.
		    port3a = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row one,   button three.
		    port4a = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row one,   button four.
		    #													#
		    port1b = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row two,   button one.
		    port2b = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row two,   button two.
		    port3b = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row two,   button three.
		    port4b = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row two,   button four.
		    #													#
		    port1c = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row three, button one.
		    port2c = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row three, button two.
		    port3c = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row three, button three.
		    port4c = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row three, button four.


															# These are the site-watcher callbacks we pass to the
															# guiboss layer to find out where our buttons are on
															# the window:
															#
		    fun sitewatcher1a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1a', site);			# Row one,   first  button, site notification callback.
		    fun sitewatcher2a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2a', site);			# Row one,   second button, site notification callback.
		    fun sitewatcher3a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site3a', site);			# Row one,   third  button, site notification callback.
		    fun sitewatcher4a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site4a', site);			# Row one,   fourth button, site notification callback.
		    #													#
		    fun sitewatcher1b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1b', site);			# Row two,   first  button, site notification callback.
		    fun sitewatcher2b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2b', site);			# Row two,   second button, site notification callback.
		    fun sitewatcher3b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site3b', site);			# Row two,   third  button, site notification callback.
		    fun sitewatcher4b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site4b', site);			# Row two,   fourth button, site notification callback.
		    #													#
		    fun sitewatcher1c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1c', site);			# Row three, first  button, site notification callback.
		    fun sitewatcher2c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2c', site);			# Row three, second button, site notification callback.
		    fun sitewatcher3c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site3c', site);			# Row three, third  button, site notification callback.
		    fun sitewatcher4c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site4c', site);			# Row three, fourth button, site notification callback.


		    fun portwatcher1a (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port1a', port);	# Row one,   first  button, port notification callback.
		    fun portwatcher2a (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port2a', port);	# Row one,   second button, port notification callback.
		    fun portwatcher3a (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port3a', port);	# Row one,   third  button, port notification callback.
		    fun portwatcher4a (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port4a', port);	# Row one,   fourth button, port notification callback.
		    #													#
		    fun portwatcher1b (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port1b', port);	# Row two,   first  button, port notification callback.
		    fun portwatcher2b (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port2b', port);	# Row two,   second button, port notification callback.
		    fun portwatcher3b (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port3b', port);	# Row two,   third  button, port notification callback.
		    fun portwatcher4b (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port4b', port);	# Row two,   fourth button, port notification callback.
		    #													#
		    fun portwatcher1c (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port1c', port);	# Row three, first  button, port notification callback.
		    fun portwatcher2c (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port2c', port);	# Row three, second button, port notification callback.
		    fun portwatcher3c (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port3c', port);	# Row three, third  button, port notification callback.
		    fun portwatcher4c (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port4c', port);	# Row three, fourth button, port notification callback.

		    fun read_back_sites_and_ports_of_guiplan_widgets ()							# Fill in the above globals via blocking reads.
			=												# We use timeouts (only) to recover gracefully if things are
			{												# somehow so broken that guiboss-imp never calls our callbacks.
															# The order shouldn't matter; here we go left-to-right top-to-bottom:

# XXX SUCKO FIXME all of these 'take' operations really should be done
# in a microthread that loops, rather than just once here, otherwise
# dynamic re-layout ops will not result in our 'site*' values getting
# properly updated here.  (This logic predates dynamic re-layouts.)
			    do_one_mailop [ take_from_mailqueue' site1a' ==> {. site1a := #site;		assert(TRUE);  },	# Row one,   button one.
					    timeout_in' 1.0		 ==> {. printf "no site1a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2a' ==> {. site2a := #site;		assert(TRUE);  },	# Row one,   button two.
					    timeout_in' 1.0		 ==> {. printf "no site2a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site3a' ==> {. site3a := #site;		assert(TRUE);  },	# Row one,   button three.
					    timeout_in' 1.0		 ==> {. printf "no site3a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site4a' ==> {. site4a := #site;		assert(TRUE);  },	# Row one,   button four.
					    timeout_in' 1.0		 ==> {. printf "no site4a in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1b' ==> {. site1b := #site;		assert(TRUE);  },	# Row two,   button one.
					    timeout_in' 1.0		 ==> {. printf "no site1b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2b' ==> {. site2b := #site;		assert(TRUE);  },	# Row two,   button two.
					    timeout_in' 1.0		 ==> {. printf "no site2bin 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site3b' ==> {. site3b := #site;		assert(TRUE);  },	# Row two,   button three.
					    timeout_in' 1.0		 ==> {. printf "no site3b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site4b' ==> {. site4b := #site;		assert(TRUE);  },	# Row two,   button four.
					    timeout_in' 1.0		 ==> {. printf "no site4b in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1c' ==> {. site1c := #site;		assert(TRUE);  },	# Row three, button one.
					    timeout_in' 1.0		 ==> {. printf "no site1c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2c' ==> {. site2c := #site;		assert(TRUE);  },	# Row three, button two.
					    timeout_in' 1.0		 ==> {. printf "no site2c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site3c' ==> {. site3c := #site;		assert(TRUE);  },	# Row three, button three.
					    timeout_in' 1.0		 ==> {. printf "no site3c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site4c' ==> {. site4c := #site;		assert(TRUE);  },	# Row three, button four.
					    timeout_in' 1.0		 ==> {. printf "no site4c in 1 sec!\n";	assert(FALSE); }
					  ];



			    do_one_mailop [ take_from_mailqueue' port1a' ==> {. port1a := #port;		assert(TRUE);  },	# Row one,   button one.
					    timeout_in' 1.0		 ==> {. printf "no port1a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' port2a' ==> {. port2a := #port;		assert(TRUE);  },	# Row one,   button two.
					    timeout_in' 1.0		 ==> {. printf "no port2a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' port3a' ==> {. port3a := #port;		assert(TRUE);  },	# Row one,   button three.
					    timeout_in' 1.0		 ==> {. printf "no port3a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' port4a' ==> {. port4a := #port;		assert(TRUE);  },	# Row one,   button four.
					    timeout_in' 1.0		 ==> {. printf "no port4a in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' port1b' ==> {. port1b := #port;		assert(TRUE);  },	# Row two,   button one.
					    timeout_in' 1.0		 ==> {. printf "no port1b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' port2b' ==> {. port2b := #port;		assert(TRUE);  },	# Row two,   button two.
					    timeout_in' 1.0		 ==> {. printf "no port2b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' port3b' ==> {. port3b := #port;		assert(TRUE);  },	# Row two,   button three.
					    timeout_in' 1.0		 ==> {. printf "no port3b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' port4b' ==> {. port4b := #port;		assert(TRUE);  },	# Row two,   button four.
					    timeout_in' 1.0		 ==> {. printf "no port4b in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' port1c' ==> {. port1c := #port;		assert(TRUE);  },	# Row three, button one.
					    timeout_in' 1.0		 ==> {. printf "no port1c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' port2c' ==> {. port2c := #port;		assert(TRUE);  },	# Row three, button two.
					    timeout_in' 1.0		 ==> {. printf "no port2c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' port3c' ==> {. port3c := #port;		assert(TRUE);  },	# Row three, button three.
					    timeout_in' 1.0		 ==> {. printf "no port3c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' port4c' ==> {. port4c := #port;		assert(TRUE);  },	# Row three, button four.
					    timeout_in' 1.0		 ==> {. printf "no port4c in 1 sec!\n";	assert(FALSE); }
					  ];
			};
		end;												# stipulate

#		fun mouse_drag_fn										# This mouse-drag callback fn is used by all twelve buttons.
#		      {	
#			id:			iul::Id,							# Unique id.
#			event_point:		g2d::Point,
#			start_point:		g2d::Point,
#			last_point:		g2d::Point,
#			widget_layout_hint:		gt::Widget_Layout_Hint,
#			site:			g2d::Box,							# Widget's assigned area in window coordinates.
#			phase:			gt::Drag_Phase,	
#			button:			evt::Mousebutton,
#			modifier_keys_state:	evt::Modifier_Keys_State,					# State of the modifier keys (shift, ctrl...).
#			mousebuttons_state:	evt::Mousebuttons_State,					# State of mouse buttons as a bool record.
#			widget_to_guiboss:	gt::Widget_To_Guiboss,
#			theme:			wt::Widget_Theme,
#			do:			(Void -> Void) -> Void,
#		      }
#		    =
#		    if (phase == gt::DRAG)									# Ignore the OPEN and DONE events because OPEN won't have a good last_point and
#			#											# DONE's event_point may be dubious, e.g. if drag ended outside of drag widget.
#			motion = event_point - last_point;
#			#
#			scroll_state := *scroll_state + motion;
#
#			case *scrollport_scroller
#			    #
#			    NULL  =>    ();
#			    THE s =>    s.set_scrollport_origin *scroll_state;
#			esac;
#		    fi;

		fun arrowbutton_mouse_drag_fn									# 
		      #	
		      (port:				Ref( Null_Or( ab::App_To_Arrowbutton )))		# Curried.
		      #	
		      ( ab::MOUSE_DRAG_FN_ARG
			  {	
			    id:				iul::Id,						# Unique id.
			    event_point:		g2d::Point,
			    start_point:		g2d::Point,
			    last_point:			g2d::Point,
			    widget_layout_hint:		gt::Widget_Layout_Hint,
			    site:			g2d::Box,						# Widget's assigned area in window coordinates.
			    phase:			gt::Drag_Phase,	
			    button:			evt::Mousebutton,
			    modifier_keys_state:	evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
			    mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons as a bool record.
			    widget_to_guiboss:		gt::Widget_To_Guiboss,
			    theme:			wt::Widget_Theme,
			    do:				(Void -> Void) -> Void,					# Used by widget subthreads to execute code in main widget microthread.
			    #
			    default_mouse_drag_fn:	ab::Mouse_Drag_Fn,
			    #
			    button_state:		Bool,							# Is the button ON or OFF?
			    button_direction:		Ref(ab::d::Button_Direction),				# Which way does the arrow on the button point?
			    button_type:		    ab::t::Button_Type,					# Is the button push-on-push-off or momentary-contact?
			    button_relief:		Ref(wt::Relief),					# Is the button outline a slope, a ridge, or a flat band?
			    #
			    initial_state:		Bool,							# Original state of button.
			    note_state:			Bool -> Void,						# Change state of button. This takes care of notifying our state-watchers.
			    needs_redraw_gadget_request:Void -> Void						# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
			  }
		      )	
		    =
		    if (mousebuttons_state  == evt::only_mouse_button_1_was_down
		    and modifier_keys_state == evt::no_modifier_keys_were_down)	
			#
			# Handle drag stuff:
			#
			if (phase == gt::DRAG)									# Ignore the OPEN and DONE events because OPEN won't have a good last_point and
			    #											# DONE's event_point may be dubious, e.g. if drag ended outside of drag widget.
			    motion = event_point - last_point;
			    #
			    scroll_state := *scroll_state + motion;

			    case *scrollport_scroller
				#
				NULL  =>    ();
				THE s =>    s.set_scrollport_origin *scroll_state;
			    esac;
			fi;

			if (phase == gt::DONE)
			    #
			    case *port
				#
				NULL =>
				    {
					();
				    };

				THE app_to_arrowbutton
				    =>
				    {
					relief = app_to_arrowbutton.get_button_relief ();
old_relief = relief;
					relief = next_relief relief;
nb {. sprintf "make_three_row_guiplan.arrowbutton_mouse_drag_fn: relief was %s, now %s" (relief_to_string old_relief) (relief_to_string relief); };

					app_to_arrowbutton.set_state_to         FALSE;				# Widget appearance depends on both 'state' and 'relief' settings; keep state FALSE for simplicity.
					app_to_arrowbutton.set_button_relief_to relief;
				    };
			    esac; 
			fi;
		    fi;


		stipulate
		    client_to_guiwindow_ref_1a = REF (NULL: Null_Or( gt::Client_To_Guiwindow ) );		# This is NULL when our popup_plan sub-gui is not running; when popup_plan gui is running it contains (THE client_to_guiwindow), which interface contains the call to shut down the popup gui.
		    client_to_guiwindow_ref_4a = REF (NULL: Null_Or( gt::Client_To_Guiwindow ) );		# This is NULL when our popup_plan sub-gui is not running; when popup_plan gui is running it contains (THE client_to_guiwindow), which interface contains the call to shut down the popup gui.
		    client_to_guiwindow_ref_1c = REF (NULL: Null_Or( gt::Client_To_Guiwindow ) );		# This is NULL when our popup_plan sub-gui is not running; when popup_plan gui is running it contains (THE client_to_guiwindow), which interface contains the call to shut down the popup gui.
		    client_to_guiwindow_ref_2c = REF (NULL: Null_Or( gt::Client_To_Guiwindow ) );		# This is NULL when our popup_plan sub-gui is not running; when popup_plan gui is running it contains (THE client_to_guiwindow), which interface contains the call to shut down the popup gui.
		    client_to_guiwindow_ref_3c = REF (NULL: Null_Or( gt::Client_To_Guiwindow ) );		# This is NULL when our popup_plan sub-gui is not running; when popup_plan gui is running it contains (THE client_to_guiwindow), which interface contains the call to shut down the popup gui.
		    client_to_guiwindow_ref_4c = REF (NULL: Null_Or( gt::Client_To_Guiwindow ) );		# This is NULL when our popup_plan sub-gui is not running; when popup_plan gui is running it contains (THE client_to_guiwindow), which interface contains the call to shut down the popup gui.
		herein
		    fun mouse_drag_and_popup_fn_1a								# This mouse-drag callback fn is used by only row-1, button-4 on guiplan gui, which button pops up a popup gui based on popup_plan.
			  (
			    ab::MOUSE_DRAG_FN_ARG
			      {	
				id:				iul::Id,					# Unique id.
				event_point:			g2d::Point,
				start_point:			g2d::Point,
				last_point:			g2d::Point,
				widget_layout_hint:		gt::Widget_Layout_Hint,
				site:				g2d::Box,					# Widget's assigned area in window coordinates.
				phase:				gt::Drag_Phase,	
				button:				evt::Mousebutton,
				modifier_keys_state:		evt::Modifier_Keys_State,			# State of the modifier keys (shift, ctrl...).
				mousebuttons_state:		evt::Mousebuttons_State,			# State of mouse buttons as a bool record.
				widget_to_guiboss:		gt::Widget_To_Guiboss,
				theme:				wt::Widget_Theme,
				do:				(Void -> Void) -> Void,				# Used by widget subthreads to execute code in main widget microthread.
				#
				default_mouse_drag_fn:		ab::Mouse_Drag_Fn,
				#
				button_state:			Bool,						# Is the button ON or OFF?
				button_direction:		Ref(ab::d::Button_Direction),			# Which way does the arrow on the button point?
				button_type:			    ab::t::Button_Type,				# Is the button push-on-push-off or momentary-contact?
				button_relief:			Ref(wt::Relief),				# Is the button outline a slope, a ridge, or a flat band?
				#
				initial_state:			Bool,						# Original state of button.
				note_state:			Bool -> Void,					# Change state of button. This takes care of notifying our state-watchers.
				needs_redraw_gadget_request:	Void -> Void					# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
			      }
			  )
			=
			case phase
			    #
			    gt::DONE => ();									# Ignore the DONE event.
			    gt::OPEN
				=>
				if (button == evt::button1)
				    #
				    case *client_to_guiwindow_ref_1a
					#
					THE client_to_guiwindow							# popup_plan is running, so we'll interpret the mouse downclick as a request to kill it.
					    =>
					    {
						client_to_guiwindow.kill_gui ();					# Tell guiboss_imp to shut down the popup_plan gui.
						#
						client_to_guiwindow_ref_1a := NULL;					# Trust that guiboss_imp did so and record the popup_plan as being dead.
					    };

					NULL =>									# popup_plan is not currently running, so we'll interpret the mouse downclick as a request try starting it.
					    case popup_info3
						#
						NULL => ();								# This gui doesn't pop up a sub-gui.

						THE popup_info_fn
						    =>
						    {
							(popup_info_fn ())
							    ->
							    { requested_popup_site:	g2d::Box,			# For popup_plan this was:  { row => 200, col => 200, wide => 1200, high => 900 };
							      popup_plan:		gt::Guiplan,			# 
							      read_sites_and_ports
							    };

							(widget_to_guiboss.g.make_popup (requested_popup_site, popup_plan))
							    ->
							    (actual_site, client_to_guiwindow);

							client_to_guiwindow_ref_1a :=  (THE client_to_guiwindow);

							read_sites_and_ports ();
						    };
					    esac;
				    esac;
				fi;

			    gt::DRAG										# For drag purposes (sliding the scrollport contents) we ignore the OPEN
				=>										# and DONE events because OPEN won't have a good last_point and DONE's
				if (mousebuttons_state  == evt::only_mouse_button_1_was_down			# event_point may be dubious, e.g. if drag ended outside of drag widget.
				and modifier_keys_state == evt::no_modifier_keys_were_down)	
				    #
				    motion = event_point - last_point;
				    #
				    scroll_state := *scroll_state + motion;

				    case *scrollport_scroller
					#
					NULL  =>    ();
					THE s =>    s.set_scrollport_origin *scroll_state;
				    esac;
				fi;
			esac;

		    fun mouse_drag_and_popup_fn_4a								# This mouse-drag callback fn is used by only row-1, button-4 on guiplan gui, which button pops up a popup gui based on popup_plan.
			  (
			    ab::MOUSE_DRAG_FN_ARG
			      {	
				id:				iul::Id,					# Unique id.
				event_point:			g2d::Point,
				start_point:			g2d::Point,
				last_point:			g2d::Point,
				widget_layout_hint:		gt::Widget_Layout_Hint,
				site:				g2d::Box,					# Widget's assigned area in window coordinates.
				phase:				gt::Drag_Phase,	
				button:				evt::Mousebutton,
				modifier_keys_state:		evt::Modifier_Keys_State,			# State of the modifier keys (shift, ctrl...).
				mousebuttons_state:		evt::Mousebuttons_State,			# State of mouse buttons as a bool record.
				widget_to_guiboss:		gt::Widget_To_Guiboss,
				theme:				wt::Widget_Theme,
				do:				(Void -> Void) -> Void,				# Used by widget subthreads to execute code in main widget microthread.
				#
				default_mouse_drag_fn:		ab::Mouse_Drag_Fn,
				#
				button_state:			Bool,						# Is the button ON or OFF?
				button_direction:		Ref(ab::d::Button_Direction),			# Which way does the arrow on the button point?
				button_type:			    ab::t::Button_Type,				# Is the button push-on-push-off or momentary-contact?
				button_relief:			Ref(wt::Relief),				# Is the button outline a slope, a ridge, or a flat band?
				#
				initial_state:			Bool,						# Original state of button.
				note_state:			Bool -> Void,					# Change state of button. This takes care of notifying our state-watchers.
				needs_redraw_gadget_request:	Void -> Void					# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
			      }
			  )
			=
			case phase
			    #
			    gt::DONE => ();									# Ignore the DONE event.
			    gt::OPEN
				=>
				if (button == evt::button1)
				    #
				    case *client_to_guiwindow_ref_4a
					#
					THE client_to_guiwindow							# popup_plan is running, so we'll interpret the mouse downclick as a request to kill it.
					    =>
					    {
						client_to_guiwindow.kill_gui ();					# Tell guiboss_imp to shut down the popup_plan gui.
						#
						client_to_guiwindow_ref_4a := NULL;					# Trust that guiboss_imp did so and record the popup_plan as being dead.
					    };

					NULL =>									# popup_plan is not currently running, so we'll interpret the mouse downclick as a request try starting it.
					    case popup_info
						#
						NULL => ();								# This gui doesn't pop up a sub-gui.

						THE popup_info_fn
						    =>
						    {   (popup_info_fn ())
							    ->
							    { requested_popup_site:	g2d::Box,			# For popup_plan this was:  { row => 200, col => 200, wide => 1200, high => 900 };
							      popup_plan:		gt::Guiplan,			# 
							      read_sites_and_ports
							    };

							(widget_to_guiboss.g.make_popup (requested_popup_site, popup_plan))
							    ->
							    (actual_site, client_to_guiwindow);

							client_to_guiwindow_ref_4a :=  (THE client_to_guiwindow);

							read_sites_and_ports ();
						    };
					    esac;
				    esac;
				fi;

			    gt::DRAG										# For drag purposes (sliding the scrollport contents) we ignore the OPEN
				=>										# and DONE events because OPEN won't have a good last_point and DONE's
				if (mousebuttons_state  == evt::only_mouse_button_1_was_down			# event_point may be dubious, e.g. if drag ended outside of drag widget.
				and modifier_keys_state == evt::no_modifier_keys_were_down)	
				    #
				    motion = event_point - last_point;
				    #
				    scroll_state := *scroll_state + motion;

				    case *scrollport_scroller
					#
					NULL  =>    ();
					THE s =>    s.set_scrollport_origin *scroll_state;
				    esac;
				fi;
			esac;

		    fun mouse_drag_and_popup_fn_1c								# This mouse-drag callback fn is used by only row-3, button-1 on guiplan gui, which button pops up a popup gui based on hsliders_plan.
			  (
			    ab::MOUSE_DRAG_FN_ARG
			      {	
				id:				iul::Id,					# Unique id.
				event_point:			g2d::Point,
				start_point:			g2d::Point,
				last_point:			g2d::Point,
				widget_layout_hint:		gt::Widget_Layout_Hint,
				site:				g2d::Box,					# Widget's assigned area in window coordinates.
				phase:				gt::Drag_Phase,	
				button:				evt::Mousebutton,
				modifier_keys_state:		evt::Modifier_Keys_State,			# State of the modifier keys (shift, ctrl...).
				mousebuttons_state:		evt::Mousebuttons_State,			# State of mouse buttons as a bool record.
				widget_to_guiboss:		gt::Widget_To_Guiboss,
				theme:				wt::Widget_Theme,
				do:				(Void -> Void) -> Void,				# Used by widget subthreads to execute code in main widget microthread.
				#
				default_mouse_drag_fn:		ab::Mouse_Drag_Fn,
				#
				button_state:			Bool,						# Is the button ON or OFF?
				button_direction:		Ref(ab::d::Button_Direction),			# Which way does the arrow on the button point?
				button_type:			    ab::t::Button_Type,				# Is the button push-on-push-off or momentary-contact?
				button_relief:			Ref(wt::Relief),				# Is the button outline a slope, a ridge, or a flat band?
				#
				initial_state:			Bool,						# Original state of button.
				note_state:			Bool -> Void,					# Change state of button. This takes care of notifying our state-watchers.
				needs_redraw_gadget_request:	Void -> Void					# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
			      }
			  )
			=
			case phase
			    #
			    gt::DONE => ();									# Ignore the DONE event.
			    gt::OPEN
				=>
				if (button == evt::button1)
				    #
				    case *client_to_guiwindow_ref_1c
					#
					THE client_to_guiwindow							# hsliders_plan is running, so we'll interpret the mouse downclick as a request to kill it.
					    =>
					    {
						client_to_guiwindow.kill_gui ();					# Tell guiboss_imp to shut down the popup_plan gui.
						#
						client_to_guiwindow_ref_1c := NULL;					# Trust that guiboss_imp did so and record the popup_plan as being dead.
					    };

					NULL =>									# hsliders_plan is not currently running, so we'll interpret the mouse downclick as a request try starting it.
					    case popup_info1c
						#
						NULL => ();								# This gui doesn't pop up a sub-gui.

						THE popup_info_fn
						    =>
						    {
							(popup_info_fn ())
							    ->
							    { requested_popup_site:	g2d::Box,			# For popup_plan this was:  { row => 200, col => 200, wide => 1200, high => 900 };
							      popup_plan:		gt::Guiplan,			# 
							      read_sites_and_ports
							    };

							(widget_to_guiboss.g.make_popup (requested_popup_site, popup_plan))
							    ->
							    (actual_site, client_to_guiwindow);

							client_to_guiwindow_ref_1c :=  (THE client_to_guiwindow);

							read_sites_and_ports ();
						    };
					    esac;
				    esac;
				fi;

			    gt::DRAG									# For drag purposes (sliding the scrollport contents) we ignore the OPEN
				=>										# and DONE events because OPEN won't have a good last_point and DONE's
				if (mousebuttons_state  == evt::only_mouse_button_1_was_down		# event_point may be dubious, e.g. if drag ended outside of drag widget.
				and modifier_keys_state == evt::no_modifier_keys_were_down)	
				    #
				    motion = event_point - last_point;
				    #
				    scroll_state := *scroll_state + motion;

				    case *scrollport_scroller
					#
					NULL  =>    ();
					THE s =>    s.set_scrollport_origin *scroll_state;
				    esac;
				fi;
			esac;


		    fun mouse_drag_and_popup_fn_2c								# This mouse-drag callback fn is used by only row-3, button-2 on guiplan gui, which button pops up a popup gui based on hsliders_plan.
			  (
			    ab::MOUSE_DRAG_FN_ARG
			      {	
				id:				iul::Id,					# Unique id.
				event_point:			g2d::Point,
				start_point:			g2d::Point,
				last_point:			g2d::Point,
				widget_layout_hint:		gt::Widget_Layout_Hint,
				site:				g2d::Box,					# Widget's assigned area in window coordinates.
				phase:				gt::Drag_Phase,	
				button:				evt::Mousebutton,
				modifier_keys_state:		evt::Modifier_Keys_State,			# State of the modifier keys (shift, ctrl...).
				mousebuttons_state:		evt::Mousebuttons_State,			# State of mouse buttons as a bool record.
				widget_to_guiboss:		gt::Widget_To_Guiboss,
				theme:				wt::Widget_Theme,
				do:				(Void -> Void) -> Void,				# Used by widget subthreads to execute code in main widget microthread.
				#
				default_mouse_drag_fn:		ab::Mouse_Drag_Fn,
				#
				button_state:			Bool,						# Is the button ON or OFF?
				button_direction:		Ref(ab::d::Button_Direction),			# Which way does the arrow on the button point?
				button_type:			    ab::t::Button_Type,				# Is the button push-on-push-off or momentary-contact?
				button_relief:			Ref(wt::Relief),				# Is the button outline a slope, a ridge, or a flat band?
				#
				initial_state:			Bool,						# Original state of button.
				note_state:			Bool -> Void,					# Change state of button. This takes care of notifying our state-watchers.
				needs_redraw_gadget_request:	Void -> Void					# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
			      }
			  )
			=
			case phase
			    #
			    gt::DONE => ();									# Ignore the DONE event.
			    gt::OPEN
				=>
				if (button == evt::button1)
				    #
				    case *client_to_guiwindow_ref_2c
					#
					THE client_to_guiwindow							# hsliders_plan is running, so we'll interpret the mouse downclick as a request to kill it.
					    =>
					    {
						client_to_guiwindow.kill_gui ();					# Tell guiboss_imp to shut down the popup_plan gui.
						#
						client_to_guiwindow_ref_2c := NULL;					# Trust that guiboss_imp did so and record the popup_plan as being dead.
					    };

					NULL =>									# hsliders_plan is not currently running, so we'll interpret the mouse downclick as a request try starting it.
					    case popup_info2c
						#
						NULL => ();								# This gui doesn't pop up a sub-gui.

						THE popup_info_fn
						    =>
						    {
							(popup_info_fn ())
							    ->
							    { requested_popup_site:	g2d::Box,			# For popup_plan this was:  { row => 200, col => 200, wide => 1200, high => 900 };
							      popup_plan:		gt::Guiplan,			# 
							      read_sites_and_ports
							    };

							(widget_to_guiboss.g.make_popup (requested_popup_site, popup_plan))
							    ->
							    (actual_site, client_to_guiwindow);

							client_to_guiwindow_ref_2c :=  (THE client_to_guiwindow);

							read_sites_and_ports ();
						    };
					    esac;
				    esac;
				fi;

			    gt::DRAG										# For drag purposes (sliding the scrollport contents) we ignore the OPEN
				=>										# and DONE events because OPEN won't have a good last_point and DONE's
				if (mousebuttons_state  == evt::only_mouse_button_1_was_down			# event_point may be dubious, e.g. if drag ended outside of drag widget.
				and modifier_keys_state == evt::no_modifier_keys_were_down)	
				    #
				    motion = event_point - last_point;
				    #
				    scroll_state := *scroll_state + motion;

				    case *scrollport_scroller
					#
					NULL  =>    ();
					THE s =>    s.set_scrollport_origin *scroll_state;
				    esac;
				fi;
			esac;

		    fun mouse_drag_and_popup_fn_3c								# This mouse-drag callback fn is used by only row-3, button-3 on guiplan gui, which button pops up a popup gui based on hsliders_plan.
			  (
			    ab::MOUSE_DRAG_FN_ARG
			      {	
				id:				iul::Id,					# Unique id.
				event_point:			g2d::Point,
				start_point:			g2d::Point,
				last_point:			g2d::Point,
				widget_layout_hint:		gt::Widget_Layout_Hint,
				site:				g2d::Box,					# Widget's assigned area in window coordinates.
				phase:				gt::Drag_Phase,	
				button:				evt::Mousebutton,
				modifier_keys_state:		evt::Modifier_Keys_State,			# State of the modifier keys (shift, ctrl...).
				mousebuttons_state:		evt::Mousebuttons_State,			# State of mouse buttons as a bool record.
				widget_to_guiboss:		gt::Widget_To_Guiboss,
				theme:				wt::Widget_Theme,
				do:				(Void -> Void) -> Void,				# Used by widget subthreads to execute code in main widget microthread.
				#
				default_mouse_drag_fn:		ab::Mouse_Drag_Fn,
				#
				button_state:			Bool,						# Is the button ON or OFF?
				button_direction:		Ref(ab::d::Button_Direction),			# Which way does the arrow on the button point?
				button_type:			    ab::t::Button_Type,				# Is the button push-on-push-off or momentary-contact?
				button_relief:			Ref(wt::Relief),				# Is the button outline a slope, a ridge, or a flat band?
				#
				initial_state:			Bool,						# Original state of button.
				note_state:			Bool -> Void,					# Change state of button. This takes care of notifying our state-watchers.
				needs_redraw_gadget_request:	Void -> Void					# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
			      }
			  )
			=
			case phase
			    #
			    gt::DONE => ();									# Ignore the DONE event.
			    gt::OPEN
				=>
				if (button == evt::button1)
				    #
				    case *client_to_guiwindow_ref_3c
					#
					THE client_to_guiwindow							# hsliders_plan is running, so we'll interpret the mouse downclick as a request to kill it.
					    =>
					    {
						client_to_guiwindow.kill_gui ();					# Tell guiboss_imp to shut down the popup_plan gui.
						#
						client_to_guiwindow_ref_3c := NULL;					# Trust that guiboss_imp did so and record the popup_plan as being dead.
					    };

					NULL =>									# hsliders_plan is not currently running, so we'll interpret the mouse downclick as a request try starting it.
					    case popup_info3c
						#
						NULL => ();								# This gui doesn't pop up a sub-gui.

						THE popup_info_fn
						    =>
						    {
							(popup_info_fn ())
							    ->
							    { requested_popup_site:	g2d::Box,			# For popup_plan this was:  { row => 200, col => 200, wide => 1200, high => 900 };
							      popup_plan:		gt::Guiplan,			# 
							      read_sites_and_ports
							    };

							(widget_to_guiboss.g.make_popup (requested_popup_site, popup_plan))
							    ->
							    (actual_site, client_to_guiwindow);

							client_to_guiwindow_ref_3c :=  (THE client_to_guiwindow);

							read_sites_and_ports ();
						    };
					    esac;
				    esac;
				fi;

			    gt::DRAG										# For drag purposes (sliding the scrollport contents) we ignore the OPEN
				=>										# and DONE events because OPEN won't have a good last_point and DONE's
				if (mousebuttons_state  == evt::only_mouse_button_1_was_down			# event_point may be dubious, e.g. if drag ended outside of drag widget.
				and modifier_keys_state == evt::no_modifier_keys_were_down)	
				    #
				    motion = event_point - last_point;
				    #
				    scroll_state := *scroll_state + motion;

				    case *scrollport_scroller
					#
					NULL  =>    ();
					THE s =>    s.set_scrollport_origin *scroll_state;
				    esac;
				fi;
			esac;

		    fun mouse_drag_and_popup_fn_4c								# This mouse-drag callback fn is used by only row-3, button-4 on guiplan gui, which button pops up a popup gui based on hsliders_plan.
			  (
			    ab::MOUSE_DRAG_FN_ARG
			      {	
				id:				iul::Id,					# Unique id.
				event_point:			g2d::Point,
				start_point:			g2d::Point,
				last_point:			g2d::Point,
				widget_layout_hint:		gt::Widget_Layout_Hint,
				site:				g2d::Box,					# Widget's assigned area in window coordinates.
				phase:				gt::Drag_Phase,	
				button:				evt::Mousebutton,
				modifier_keys_state:		evt::Modifier_Keys_State,			# State of the modifier keys (shift, ctrl...).
				mousebuttons_state:		evt::Mousebuttons_State,			# State of mouse buttons as a bool record.
				widget_to_guiboss:		gt::Widget_To_Guiboss,
				theme:				wt::Widget_Theme,
				do:				(Void -> Void) -> Void,				# Used by widget subthreads to execute code in main widget microthread.
				#
				default_mouse_drag_fn:		ab::Mouse_Drag_Fn,
				#
				button_state:			Bool,						# Is the button ON or OFF?
				button_direction:		Ref(ab::d::Button_Direction),			# Which way does the arrow on the button point?
				button_type:			    ab::t::Button_Type,				# Is the button push-on-push-off or momentary-contact?
				button_relief:			Ref(wt::Relief),				# Is the button outline a slope, a ridge, or a flat band?
				#
				initial_state:			Bool,						# Original state of button.
				note_state:			Bool -> Void,					# Change state of button. This takes care of notifying our state-watchers.
				needs_redraw_gadget_request:	Void -> Void					# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
			      }
			  )
			=
			case phase
			    #
			    gt::DONE => ();									# Ignore the DONE event.
			    gt::OPEN
				=>
				if (button == evt::button1)
				    #
				    case *client_to_guiwindow_ref_4c
					#
					THE client_to_guiwindow							# hsliders_plan is running, so we'll interpret the mouse downclick as a request to kill it.
					    =>
					    {
						client_to_guiwindow.kill_gui ();					# Tell guiboss_imp to shut down the popup_plan gui.
						#
						client_to_guiwindow_ref_4c := NULL;					# Trust that guiboss_imp did so and record the popup_plan as being dead.
					    };

					NULL =>									# hsliders_plan is not currently running, so we'll interpret the mouse downclick as a request try starting it.
					    case popup_info4c
						#
						NULL => ();								# This gui doesn't pop up a sub-gui.

						THE popup_info_fn
						    =>
						    {
							(popup_info_fn ())
							    ->
							    { requested_popup_site:	g2d::Box,			# For popup_plan this was:  { row => 200, col => 200, wide => 1200, high => 900 };
							      popup_plan:		gt::Guiplan,			# 
							      read_sites_and_ports
							    };

							(widget_to_guiboss.g.make_popup (requested_popup_site, popup_plan))
							    ->
							    (actual_site, client_to_guiwindow);

							client_to_guiwindow_ref_4c :=  (THE client_to_guiwindow);

							read_sites_and_ports ();
						    };
					    esac;
				    esac;
				fi;

			    gt::DRAG										# For drag purposes (sliding the scrollport contents) we ignore the OPEN
				=>										# and DONE events because OPEN won't have a good last_point and DONE's
				if (mousebuttons_state  == evt::only_mouse_button_1_was_down			# event_point may be dubious, e.g. if drag ended outside of drag widget.
				and modifier_keys_state == evt::no_modifier_keys_were_down)	
				    motion = event_point - last_point;
				    #
				    scroll_state := *scroll_state + motion;

				    case *scrollport_scroller
					#
					NULL  =>    ();
					THE s =>    s.set_scrollport_origin *scroll_state;
				    esac;
				fi;
			esac;
		end;


		font = [ "-*-courier-bold-r-*-*-20-*-*-*-*-*-*-*" ];

		label_1c = case popup_info1c NULL => ab::TEXT "xyz"; _ => ab::TEXT "HSLIDERS";     esac;
		label_2c = case popup_info2c NULL => ab::TEXT "xyz"; _ => ab::TEXT "VSLIDERS";     esac;
		label_3c = case popup_info3c NULL => ab::TEXT "xyz"; _ => ab::TEXT "TEXT ENTRIES"; esac;
		label_4c = case popup_info4c NULL => ab::TEXT "xyz"; _ => ab::TEXT "TEXT EDITOR";  esac;

		guiplan
		  =
		  gt::FRAME
		    ( [],
		      gt::COL
			[
			  ( gt::FRAME
			      ( [],
				gt::ROW [
				      arrowbutton::with     [                        ab::PORTWATCHER portwatcher1a,  ab::LEFT ,  ab::TEXT "BUTTONS",  ab::THICK 20,  ab::FONTS font,  ab::MARGIN 40,  ab::SITEWATCHER sitewatcher1a,  ab::MOUSE_DRAG_FN mouse_drag_and_popup_fn_1a ],
				      arrowbutton::with     [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher2a,  ab::UP   ,  ab::TEXT "xyz",      ab::THICK 20,  ab::FONTS font,  ab::MARGIN 40,  ab::SITEWATCHER sitewatcher2a,  ab::MOUSE_DRAG_FN (arrowbutton_mouse_drag_fn port2a) ],
				      arrowbutton::with     [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher3a,  ab::DOWN ,  ab::TEXT "xyz",      ab::THICK 20,  ab::FONTS font,  ab::MARGIN 40,  ab::SITEWATCHER sitewatcher3a,  ab::MOUSE_DRAG_FN (arrowbutton_mouse_drag_fn port3a) ],
				      arrowbutton::with     [                        ab::PORTWATCHER portwatcher4a,  ab::RIGHT,  ab::TEXT "SUB",      ab::THICK 20,  ab::FONTS font,  ab::MARGIN 40,  ab::SITEWATCHER sitewatcher4a,  ab::MOUSE_DRAG_FN mouse_drag_and_popup_fn_4a ]
				    ]
			      )
			  ),

			  ( gt::SCROLLPORT
			      {
				scroller_callback =>   (\\ scroller =  scrollport_scroller := scroller):	gt::Scroller_Callback,
				#
				pixmap_size => scrollable_view_size,
				widget      => gt::FRAME
						( [],
						  gt::ROW [
							arrowbutton::with [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher1b,  ab::LEFT ,  ab::TEXT "xyz",      ab::THICK 20,  ab::FONTS font,  ab::MARGIN 40,  ab::SITEWATCHER sitewatcher1b,  ab::MOUSE_DRAG_FN (arrowbutton_mouse_drag_fn port1b) ],
							arrowbutton::with [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher2b,  ab::UP   ,  ab::TEXT "xyz",      ab::THICK 20,  ab::FONTS font,  ab::MARGIN 40,  ab::SITEWATCHER sitewatcher2b,  ab::MOUSE_DRAG_FN (arrowbutton_mouse_drag_fn port2b) ],
							arrowbutton::with [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher3b,  ab::DOWN ,  ab::TEXT "xyz",      ab::THICK 20,  ab::FONTS font,  ab::MARGIN 40,  ab::SITEWATCHER sitewatcher3b,  ab::MOUSE_DRAG_FN (arrowbutton_mouse_drag_fn port3b) ],
							arrowbutton::with [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher4b,  ab::RIGHT,  ab::TEXT "xyz",      ab::THICK 20,  ab::FONTS font,  ab::MARGIN 40,  ab::SITEWATCHER sitewatcher4b,  ab::MOUSE_DRAG_FN (arrowbutton_mouse_drag_fn port4b) ]
						      ]
						)
			      }	
			  ),

			  ( gt::FRAME
			      ( [],
				gt::ROW [
				      arrowbutton::with     [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher1c,  ab::LEFT ,  label_1c,            ab::THICK 20,  ab::FONTS font,  ab::MARGIN 40,  ab::SITEWATCHER sitewatcher1c,  ab::MOUSE_DRAG_FN mouse_drag_and_popup_fn_1c ],
				      arrowbutton::with     [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher2c,  ab::UP   ,  label_2c,            ab::THICK 20,  ab::FONTS font,  ab::MARGIN 40,  ab::SITEWATCHER sitewatcher2c,  ab::MOUSE_DRAG_FN mouse_drag_and_popup_fn_2c ],
				      arrowbutton::with     [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher3c,  ab::DOWN ,  label_3c,            ab::THICK 20,  ab::FONTS font,  ab::MARGIN 40,  ab::SITEWATCHER sitewatcher3c,  ab::MOUSE_DRAG_FN mouse_drag_and_popup_fn_3c ],
				      arrowbutton::with     [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher4c,  ab::RIGHT,  label_4c,            ab::THICK 20,  ab::FONTS font,  ab::MARGIN 40,  ab::SITEWATCHER sitewatcher4c,  ab::MOUSE_DRAG_FN mouse_drag_and_popup_fn_4c ]
				    ]
			      )
			  )
			]
		    );

		{ guiplan,
		  scrollport_scroller,
		  scroll_state,

		  widget_sites =>     { site1a, site2a, site3a, site4a,
					site1b, site2b, site3b, site4b,
					site1c, site2c, site3c, site4c
				      },

		  read_back_sites_and_ports_of_guiplan_widgets
		};
	    };														# fun make_three_row_guiplan

	fun make_grid_guiplan  ()
	      #
	      :	{ guiplan:		gt::Guiplan,
															# Here we return globals which wind up containing the window sites
															# assigned to our various widgets.  Normal application code never
															# needs to know this, but our test code needs this information in
															# order to synthesize fake mouseclicks etc on the buttons.
															#
		  widget_sites:   { site1a: Ref (Null_Or(g2d::Box)),							# Row one,   button one.
				    site2a: Ref (Null_Or(g2d::Box)),							# Row one,   button two.
															#
				    site1b: Ref (Null_Or(g2d::Box)),							# Row two,   button one.  
				    site2b: Ref (Null_Or(g2d::Box))							# Row two,   button two.  
				  },

		  read_back_sites_and_ports_of_grid_guiplan_widgets:	Void -> Void					# Fills in values of widget_sites
		}
	    =
	    {
		stipulate
		    site1a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row one,   first  button, site notification mailqueue.
		    site2a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row one,   second button, site notification mailqueue.
		    #													#
		    site1b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row two,   first  button, site notification mailqueue.
		    site2b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );		# Row two,   second button, site notification mailqueue.

		    port1a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row one,   first  button, port notification mailqueue.
		    port2a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row one,   seond  button, port notification mailqueue.
		    #	
		    port1b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row two,   first  button, port notification mailqueue.
		    port2b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(ab::App_To_Arrowbutton) );	# Row two,   second button, port notification mailqueue.
		herein														                                                     
															# These globals hold the values read from the above
															# mailops by the later do_one_mailop() calls.
															# They hold the sites (window locations) assigned to
															# our twelve pushbuttons. (We need this information
															# to generate fake mouseclicks on them for test
															# purposes. A normal GUI app wouldn't do this.) 
															#
		    site1a = REF (NULL: Null_Or(g2d::Box));								# Row one,   button one.
		    site2a = REF (NULL: Null_Or(g2d::Box));								# Row one,   button two.
		    #													#
		    site1b = REF (NULL: Null_Or(g2d::Box));								# Row two,   button one.
		    site2b = REF (NULL: Null_Or(g2d::Box));								# Row two,   button two.

		    port1a = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row one,   button one.
		    port2a = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row one,   button two.
		    #													#
		    port1b = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row two,   button one.
		    port2b = REF (NULL: Null_Or( ab::App_To_Arrowbutton ));						# Row two,   button two.

															# These are the site-watcher callbacks we pass to the
															# guiboss layer to find out where our buttons are on
															# the window:
															#
#		    fun sitewatcher1a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1a', site);			# Row one,   first  button, site notification callback.
#		    fun sitewatcher2a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2a', site);			# Row one,   second button, site notification callback.
#		    #													#
#		    fun sitewatcher1b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1b', site);			# Row two,   first  button, site notification callback.
#		    fun sitewatcher2b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2b', site);			# Row two,   second button, site notification callback.

		    fun sitewatcher1a (site: Null_Or(g2d::Box))
			=
			{
nb {. sprintf "make_grid_guiplan/sitewatcher1a/AAA -- widget-unit-test.pkg"; };
			    put_in_mailqueue (site1a', site);			# Row one,   first  button, site notification callback.
nb {. sprintf "make_grid_guiplan/sitewatcher1a/ZZZ -- widget-unit-test.pkg"; };
			};

		    fun sitewatcher2a (site: Null_Or(g2d::Box))
			=
			{
nb {. sprintf "make_grid_guiplan/sitewatcher2a/AAA -- widget-unit-test.pkg"; };
			    put_in_mailqueue (site2a', site);			# Row one,   second button, site notification callback.
nb {. sprintf "make_grid_guiplan/sitewatcher2a/ZZZ -- widget-unit-test.pkg"; };
			};
		    #													#
		    fun sitewatcher1b (site: Null_Or(g2d::Box))
			=
			{
nb {. sprintf "make_grid_guiplan/sitewatcher1b/AAA -- widget-unit-test.pkg"; };
			    put_in_mailqueue (site1b', site);			# Row two,   first  button, site notification callback.
nb {. sprintf "make_grid_guiplan/sitewatcher1b/ZZZ -- widget-unit-test.pkg"; };
			};
		    fun sitewatcher2b (site: Null_Or(g2d::Box))
			=
			{
nb {. sprintf "make_grid_guiplan/sitewatcher2b/AAA -- widget-unit-test.pkg"; };
			    put_in_mailqueue (site2b', site);			# Row two,   second button, site notification callback.
nb {. sprintf "make_grid_guiplan/sitewatcher2b/ZZZ -- widget-unit-test.pkg"; };
			};

		    fun portwatcher1a (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port1a', port);	# Row one,   first  button, port notification callback.
		    fun portwatcher2a (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port2a', port);	# Row one,   second button, port notification callback.
		    #													#
		    fun portwatcher1b (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port1b', port);	# Row two,   first  button, port notification callback.
		    fun portwatcher2b (port: Null_Or(ab::App_To_Arrowbutton)) =  put_in_mailqueue (port2b', port);	# Row two,   second button, port notification callback.


		    fun read_back_sites_and_ports_of_grid_guiplan_widgets ()						# Fill in the above globals via blocking reads.
			=												# We use timeouts (only) to recover gracefully if things are
			{												# somehow so broken that guiboss-imp never calls our callbacks.
															# The order shouldn't matter; here we go left-to-right top-to-bottom:

			    do_one_mailop [ take_from_mailqueue' site1a'	==> {. site1a := #site;			assert(TRUE);  },	# Row one,   button one.
					    timeout_in' 1.0		==> {. printf "no site1a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2a'	==> {. site2a := #site;			assert(TRUE);  },	# Row one,   button two.
					    timeout_in' 1.0		==> {. printf "no site2a in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1b'	==> {. site1b := #site;			assert(TRUE);  },	# Row two,   button one.
					    timeout_in' 1.0		==> {. printf "no site1b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2b'	==> {. site2b := #site;			assert(TRUE);  },	# Row two,   button two.
					    timeout_in' 1.0		==> {. printf "no site2b in 1 sec!\n";	assert(FALSE); }
					  ];


			    do_one_mailop [ take_from_mailqueue' port1a'	==> {. port1a := #port;			assert(TRUE);  },	# Row one,   button one.
					    timeout_in' 1.0		==> {. printf "no port1a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' port2a'	==> {. port2a := #port;			assert(TRUE);  },	# Row one,   button two.
					    timeout_in' 1.0		==> {. printf "no port2a in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' port1b'	==> {. port1b := #port;			assert(TRUE);  },	# Row two,   button one.
					    timeout_in' 1.0		==> {. printf "no port1b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' port2b'	==> {. port2b := #port;			assert(TRUE);  },	# Row two,   button two.
					    timeout_in' 1.0		==> {. printf "no port2b in 1 sec!\n";	assert(FALSE); }
					  ];

			};
		end;

#		fun mouse_drag_fn										# 
#		      {	
#			id:			iul::Id,							# Unique id.
#			event_point:		g2d::Point,
#			start_point:		g2d::Point,
#			last_point:		g2d::Point,
#			widget_layout_hint:	gt::Widget_Layout_Hint,
#			site:			g2d::Box,							# Widget's assigned area in window coordinates.
#			phase:			gt::Drag_Phase,	
#			button:			evt::Mousebutton,
#			modifier_keys_state:	evt::Modifier_Keys_State,					# State of the modifier keys (shift, ctrl...).
#			mousebuttons_state:	evt::Mousebuttons_State,					# State of mouse buttons as a bool record.
#			widget_to_guiboss:	gt::Widget_To_Guiboss,
#			theme:			wt::Widget_Theme,
#			do:			(Void -> Void) -> Void
#		      }
#		    =
#		    if (phase == gt::DRAG)									# Ignore the OPEN and DONE events because OPEN won't have a good last_point and
#			#											# DONE's event_point may be dubious, e.g. if drag ended outside of drag widget.
#			motion = event_point - last_point;
#			#
#		    fi;

		fun arrowbutton_mouse_drag_fn									# 
		      #	
		      (port:			Ref( Null_Or( ab::App_To_Arrowbutton )))			# Curried.
		      #
		    =	
		    {   big = REF FALSE;									# Issue each button its own boolean state value.
			#
			\\  ( ab::MOUSE_DRAG_FN_ARG
				{	
				  id:				iul::Id,					# Unique id.
				  event_point:			g2d::Point,
				  start_point:			g2d::Point,
				  last_point:			g2d::Point,
				  widget_layout_hint:		gt::Widget_Layout_Hint,
				  site:				g2d::Box,					# Widget's assigned area in window coordinates.
				  phase:			gt::Drag_Phase,	
				  button:			evt::Mousebutton,
				  modifier_keys_state:		evt::Modifier_Keys_State,			# State of the modifier keys (shift, ctrl...).
				  mousebuttons_state:		evt::Mousebuttons_State,			# State of mouse buttons as a bool record.
				  widget_to_guiboss:		gt::Widget_To_Guiboss,
				  theme:			wt::Widget_Theme,
				  do:				(Void -> Void) -> Void,				# Used by widget subthreads to execute code in main widget microthread.
				  #
				  default_mouse_drag_fn:	ab::Mouse_Drag_Fn,
				  #
				  button_state:			Bool,						# Is the button ON or OFF?
				  button_direction:		Ref(ab::d::Button_Direction),			# Which way does the arrow on the button point?
				  button_type:			ab::t::Button_Type,				# Is the button push-on-push-off or momentary-contact?
				  button_relief:		Ref(wt::Relief),				# Is the button outline a slope, a ridge, or a flat band?
				  #
				  initial_state:		Bool,						# Original state of button.
				  note_state:			Bool -> Void,					# Change state of button. This takes care of notifying our state-watchers.
				  needs_redraw_gadget_request:	Void -> Void					# Notify guiboss-imp that this button needs to be redrawn (i.e., sent a redraw_gadget_request()).
				}
			    )	
			    =
			    # Handle drag stuff:
			    #
			    case phase
				#
				gt::OPEN => if (button              == evt::button1
					    and mousebuttons_state  == evt::no_mouse_buttons_were_down
					    and modifier_keys_state == evt::no_modifier_keys_were_down)
						#
						big := not *big;
nb {. sprintf "grid/arrowbutton_mouse_drag_fn/OPEN:  big=%B  widget_layout_hint.pixels_high_min=%d  widget_layout_hint.pixels_wide_min=%d"  *big  widget_layout_hint.pixels_high_min  widget_layout_hint.pixels_wide_min; };

						widget_layout_hint
						  ->
						  { pixels_high_min,
						    pixels_wide_min,
						    pixels_high_cut,
						    pixels_wide_cut
						  };

						my (pixels_high_min, pixels_wide_min)
						    =
						    *big ?? (pixels_high_min + 10, pixels_wide_min + 10)
						         :: (pixels_high_min - 10, pixels_wide_min - 10);

						widget_layout_hint
						  =
						  { pixels_high_min,
						    pixels_wide_min,
						    pixels_high_cut,
						    pixels_wide_cut
						  };

						widget_to_guiboss.note_widget_layout_hint { id, widget_layout_hint };

						();
					    fi;

				gt::DRAG => if (mousebuttons_state  == evt::only_mouse_button_1_was_down
					    and modifier_keys_state == evt::no_modifier_keys_were_down)	
						#
						motion = event_point - last_point;
					    fi;

				gt::DONE => if (mousebuttons_state  == evt::only_mouse_button_1_was_down
					    and modifier_keys_state == evt::no_modifier_keys_were_down)	
						#
						case *port
						    #
						    NULL =>
							{
							    ();
							};

						    THE app_to_arrowbutton
							=>
							{
							    relief = app_to_arrowbutton.get_button_relief ();
old_relief = relief;
							    relief = next_relief relief;
nb {. sprintf "make_grid_guiplan.arrowbutton_mouse_drag_fn: relief was %s, now %s"  (relief_to_string old_relief) (relief_to_string relief); };

							    app_to_arrowbutton.set_state_to         FALSE;				# Widget appearance depends on both 'state' and 'relief' settings; keep state FALSE for simplicity.
							    app_to_arrowbutton.set_button_relief_to relief;
							};
						esac; 
					    fi;

			    esac;
		    };


		guiplan
		  =
		  gt::FRAME
		    ( [],
		      ( gt::GRID
			  [
			    [ arrowbutton::with [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher1a,  ab::SITEWATCHER sitewatcher1a, ab::LEFT , ab::MOUSE_DRAG_FN (arrowbutton_mouse_drag_fn port1a),  ab::PIXELS_HIGH_MIN  0,  ab::PIXELS_WIDE_MIN  0,  ab::PIXELS_HIGH_CUT 1.0,  ab::PIXELS_WIDE_CUT 1.0,  ab::MARGIN 40,  ab::THICK 20  ],
			      arrowbutton::with [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher2a,  ab::SITEWATCHER sitewatcher2a, ab::UP   , ab::MOUSE_DRAG_FN (arrowbutton_mouse_drag_fn port2a),  ab::PIXELS_HIGH_MIN  0,  ab::PIXELS_WIDE_MIN 40,  ab::PIXELS_HIGH_CUT 1.0,  ab::PIXELS_WIDE_CUT 0.0 ]
			    ],
			    [ arrowbutton::with [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher1b,  ab::SITEWATCHER sitewatcher1b, ab::LEFT , ab::MOUSE_DRAG_FN (arrowbutton_mouse_drag_fn port1b),  ab::PIXELS_HIGH_MIN 40,  ab::PIXELS_WIDE_MIN  0,  ab::PIXELS_HIGH_CUT 0.0,  ab::PIXELS_WIDE_CUT 1.0 ],
			      arrowbutton::with [ ab::MOMENTARY_CONTACT, ab::PORTWATCHER portwatcher2b,  ab::SITEWATCHER sitewatcher2b, ab::UP   , ab::MOUSE_DRAG_FN (arrowbutton_mouse_drag_fn port2b),  ab::PIXELS_HIGH_MIN 40,  ab::PIXELS_WIDE_MIN 40,  ab::PIXELS_HIGH_CUT 0.0,  ab::PIXELS_WIDE_CUT 0.0 ]
			    ]
			  ]
		      )
		    );

		{ guiplan,

		  widget_sites =>     { site1a, site2a,
					site1b, site2b
				      },

		  read_back_sites_and_ports_of_grid_guiplan_widgets
		};
	    };													# fun make_grid_guiplan

	fun make_buttons_guiplan  ()
	      #
	      :	{ guiplan:		gt::Guiplan,
														# Here we return globals which wind up containing the window sites
														# assigned to our various widgets.  Normal application code never
														# needs to know this, but our test code needs this information in
														# order to synthesize fake mouseclicks etc on the buttons.
														#
		  widget_sites:   { site1a: Ref (Null_Or(g2d::Box)),						# Row one,   button one.
				    site2a: Ref (Null_Or(g2d::Box)),						# Row one,   button two.
				    site3a: Ref (Null_Or(g2d::Box)),						# Row one,   button three.
				    site4a: Ref (Null_Or(g2d::Box)),						# Row one,   button four.
														#
				    site1b: Ref (Null_Or(g2d::Box)),						# Row two,   button one.  
				    site2b: Ref (Null_Or(g2d::Box)),						# Row two,   button two.  
				    site3b: Ref (Null_Or(g2d::Box)),						# Row two,   button three.
				    site4b: Ref (Null_Or(g2d::Box)),						# Row two,   button four.
														#
				    site1c: Ref (Null_Or(g2d::Box)),						# Row three, button one.  
				    site2c: Ref (Null_Or(g2d::Box)),						# Row three, button two.  
				    site3c: Ref (Null_Or(g2d::Box)),						# Row three, button three.
				    site4c: Ref (Null_Or(g2d::Box)),						# Row three, button four.
														#
				    site1d: Ref (Null_Or(g2d::Box)),						# Row four,  button one.  
				    site2d: Ref (Null_Or(g2d::Box)),						# Row four,  button two.  
				    site3d: Ref (Null_Or(g2d::Box)),						# Row four,  button three.
				    site4d: Ref (Null_Or(g2d::Box))						# Row four,  button four.
				  },

		  read_back_sites_and_ports_of_buttons_guiplan_widgets:	Void -> Void				# Fills in values of widget_sites
		}
	    =
	    {
		stipulate
		    site1a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row one,   first  button, site notification mailqueue.
		    site2a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row one,   second button, site notification mailqueue.
		    site3a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row one,   third  button, site notification mailqueue.
		    site4a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row one,   fourth button, site notification mailqueue.
		    #												#
		    site1b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row two,   first  button, site notification mailqueue.
		    site2b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row two,   second button, site notification mailqueue.
		    site3b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row two,   third  button, site notification mailqueue.
		    site4b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row two,   fourth button, site notification mailqueue.
		    #												#
		    site1c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row three, first  button, site notification mailqueue.
		    site2c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row three, second button, site notification mailqueue.
		    site3c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row three, third  button, site notification mailqueue.
		    site4c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row three, fourth button, site notification mailqueue.
		    #												#
		    site1d' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row four,  first  button, site notification mailqueue.
		    site2d' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row four,  second button, site notification mailqueue.
		    site3d' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row four,  third  button, site notification mailqueue.
		    site4d' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row four,  fourth button, site notification mailqueue.
		herein														                                                     
														# These globals hold the values read from the above
														# mailops by the later do_one_mailop() calls.
														# They hold the sites (window locations) assigned to
														# our twelve pushbuttons. (We need this information
														# to generate fake mouseclicks on them for test
														# purposes. A normal GUI app wouldn't do this.) 
														#
		    site1a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button one.
		    site2a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button two.
		    site3a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button three.
		    site4a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button four.
		    #												#
		    site1b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button one.
		    site2b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button two.
		    site3b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button three.
		    site4b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button four.
		    #												#
		    site1c = REF (NULL: Null_Or(g2d::Box));							# Row three, button one.
		    site2c = REF (NULL: Null_Or(g2d::Box));							# Row three, button two.
		    site3c = REF (NULL: Null_Or(g2d::Box));							# Row three, button three.
		    site4c = REF (NULL: Null_Or(g2d::Box));							# Row three, button four.
		    #												#
		    site1d = REF (NULL: Null_Or(g2d::Box));							# Row four,  button one.
		    site2d = REF (NULL: Null_Or(g2d::Box));							# Row four,  button two.
		    site3d = REF (NULL: Null_Or(g2d::Box));							# Row four,  button three.
		    site4d = REF (NULL: Null_Or(g2d::Box));							# Row four,  button four.

														# These are the site-watcher callbacks we pass to the
														# guiboss layer to find out where our buttons are on
														# the window:
														#
		    fun sitewatcher1a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1a', site);		# Row one,   first  button, site notification callback.
		    fun sitewatcher2a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2a', site);		# Row one,   second button, site notification callback.
		    fun sitewatcher3a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site3a', site);		# Row one,   third  button, site notification callback.
		    fun sitewatcher4a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site4a', site);		# Row one,   fourth button, site notification callback.
		    #												#
		    fun sitewatcher1b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1b', site);		# Row two,   first  button, site notification callback.
		    fun sitewatcher2b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2b', site);		# Row two,   second button, site notification callback.
		    fun sitewatcher3b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site3b', site);		# Row two,   third  button, site notification callback.
		    fun sitewatcher4b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site4b', site);		# Row two,   fourth button, site notification callback.
		    #												#
		    fun sitewatcher1c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1c', site);		# Row three, first  button, site notification callback.
		    fun sitewatcher2c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2c', site);		# Row three, second button, site notification callback.
		    fun sitewatcher3c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site3c', site);		# Row three, third  button, site notification callback.
		    fun sitewatcher4c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site4c', site);		# Row three, fourth button, site notification callback.
		    #												#
		    fun sitewatcher1d (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1d', site);		# Row four,  first  button, site notification callback.
		    fun sitewatcher2d (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2d', site);		# Row four,  second button, site notification callback.
		    fun sitewatcher3d (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site3d', site);		# Row four,  third  button, site notification callback.
		    fun sitewatcher4d (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site4d', site);		# Row four,  fourth button, site notification callback.


		    fun read_back_sites_and_ports_of_buttons_guiplan_widgets ()					# Fill in the above globals via blocking reads.
			=											# We use timeouts (only) to recover gracefully if things are
			{											# somehow so broken that guiboss-imp never calls our callbacks.
														# The order shouldn't matter; here we go left-to-right top-to-bottom:

			    do_one_mailop [ take_from_mailqueue' site1a'	==> {. site1a := #site;			assert(TRUE);  },	# Row one,   button one.
					    timeout_in' 1.0		==> {. printf "no site1a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2a'	==> {. site2a := #site;			assert(TRUE);  },	# Row one,   button two.
					    timeout_in' 1.0		==> {. printf "no site2a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site3a'	==> {. site3a := #site;			assert(TRUE);  },	# Row one,   button three.
					    timeout_in' 1.0		==> {. printf "no site3a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site4a'	==> {. site4a := #site;			assert(TRUE);  },	# Row one,   button four.
					    timeout_in' 1.0		==> {. printf "no site4a in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1b'	==> {. site1b := #site;			assert(TRUE);  },	# Row two,   button one.
					    timeout_in' 1.0		==> {. printf "no site1b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2b'	==> {. site2b := #site;			assert(TRUE);  },	# Row two,   button two.
					    timeout_in' 1.0		==> {. printf "no site2b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site3b'	==> {. site3b := #site;			assert(TRUE);  },	# Row two,   button three.
					    timeout_in' 1.0		==> {. printf "no site3b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site4b'	==> {. site4b := #site;			assert(TRUE);  },	# Row two,   button four.
					    timeout_in' 1.0		==> {. printf "no site4b in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1c'	==> {. site1c := #site;			assert(TRUE);  },	# Row three, button one.
					    timeout_in' 1.0		==> {. printf "no site1c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2c'	==> {. site2c := #site;			assert(TRUE);  },	# Row three, button two.
					    timeout_in' 1.0		==> {. printf "no site2c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site3c'	==> {. site3c := #site;			assert(TRUE);  },	# Row three, button three.
					    timeout_in' 1.0		==> {. printf "no site3c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site4c'	==> {. site4c := #site;			assert(TRUE);  },	# Row three, button four.
					    timeout_in' 1.0		==> {. printf "no site4c in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1d'	==> {. site1d := #site;			assert(TRUE);  },	# Row four,  button one.
					    timeout_in' 1.0		==> {. printf "no site1d in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2d'	==> {. site2d := #site;			assert(TRUE);  },	# Row four,  button two.
					    timeout_in' 1.0		==> {. printf "no site2d in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site3d'	==> {. site3d := #site;			assert(TRUE);  },	# Row four,  button three.
					    timeout_in' 1.0		==> {. printf "no site3d in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site4d'	==> {. site4d := #site;			assert(TRUE);  },	# Row four,  button four.
					    timeout_in' 1.0		==> {. printf "no site4d in 1 sec!\n";	assert(FALSE); }
					  ];
			};
		end;

		on_image
		    =
		    mtx::make_rw_matrix ((rows, cols), yellow)
		    where
			rows   = 30;
			cols   = 30;
			yellow = r8::rgb8_yellow;
		    end;

		off_image
		    =
		    mtx::make_rw_matrix ((rows, cols), green)
		    where
			rows   = 30;
			cols   = 30;
			green  = r8::rgb8_green;
		    end;

		guiplan
		  =
		  gt::FRAME
		    ( [],
		      ( gt::GRID
			  [
			    [   arrowbutton::with [  ab::SITEWATCHER sitewatcher1a, ab::LEFT ,                                                                                          ab::PIXELS_HIGH_MIN  0,   ab::PIXELS_WIDE_MIN  0,   ab::PIXELS_HIGH_CUT 1.0,   ab::PIXELS_WIDE_CUT 1.0 ],
			             button::with [  bb::SITEWATCHER sitewatcher2a,                                                                                                     bb::PIXELS_HIGH_MIN  0,   bb::PIXELS_WIDE_MIN  0,   bb::PIXELS_HIGH_CUT 1.0,   bb::PIXELS_WIDE_CUT 1.0 ],
			           checkbox::with [  cb::SITEWATCHER sitewatcher3a,                                                                                                     cb::PIXELS_HIGH_MIN  0,   cb::PIXELS_WIDE_MIN  0,   cb::PIXELS_HIGH_CUT 1.0,   cb::PIXELS_WIDE_CUT 1.0 ],
			           checkbox::with [  cb::SITEWATCHER sitewatcher4a, cb::TEXT "fee", cb::ON_TEXT "FEE",                                                                  cb::PIXELS_HIGH_MIN  0,   cb::PIXELS_WIDE_MIN  0,   cb::PIXELS_HIGH_CUT 1.0,   cb::PIXELS_WIDE_CUT 1.0 ]
			    ],
			    [ diamondbutton::with [  db::SITEWATCHER sitewatcher1b, db::TEXT "bff", db::ON_TEXT "BFF",                                                                  db::PIXELS_HIGH_MIN  0,   db::PIXELS_WIDE_MIN  0,   db::PIXELS_HIGH_CUT 1.0,   db::PIXELS_WIDE_CUT 1.0 ],
			        roundbutton::with [  rb::SITEWATCHER sitewatcher2b, rb::TEXT "xyz",                                                                                     rb::PIXELS_HIGH_MIN  0,   rb::PIXELS_WIDE_MIN  0,   rb::PIXELS_HIGH_CUT 1.0,   rb::PIXELS_WIDE_CUT 1.0 ],
				      blank::with [ blk::SITEWATCHER sitewatcher3b,                                                                                                    blk::PIXELS_HIGH_MIN  0,  blk::PIXELS_WIDE_MIN  0,  blk::PIXELS_HIGH_CUT 1.0,  blk::PIXELS_WIDE_CUT 1.0 ],
			           checkbox::with [  cb::SITEWATCHER sitewatcher4b, cb::TEXT "fie", cb::ON_TEXT "FIE",                                                                  cb::PIXELS_HIGH_MIN  0,   cb::PIXELS_WIDE_MIN  0,   cb::PIXELS_HIGH_CUT 1.0,   cb::PIXELS_WIDE_CUT 1.0 ]
			    ],
			    [        button::with [  bb::SITEWATCHER sitewatcher1c, bb::ON_IMAGE on_image, bb::OFF_IMAGE off_image,                                                     bb::PIXELS_HIGH_MIN  0,   bb::PIXELS_WIDE_MIN  0,   bb::PIXELS_HIGH_CUT 1.0,   bb::PIXELS_WIDE_CUT 1.0 ],
			             button::with [  bb::SITEWATCHER sitewatcher2c, bb::ON_IMAGE on_image, bb::OFF_IMAGE off_image,  bb::ITALIC, bb::ON_TEXT "ON", bb::OFF_TEXT "OFF",  bb::PIXELS_HIGH_MIN  0,   bb::PIXELS_WIDE_MIN  0,   bb::PIXELS_HIGH_CUT 1.0,   bb::PIXELS_WIDE_CUT 1.0 ],
				     button::with [  bb::SITEWATCHER sitewatcher3c,                                                  bb::ITALIC, bb::ON_TEXT "ON", bb::OFF_TEXT "OFF",  bb::PIXELS_HIGH_MIN  0,   bb::PIXELS_WIDE_MIN  0,   bb::PIXELS_HIGH_CUT 1.0,   bb::PIXELS_WIDE_CUT 1.0 ],
			           checkbox::with [  cb::SITEWATCHER sitewatcher4c, cb::TEXT "foe", cb::ON_TEXT "FOE",                                                                  cb::PIXELS_HIGH_MIN  0,   cb::PIXELS_WIDE_MIN  0,   cb::PIXELS_HIGH_CUT 1.0,   cb::PIXELS_WIDE_CUT 1.0 ]
			    ],
			    [         blank::with [ blk::SITEWATCHER sitewatcher1d,                                                                                                    blk::PIXELS_HIGH_MIN  0,  blk::PIXELS_WIDE_MIN  0,  blk::PIXELS_HIGH_CUT 1.0,  blk::PIXELS_WIDE_CUT 1.0 ],
				        his::with [ his::SITEWATCHER sitewatcher2d,                                                                                                    his::PIXELS_HIGH_MIN  0,  his::PIXELS_WIDE_MIN  0,  his::PIXELS_HIGH_CUT 1.0,  his::PIXELS_WIDE_CUT 1.0 ],
				      blank::with [ blk::SITEWATCHER sitewatcher3d,                                                                                                    blk::PIXELS_HIGH_MIN  0,  blk::PIXELS_WIDE_MIN  0,  blk::PIXELS_HIGH_CUT 1.0,  blk::PIXELS_WIDE_CUT 1.0 ],
			           checkbox::with [  cb::SITEWATCHER sitewatcher4d, cb::TEXT "fum", cb::ON_TEXT "FUM",                                                                  cb::PIXELS_HIGH_MIN  0,   cb::PIXELS_WIDE_MIN  0,   cb::PIXELS_HIGH_CUT 1.0,   cb::PIXELS_WIDE_CUT 1.0 ]
			    ]
			  ]
		      )
		    );

		{ guiplan,

		  widget_sites =>     { site1a, site2a, site3a, site4a,
					site1b, site2b, site3b, site4b,
					site1c, site2c, site3c, site4c,
					site1d, site2d, site3d, site4d
				      },

		  read_back_sites_and_ports_of_buttons_guiplan_widgets
		};
	    };													# fun make_buttons_guiplan

	fun make_hsliders_guiplan  ()
	      #
	      :	{ guiplan:		gt::Guiplan,
														# Here we return globals which wind up containing the window sites
														# assigned to our various widgets.  Normal application code never
														# needs to know this, but our test code needs this information in
														# order to synthesize fake mouseclicks etc on the buttons.
														#
		  widget_sites:   { site1a: Ref (Null_Or(g2d::Box)),						# Row one,   button one.
				    site2a: Ref (Null_Or(g2d::Box)),						# Row one,   button two.
														#
				    site1b: Ref (Null_Or(g2d::Box)),						# Row two,   button one.  
				    site2b: Ref (Null_Or(g2d::Box)),						# Row two,   button two.  
														#
				    site1c: Ref (Null_Or(g2d::Box)),						# Row three, button one.  
				    site2c: Ref (Null_Or(g2d::Box)),						# Row three, button two.  
														#
				    site1d: Ref (Null_Or(g2d::Box)),						# Row four,  button one.  
				    site2d: Ref (Null_Or(g2d::Box)),						# Row four,  button two.  
														#
				    site1e: Ref (Null_Or(g2d::Box)),						# Row five,  button one.
				    site2e: Ref (Null_Or(g2d::Box)),						# Row five,  button two.  
														#
				    site1f: Ref (Null_Or(g2d::Box)),						# Row six,   button one.  
				    site2f: Ref (Null_Or(g2d::Box)),						# Row six,   button two.  
														#
				    site1g: Ref (Null_Or(g2d::Box)),						# Row seven, button one.  
				    site2g: Ref (Null_Or(g2d::Box)),						# Row seven, button two.  
														#
				    site1h: Ref (Null_Or(g2d::Box)),						# Row eight, button one.  
				    site2h: Ref (Null_Or(g2d::Box))						# Row eight, button two.  
				  },

		  read_back_sites_and_ports_of_hsliders:	Void -> Void					# Fills in values of widget_sites
		}
	    =
	    {
		stipulate
		    site1a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row one,   first  button, site notification mailqueue.
		    site2a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row one,   second button, site notification mailqueue.
		    #												#
		    site1b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row two,   first  button, site notification mailqueue.
		    site2b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row two,   second button, site notification mailqueue.
		    #												#
		    site1c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row three, first  button, site notification mailqueue.
		    site2c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row three, second button, site notification mailqueue.
		    #												#
		    site1d' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row four,  first  button, site notification mailqueue.
		    site2d' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row four,  second button, site notification mailqueue.
		    #												#
		    site1e' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row five,  first  button, site notification mailqueue.
		    site2e' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row five,  second button, site notification mailqueue.
		    #												#
		    site1f' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row six,   first  button, site notification mailqueue.
		    site2f' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row six,   second button, site notification mailqueue.
		    #												#
		    site1g' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row seven, first  button, site notification mailqueue.
		    site2g' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row seven, second button, site notification mailqueue.
		    #												#
		    site1h' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row eight, first  button, site notification mailqueue.
		    site2h' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row eight, second button, site notification mailqueue.
		herein														                                                     
														# These globals hold the values read from the above
														# mailops by the later do_one_mailop() calls.
														# They hold the sites (window locations) assigned to
														# our twelve pushbuttons. (We need this information
														# to generate fake mouseclicks on them for test
														# purposes. A normal GUI app wouldn't do this.) 
														#
		    site1a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button one.
		    site2a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button two.
		    #												#
		    site1b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button one.
		    site2b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button two.
		    #												#
		    site1c = REF (NULL: Null_Or(g2d::Box));							# Row three, button one.
		    site2c = REF (NULL: Null_Or(g2d::Box));							# Row three, button two.
		    #												#
		    site1d = REF (NULL: Null_Or(g2d::Box));							# Row four,  button one.
		    site2d = REF (NULL: Null_Or(g2d::Box));							# Row four,  button two.
		    #												#
		    site1e = REF (NULL: Null_Or(g2d::Box));							# Row five,  button one.
		    site2e = REF (NULL: Null_Or(g2d::Box));							# Row five,  button two.
		    #												#
		    site1f = REF (NULL: Null_Or(g2d::Box));							# Row six,   button one.
		    site2f = REF (NULL: Null_Or(g2d::Box));							# Row six,   button two.
		    #												#
		    site1g = REF (NULL: Null_Or(g2d::Box));							# Row seven, button one.
		    site2g = REF (NULL: Null_Or(g2d::Box));							# Row seven, button two.
		    #												#
		    site1h = REF (NULL: Null_Or(g2d::Box));							# Row eight, button one.
		    site2h = REF (NULL: Null_Or(g2d::Box));							# Row eight, button two.

														# These are the site-watcher callbacks we pass to the
														# guiboss layer to find out where our buttons are on
														# the window:
														#
		    fun sitewatcher1a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1a', site);		# Row one,   first  button, site notification callback.
		    fun sitewatcher2a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2a', site);		# Row one,   second button, site notification callback.
		    #												#
		    fun sitewatcher1b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1b', site);		# Row two,   first  button, site notification callback.
		    fun sitewatcher2b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2b', site);		# Row two,   second button, site notification callback.
		    #												#
		    fun sitewatcher1c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1c', site);		# Row three, first  button, site notification callback.
		    fun sitewatcher2c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2c', site);		# Row three, second button, site notification callback.
		    #												#
		    fun sitewatcher1d (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1d', site);		# Row four,  first  button, site notification callback.
		    fun sitewatcher2d (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2d', site);		# Row four,  second button, site notification callback.
		    #												#
		    fun sitewatcher1e (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1e', site);		# Row five,  first  button, site notification callback.
		    fun sitewatcher2e (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2e', site);		# Row five,  second button, site notification callback.
		    #												#
		    fun sitewatcher1f (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1f', site);		# Row six,   first  button, site notification callback.
		    fun sitewatcher2f (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2f', site);		# Row six,   second button, site notification callback.
		    #												#
		    fun sitewatcher1g (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1g', site);		# Row seven, first  button, site notification callback.
		    fun sitewatcher2g (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2g', site);		# Row seven, second button, site notification callback.
		    #												#
		    fun sitewatcher1h (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1h', site);		# Row eight, first  button, site notification callback.
		    fun sitewatcher2h (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2h', site);		# Row eight, second button, site notification callback.


		    fun read_back_sites_and_ports_of_hsliders ()						# Fill in the above globals via blocking reads.
			=											# We use timeouts (only) to recover gracefully if things are
			{											# somehow so broken that guiboss-imp never calls our callbacks.
														# The order shouldn't matter; here we go left-to-right top-to-bottom:

			    do_one_mailop [ take_from_mailqueue' site1a'	==> {. site1a := #site;			assert(TRUE);  },	# Row one,   button one.
					    timeout_in' 1.0		==> {. printf "no site1a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2a'	==> {. site2a := #site;			assert(TRUE);  },	# Row one,   button two.
					    timeout_in' 1.0		==> {. printf "no site2a in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1b'	==> {. site1b := #site;			assert(TRUE);  },	# Row two,   button one.
					    timeout_in' 1.0		==> {. printf "no site1b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2b'	==> {. site2b := #site;			assert(TRUE);  },	# Row two,   button two.
					    timeout_in' 1.0		==> {. printf "no site2b in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1c'	==> {. site1c := #site;			assert(TRUE);  },	# Row three, button one.
					    timeout_in' 1.0		==> {. printf "no site1c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2c'	==> {. site2c := #site;			assert(TRUE);  },	# Row three, button two.
					    timeout_in' 1.0		==> {. printf "no site2c in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1d'	==> {. site1d := #site;			assert(TRUE);  },	# Row four,  button one.
					    timeout_in' 1.0		==> {. printf "no site1d in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2d'	==> {. site2d := #site;			assert(TRUE);  },	# Row four,  button two.
					    timeout_in' 1.0		==> {. printf "no site2d in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1e'	==> {. site1e := #site;			assert(TRUE);  },	# Row five,  button one.
					    timeout_in' 1.0		==> {. printf "no site1e in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2e'	==> {. site2e := #site;			assert(TRUE);  },	# Row five,  button two.
					    timeout_in' 1.0		==> {. printf "no site2e in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1f'	==> {. site1f := #site;			assert(TRUE);  },	# Row six,   button one.
					    timeout_in' 1.0		==> {. printf "no site1f in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2f'	==> {. site2f := #site;			assert(TRUE);  },	# Row six,   button two.
					    timeout_in' 1.0		==> {. printf "no site2f in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1g'	==> {. site1g := #site;			assert(TRUE);  },	# Row seven, button one.
					    timeout_in' 1.0		==> {. printf "no site1g in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2g'	==> {. site2g := #site;			assert(TRUE);  },	# Row seven, button two.
					    timeout_in' 1.0		==> {. printf "no site2g in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1h'	==> {. site1h := #site;			assert(TRUE);  },	# Row eight, button one.
					    timeout_in' 1.0		==> {. printf "no site1h in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2h'	==> {. site2h := #site;			assert(TRUE);  },	# Row eight, button two.
					    timeout_in' 1.0		==> {. printf "no site2h in 1 sec!\n";	assert(FALSE); }
					  ];
			};
		end;


		on_image
		    =
		    mtx::make_rw_matrix ((rows, cols), yellow)
		    where
			rows   = 30;
			cols   = 30;
			yellow = r8::rgb8_yellow;
		    end;

		off_image
		    =
		    mtx::make_rw_matrix ((rows, cols), green)
		    where
			rows   = 30;
			cols   = 30;
			green  = r8::rgb8_green;
		    end;

		guiplan
		  =
		  gt::FRAME
		    ( [],
		      ( gt::GRID
			  [
			    [ hflider::with [ hfs::SITEWATCHER sitewatcher1a,  hfs::TEXT "red",   hfs::LOWER_LIMIT 0.0, hfs::UPPER_LIMIT 1.0,  hfs::INITIAL_VALUE 0.5, hfs::PIXELS_HIGH_MIN  0,  hfs::PIXELS_WIDE_MIN  0,  hfs::PIXELS_HIGH_CUT 1.0,  hfs::PIXELS_WIDE_CUT 1.0 ],
			      hflider::with [ hfs::SITEWATCHER sitewatcher2a,  		    	  hfs::LOWER_LIMIT 0.0, hfs::UPPER_LIMIT 1.0,  hfs::INITIAL_VALUE 0.5, hfs::PIXELS_HIGH_MIN  0,  hfs::PIXELS_WIDE_MIN  0,  hfs::PIXELS_HIGH_CUT 1.0,  hfs::PIXELS_WIDE_CUT 1.0 ]
			    ],
			    [ hflider::with [ hfs::SITEWATCHER sitewatcher1b,  hfs::TEXT "green", hfs::LOWER_LIMIT 0.0, hfs::UPPER_LIMIT 1.0,  hfs::INITIAL_VALUE 0.5, hfs::PIXELS_HIGH_MIN  0,  hfs::PIXELS_WIDE_MIN  0,  hfs::PIXELS_HIGH_CUT 1.0,  hfs::PIXELS_WIDE_CUT 1.0, hfs::SHOW_LIMITS FALSE, hfs::SHOW_VALUE FALSE, hfs::COVERAGE 0.3 ],
			      hflider::with [ hfs::SITEWATCHER sitewatcher2b,  		    	  hfs::LOWER_LIMIT 0.0, hfs::UPPER_LIMIT 1.0,  hfs::INITIAL_VALUE 0.5, hfs::PIXELS_HIGH_MIN  0,  hfs::PIXELS_WIDE_MIN  0,  hfs::PIXELS_HIGH_CUT 1.0,  hfs::PIXELS_WIDE_CUT 1.0, hfs::SHOW_LIMITS FALSE, hfs::SHOW_VALUE FALSE, hfs::COVERAGE 0.3 ]
			    ],
			    [ hflider::with [ hfs::SITEWATCHER sitewatcher1c,  hfs::TEXT "blue",  hfs::LOWER_LIMIT 0.0, hfs::UPPER_LIMIT 1.0,  hfs::INITIAL_VALUE 0.5, hfs::PIXELS_HIGH_MIN  0,  hfs::PIXELS_WIDE_MIN  0,  hfs::PIXELS_HIGH_CUT 1.0,  hfs::PIXELS_WIDE_CUT 1.0 ],
			      hflider::with [ hfs::SITEWATCHER sitewatcher2c,  		 	  hfs::LOWER_LIMIT 0.0, hfs::UPPER_LIMIT 1.0,  hfs::INITIAL_VALUE 0.5, hfs::PIXELS_HIGH_MIN  0,  hfs::PIXELS_WIDE_MIN  0,  hfs::PIXELS_HIGH_CUT 1.0,  hfs::PIXELS_WIDE_CUT 1.0 ]
			    ],
			    [ hflider::with [ hfs::SITEWATCHER sitewatcher1d,  hfs::TEXT "alpha", hfs::LOWER_LIMIT 0.0, hfs::UPPER_LIMIT 1.0,  hfs::INITIAL_VALUE 0.5, hfs::PIXELS_HIGH_MIN  0,  hfs::PIXELS_WIDE_MIN  0,  hfs::PIXELS_HIGH_CUT 1.0,  hfs::PIXELS_WIDE_CUT 1.0 ],
			      hflider::with [ hfs::SITEWATCHER sitewatcher2d,  			  hfs::LOWER_LIMIT 0.0, hfs::UPPER_LIMIT 1.0,  hfs::INITIAL_VALUE 0.5, hfs::PIXELS_HIGH_MIN  0,  hfs::PIXELS_WIDE_MIN  0,  hfs::PIXELS_HIGH_CUT 1.0,  hfs::PIXELS_WIDE_CUT 1.0 ]
			    ],

			    [ hslider::with [ his::SITEWATCHER sitewatcher1e,  his::TEXT "red",   his::LOWER_LIMIT 0,   his::UPPER_LIMIT 1000, his::INITIAL_VALUE 500, his::PIXELS_HIGH_MIN  0,  his::PIXELS_WIDE_MIN  0,  his::PIXELS_HIGH_CUT 1.0,  his::PIXELS_WIDE_CUT 1.0 ],
			      hslider::with [ his::SITEWATCHER sitewatcher2e,  			  his::LOWER_LIMIT 0,   his::UPPER_LIMIT 1000, his::INITIAL_VALUE 500, his::PIXELS_HIGH_MIN  0,  his::PIXELS_WIDE_MIN  0,  his::PIXELS_HIGH_CUT 1.0,  his::PIXELS_WIDE_CUT 1.0 ]
			    ],
			    [ hslider::with [ his::SITEWATCHER sitewatcher1f,  his::TEXT "green", his::LOWER_LIMIT 0,   his::UPPER_LIMIT 1000, his::INITIAL_VALUE 500, his::PIXELS_HIGH_MIN  0,  his::PIXELS_WIDE_MIN  0,  his::PIXELS_HIGH_CUT 1.0,  his::PIXELS_WIDE_CUT 1.0, his::SHOW_LIMITS FALSE, his::SHOW_VALUE FALSE, his::COVERAGE 0.3 ],
			      hslider::with [ his::SITEWATCHER sitewatcher2f,  		 	  his::LOWER_LIMIT 0,   his::UPPER_LIMIT 1000, his::INITIAL_VALUE 500, his::PIXELS_HIGH_MIN  0,  his::PIXELS_WIDE_MIN  0,  his::PIXELS_HIGH_CUT 1.0,  his::PIXELS_WIDE_CUT 1.0, his::SHOW_LIMITS FALSE, his::SHOW_VALUE FALSE, his::COVERAGE 0.3 ]
			    ],
			    [ hslider::with [ his::SITEWATCHER sitewatcher1g,  his::TEXT "blue",  his::LOWER_LIMIT 0,   his::UPPER_LIMIT 1000, his::INITIAL_VALUE 500, his::PIXELS_HIGH_MIN  0,  his::PIXELS_WIDE_MIN  0,  his::PIXELS_HIGH_CUT 1.0,  his::PIXELS_WIDE_CUT 1.0 ],
			      hslider::with [ his::SITEWATCHER sitewatcher2g,  			  his::LOWER_LIMIT 0,   his::UPPER_LIMIT 1000, his::INITIAL_VALUE 500, his::PIXELS_HIGH_MIN  0,  his::PIXELS_WIDE_MIN  0,  his::PIXELS_HIGH_CUT 1.0,  his::PIXELS_WIDE_CUT 1.0 ]
			    ],
			    [ hslider::with [ his::SITEWATCHER sitewatcher1h,  his::TEXT "alpha", his::LOWER_LIMIT 0,   his::UPPER_LIMIT 1000, his::INITIAL_VALUE 500, his::PIXELS_HIGH_MIN  0,  his::PIXELS_WIDE_MIN  0,  his::PIXELS_HIGH_CUT 1.0,  his::PIXELS_WIDE_CUT 1.0 ],
			      hslider::with [ his::SITEWATCHER sitewatcher2h,  			  his::LOWER_LIMIT 0,   his::UPPER_LIMIT 1000, his::INITIAL_VALUE 500, his::PIXELS_HIGH_MIN  0,  his::PIXELS_WIDE_MIN  0,  his::PIXELS_HIGH_CUT 1.0,  his::PIXELS_WIDE_CUT 1.0 ]
			    ]
			  ]
		      )
		    );

		{ guiplan,

		  widget_sites =>     { site1a, site2a,
					site1b, site2b,
					site1c, site2c,
				     	site1d, site2d,
				     	site1e, site2e,
				     	site1f, site2f,
				     	site1g, site2g,
				     	site1h, site2h
				      },

		  read_back_sites_and_ports_of_hsliders
		};
	    };																	# fun make_hsliders_guiplan

	fun make_vsliders_guiplan  ()
	      #
	      :	{ guiplan:		gt::Guiplan,
														# Here we return globals which wind up containing the window sites
														# assigned to our various widgets.  Normal application code never
														# needs to know this, but our test code needs this information in
														# order to synthesize fake mouseclicks etc on the buttons.
														#
		  widget_sites:   { site1a: Ref (Null_Or(g2d::Box)),						# Row one,   button one.
				    site2a: Ref (Null_Or(g2d::Box)),						# Row one,   button two.
														#
				    site1b: Ref (Null_Or(g2d::Box)),						# Row two,   button one.  
				    site2b: Ref (Null_Or(g2d::Box)),						# Row two,   button two.  
														#
				    site1c: Ref (Null_Or(g2d::Box)),						# Row three, button one.  
				    site2c: Ref (Null_Or(g2d::Box)),						# Row three, button two.  
														#
				    site1d: Ref (Null_Or(g2d::Box)),						# Row four,  button one.  
				    site2d: Ref (Null_Or(g2d::Box)),						# Row four,  button two.  
														#
				    site1e: Ref (Null_Or(g2d::Box)),						# Row five,  button one.
				    site2e: Ref (Null_Or(g2d::Box)),						# Row five,  button two.  
														#
				    site1f: Ref (Null_Or(g2d::Box)),						# Row six,   button one.  
				    site2f: Ref (Null_Or(g2d::Box)),						# Row six,   button two.  
														#
				    site1g: Ref (Null_Or(g2d::Box)),						# Row seven, button one.  
				    site2g: Ref (Null_Or(g2d::Box)),						# Row seven, button two.  
														#
				    site1h: Ref (Null_Or(g2d::Box)),						# Row eight, button one.  
				    site2h: Ref (Null_Or(g2d::Box))						# Row eight, button two.  
				  },

		  read_back_sites_and_ports_of_vsliders:	Void -> Void					# Fills in values of widget_sites
		}
	    =
	    {
		stipulate
		    site1a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row one,   first  button, site notification mailqueue.
		    site2a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row one,   second button, site notification mailqueue.
		    #												#
		    site1b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row two,   first  button, site notification mailqueue.
		    site2b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row two,   second button, site notification mailqueue.
		    #												#
		    site1c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row three, first  button, site notification mailqueue.
		    site2c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row three, second button, site notification mailqueue.
		    #												#
		    site1d' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row four,  first  button, site notification mailqueue.
		    site2d' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row four,  second button, site notification mailqueue.
		    #												#
		    site1e' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row five,  first  button, site notification mailqueue.
		    site2e' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row five,  second button, site notification mailqueue.
		    #												#
		    site1f' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row six,   first  button, site notification mailqueue.
		    site2f' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row six,   second button, site notification mailqueue.
		    #												#
		    site1g' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row seven, first  button, site notification mailqueue.
		    site2g' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row seven, second button, site notification mailqueue.
		    #												#
		    site1h' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row eight, first  button, site notification mailqueue.
		    site2h' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row eight, second button, site notification mailqueue.
		herein														                                                     
														# These globals hold the values read from the above
														# mailops by the later do_one_mailop() calls.
														# They hold the sites (window locations) assigned to
														# our twelve pushbuttons. (We need this information
														# to generate fake mouseclicks on them for test
														# purposes. A normal GUI app wouldn't do this.) 
														#
		    site1a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button one.
		    site2a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button two.
		    #												#
		    site1b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button one.
		    site2b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button two.
		    #												#
		    site1c = REF (NULL: Null_Or(g2d::Box));							# Row three, button one.
		    site2c = REF (NULL: Null_Or(g2d::Box));							# Row three, button two.
		    #												#
		    site1d = REF (NULL: Null_Or(g2d::Box));							# Row four,  button one.
		    site2d = REF (NULL: Null_Or(g2d::Box));							# Row four,  button two.
		    #												#
		    site1e = REF (NULL: Null_Or(g2d::Box));							# Row five,  button one.
		    site2e = REF (NULL: Null_Or(g2d::Box));							# Row five,  button two.
		    #												#
		    site1f = REF (NULL: Null_Or(g2d::Box));							# Row six,   button one.
		    site2f = REF (NULL: Null_Or(g2d::Box));							# Row six,   button two.
		    #												#
		    site1g = REF (NULL: Null_Or(g2d::Box));							# Row seven, button one.
		    site2g = REF (NULL: Null_Or(g2d::Box));							# Row seven, button two.
		    #												#
		    site1h = REF (NULL: Null_Or(g2d::Box));							# Row eight, button one.
		    site2h = REF (NULL: Null_Or(g2d::Box));							# Row eight, button two.

														# These are the site-watcher callbacks we pass to the
														# guiboss layer to find out where our buttons are on
														# the window:
														#
		    fun sitewatcher1a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1a', site);		# Row one,   first  button, site notification callback.
		    fun sitewatcher2a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2a', site);		# Row one,   second button, site notification callback.
		    #												#
		    fun sitewatcher1b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1b', site);		# Row two,   first  button, site notification callback.
		    fun sitewatcher2b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2b', site);		# Row two,   second button, site notification callback.
		    #												#
		    fun sitewatcher1c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1c', site);		# Row three, first  button, site notification callback.
		    fun sitewatcher2c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2c', site);		# Row three, second button, site notification callback.
		    #												#
		    fun sitewatcher1d (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1d', site);		# Row four,  first  button, site notification callback.
		    fun sitewatcher2d (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2d', site);		# Row four,  second button, site notification callback.
		    #												#
		    fun sitewatcher1e (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1e', site);		# Row five,  first  button, site notification callback.
		    fun sitewatcher2e (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2e', site);		# Row five,  second button, site notification callback.
		    #												#
		    fun sitewatcher1f (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1f', site);		# Row six,   first  button, site notification callback.
		    fun sitewatcher2f (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2f', site);		# Row six,   second button, site notification callback.
		    #												#
		    fun sitewatcher1g (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1g', site);		# Row seven, first  button, site notification callback.
		    fun sitewatcher2g (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2g', site);		# Row seven, second button, site notification callback.
		    #												#
		    fun sitewatcher1h (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1h', site);		# Row eight, first  button, site notification callback.
		    fun sitewatcher2h (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2h', site);		# Row eight, second button, site notification callback.


		    fun read_back_sites_and_ports_of_vsliders ()						# Fill in the above globals via blocking reads.
			=											# We use timeouts (only) to recover gracefully if things are
			{											# somehow so broken that guiboss-imp never calls our callbacks.
														# The order shouldn't matter; here we go left-to-right top-to-bottom:

			    do_one_mailop [ take_from_mailqueue' site1a'	==> {. site1a := #site;			assert(TRUE);  },	# Row one,   button one.
					    timeout_in' 1.0		==> {. printf "no site1a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2a'	==> {. site2a := #site;			assert(TRUE);  },	# Row one,   button two.
					    timeout_in' 1.0		==> {. printf "no site2a in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1b'	==> {. site1b := #site;			assert(TRUE);  },	# Row two,   button one.
					    timeout_in' 1.0		==> {. printf "no site1b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2b'	==> {. site2b := #site;			assert(TRUE);  },	# Row two,   button two.
					    timeout_in' 1.0		==> {. printf "no site2b in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1c'	==> {. site1c := #site;			assert(TRUE);  },	# Row three, button one.
					    timeout_in' 1.0		==> {. printf "no site1c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2c'	==> {. site2c := #site;			assert(TRUE);  },	# Row three, button two.
					    timeout_in' 1.0		==> {. printf "no site2c in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1d'	==> {. site1d := #site;			assert(TRUE);  },	# Row four,  button one.
					    timeout_in' 1.0		==> {. printf "no site1d in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2d'	==> {. site2d := #site;			assert(TRUE);  },	# Row four,  button two.
					    timeout_in' 1.0		==> {. printf "no site2d in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1e'	==> {. site1e := #site;			assert(TRUE);  },	# Row five,  button one.
					    timeout_in' 1.0		==> {. printf "no site1e in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2e'	==> {. site2e := #site;			assert(TRUE);  },	# Row five,  button two.
					    timeout_in' 1.0		==> {. printf "no site2e in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1f'	==> {. site1f := #site;			assert(TRUE);  },	# Row six,   button one.
					    timeout_in' 1.0		==> {. printf "no site1f in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2f'	==> {. site2f := #site;			assert(TRUE);  },	# Row six,   button two.
					    timeout_in' 1.0		==> {. printf "no site2f in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1g'	==> {. site1g := #site;			assert(TRUE);  },	# Row seven, button one.
					    timeout_in' 1.0		==> {. printf "no site1g in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2g'	==> {. site2g := #site;			assert(TRUE);  },	# Row seven, button two.
					    timeout_in' 1.0		==> {. printf "no site2g in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1h'	==> {. site1h := #site;			assert(TRUE);  },	# Row eight, button one.
					    timeout_in' 1.0		==> {. printf "no site1h in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2h'	==> {. site2h := #site;			assert(TRUE);  },	# Row eight, button two.
					    timeout_in' 1.0		==> {. printf "no site2h in 1 sec!\n";	assert(FALSE); }
					  ];
			};
		end;


		on_image
		    =
		    mtx::make_rw_matrix ((rows, cols), yellow)
		    where
			rows   = 30;
			cols   = 30;
			yellow = r8::rgb8_yellow;
		    end;

		off_image
		    =
		    mtx::make_rw_matrix ((rows, cols), green)
		    where
			rows   = 30;
			cols   = 30;
			green  = r8::rgb8_green;
		    end;

		guiplan
		  =
		  gt::FRAME
		    ( [],
		      ( gt::GRID
			  [
			    [ vflider::with [ vfs::SITEWATCHER sitewatcher1a,  vfs::TEXT "red",   vfs::LOWER_LIMIT 0.0, vfs::UPPER_LIMIT 1.0,  vfs::INITIAL_VALUE 0.5, vfs::PIXELS_HIGH_MIN  0,  vfs::PIXELS_WIDE_MIN  0,  vfs::PIXELS_HIGH_CUT 1.0,  vfs::PIXELS_WIDE_CUT 1.0 ],
			      vflider::with [ vfs::SITEWATCHER sitewatcher2a,  vfs::TEXT "green", vfs::LOWER_LIMIT 0.0, vfs::UPPER_LIMIT 1.0,  vfs::INITIAL_VALUE 0.5, vfs::PIXELS_HIGH_MIN  0,  vfs::PIXELS_WIDE_MIN  0,  vfs::PIXELS_HIGH_CUT 1.0,  vfs::PIXELS_WIDE_CUT 1.0, vfs::SHOW_LIMITS FALSE, vfs::SHOW_VALUE FALSE, vfs::COVERAGE 0.3 ],
			      vflider::with [ vfs::SITEWATCHER sitewatcher1b,  vfs::TEXT "blue",  vfs::LOWER_LIMIT 0.0, vfs::UPPER_LIMIT 1.0,  vfs::INITIAL_VALUE 0.5, vfs::PIXELS_HIGH_MIN  0,  vfs::PIXELS_WIDE_MIN  0,  vfs::PIXELS_HIGH_CUT 1.0,  vfs::PIXELS_WIDE_CUT 1.0 ],
			      vflider::with [ vfs::SITEWATCHER sitewatcher2b,  vfs::TEXT "alpha", vfs::LOWER_LIMIT 0.0, vfs::UPPER_LIMIT 1.0,  vfs::INITIAL_VALUE 0.5, vfs::PIXELS_HIGH_MIN  0,  vfs::PIXELS_WIDE_MIN  0,  vfs::PIXELS_HIGH_CUT 1.0,  vfs::PIXELS_WIDE_CUT 1.0 ]
			    ],
			    [ vflider::with [ vfs::SITEWATCHER sitewatcher1c,    		  vfs::LOWER_LIMIT 0.0, vfs::UPPER_LIMIT 1.0,  vfs::INITIAL_VALUE 0.5, vfs::PIXELS_HIGH_MIN  0,  vfs::PIXELS_WIDE_MIN  0,  vfs::PIXELS_HIGH_CUT 1.0,  vfs::PIXELS_WIDE_CUT 1.0 ],
			      vflider::with [ vfs::SITEWATCHER sitewatcher2c,  		   	  vfs::LOWER_LIMIT 0.0, vfs::UPPER_LIMIT 1.0,  vfs::INITIAL_VALUE 0.5, vfs::PIXELS_HIGH_MIN  0,  vfs::PIXELS_WIDE_MIN  0,  vfs::PIXELS_HIGH_CUT 1.0,  vfs::PIXELS_WIDE_CUT 1.0, vfs::SHOW_LIMITS FALSE, vfs::SHOW_VALUE FALSE, vfs::COVERAGE 0.3 ],
			      vflider::with [ vfs::SITEWATCHER sitewatcher1d,   		  vfs::LOWER_LIMIT 0.0, vfs::UPPER_LIMIT 1.0,  vfs::INITIAL_VALUE 0.5, vfs::PIXELS_HIGH_MIN  0,  vfs::PIXELS_WIDE_MIN  0,  vfs::PIXELS_HIGH_CUT 1.0,  vfs::PIXELS_WIDE_CUT 1.0 ],
			      vflider::with [ vfs::SITEWATCHER sitewatcher2d,  		          vfs::LOWER_LIMIT 0.0, vfs::UPPER_LIMIT 1.0,  vfs::INITIAL_VALUE 0.5, vfs::PIXELS_HIGH_MIN  0,  vfs::PIXELS_WIDE_MIN  0,  vfs::PIXELS_HIGH_CUT 1.0,  vfs::PIXELS_WIDE_CUT 1.0 ]
			    ],

			    [ vslider::with [ vis::SITEWATCHER sitewatcher1e,  vis::TEXT "red",   vis::LOWER_LIMIT 0,   vis::UPPER_LIMIT 1000, vis::INITIAL_VALUE 500, vis::PIXELS_HIGH_MIN  0,  vis::PIXELS_WIDE_MIN  0,  vis::PIXELS_HIGH_CUT 1.0,  vis::PIXELS_WIDE_CUT 1.0 ],
			      vslider::with [ vis::SITEWATCHER sitewatcher2e,  vis::TEXT "green", vis::LOWER_LIMIT 0,   vis::UPPER_LIMIT 1000, vis::INITIAL_VALUE 500, vis::PIXELS_HIGH_MIN  0,  vis::PIXELS_WIDE_MIN  0,  vis::PIXELS_HIGH_CUT 1.0,  vis::PIXELS_WIDE_CUT 1.0, vis::SHOW_LIMITS FALSE, vis::SHOW_VALUE FALSE, vis::COVERAGE 0.3 ],
			      vslider::with [ vis::SITEWATCHER sitewatcher1f,  vis::TEXT "blue",  vis::LOWER_LIMIT 0,   vis::UPPER_LIMIT 1000, vis::INITIAL_VALUE 500, vis::PIXELS_HIGH_MIN  0,  vis::PIXELS_WIDE_MIN  0,  vis::PIXELS_HIGH_CUT 1.0,  vis::PIXELS_WIDE_CUT 1.0 ],
			      vslider::with [ vis::SITEWATCHER sitewatcher2f,  vis::TEXT "alpha", vis::LOWER_LIMIT 0,   vis::UPPER_LIMIT 1000, vis::INITIAL_VALUE 500, vis::PIXELS_HIGH_MIN  0,  vis::PIXELS_WIDE_MIN  0,  vis::PIXELS_HIGH_CUT 1.0,  vis::PIXELS_WIDE_CUT 1.0 ]
			    ],
			    [ vslider::with [ vis::SITEWATCHER sitewatcher1g,                     vis::LOWER_LIMIT 0,   vis::UPPER_LIMIT 1000, vis::INITIAL_VALUE 500, vis::PIXELS_HIGH_MIN  0,  vis::PIXELS_WIDE_MIN  0,  vis::PIXELS_HIGH_CUT 1.0,  vis::PIXELS_WIDE_CUT 1.0 ],
			      vslider::with [ vis::SITEWATCHER sitewatcher2g,  		          vis::LOWER_LIMIT 0,   vis::UPPER_LIMIT 1000, vis::INITIAL_VALUE 500, vis::PIXELS_HIGH_MIN  0,  vis::PIXELS_WIDE_MIN  0,  vis::PIXELS_HIGH_CUT 1.0,  vis::PIXELS_WIDE_CUT 1.0, vis::SHOW_LIMITS FALSE, vis::SHOW_VALUE FALSE, vis::COVERAGE 0.3 ],
			      vslider::with [ vis::SITEWATCHER sitewatcher1h,                     vis::LOWER_LIMIT 0,   vis::UPPER_LIMIT 1000, vis::INITIAL_VALUE 500, vis::PIXELS_HIGH_MIN  0,  vis::PIXELS_WIDE_MIN  0,  vis::PIXELS_HIGH_CUT 1.0,  vis::PIXELS_WIDE_CUT 1.0 ],
			      vslider::with [ vis::SITEWATCHER sitewatcher2h,  		          vis::LOWER_LIMIT 0,   vis::UPPER_LIMIT 1000, vis::INITIAL_VALUE 500, vis::PIXELS_HIGH_MIN  0,  vis::PIXELS_WIDE_MIN  0,  vis::PIXELS_HIGH_CUT 1.0,  vis::PIXELS_WIDE_CUT 1.0 ]
			    ]
			  ]
		      )
		    );

		{ guiplan,

		  widget_sites =>     { site1a, site2a,
					site1b, site2b,
					site1c, site2c,
				     	site1d, site2d,
				     	site1e, site2e,
				     	site1f, site2f,
				     	site1g, site2g,
				     	site1h, site2h
				      },

		  read_back_sites_and_ports_of_vsliders
		};
	    };													# fun make_vsliders_guiplan

	fun make_textentries_guiplan  ()
	      #
	      :	{ guiplan:		gt::Guiplan,
														# Here we return globals which wind up containing the window sites
														# assigned to our various widgets.  Normal application code never
														# needs to know this, but our test code needs this information in
														# order to synthesize fake mouseclicks etc on the buttons.
														#
		  widget_sites:   { site1a: Ref (Null_Or(g2d::Box)),						# Row one,   button one.
				    site2a: Ref (Null_Or(g2d::Box)),						# Row one,   button two.
														#
				    site1b: Ref (Null_Or(g2d::Box)),						# Row two,   button one.  
				    site2b: Ref (Null_Or(g2d::Box)),						# Row two,   button two.  
														#
				    site1c: Ref (Null_Or(g2d::Box)),						# Row three, button one.  
				    site2c: Ref (Null_Or(g2d::Box)),						# Row three, button two.  
														#
				    site1d: Ref (Null_Or(g2d::Box)),						# Row four,  button one.  
				    site2d: Ref (Null_Or(g2d::Box)),						# Row four,  button two.  
														#
				    site1e: Ref (Null_Or(g2d::Box)),						# Row five,  button one.
				    site2e: Ref (Null_Or(g2d::Box)),						# Row five,  button two.  
														#
				    site1f: Ref (Null_Or(g2d::Box)),						# Row six,   button one.  
				    site2f: Ref (Null_Or(g2d::Box)),						# Row six,   button two.  
														#
				    site1g: Ref (Null_Or(g2d::Box)),						# Row seven, button one.  
				    site2g: Ref (Null_Or(g2d::Box)),						# Row seven, button two.  
														#
				    site1h: Ref (Null_Or(g2d::Box)),						# Row eight, button one.  
				    site2h: Ref (Null_Or(g2d::Box))						# Row eight, button two.  
				  },

		  read_back_sites_and_ports_of_textentries:	Void -> Void					# Fills in values of widget_sites
		}
	    =
	    {
		stipulate
		    site1a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row one,   first  button, site notification mailqueue.
		    site2a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row one,   second button, site notification mailqueue.
		    #												#
		    site1b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row two,   first  button, site notification mailqueue.
		    site2b' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row two,   second button, site notification mailqueue.
		    #												#
		    site1c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row three, first  button, site notification mailqueue.
		    site2c' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row three, second button, site notification mailqueue.
		    #												#
		    site1d' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row four,  first  button, site notification mailqueue.
		    site2d' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row four,  second button, site notification mailqueue.
		    #												#
		    site1e' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row five,  first  button, site notification mailqueue.
		    site2e' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row five,  second button, site notification mailqueue.
		    #												#
		    site1f' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row six,   first  button, site notification mailqueue.
		    site2f' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row six,   second button, site notification mailqueue.
		    #												#
		    site1g' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row seven, first  button, site notification mailqueue.
		    site2g' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row seven, second button, site notification mailqueue.
		    #												#
		    site1h' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row eight, first  button, site notification mailqueue.
		    site2h' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row eight, second button, site notification mailqueue.
		herein														                                                     
														# These globals hold the values read from the above
														# mailops by the later do_one_mailop() calls.
														# They hold the sites (window locations) assigned to
														# our twelve pushbuttons. (We need this information
														# to generate fake mouseclicks on them for test
														# purposes. A normal GUI app wouldn't do this.) 
														#
		    site1a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button one.
		    site2a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button two.
		    #												#
		    site1b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button one.
		    site2b = REF (NULL: Null_Or(g2d::Box));							# Row two,   button two.
		    #												#
		    site1c = REF (NULL: Null_Or(g2d::Box));							# Row three, button one.
		    site2c = REF (NULL: Null_Or(g2d::Box));							# Row three, button two.
		    #												#
		    site1d = REF (NULL: Null_Or(g2d::Box));							# Row four,  button one.
		    site2d = REF (NULL: Null_Or(g2d::Box));							# Row four,  button two.
		    #												#
		    site1e = REF (NULL: Null_Or(g2d::Box));							# Row five,  button one.
		    site2e = REF (NULL: Null_Or(g2d::Box));							# Row five,  button two.
		    #												#
		    site1f = REF (NULL: Null_Or(g2d::Box));							# Row six,   button one.
		    site2f = REF (NULL: Null_Or(g2d::Box));							# Row six,   button two.
		    #												#
		    site1g = REF (NULL: Null_Or(g2d::Box));							# Row seven, button one.
		    site2g = REF (NULL: Null_Or(g2d::Box));							# Row seven, button two.
		    #												#
		    site1h = REF (NULL: Null_Or(g2d::Box));							# Row eight, button one.
		    site2h = REF (NULL: Null_Or(g2d::Box));							# Row eight, button two.

														# These are the site-watcher callbacks we pass to the
														# guiboss layer to find out where our buttons are on
														# the window:
														#
		    fun sitewatcher1a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1a', site);		# Row one,   first  button, site notification callback.
		    fun sitewatcher2a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2a', site);		# Row one,   second button, site notification callback.
		    #												#
		    fun sitewatcher1b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1b', site);		# Row two,   first  button, site notification callback.
		    fun sitewatcher2b (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2b', site);		# Row two,   second button, site notification callback.
		    #												#
		    fun sitewatcher1c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1c', site);		# Row three, first  button, site notification callback.
		    fun sitewatcher2c (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2c', site);		# Row three, second button, site notification callback.
		    #												#
		    fun sitewatcher1d (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1d', site);		# Row four,  first  button, site notification callback.
		    fun sitewatcher2d (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2d', site);		# Row four,  second button, site notification callback.
		    #												#
		    fun sitewatcher1e (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1e', site);		# Row five,  first  button, site notification callback.
		    fun sitewatcher2e (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2e', site);		# Row five,  second button, site notification callback.
		    #												#
		    fun sitewatcher1f (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1f', site);		# Row six,   first  button, site notification callback.
		    fun sitewatcher2f (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2f', site);		# Row six,   second button, site notification callback.
		    #												#
		    fun sitewatcher1g (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1g', site);		# Row seven, first  button, site notification callback.
		    fun sitewatcher2g (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2g', site);		# Row seven, second button, site notification callback.
		    #												#
		    fun sitewatcher1h (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1h', site);		# Row eight, first  button, site notification callback.
		    fun sitewatcher2h (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site2h', site);		# Row eight, second button, site notification callback.


		    fun read_back_sites_and_ports_of_textentries ()						# Fill in the above globals via blocking reads.
			=											# We use timeouts (only) to recover gracefully if things are
			{											# somehow so broken that guiboss-imp never calls our callbacks.
														# The order shouldn't matter; here we go left-to-right top-to-bottom:

			    do_one_mailop [ take_from_mailqueue' site1a'	==> {. site1a := #site;			assert(TRUE);  },	# Row one,   button one.
					    timeout_in' 1.0		==> {. printf "no site1a in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2a'	==> {. site2a := #site;			assert(TRUE);  },	# Row one,   button two.
					    timeout_in' 1.0		==> {. printf "no site2a in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1b'	==> {. site1b := #site;			assert(TRUE);  },	# Row two,   button one.
					    timeout_in' 1.0		==> {. printf "no site1b in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2b'	==> {. site2b := #site;			assert(TRUE);  },	# Row two,   button two.
					    timeout_in' 1.0		==> {. printf "no site2b in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1c'	==> {. site1c := #site;			assert(TRUE);  },	# Row three, button one.
					    timeout_in' 1.0		==> {. printf "no site1c in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2c'	==> {. site2c := #site;			assert(TRUE);  },	# Row three, button two.
					    timeout_in' 1.0		==> {. printf "no site2c in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1d'	==> {. site1d := #site;			assert(TRUE);  },	# Row four,  button one.
					    timeout_in' 1.0		==> {. printf "no site1d in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2d'	==> {. site2d := #site;			assert(TRUE);  },	# Row four,  button two.
					    timeout_in' 1.0		==> {. printf "no site2d in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1e'	==> {. site1e := #site;			assert(TRUE);  },	# Row five,  button one.
					    timeout_in' 1.0		==> {. printf "no site1e in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2e'	==> {. site2e := #site;			assert(TRUE);  },	# Row five,  button two.
					    timeout_in' 1.0		==> {. printf "no site2e in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1f'	==> {. site1f := #site;			assert(TRUE);  },	# Row six,   button one.
					    timeout_in' 1.0		==> {. printf "no site1f in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2f'	==> {. site2f := #site;			assert(TRUE);  },	# Row six,   button two.
					    timeout_in' 1.0		==> {. printf "no site2f in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1g'	==> {. site1g := #site;			assert(TRUE);  },	# Row seven, button one.
					    timeout_in' 1.0		==> {. printf "no site1g in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2g'	==> {. site2g := #site;			assert(TRUE);  },	# Row seven, button two.
					    timeout_in' 1.0		==> {. printf "no site2g in 1 sec!\n";	assert(FALSE); }
					  ];

			    do_one_mailop [ take_from_mailqueue' site1h'	==> {. site1h := #site;			assert(TRUE);  },	# Row eight, button one.
					    timeout_in' 1.0		==> {. printf "no site1h in 1 sec!\n";	assert(FALSE); }
					  ];
			    do_one_mailop [ take_from_mailqueue' site2h'	==> {. site2h := #site;			assert(TRUE);  },	# Row eight, button two.
					    timeout_in' 1.0		==> {. printf "no site2h in 1 sec!\n";	assert(FALSE); }
					  ];
			};
		end;


		guiplan
		  =
		  gt::FRAME
		    ( [],
		      ( gt::GRID
			  [
			    [ textentry::with [ ten::SITEWATCHER sitewatcher1a,  ten::TEXT "red",   ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ],
			      textentry::with [ ten::SITEWATCHER sitewatcher2a,  ten::TEXT "green", ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ],
			      textentry::with [ ten::SITEWATCHER sitewatcher1b,  ten::TEXT "blue",  ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ],
			      textentry::with [ ten::SITEWATCHER sitewatcher2b,  ten::TEXT "alpha", ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ]
			    ],
			    [ textentry::with [ ten::SITEWATCHER sitewatcher1c,    		    ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ],
			      textentry::with [ ten::SITEWATCHER sitewatcher2c,  		    ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ],
			      textentry::with [ ten::SITEWATCHER sitewatcher1d,   		    ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ],
			      textentry::with [ ten::SITEWATCHER sitewatcher2d,  		    ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ]
			    ],

			    [ textentry::with [ ten::SITEWATCHER sitewatcher1e,  ten::TEXT "red",   ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ],
			      textentry::with [ ten::SITEWATCHER sitewatcher2e,  ten::TEXT "green", ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ],
			      textentry::with [ ten::SITEWATCHER sitewatcher1f,  ten::TEXT "blue",  ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ],
			      textentry::with [ ten::SITEWATCHER sitewatcher2f,  ten::TEXT "alpha", ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ]
			    ],
			    [ textentry::with [ ten::SITEWATCHER sitewatcher1g,                     ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ],
			      textentry::with [ ten::SITEWATCHER sitewatcher2g,  		    ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ],
			      textentry::with [ ten::SITEWATCHER sitewatcher1h,                     ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ],
			      textentry::with [ ten::SITEWATCHER sitewatcher2h,  		    ten::PIXELS_HIGH_MIN  0,  ten::PIXELS_WIDE_MIN  0,  ten::PIXELS_HIGH_CUT 1.0,  ten::PIXELS_WIDE_CUT 1.0 ]
			    ]
			  ]
		      )
		    );

		{ guiplan,

		  widget_sites =>     { site1a, site2a,
					site1b, site2b,
					site1c, site2c,
				     	site1d, site2d,
				     	site1e, site2e,
				     	site1f, site2f,
				     	site1g, site2g,
				     	site1h, site2h
				      },

		  read_back_sites_and_ports_of_textentries
		};
	    };																	# fun make_textentries_guiplan

	fun make_texteditor_guiplan  ()
	      #
	      :	{ guiplan:		gt::Guiplan,
														# Here we return globals which wind up containing the window sites
														# assigned to our various widgets.  Normal application code never
														# needs to know this, but our test code needs this information in
														# order to synthesize fake mouseclicks etc on the buttons.
														#
		  widget_sites:   { site1a: Ref (Null_Or(g2d::Box))						# Row one,   button one.
				  },

		  read_back_sites_and_ports_of_texteditor:	Void -> Void					# Fills in values of widget_sites
		}
	    =
	    {
		stipulate
		    site1a' = make_mailqueue (get_current_microthread()): Mailqueue( Null_Or(g2d::Box) );	# Row one,   first  button, site notification mailqueue.
		herein														                                                     
														# These globals hold the values read from the above
														# mailops by the later do_one_mailop() calls.
														# They hold the sites (window locations) assigned to
														# our twelve pushbuttons. (We need this information
														# to generate fake mouseclicks on them for test
														# purposes. A normal GUI app wouldn't do this.) 
														#
		    site1a = REF (NULL: Null_Or(g2d::Box));							# Row one,   button one.

														# These are the site-watcher callbacks we pass to the
														# guiboss layer to find out where our buttons are on
														# the window:
														#
		    fun sitewatcher1a (site: Null_Or(g2d::Box)) =  put_in_mailqueue (site1a', site);		# Row one,   first  button, site notification callback.


		    fun read_back_sites_and_ports_of_texteditor ()						# Fill in the above globals via blocking reads.
			=											# We use timeouts (only) to recover gracefully if things are
			{											# somehow so broken that guiboss-imp never calls our callbacks.
														# The order shouldn't matter; here we go left-to-right top-to-bottom:

			    do_one_mailop [ take_from_mailqueue' site1a'	==> {. site1a := #site;			assert(TRUE);  },	# Row one,   button one.
					    timeout_in' 1.0		==> {. printf "no site1a in 1 sec!\n";	assert(FALSE); }
					  ];
			};
		end;


		guiplan =  texteditor::with ("*testbuffer*", [ ted::SITEWATCHER sitewatcher1a,  ted::TEXT "The quick brown fox jumps over the lazy dog." ]);

		{ guiplan,
		  #
		  widget_sites =>     { site1a
				      },

		  read_back_sites_and_ports_of_texteditor
		};
	    };																	# fun make_texteditor_guiplan

	fun exercise_window_stuff  ()
	    =
	    {

		fun int_sink i = ();
printf "widget-unit-test.pkg/exercise_window_stuff/TOP\n";

		# Here we build a three-layer cake:
		#
		#    -----------------
		#    |     Gui Boss |
		#    -----------------
		#    |     Theme     |
		#    -----------------
		#    |     Appwindow |
		#    -----------------
		#
		# The Gui Boss is windowsystem-agnostic; it de/constructs and maintains running GUI impnets from gui specification trees. 
		# The Theme is windowsystem-specific (e.g., X-specific) and encapsulates how to draw the various widgets on the given windowsystem.
		# The Appwindow is windowsystem-specific and encapulates X-specific application window stuff like EXPOSE event-handling.


		(make_run_gun ()) ->   { run_gun', fire_run_gun };
		(make_end_gun ()) ->   { end_gun', fire_end_gun };

		windowsystem_needs   =  { };
		windowsystem_options =  [ ];
		windowsystem_arg     =  (windowsystem_needs, windowsystem_options);
		#
		(awx::make_windowsystem_egg  windowsystem_arg  NULL) ->  windowsystem_egg;
		#
		(windowsystem_egg			()) ->   (windowsystem_exports, windowsystem_egg');


		(dbx::make_sprite_theme_egg	[]) ->   sprite_theme_egg;
		(sprite_theme_egg		()) ->  (sprite_theme_exports, sprite_theme_egg');
		#
		(dcx::make_object_theme_egg	[]) ->   object_theme_egg;
		(object_theme_egg		()) ->  (object_theme_exports, object_theme_egg');
		#
		(dtx::make_widget_theme_egg	[]) ->   widget_theme_egg;
		(widget_theme_egg		()) ->  (widget_theme_exports, widget_theme_egg');

		
		(gq::make_guiboss_egg		[]) ->  guiboss_egg;
		(guiboss_egg			()) -> (guiboss_exports, guiboss_egg');

		#
		(ti::make_template_egg		[]) -> template_egg;
		(template_egg			()) -> (template_exports, template_egg');

		#
		windowsystem_exports	-> { guiboss_to_guishim		};
		#
		sprite_theme_exports	-> { gui_to_sprite_theme	};
		object_theme_exports	-> { gui_to_object_theme	};
		widget_theme_exports	-> { theme			};
		#
		guiboss_exports		-> { client_to_guiboss		};
		template_exports	-> { template			};

		template_imports = { int_sink =>  \\ (i: Int) = ()  };

		guiboss_egg'		( { int_sink,
					    guiboss_to_guishim,
					    gui_to_sprite_theme,
					    gui_to_object_theme,
					    theme
					  },
					  run_gun', end_gun'
				        );
		#
		sprite_theme_egg'	({ int_sink,     guiboss_to_guishim		},	run_gun', end_gun');
		object_theme_egg'	({ int_sink,     guiboss_to_guishim		},	run_gun', end_gun');
		widget_theme_egg'	({ int_sink,     guiboss_to_guishim		},	run_gun', end_gun');
		#
		windowsystem_egg'	({ int_sink					},	run_gun', end_gun');
		template_egg'		( template_imports,					run_gun', end_gun');



		fire_run_gun ();

		b  =  client_to_guiboss.get_sprite_theme ();
		c  =  client_to_guiboss.get_object_theme ();
		t  =  client_to_guiboss.get_widget_theme ();
		#
		{
# We do not yet have asserts on these two:    XXX SUCKO FIXME
		    got_state_change_event		= REF FALSE;
		    got_redraw_gadget_request_event	= REF FALSE;
		    #
		    got_button_press_event		= REF FALSE;
		    got_button_release_event		= REF FALSE;
		    #
		    got_key_press_event			= REF FALSE;
		    got_key_release_event		= REF FALSE;

# 		    stipulate
# 			first_frame1 =  REF TRUE;
# 			first_frame2 =  REF TRUE;
# 
# 			fun redraw_request_fn1
# 			    {
# 			      id:				iul::Id,						# Unique id.
# 			      frame_number:			Int,							# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
# 			      site:				g2d::Box,						# Window rectangle in which to draw.
# 			      visible:				Bool,							# If FALSE, widget is not visible on screen, so widget-imp may be able to avoid updating foreground and background.
# 			      duration_in_seconds:		Float,							# If state has changed widget-imp should call redraw_gadget() before this time is up. Also useful for motionblur.
# 			      widget_to_guiboss:		gt::Widget_To_Guiboss,
# 			      gadget_mode:			gt::Gadget_Mode,
# 			      theme:				wt::Widget_Theme
# 			    }
# 			    =
# 			    {
# #				if *first_frame1
# 				    first_frame1 := FALSE;
# 
# 				    background_box =  site;
# 				    foreground_box =  g2d::box::make_nested_box (background_box, 4);
# 
# 				    background = gt::CHANGED (THE (gd::COLOR (r8::rgb8_red,    [ gd::POLY_FILL_BOX [ background_box ]])));
# 				    foreground = gt::CHANGED (THE (gd::COLOR (r8::rgb8_yellow, [ gd::POLY_FILL_BOX [ foreground_box ]])));
# 
# 				    widget_to_guiboss.g.redraw_gadget { id, site, foreground, background };
# #				fi;
# 			    };
# 
# 			fun redraw_request_fn2
# 			    {
# 			      id:				iul::Id,						# Unique id.
# 			      frame_number:			Int,							# 1,2,3,... Purely for convenience of widget-imp, guiboss-imp makes no use of this.
# 			      site:				g2d::Box,						# Window rectangle in which to draw.
# 			      visible:				Bool,							# If FALSE, widget is not visible on screen, so widget-imp may be able to avoid updating foreground and background.
# 			      duration_in_seconds:		Float,							# If state has changed widget-imp should call redraw_gadget() before this time is up. Also useful for motionblur.
# 			      widget_to_guiboss:		gt::Widget_To_Guiboss,
# 			      gadget_mode:			gt::Gadget_Mode,
# 			      theme:				wt::Widget_Theme
# 			    }
# 			    =
# 			    {
# #				if *first_frame
# 				    first_frame2 := FALSE;
# 
# 				    background_box =  site;
# 				    foreground_box =  g2d::box::make_nested_box (background_box, 4);
# 
# 				    background = gt::CHANGED (THE (gd::COLOR (r8::rgb8_red,    [ gd::POLY_FILL_BOX [ background_box ]])));
# 				    foreground = gt::CHANGED (THE (gd::COLOR (r8::rgb8_yellow, [ gd::POLY_FILL_BOX [ foreground_box ]])));
# 
# 				    widget_to_guiboss.g.redraw_gadget { id, site, foreground, background };
# #				fi;
# 			    };
# 
# 			fun button_press_fn
# 			      {
#				id:				iul::Id,						# Unique id.
#				button:				evt::Mousebutton,
# 				point:				g2d::Point,
#				widget_layout_hint:		gt::Widget_Layout_Hint,
# 				site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				widget_to_guiboss:		gt::Widget_To_Guiboss,
# 				theme:				wt::Widget_Theme
# 			      }
# 			    = 
# 			    {
# 				got_button_press_event := TRUE;
# nb {. sprintf "button_press_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			fun button_release_fn
# 			      {
#				id:				iul::Id,						# Unique id.
#				button:				evt::Mousebutton,
# 				point:				g2d::Point,
#				widget_layout_hint:		gt::Widget_Layout_Hint,
# 				site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				widget_to_guiboss:		gt::Widget_To_Guiboss,
# 				theme:				wt::Widget_Theme
# 			      }
# 			    = 
# 			    {
# 				got_button_release_event := TRUE;
# nb {. sprintf "button_release_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			fun key_press_fn
# 			      {
#				id:				iul::Id,						# Unique id.
#				keycode:			evt::Keycode,						# Keycode of the depressed key.
# 				keysym:				evt::Keysym,						# Keysym  of the depressed key.
# 				ascii:				String,							# Ascii  for the depressed key.
# 				point:				g2d::Point,
#				widget_layout_hint:		gt::Widget_Layout_Hint,
# 				site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				widget_to_guiboss:		gt::Widget_To_Guiboss,
# 				theme:				wt::Widget_Theme
# 			      }
# 			    = 
# 			    {
# 				got_key_press_event := TRUE;
# nb {. sprintf "key_press_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			fun key_release_fn
# 			      {
#				id:				iul::Id,						# Unique id.
#			        keycode:			evt::Keycode,						# Keycode of the released key.
# 				keysym:				evt::Keysym,						# Keysym  of the released key.
# 				ascii:				String,							# Ascii  for the released key.
# 				point:				g2d::Point,
#				widget_layout_hint:		gt::Widget_Layout_Hint,
# 				site:		 		g2d::Box,						# Widget's assigned area in window coordinates.
# 				modifier_keys_state:		evt::Modifier_Keys_State,				# State of the modifier keys (shift, ctrl...).
# 				mousebuttons_state:		evt::Mousebuttons_State,				# State of mouse buttons.
# 				widget_to_guiboss:		gt::Widget_To_Guiboss,
# 				theme:				wt::Widget_Theme
# 			      }
# 			    = 
# 			    {
# 				got_key_release_event := TRUE;
# nb {. sprintf "key_release_fn called!   -- widget-unit-test.pkg"; };
# 			       ();
# 			    };
# 
# 			widget_options1
# 			  =
# 			  [
# 			    wim::REDRAW_REQUEST_FN		redraw_request_fn1,
# 			    wim::BUTTON_PRESS_FN		button_press_fn,
# 			    wim::BUTTON_RELEASE_FN		button_release_fn,
# 			    wim::KEY_PRESS_FN			key_press_fn,
# 			    wim::KEY_RELEASE_FN			key_release_fn
# 			  ];
# 
# 			widget_options2
# 			  =
# 			  [
# 			    wim::REDRAW_REQUEST_FN		redraw_request_fn2,
# 			    wim::BUTTON_PRESS_FN		button_press_fn,
# 			    wim::BUTTON_RELEASE_FN		button_release_fn,
# 			    wim::KEY_PRESS_FN			key_press_fn,
# 			    wim::KEY_RELEASE_FN			key_release_fn
# 			  ];
# 
# 		    herein
# 			make_widget_fn1 =  wim::make_widget_start_fn  widget_options1;
# 			make_widget_fn2 =  wim::make_widget_start_fn  widget_options2;
# 			    
# 		    end;


		    # We're constructing a guiplan with three rows of four buttons each.
		    #
		    # Each button responds to a click by changing its appearance.
		    #
		    # Also, the middle row of buttons is in a scrollable scrollport;
		    # dragging on any button will scroll the middle row around in
		    # its scrollport.
		    #
		    # We also note the site (size and location) of each button widget;
		    # we need this information (only) to synthesize fake test clicks
		    # on the buttons via
		    #     guiboss_to_topwindow.send_fake_mousebutton_release_event()

														# These mailops are referenced only in
														#     1) The immediately following sitewatcher1a etc fns
														#     2) The read_back_sites_and_ports_of_guiplan_widgets do_one_mailop() calls
														#        which copy read value into site1a etc.





		    # Create guiplan:
		    #
		    stipulate														# NB: This is size for the view visible in the scrollport, not the scrollport itself.
#			scrollable_view_size = { wide => 1600, high => 400 },								# This setting makes middle row exactly fill scrollport.
			scrollable_view_size = { wide => 1580, high => 380 };								# This setting makes middle row slightly to small for scrollport -- useful for testing the logic which fills the cracks with black at startup.


			fun popup_info ()
			    =
			    {   requested_popup_site = { row => 200, col => 200, wide => 1200, high => 900 };
				#
				# Create popup_plan:
				#
				stipulate												# NB: This is size for the view visible in the scrollport, not the scrollport itself.
#				    scrollable_view_size = { wide => 1200, high => 300 };						# This setting makes middle row exactly fill scrollport.
				    scrollable_view_size = { wide => 1150, high => 280 };						# This setting makes middle row slightly to small for scrollport -- useful for testing the logic which fills the cracks with black at startup.

				    fun popup_info2 ()
					=
					{   requested_popup_site = { row => 100, col => 100, wide => 600, high => 600 };
					    #
					    # Create popup_plan2:
					    #
					    (make_grid_guiplan ())
						->
						{ guiplan	=>  popup_plan2,
						  widget_sites	=>  widget_sites_for_popup2,
						  #
						  read_back_sites_and_ports_of_grid_guiplan_widgets
						};


					    { requested_popup_site,
					      popup_plan => popup_plan2,
					      read_sites_and_ports => read_back_sites_and_ports_of_grid_guiplan_widgets
					    };
					};


				herein
				    (make_three_row_guiplan (scrollable_view_size, THE popup_info2, NULL, NULL, NULL, NULL, NULL))
					->
					{ guiplan		=>  popup_plan,
					  scrollport_scroller	=>  scrollport_scroller_for_popup,
					  scroll_state		=>  scroll_state_for_popup,
					  widget_sites		=>  widget_sites_for_popup,
					  #
					  read_back_sites_and_ports_of_guiplan_widgets
					};
				end;

				{ requested_popup_site,
 				  popup_plan,
				  read_sites_and_ports              =>  read_back_sites_and_ports_of_guiplan_widgets
				};
			    };

			fun buttons_popup_info ()
			    =
			    {   # Create popup_plan3 (the button zoo, triggered by button 1 in row 1):
				#
				(make_buttons_guiplan ())
				    ->
				    { guiplan	   =>  popup_plan3,
				      widget_sites =>  widget_sites_for_popup3,
				      #
				      read_back_sites_and_ports_of_buttons_guiplan_widgets
				    };


				requested_popup_site = { row => 400, col => 400, wide => 600, high => 600 };

				{ requested_popup_site,
				  popup_plan => popup_plan3,
				  read_sites_and_ports              =>   read_back_sites_and_ports_of_buttons_guiplan_widgets
				};
			    };

			fun hsliders_popup_info ()
			    =
			    {   # Create popup_plan1c (the slider zoo, triggered by button 1 in row 3):
				#
				(make_hsliders_guiplan ())
				    ->
				    { guiplan	   =>  popup_plan1c,
				      widget_sites =>  widget_sites_for_popup1c,
				      #
				      read_back_sites_and_ports_of_hsliders
				    };


				requested_popup_site = { row => 500, col => 400, wide => 1000, high => 400 };

				{ requested_popup_site,
				  popup_plan => popup_plan1c,
				  read_sites_and_ports              =>   read_back_sites_and_ports_of_hsliders
				};
			    };

			fun vsliders_popup_info ()
			    =
			    {   # Create popup_plan2c (the slider zoo, triggered by button 2 in row 3):
				#
				(make_vsliders_guiplan ())
				    ->
				    { guiplan	   =>  popup_plan2c,
				      widget_sites =>  widget_sites_for_popup2c,
				      #
				      read_back_sites_and_ports_of_vsliders
				    };


				requested_popup_site = { row => 100, col => 900, high => 1000, wide => 200 };

				{ requested_popup_site,
				  popup_plan => popup_plan2c,
				  read_sites_and_ports              =>   read_back_sites_and_ports_of_vsliders
				};
			    };

			fun textentries_popup_info ()
			    =
			    {   # Create popup_plan3c (the text-entry zoo, triggered by button 3 in row 3):
				#
				(make_textentries_guiplan ())
				    ->
				    { guiplan	   =>  popup_plan3c,
				      widget_sites =>  widget_sites_for_popup3c,
				      #
				      read_back_sites_and_ports_of_textentries
				    };


				requested_popup_site = { row => 100, col => 400, high => 200, wide => 1000 };

				{ requested_popup_site,
				  popup_plan => popup_plan3c,
				  read_sites_and_ports              =>   read_back_sites_and_ports_of_textentries
				};
			    };

			fun texteditor_popup_info ()
			    =
			    {   # Create popup_plan4c (the text-entry zoo, triggered by button 4 in row 3):
				#
				(make_texteditor_guiplan ())
				    ->
				    { guiplan	   =>  popup_plan4c,
				      widget_sites =>  widget_sites_for_popup4c,
				      #
				      read_back_sites_and_ports_of_texteditor
				    };


				requested_popup_site = { row => 100, col => 100, high => 1000, wide => 1000 };

				{ requested_popup_site,
				  popup_plan => popup_plan4c,
				  read_sites_and_ports              =>   read_back_sites_and_ports_of_texteditor
				};
			    };

		    herein
			(make_three_row_guiplan (scrollable_view_size, THE popup_info, THE buttons_popup_info, THE hsliders_popup_info, THE vsliders_popup_info, THE textentries_popup_info, THE texteditor_popup_info))
			    ->
			    { guiplan,
			      scrollport_scroller,
			      scroll_state,
			      widget_sites,
			      #	
			      read_back_sites_and_ports_of_guiplan_widgets
			    };
		    end;



# nb {. sprintf "widget-unit-test pprinting guiplan:"; };
#		    gt::pprint_guiplan  guiplan;

		    topwindow_hints		# 
			=			# 
			[
			  gtg::BACKGROUND_PIXEL	(r8::rgb8_from_ints (128+32, 16, 32)),		# Slightly desaturated green. (NOW RED.)
			  gtg::BORDER_PIXEL	(r8::rgb8_from_ints (0,       0,  0)),		# Black.
			  #
			  gtg::SITE		( { upperleft		=>   { col =>     0, row  =>    0 },
						    size		=>   { wide => 1600, high => 1200 },
						    border_thickness	=>  1
						  }
						  : g2d::Window_Site
						)
			];

		    (client_to_guiboss.make_topwindow  topwindow_hints)
			->
			guiboss_to_topwindow;

		    (guiboss_to_topwindow.exercise_appwindow ())
			->
		        wait_until_exercise_is_complete;
			

		    wait_until_exercise_is_complete ();



		    (client_to_guiboss.start_gui  (guiboss_to_topwindow, guiplan))
			->
			block_until_gui_startup_is_complete;

		    (block_until_gui_startup_is_complete())
			->
			client_to_guiwindow;

# nb {. sprintf "widget-unit-test doing guiboss_to_topwindow.send_fake_mousebutton_press_event() ..."; };
		    #
#		    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, { row => 13, col => 17 });
#		    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, { row => 14, col => 18 });
		    #
#		    guiboss_to_topwindow.send_fake_key_press_event   (evt::KEYCODE 1, { row => 23, col => 27 });
#		    guiboss_to_topwindow.send_fake_key_release_event (evt::KEYCODE 1, { row => 24, col => 28 });



		    read_back_sites_and_ports_of_guiplan_widgets ();




		    sleep_for 3.0;												# Just to give human observer time to observe.

 		    for (i = 1; i <= 10; ++i) {
 			#
if (*log::debugging) log::note  {. sprintf "widget-unit-test lup %d ..." i; }; fi;

#			scroll_state := *scroll_state + autoscroll_distance;
#
#			case *scrollport_scroller
#			    #
#			    NULL  =>    ();
#			    THE s =>    s.set_scrollport_origin *scroll_state;
#			esac;

			case *widget_sites.site1a
			    #
			    THE site => {
# printf "site1 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
					    site_midpoint = g2d::box::midpoint site;
if (*log::debugging) log::note  {. "widget-unit-test sending site1 downclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
if (*log::debugging) log::note  {. "widget-unit-test sending site1   upclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
					    window_rectangle_to_read = g2d::box::make (site_midpoint, { wide => 5, high => 5 });
					    rw_matrix_rgb8 = guiboss_to_topwindow.get_pixel_rectangle window_rectangle_to_read;
					    row = 1;
					    col = 1;
					    rgb8 = rw_matrix_rgb8[row,col];
					    rgb  =  r8::rgb8_to_rgb rgb8;
# nb {. sprintf "widget-unit-test rw_matrix_rgb8[%d,%d] = { red => %g, green => %g, blue => %g }\n" row col rgb.red rgb.green rgb.blue; };
					};
			    NULL	 => ();
			esac;
# 			case *site2a
# 			    #
# 			    THE site => {
# # printf "site2 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site2 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site2   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site3a
# 			    #
# 			    THE site => {
# # printf "site3 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site3 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site3   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
			case *widget_sites.site4a
			    #
			    THE site => {
# printf "site4 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
					    site_midpoint = g2d::box::midpoint site;
if (*log::debugging) log::note  {. "widget-unit-test sending site4 downclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
if (*log::debugging) log::note  {. "widget-unit-test sending site4   upclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
					};
			    NULL	 => ();
			esac;


			case *widget_sites.site1b
			    #
			    THE site => {
# printf "site1 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# XXX BUGGO FIXME DO NOT USE 'i' HERE!!!
					    site_midpoint = g2d::box::midpoint site + { row => 400 + i*10, col => i*10 };				# The added 400 is to transform us from the scrollable-view coordinate system into the toplevel window coordinate system.
if (*log::debugging) log::note  {. "widget-unit-test sending site1 downclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
if (*log::debugging) log::note  {. "widget-unit-test sending site1   upclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
					    window_rectangle_to_read = g2d::box::make (site_midpoint, { wide => 5, high => 5 });
					    rw_matrix_rgb8 = guiboss_to_topwindow.get_pixel_rectangle window_rectangle_to_read;
					    row = 1;
					    col = 1;
					    rgb8 = rw_matrix_rgb8[row,col];
					    rgb  =  r8::rgb8_to_rgb rgb8;
# nb {. sprintf "widget-unit-test rw_matrix_rgb8[%d,%d] = { red => %g, green => %g, blue => %g }\n" row col rgb.red rgb.green rgb.blue; };
					};
			    NULL	 => ();
			esac;
# 			case *site2b
# 			    #
# 			    THE site => {
# # printf "site2 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# # XXX BUGGO FIXME DO NOT USE 'i' HERE!!!
# 					    site_midpoint = g2d::box::midpoint site + { row => 400 + i*10, col => i*10 };				# The added 400 is to transform us from the scrollable-view coordinate system into the toplevel window coordinate system.
# if (*log::debugging) log::note  {. "widget-unit-test sending site2 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site2   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site3b
# 			    #
# 			    THE site => {
# # printf "site3 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# # XXX BUGGO FIXME DO NOT USE 'i' HERE!!!
# 					    site_midpoint = g2d::box::midpoint site + { row => 400 + i*10, col => i*10 };				# The added 400 is to transform us from the scrollable-view coordinate system into the toplevel window coordinate system.
# if (*log::debugging) log::note  {. "widget-unit-test sending site3 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site3   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site4b
# 			    #
# 			    THE site => {
# # printf "site4 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# # XXX BUGGO FIXME DO NOT USE 'i' HERE!!!
# 					    site_midpoint = g2d::box::midpoint site + { row => 400 + i*10, col => i*10 };				# The added 400 is to transform us from the scrollable-view coordinate system into the toplevel window coordinate system.
# if (*log::debugging) log::note  {. "widget-unit-test sending site4 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site4   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;


			case *widget_sites.site1c
			    #
			    THE site => {
# printf "site1 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
					    site_midpoint = g2d::box::midpoint site;
if (*log::debugging) log::note  {. "widget-unit-test sending site1 downclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
if (*log::debugging) log::note  {. "widget-unit-test sending site1   upclick ..."; }; fi;
#					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
					    window_rectangle_to_read = g2d::box::make (site_midpoint, { wide => 5, high => 5 });
					    rw_matrix_rgb8 = guiboss_to_topwindow.get_pixel_rectangle window_rectangle_to_read;
					    row = 1;
					    col = 1;
					    rgb8 = rw_matrix_rgb8[row,col];
					    rgb  =  r8::rgb8_to_rgb rgb8;
# nb {. sprintf "widget-unit-test rw_matrix_rgb8[%d,%d] = { red => %g, green => %g, blue => %g }\n" row col rgb.red rgb.green rgb.blue; };
					};
			    NULL	 => ();
			esac;
# 			case *site2c
# 			    #
# 			    THE site => {
# # printf "site2 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site2 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site2   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site3c
# 			    #
# 			    THE site => {
# # printf "site3 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site3 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site3   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;
# 			case *site4c
# 			    #
# 			    THE site => {
# # printf "site4 == { row => %d, col => %d, high => %d, wide => %d }\n" site.row site.col site.high site.wide;
# 					    site_midpoint = g2d::box::midpoint site;
# if (*log::debugging) log::note  {. "widget-unit-test sending site4 downclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_press_event    (evt::button1, site_midpoint );
# if (*log::debugging) log::note  {. "widget-unit-test sending site4   upclick ..."; }; fi;
# #					    guiboss_to_topwindow.send_fake_mousebutton_release_event  (evt::button1, site_midpoint );
# 					};
# 			    NULL	 => ();
# 			esac;



# nb {. sprintf "widget-unit-test calling sleep_for 5.0 ..."; };
if (*log::debugging) log::note  {. "widget-unit-test calling sleep_for 2.0 ..."; }; fi;
			sleep_for 2.0;
		    };
# if (*log::debugging) log::note  {. "widget-unit-test setting log::debugging back to FALSE."; }; fi;
# log::debugging := FALSE;
# interprocess_signals::set_log_if_on FALSE;

#		    assert *got_button_press_event;
#		    assert *got_button_release_event;

#		    assert *got_key_press_event;
#		    assert *got_key_release_event;

nb {. sprintf "widget-unit-test ending gui run by calling kill_gui..."; };
		    paused_gui' = client_to_guiwindow.kill_gui ();

# nb {. sprintf "widget-unit-test pprinting paused_gui':"; };
#		    gt::pprint_paused_gui  paused_gui';
		};	

		sprite_to_spritespace									# Dummy port back to spritespace-imp from sprite-imp.
		  =
		  { id           =>  id_zero,
		    look_changed =>  (\\ _ = ())
		  };

		object_to_objectspace									# Dummy port back to objectspace-imp from object-imp.
		  =
		  { id           =>  id_zero,
		    look_changed =>  (\\ _ = ())
		  };



# Following is broken at the moment by the restructuring
# of sprite and object code on the model of widget code.
# In particular I think balls wound up with boolean values
# instead of position+velocity values.
#
# For the moment my focus is elsewhere so I'm letting this slide.
# XXX SUCKO FIXME.
# 			-- 2014-07-05 CrT

#		ball_state_endstate_oneshot = NULL;
#		ball_look_endstate_oneshot  = NULL;
#		ball_look_arg         = [];
#		ball_arg =  ( { position => { x => 0.0, y => 0.0, z => 0.0 },
#				velocity => { x => 0.0, y => 0.0, z => 0.0 }
#			      }, 	
#			      []
#			    );
#		(dbl::make_egg ( /* guiboss_to_guishim, */ ball_arg, ball_look_arg, sprite_to_spritespace, ball_state_endstate_oneshot, ball_look_endstate_oneshot))
#		    ->
#		    ball_look_egg;
#
#
#
#		node_state_endstate_oneshot = NULL;
#		node_look_endstate_oneshot  = NULL;
#		node_look_arg         = [];
#		node_arg =  ( { text => "foo" },
#			      []
#			    );
#		(dnl::make_egg ( /* guiboss_to_guishim, */ node_arg, node_look_arg, object_to_objectspace, node_state_endstate_oneshot, node_look_endstate_oneshot))
#		    ->
#		    node_look_egg;


		fire_end_gun ();
		

		();
	    };

	fun run ()
	    =
	    {   # Remove any old version of the tracefile:
		#
		if (isfile tracefile)  
		    unlink tracefile;
		fi;


		printf "\nDoing %s:\n" name;   


		# Open tracelog file and
                # select tracing level:
		#
		{   include package   logger;				# logger			is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
		    #
		    set_logger_to  (fil::LOG_TO_FILE tracefile);
		    #
#		    enable fil::all_logging;			# Gross overkill.
#		    enable xtr::xkit_logging;			# Lesser overkill.
#		    enable xtr::io_logging;			# Saner yet.	
		};

		assert  (tsr::thread_scheduler_is_running ());

		exercise_convex_hull	    ();
		exercise_point_in_polygon   ();
		exercise_window_stuff	    ();

		assert TRUE;

		summarize_unit_tests  name;
	    };
    };

end;




##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
