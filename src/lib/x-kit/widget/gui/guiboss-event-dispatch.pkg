## guiboss-event-dispatch.pkg
#
# A support library for 
#
#     src/lib/x-kit/widget/gui/guiboss-imp.pkg
#
# This code used to live in it, but guiboss-imp.pkg was getting too big,
# so event-dispatch moved into this dedicated support package.
#
# Our primary responsibilities here are:
#
#  *  Dispatching incoming X events to the appropriate gadget,
#     determined primarily by which visible gadget is positioned
#     under the click coordinate.
#
#  *  Tracking which gadget has the mouse focus and synthesizing
#     enter/leave events when the focus moves from one gadget to
#     another gadget.

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom			is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication			is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap				is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat				is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display				is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index				is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap		is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix				is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap				is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window				is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector				is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection			is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade					is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk				is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer			is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger				is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt				is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts		is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire				is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget				is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window				is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink			is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher		is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style				is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient				is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk				is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package evt =  gui_event_types;				# gui_event_types			is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string			is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;				# guiboss_types				is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
    package gtj =  guiboss_types_junk;				# guiboss_types_junk			is from   src/lib/x-kit/widget/gui/guiboss-types_junk.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router		is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist			is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill		is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package bt  =  gui_to_sprite_theme;				# gui_to_sprite_theme			is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
    package ct  =  gui_to_object_theme;				# gui_to_object_theme			is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
    package wt  =  widget_theme;				# widget_theme				is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

    package boi =  spritespace_imp;				# spritespace_imp			is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;				# objectspace_imp			is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;				# widgetspace_imp			is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gtg =  guiboss_to_guishim;				# guiboss_to_guishim			is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package b2s =  spritespace_to_sprite;			# spritespace_to_sprite			is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;			# objectspace_to_object			is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg

    package s2s =  sprite_to_spritespace;			# sprite_to_spritespace			is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2o =  object_to_objectspace;			# object_to_objectspace			is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg

#   package s2g =   space_to_gui;				# space_to_gui				is from   src/lib/x-kit/widget/gui/space-to-gui.pkg
    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap			is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package frm =  frame;					# frame					is from   src/lib/x-kit/widget/leaf/frame.pkg

    package iul =  issue_unique_look_id;			# issue_unique_look_id			is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

    package im  =  int_red_black_map;				# int_red_black_map			is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set			is from   src/lib/src/int-red-black-set.pkg

    package r8  =  rgb8;					# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d				is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;				# geometry2d_junk			is from   src/lib/std/2d/geometry2d-junk.pkg

    package ebi =  editboss_imp;				# editboss_imp				is from   src/lib/x-kit/widget/edit/editboss-imp.pkg
    package e2g =  editboss_to_guiboss;				# editboss_to_guiboss			is from   src/lib/x-kit/widget/edit/editboss-to-guiboss.pkg

    package t2t =  texteditor_to_textbuffer;			# texteditor_to_textbuffer		is from   src/lib/x-kit/widget/edit/texteditor-to-textbuffer.pkg
#   package tbi =  textbuffer_imp;				# textbuffer_imp			is from   src/lib/x-kit/widget/edit/textbuffer-imp.pkg

    package gxi =  translate_runninggui_to_exportgui;		# guiboss_export_import			is from   src/lib/x-kit/widget/gui/translate-runninggui-to-exportgui.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log					is from   src/lib/std/src/log.pkg

Dummy1 = ebi::Editboss_Option;				# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
dummy2 = gxi::running_gui__to__export_gui;		# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.

herein

    package guiboss_event_dispatch
    :       Guiboss_Event_Dispatch											# Guiboss_Event_Dispatch	is from   src/lib/x-kit/widget/gui/guiboss-event-dispatch.api
    {
	Dummy = Int;

	#################################################################################
	# guiboss interface fns::
	#
	#
	stipulate
	    Appropriate_Gadget_Imp_Info												# Return value type for    find_appropriate_gadget_imp_info().
	      #
	      =    APPROPRIATE_GADGET (gt::Gadget_Imp_Info, g2d::Point)								# The g2d::Point is the query point transformed into the appropriate local coordinate system for the gadget.
	      | NO_APPROPRIATE_GADGET                       g2d::Point
	      ;

	    fun find_appropriate_gadget_imp_info										# Which widget did the user click on?  This is usually easy but it might be in a scrollable view in a tabbed view in another scrollable view, say.
		  (
		    me:				gt::Guiboss_State,									# State which is preserved across imp shutdown/restart cycles.
		    topwindow_info:		gt::Topwindow_Info,
		    event_point
		  )
		=
		{
		    subwindow_infos												#
			=
			gtj::return_all_subwindow_infos_in_descending_stacking_order
			    #
			    *topwindow_info.subwindow_info;

		    search_subwindow_infos_in_descending_stacking_order  subwindow_infos
		    where
			fun search_subwindow_infos_in_descending_stacking_order  []
				=>
				NO_APPROPRIATE_GADGET event_point;								# Tried everything, no hits, give up.

			    search_subwindow_infos_in_descending_stacking_order  (subwindow_info ! rest)			# Try topmost remaining popup first.
				=>
				{   site   =  gtj::subwindow_info_site_in_basewindow_coordinates  subwindow_info;
				    #
				    if (g2d::box::point_in_box (event_point, site))
					#
					find_appropriate_gadget_imp_info_for_running_gui  subwindow_info;			# Found the right popup (or base) running gui, see if we hit any widgets within it.
				    else
					search_subwindow_infos_in_descending_stacking_order  rest;				# event_point is not within this running gui, so try next one.
				    fi;
				};
			end;
		    end;		
		}
		where
		    fun find_appropriate_gadget_imp_info_for_running_gui							# Which widget did the user click on?  This is usually easy but it might be in a scrollable view in a tabbed view in another scrollable view, say.
			  (
			    subwindow_info:		gt::Subwindow_Info							# This will be the subwindow_info for either the topllevel running gui on the topwindow, or else the running gui for one of its popups.
			  )
			=
			case (*subwindow_info.running_gui)
			    #
			    THE (running_gui:	gt::Running_Gui)
				=>
				{   event_point
					=
					event_point
					-
					(gtj::subwindow_info_origin_in_base_window_coordinates subwindow_info);			#
				    #
				    find_gadget_imp_info (running_gui.rg_widget, event_point);
				}
				where
				    fun try_all_widgets ([]: List(gt::Rg_Widget),  point: g2d::Point)
					    =>
					    NO_APPROPRIATE_GADGET point;

					try_all_widgets (row_or_col_widget ! rest,  point)
					    =>
					    case (find_gadget_imp_info  (row_or_col_widget, point))
						#
						NO_APPROPRIATE_GADGET _ =>  try_all_widgets (rest,  point);			# Try the remaining widgets in ROW/COL/FRAME/whatever.
						info =>  info;									# Got it.
					    esac;
				    end

				    also
				    fun try_all_rows ([]: List(List(gt::Rg_Widget)),  point: g2d::Point)
					    =>
					    NO_APPROPRIATE_GADGET point;

					try_all_rows (row ! rest,  point)
					    =>
					    case (try_all_widgets (row, point))
						#
						NO_APPROPRIATE_GADGET _ =>  try_all_rows (rest,  point);			# Try the remaining widgets in ROW/COL/FRAME/whatever.
						info =>  info;									# Got it.
					    esac;
				    end

				    also	
				    fun find_gadget_imp_info
					  (
					    rg_widget:		gt::Rg_Widget,
					    point:		g2d::Point
					  )
					=
					if (g2d::box::point_in_box  (point,  gtj::widget_site rg_widget))
					    #
					    case rg_widget
						#
						gt::RG_ROW r =>   try_all_widgets (r.widgets, point);
						gt::RG_COL r =>   try_all_widgets (r.widgets, point);

						gt::RG_GRID r =>   try_all_rows    (r.widgets, point);


						gt::RG_SCROLLPORT r
						    =>
						    {   point = point - g2d::box::upperleft(*r.site);					# Transform mouseclick point into          view coordinate system.
							point = point - *r.origin;							# Transform mouseclick point into scrolled view coordinate system.
							#
							find_gadget_imp_info (*r.rg_widget, point);					# Recursively search for target widget of mouseclick among widgets in scrollable view.
						    };	

						gt::RG_TABPORT r
						    =>
						    {   point = point - g2d::box::upperleft(*r.site);					# Transform mouseclick point into view coordinate system.
							#
							this_tab = list::nth (r.tabs, *r.visible_tab);

							find_gadget_imp_info (this_tab.rg_widget, point);				# Recursively search for target widget of mouseclick among widgets on visible tab.
						    };

						gt::RG_FRAME r
						    =>
						    try_all_widgets ([ r.widget, r.frame_widget ], point);

						gt::RG_WIDGET (r as { guiboss_to_widget, ... })
						    =>
						    {   imps = *me.gadget_imps;
							#
							id   = iul::id_to_int guiboss_to_widget.id;

							case (im::get (imps, id))
							    #
							    NULL =>  NO_APPROPRIATE_GADGET point ;
							    #
							    THE gadget_imp_info									# Return 'point' transformed into correct coordinate system for widget.
								=>
								case (*gadget_imp_info.point_in_gadget)
								    #
								    NULL   =>                 APPROPRIATE_GADGET (gadget_imp_info, point);	# No   point_in_gadget fn supplied by gadget, so count mouseclick as having hit the gadget.
								    THE fn =>	if (fn point) APPROPRIATE_GADGET (gadget_imp_info, point);	# Have point_in_gadget fn supplied by the gadget decide whether the mouseclick was close enough to count.
										else  	   NO_APPROPRIATE_GADGET (                 point);
										fi;
								esac;
							esac;
						    };

						gt::RG_OBJECTSPACE r
						    =>
						    NO_APPROPRIATE_GADGET point; # TBD

						gt::RG_SPRITESPACE r
						    =>
						    NO_APPROPRIATE_GADGET point; # TBD

						gt::RG_NULL_WIDGET
						    =>
						    NO_APPROPRIATE_GADGET point;
					    esac;
					else
					    NO_APPROPRIATE_GADGET point;
					fi;
				end;
			    #	 
			    NULL => NO_APPROPRIATE_GADGET event_point;						# Maybe we should do:   log::fatal "find_appropriate_gadget_imp_info' called while gui not running!";
			esac;
		end;
	herein													# This package has become unwieldy; it would be good to move the event-forwarding logic to a separate subpackage at some point.  XXX SUCKO FIXME.

	    fun do_motion_notify										# Mouse has moved. Inform any relevant gadgets.
		  (
		    me:				gt::Guiboss_State,
		    theme:			wt::Widget_Theme,
		    topwindow_info:		gt::Topwindow_Info,
		    motion_xevtinfo:		evt::Motion_Xevtinfo
		  )
		=
		case (find_appropriate_gadget_imp_info (me, topwindow_info, motion_xevtinfo.event_point))
		    #
		    APPROPRIATE_GADGET (gadget_imp_info, event_point)						# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no scrollports are involved).
			=>
			{   mouse_is = topwindow_info.mouse_is;
			    #
			    gadget_imp_info -> { guiboss_to_gadget,
						 gadget_mode,
						 ...
					       };

			    case *mouse_is
				#
				gt::CROSSING_NONGADGET								# Here the mouse is crossing from non-gadget pixels into gadget pixels.
				    =>
				    {
					# Remember gadget now has mouse focus:
					#
				      (*gadget_mode) -> { has_mouse_focus => _,    is_active, has_keyboard_focus };
					gadget_mode  := { has_mouse_focus => TRUE, is_active, has_keyboard_focus };

					guiboss_to_gadget.note_mouse_transit					# Notify gadget that mouse has entered its space.
					  {
					    transit		=> gt::CAME,
					    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
					    event_point,
					    site		=> *gadget_imp_info.site,
					    theme
					  };
					guiboss_to_gadget.note_mouse_transit					# Notify gadget that mouse has entered its space.
					  {
					    transit		=> gt::MOVE,					# We send a MOVE after every CAME, for the convenience of handlers interested only in coordinates -- they can process all MOVE events and ignore CAME and LEFT events.
					    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
					    event_point,
					    site		=> *gadget_imp_info.site,
					    theme
					  };

					mouse_is := gt::CROSSING_GADGET { gadget_imp_info };			# Remember which widget mouse is in.

				    };	

				gt::CROSSING_GADGET  { gadget_imp_info => (last_gadget_imp_info as { guiboss_to_gadget => last_guiboss_to_gadget, ... }) }
				    =>
				    if (gtj::same_gadget_imp_info (gadget_imp_info, last_gadget_imp_info))
					#									# Here mouse is continuing to move on same gadget it was on at last report.
					guiboss_to_gadget.note_mouse_transit					# Notify gadget that mouse has entered its space.
					  {
					    transit		=> gt::MOVE,								# 
					    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
					    event_point,
					    site		=> *gadget_imp_info.site,
					    theme
					  };

				    else									# Here mouse has crossed from one gadget to another.

					# Remember that last gadget no longer has mousefocus:
					#
				      (*last_gadget_imp_info.gadget_mode) -> { has_mouse_focus => _,     is_active, has_keyboard_focus };
					last_gadget_imp_info.gadget_mode  := { has_mouse_focus => FALSE, is_active, has_keyboard_focus };

					# Remember that new gadget now has mousefocus:
					#
				      (*gadget_imp_info.gadget_mode) -> { has_mouse_focus => _,    is_active, has_keyboard_focus };
					gadget_imp_info.gadget_mode  := { has_mouse_focus => TRUE, is_active, has_keyboard_focus };


					last_guiboss_to_gadget.note_mouse_transit				# Notify last gadget that mouse has left its space.
					  {
					    transit		=> gt::LEFT,
					    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
					    event_point,
					    site		=> *last_gadget_imp_info.site,
					    theme
					  };

					mouse_is := gt::CROSSING_GADGET { gadget_imp_info };			# Remember that we're now on the new gadget.
					#
					guiboss_to_gadget.note_mouse_transit					# Notify new gadget that mouse has entered its space.
					  {
					    transit		=> gt::CAME,
					    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
					    event_point,
					    site		=> *gadget_imp_info.site,
					    theme
					  };
					guiboss_to_gadget.note_mouse_transit					# Notify gadget that mouse has entered its space.
					  {
					    transit		=> gt::MOVE,					# We send a MOVE after every CAME, for the convenience of handlers interested only in coordinates -- they can process all MOVE events and ignore CAME and LEFT events.
					    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
					    event_point,
					    site		=> *gadget_imp_info.site,
					    theme
					  };
				    fi;

				gt::DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
				    {
				      gadget_imp_info => dragged_gadget_imp_info,				# This is the gadget on which the drag started.  It gets all the MOVE events until drag terminates, even if mouse leaves the window area owned by the gadget. (But we only send DRAGs while cursor is in the dragged gadget.)
				      start_point,								# This is the window coordinate of the downclick which started this drag.
				      last_point								# This is the window coordinate of the last motion event for this drag.
				    }
				    =>
				    if (gtj::same_gadget_imp_info (gadget_imp_info, dragged_gadget_imp_info))	# If cursor is outside gadget in which drag started, we do absolutely nothing.
					#
					guiboss_to_gadget.note_mouse_drag_event					# 
					  {									# 
					    phase		=> gt::DRAG,
					    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
					    mousebuttons_state	=> motion_xevtinfo.mousebuttons_state,
					    event_point,
					    start_point,
					    last_point,
					    site		=> *gadget_imp_info.site,
					    theme
					  };

					mouse_is := gt::DRAGGING_IN_GADGET					# Remember location of last DRAG event.
						      {
							gadget_imp_info,					# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
							start_point,						# This is the window coordinate of the downclick which started this drag.
							last_point => event_point				# This is the window coordinate of the last DRAG event for this drag.
						      };
				    fi;
			    esac;
			};

		    NO_APPROPRIATE_GADGET event_point
			=> 
			{
			    mouse_is = topwindow_info.mouse_is;
			    #
			    case *mouse_is
				#
				gt::CROSSING_NONGADGET
				    =>
				    ();										# Nothing to do in this case.

				gt::CROSSING_GADGET  { gadget_imp_info }					# Should sent LEAVE event in this case.
				    =>
				    {	gadget_imp_info ->  { guiboss_to_gadget,
							      gadget_mode,
							      ...
							    };

					# Remember gadget no longer has mousefocus:
					#
				      (*gadget_mode) -> { has_mouse_focus => _,     is_active, has_keyboard_focus };
					gadget_mode  := { has_mouse_focus => FALSE, is_active, has_keyboard_focus };


					guiboss_to_gadget.note_mouse_transit					# Notify the gadget that we were on that mouse has left its space.
					  {
					    transit		=> gt::LEFT,
					    modifier_keys_state	=> motion_xevtinfo.modifier_keys_state,
					    event_point,
					    site		=> *gadget_imp_info.site,
					    theme
					  };

					mouse_is := gt::CROSSING_NONGADGET;
				    };

				gt::DRAGGING_IN_GADGET								# Mouse is being dragged on this gadget.
				    {
				      gadget_imp_info,								# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
				      start_point,								# This is the window coordinate of the downclick which started this drag.
				      last_point								# This is the window coordinate of the last motion event for this drag.
				    }
				    =>
				    ();										# Mouse is not in the gadget that was downclicked so we completely ignore the motion event.
			    esac;
			};
		esac;


	    fun do_button_press											# 
		  (
		    me:				gt::Guiboss_State,
		    theme:			wt::Widget_Theme,
		    topwindow_info:		gt::Topwindow_Info,
		    button_xevtinfo:		evt::Button_Xevtinfo
		  )
		=
		{
		    case (find_appropriate_gadget_imp_info (me, topwindow_info, button_xevtinfo.event_point))
			#
			APPROPRIATE_GADGET (gadget_imp_info, event_point)					# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no scrollports are involved).
			    =>
			    {
				mouse_is = topwindow_info.mouse_is;
				#
				gadget_imp_info -> { guiboss_to_gadget,
						     gadget_mode,
						     ...
						   };

				case *mouse_is
				    #
				    gt::CROSSING_NONGADGET
					=>
					{
					    # Remember gadget now has mousefocus:
					    #
					  (*gadget_mode) -> { has_mouse_focus => _,    is_active, has_keyboard_focus };
					    gadget_mode  := { has_mouse_focus => TRUE, is_active, has_keyboard_focus };

					    guiboss_to_gadget.note_mouse_transit				# Tell gadget that mouse has entered its space.
					      {
						transit		    => gt::CAME,
						modifier_keys_state => button_xevtinfo.modifier_keys_state,
						event_point,
						site		    => *gadget_imp_info.site,
						theme
					      };

					    guiboss_to_gadget.note_mouse_drag_event				# Tell gadget that user just started a drag operation on it.
					      {									# 
						phase		    => gt::OPEN,
						modifier_keys_state => button_xevtinfo.modifier_keys_state,
						mousebuttons_state  => button_xevtinfo.mousebuttons_state,
						event_point,
						start_point	    => event_point,
						last_point	    => event_point,
						site		    => *gadget_imp_info.site,
						theme
					      };

					    guiboss_to_gadget.note_mouse_drag_event				# We send a DRAG after every OPEN, for the convenience of handlers interested only in coordinates -- they can process all DRAG events and ignore OPEN and DONE events.
					      {									# 
						phase		    => gt::DRAG,
						modifier_keys_state => button_xevtinfo.modifier_keys_state,
						mousebuttons_state  => button_xevtinfo.mousebuttons_state,
						event_point,
						start_point	    => event_point,
						last_point	    => event_point,
						site		    => *gadget_imp_info.site,
						theme
					      };

					    mouse_is := gt::DRAGGING_IN_GADGET					# Remember which widget mouse is in. SHOULD GENERATE AN 'ENTER' HERE.
							  {
							    gadget_imp_info,
							    start_point => event_point,
							    last_point  => event_point
							  };
					    #
					};	

				    gt::CROSSING_GADGET  { gadget_imp_info => (last_gadget_imp_info as { guiboss_to_gadget => last_guiboss_to_gadget, ... }) }
					=>
					{
					    if (not (gtj::same_gadget_imp_info (gadget_imp_info, last_gadget_imp_info)))	# If we just left a gadget, tell it so.
						#

						# Remember that last gadget no longer has mousefocus:
						#
					      (*last_gadget_imp_info.gadget_mode) -> { has_mouse_focus => _,     is_active, has_keyboard_focus };
						last_gadget_imp_info.gadget_mode  := { has_mouse_focus => FALSE, is_active, has_keyboard_focus };

						# Remember that new gadget now has mousefocus:
						#
					      (*gadget_imp_info.gadget_mode) -> { has_mouse_focus => _,    is_active, has_keyboard_focus };
						gadget_imp_info.gadget_mode  := { has_mouse_focus => TRUE, is_active, has_keyboard_focus };

						last_guiboss_to_gadget.note_mouse_transit			# Notify last gadget that we were on that mouse has left its space.
						  {
						    transit		=> gt::LEFT,
						    modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *last_gadget_imp_info.site,
						    theme
						  };

						guiboss_to_gadget.note_mouse_transit				# Notify new gadget that mouse has entered its space.
						  {
						    transit		=> gt::CAME,
						    modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_imp_info.site,
						    theme
						  };
					    fi;

					    guiboss_to_gadget.note_mouse_drag_event				# Tell gadget that user just started a drag operation on it.
					      {									# 
						phase		    => gt::OPEN,
						modifier_keys_state => button_xevtinfo.modifier_keys_state,
						mousebuttons_state  => button_xevtinfo.mousebuttons_state,
						event_point,
						start_point	    => event_point,
						last_point	    => event_point,
						site		    => *gadget_imp_info.site,
						theme
					      };

					    guiboss_to_gadget.note_mouse_drag_event				# We send a DRAG after every OPEN, for the convenience of handlers interested only in coordinates -- they can process all DRAG events and ignore OPEN and DONE events.
					      {									# 
						phase		    => gt::DRAG,
						modifier_keys_state => button_xevtinfo.modifier_keys_state,
						mousebuttons_state  => button_xevtinfo.mousebuttons_state,
						event_point,
						start_point	    => event_point,
						last_point	    => event_point,
						site		    => *gadget_imp_info.site,
						theme
					      };

					    mouse_is := gt::DRAGGING_IN_GADGET					# Remember which widget mouse is in.
							  {
							    gadget_imp_info,
							    start_point => event_point,
							    last_point  => event_point
							  };
					    #
					};	

				    gt::DRAGGING_IN_GADGET							# Mouse is being dragged on this gadget.
					{
					  gadget_imp_info => draggee,						# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
					  start_point,								# This is the window coordinate of the downclick which started this drag.
					  last_point								# This is the window coordinate of the last motion event for this drag.
					}
					=>
					if (gtj::same_gadget_imp_info (gadget_imp_info, draggee))		# If we are still on the gadget being dragged...
					    #
					    guiboss_to_gadget.note_mouse_drag_event				# Tell the gadget where the mouse now is.
					      {									# 
						phase		    => gt::DRAG,
						modifier_keys_state => button_xevtinfo.modifier_keys_state,
						mousebuttons_state  => button_xevtinfo.mousebuttons_state,
						event_point,
						start_point,
						last_point,
						site		    => *gadget_imp_info.site,
						theme
					      };

					    mouse_is := gt::DRAGGING_IN_GADGET					# Remember new 'last_point' for dragged gadget.
							      {
								gadget_imp_info,
								start_point,
								last_point  => event_point
							      };
					fi;
				esac;
				#	

				# Following note_mousebutton_event stuff is completely independent of drag/motion stuff.

				guiboss_to_gadget.note_mousebutton_event
				  {
				    mousebutton_event	=> gt::MOUSEBUTTON_PRESS,
				    mouse_button	=> button_xevtinfo.mouse_button,
				    modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
				    mousebuttons_state	=> button_xevtinfo.mousebuttons_state,
				    event_point,
				    site		=> *gadget_imp_info.site,
				    theme
				  };
			    };

			NO_APPROPRIATE_GADGET event_point
			    =>
			    {
				mouse_is = topwindow_info.mouse_is;
				#
				case *mouse_is
				    #
				    gt::CROSSING_NONGADGET
					=>
					();

				    gt::CROSSING_GADGET  { gadget_imp_info }
					=>
					{   gadget_imp_info -> { guiboss_to_gadget, gadget_mode, ... };
					    #

					    # Remember that gadget no longer has mousefocus:
					    #
					  (*gadget_mode) -> { has_mouse_focus => _,     is_active, has_keyboard_focus };
					    gadget_mode  := { has_mouse_focus => FALSE, is_active, has_keyboard_focus };

					    guiboss_to_gadget.note_mouse_transit				# Notify last gadget that we were on that mouse has left its space.
					      {
						transit		    => gt::LEFT,
						modifier_keys_state => button_xevtinfo.modifier_keys_state,
						event_point,
						site		    => *gadget_imp_info.site,
						theme
					      };

					    mouse_is := gt::CROSSING_NONGADGET;
					};	

				    gt::DRAGGING_IN_GADGET							# Mouse is being dragged on this gadget.
					{
					  gadget_imp_info => dragged_gadget_imp_info,				# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
					  start_point,								# This is the window coordinate of the downclick which started this drag.
					  last_point								# This is the window coordinate of the last motion event for this drag.
					}
					=>
					();									# When a drag is in progress, we do nothing if we are not on the dragged gadget.
				esac;
			    };
		    esac;
		};

	    fun do_button_release										# Private.
		  (
		    me:				gt::Guiboss_State,
		    theme:			wt::Widget_Theme,
		    topwindow_info:		gt::Topwindow_Info,
		    button_xevtinfo:		evt::Button_Xevtinfo
		  )
		=
		{
		    case (find_appropriate_gadget_imp_info (me, topwindow_info, button_xevtinfo.event_point))
			#
			APPROPRIATE_GADGET (gadget_imp_info, event_point)						# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no scrollports are involved).
			    =>
			    {	gadget_imp_info -> { guiboss_to_gadget, ... };
				#
				mouse_is = topwindow_info.mouse_is;

				case *mouse_is
				    #
				    gt::CROSSING_NONGADGET
					=>
					{   gadget_imp_info -> { guiboss_to_gadget,
								 gadget_mode,
								 ...
							       };
					    #

					    # Remember gadget now has mousefocus:
					    #
					  (*gadget_mode) -> { has_mouse_focus => _,    is_active, has_keyboard_focus };
					    gadget_mode  := { has_mouse_focus => TRUE, is_active, has_keyboard_focus };

					    guiboss_to_gadget.note_mouse_transit					# Notify new gadget that mouse has entered its space.
					      {
						transit		    => gt::CAME,
						modifier_keys_state => button_xevtinfo.modifier_keys_state,
						event_point,
						site		    => *gadget_imp_info.site,
						theme
					      };

					    mouse_is := gt::CROSSING_GADGET { gadget_imp_info };
					    #
					};	

				    gt::CROSSING_GADGET  { gadget_imp_info => gadget_imp_info2 }			# This case should not actually be possible...?  How can we be in gt::CROSSING_GADGET mode with a mousebutton down?
					=>
					if (not (gtj::same_gadget_imp_info (gadget_imp_info, gadget_imp_info2)))		# If we just left a gadget, tell it so.
					    #
					    gadget_imp_info2 -> { guiboss_to_gadget => guiboss_to_gadget2, ... };

					    # Remember that last gadget no longer has mousefocus:
					    #
					  (*gadget_imp_info2.gadget_mode) -> { has_mouse_focus => _,     is_active, has_keyboard_focus };
					    gadget_imp_info2.gadget_mode  := { has_mouse_focus => FALSE, is_active, has_keyboard_focus };

					    # Remember that new gadget now has mousefocus:
					    #
					  (*gadget_imp_info.gadget_mode) -> { has_mouse_focus => _,    is_active, has_keyboard_focus };
					    gadget_imp_info.gadget_mode  := { has_mouse_focus => TRUE, is_active, has_keyboard_focus };


					    guiboss_to_gadget2.note_mouse_transit				# Notify last gadget that we were on that mouse has left its space.
					      {
						transit	        => gt::LEFT,
						modifier_keys_state => button_xevtinfo.modifier_keys_state,
						event_point,
						site		=> *gadget_imp_info2.site,
						theme
					      };

					    guiboss_to_gadget.note_mouse_transit				# Notify new gadget that mouse has entered its space.
					      {
						transit		=> gt::CAME,
						modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
						event_point,
						site		=> *gadget_imp_info.site,
						theme
					      };

					    mouse_is := gt::CROSSING_GADGET { gadget_imp_info };
					fi;

				    gt::DRAGGING_IN_GADGET							# Mouse is being dragged on this gadget.
					{
					  gadget_imp_info => gadget_imp_info2,					# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
					  start_point,								# This is the window coordinate of the downclick which started this drag.
					  last_point								# This is the window coordinate of the last motion event for this drag.
					}
					=>
					{
					    buttons = button_xevtinfo.mousebuttons_state;
					    #
					    if (evt::pressed_mousebutton_count buttons == 1)			# 'buttons' is state BEFORE the release, so if pressed-button count is 1, all buttons are now released.
						#								# All mouse buttons are now released, so drag operation is over
						gadget_imp_info2 -> { guiboss_to_gadget => guiboss_to_gadget2, ... };

						guiboss_to_gadget2.note_mouse_drag_event			# Tell the drag gadget that drag operation is complete.
						  {								# 
						    phase		=> gt::DONE,
						    modifier_keys_state	=> button_xevtinfo.modifier_keys_state,
						    mousebuttons_state	=> button_xevtinfo.mousebuttons_state,
						    event_point,
						    start_point,
						    last_point,
						    site		=> *gadget_imp_info2.site,
						    theme
						  };

						if (not (gtj::same_gadget_imp_info (gadget_imp_info, gadget_imp_info2)))	# If we just left a gadget, tell it so.
						    #

						    # Remember that last gadget no longer has mousefocus:
						    #
						  (*gadget_imp_info2.gadget_mode) -> { has_mouse_focus => _,     is_active, has_keyboard_focus };
						    gadget_imp_info2.gadget_mode  := { has_mouse_focus => FALSE, is_active, has_keyboard_focus };

						    # Remember that new gadget now has mousefocus:
						    #
						  (*gadget_imp_info.gadget_mode) -> { has_mouse_focus => _,    is_active, has_keyboard_focus };
						    gadget_imp_info.gadget_mode  := { has_mouse_focus => TRUE, is_active, has_keyboard_focus };

						    guiboss_to_gadget2.note_mouse_transit			# Notify drag gadget that we were on that mouse has left its space.
						      {
							transit		    => gt::LEFT,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							event_point,
							site		    => *gadget_imp_info2.site,
							theme
						      };

						    guiboss_to_gadget.note_mouse_transit			# Notify new gadget that mouse has entered its space.
						      {
							transit		    => gt::CAME,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							event_point,
							site		    => *gadget_imp_info.site,
							theme
						      };
						fi;

						mouse_is := gt::CROSSING_GADGET { gadget_imp_info };		# Remember that drag operation is complete.

					    else								# We still have some mouse buttons down.

						if (gtj::same_gadget_imp_info (gadget_imp_info, gadget_imp_info2))		# If we are still on the drag gadget
						    #
						    guiboss_to_gadget.note_mouse_drag_event			# Update the drag gadget with mouse location and buttonstate.
						      {								# 
							phase		    => gt::DRAG,
							modifier_keys_state => button_xevtinfo.modifier_keys_state,
							mousebuttons_state  => button_xevtinfo.mousebuttons_state,
							event_point,
							start_point,
							last_point,
							site		    => *gadget_imp_info.site,
							theme
						      };
						fi;

						mouse_is := gt::DRAGGING_IN_GADGET				# Remember new 'last_point' for dragged gadget.
								  {
								    gadget_imp_info,
								    start_point,
								    last_point  => event_point
								  };
					    fi;
					};	
				esac;
				#	
				guiboss_to_gadget.note_mousebutton_event					# note_mousebutton_event is completely independent of drag/motion stuff.
				  {
				    mousebutton_event		=> gt::MOUSEBUTTON_RELEASE,
				    mouse_button		=> button_xevtinfo.mouse_button,
				    modifier_keys_state		=> button_xevtinfo.modifier_keys_state,
				    mousebuttons_state		=> button_xevtinfo.mousebuttons_state,
				    event_point,
				    site			=> *gadget_imp_info.site,
				    theme
				  };
			    };

			NO_APPROPRIATE_GADGET event_point
			    =>
			    {
				mouse_is = topwindow_info.mouse_is;
				#
				case *mouse_is
				    #
				    gt::CROSSING_NONGADGET
					=>
					();

				    gt::CROSSING_GADGET  { gadget_imp_info }
					=>
					{   gadget_imp_info -> { guiboss_to_gadget, gadget_mode, ... };
					    #

					    # Remember that gadget no longer has mousefocus:
					    #
					  (*gadget_mode) -> { has_mouse_focus => _,     is_active, has_keyboard_focus };
					    gadget_mode  := { has_mouse_focus => FALSE, is_active, has_keyboard_focus };

					    guiboss_to_gadget.note_mouse_transit				# Notify last gadget that we were on that mouse has left its space.
					      {
						transit	        => gt::LEFT,
						modifier_keys_state => button_xevtinfo.modifier_keys_state,
						event_point,
						site		=> *gadget_imp_info.site,
						theme
					      };

					    mouse_is := gt::CROSSING_NONGADGET;
					};	

				    gt::DRAGGING_IN_GADGET							# Mouse is being dragged on this gadget.
					{
					  gadget_imp_info,							# This is the gadget on which the drag started.  It gets all the motion events until drag terminates, even if mouse leaves the window area owned by the gadget.
					  start_point,								# This is the window coordinate of the downclick which started this drag.
					  last_point								# This is the window coordinate of the last motion event for this drag.
					}
					=>
					{   buttons = button_xevtinfo.mousebuttons_state;
					    #
					    gadget_imp_info -> { guiboss_to_gadget, gadget_mode, ... };

					    if (evt::pressed_mousebutton_count buttons == 1)			# Tell the drag gadget that drag operation is complete.
						#

						# Remember that gadget no longer has mousefocus:
						#
					      (*gadget_mode) -> { has_mouse_focus => _,     is_active, has_keyboard_focus };
						gadget_mode  := { has_mouse_focus => FALSE, is_active, has_keyboard_focus };

						guiboss_to_gadget.note_mouse_drag_event				# Notify the drag gadget that the drag operation is now complete.
						  {								# 
						    phase		=> gt::DONE,
						    modifier_keys_state => button_xevtinfo.modifier_keys_state,
						    mousebuttons_state  => button_xevtinfo.mousebuttons_state,
						    event_point		=> last_point,				# event_point is not within drag gadget, so re-use old point here. Apps probably should not use this value, but some will likely ignore the OPEN/DRAG/DONE flag and blindly process all event_points.
						    start_point,
						    last_point,
						    site		=> *gadget_imp_info.site,
						    theme
						  };

						guiboss_to_gadget.note_mouse_transit				# Notify drag gadget that mouse has left its space.
						  {
						    transit	        => gt::LEFT,
						    modifier_keys_state => button_xevtinfo.modifier_keys_state,
						    event_point,
						    site		=> *gadget_imp_info.site,
						    theme
						  };

						mouse_is := gt::CROSSING_NONGADGET;
					    fi;									# No 'else' here because as long as we're dragging we generate no Gadget_Transit events.
					};
				esac;
			    };											# NO_APPROPRIATE_GADGET case._
		    esac;
		};

	    fun do_key_press											# Private.
		  (
		    me:				gt::Guiboss_State,
		    theme:			wt::Widget_Theme,
		    topwindow_info:		gt::Topwindow_Info,
		    key_xevtinfo:		evt::Key_Xevtinfo
		  )
		=
		{
		    case (find_appropriate_gadget_imp_info (me, topwindow_info, key_xevtinfo.event_point))
			#
			APPROPRIATE_GADGET (gadget_imp_info, event_point)					# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no scrollports are involved).
			    =>
			    {
				gadget_imp_info -> { guiboss_to_gadget, ... };
				#
				guiboss_to_gadget.note_key_event
				  {
				    key_event		=> gt::KEY_PRESS,
				    keycode		=> key_xevtinfo.keycode,
				    keysym		=> key_xevtinfo.keysym,
				    string		=> key_xevtinfo.ascii,
				    modifier_keys_state	=> key_xevtinfo.modifier_keys_state,
				    mousebuttons_state	=> key_xevtinfo.mousebuttons_state,
				    event_point,
				    site		=> *gadget_imp_info.site,
				    theme
				  };	
			    };

			NO_APPROPRIATE_GADGET _
			    =>
			    {
			    };
		    esac;
		};

	    fun do_key_release											# Private.
		  (
		    me:				gt::Guiboss_State,
		    theme:			wt::Widget_Theme,
		    topwindow_info:		gt::Topwindow_Info,
		    key_xevtinfo:		evt::Key_Xevtinfo
		  )
		=
		{
		    case (find_appropriate_gadget_imp_info (me, topwindow_info, key_xevtinfo.event_point))
			#
			APPROPRIATE_GADGET (gadget_imp_info, event_point)					# 'event_point' is button_xevtinfo.event_point transformed into correct coordinate system for gadget (null transform if no scrollports are involved).
			    =>
			    {	gadget_imp_info -> { guiboss_to_gadget, ... };
				#
				guiboss_to_gadget.note_key_event
				  {
				    key_event		=> gt::KEY_RELEASE,
				    keycode		=> key_xevtinfo.keycode,
				    keysym		=> key_xevtinfo.keysym,
				    string		=> key_xevtinfo.ascii,
				    modifier_keys_state	=> key_xevtinfo.modifier_keys_state,
				    mousebuttons_state	=> key_xevtinfo.mousebuttons_state,
				    event_point,
				    site		=> *gadget_imp_info.site,
				    theme
				  };	
			    };

			NO_APPROPRIATE_GADGET _
			    =>
			    {
			    };
		    esac;
		};


	end;



	fun dispatch_event
	      (
		arg
		as
		  ( route:		a2r::Envelope_Route,
		    event:		evt::x::Event
		  ),
		me:			gt::Guiboss_State,
		theme:			wt::Widget_Theme,
		topwindow_info:		gt::Topwindow_Info
	      )
	    =
	    case event
		#
		evt::x::KEY_PRESS       (key_xevtinfo:    evt::Key_Xevtinfo   ) =>  do_key_press      (me, theme, topwindow_info, key_xevtinfo   );
		evt::x::KEY_RELEASE     (key_xevtinfo:    evt::Key_Xevtinfo   ) =>  do_key_release    (me, theme, topwindow_info, key_xevtinfo   );
		evt::x::BUTTON_PRESS    (button_xevtinfo: evt::Button_Xevtinfo) =>  do_button_press   (me, theme, topwindow_info, button_xevtinfo);
		evt::x::BUTTON_RELEASE  (button_xevtinfo: evt::Button_Xevtinfo) =>  do_button_release (me, theme, topwindow_info, button_xevtinfo);
		evt::x::MOTION_NOTIFY   (motion_xevtinfo: evt::Motion_Xevtinfo) =>  do_motion_notify  (me, theme, topwindow_info, motion_xevtinfo);

		evt::x::ENTER_NOTIFY    (inout_xevtinfo: evt::Inout_Xevtinfo  )
		    =>
		    {
#			printf "guievent_sink()/ENTER_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
		    };

		evt::x::LEAVE_NOTIFY    (inout_xevtinfo: evt::Inout_Xevtinfo)
		    =>
		    {
#			printf "guievent_sink()/LEAVE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
		    };

		evt::x::FOCUS_IN	(focus_xevtinfo: evt::Focus_Xevtinfo)
		    =>
		    printf "guievent_sink()/FOCUS_IN: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::FOCUS_OUT	(focus_xevtinfo:  evt::Focus_Xevtinfo)
		    =>
		    printf "guievent_sink()/FOCUS_OUT: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::KEYMAP_NOTIFY    { }
		    =>
		    printf "guievent_sink()/KEYMAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::EXPOSE           (expose_record:         evt::x::Expose_Record)
		    =>
		    printf "guievent_sink()/EXPOSE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::GRAPHICS_EXPOSE  (graphics_expose_record: evt::x::Graphics_Expose_Record)
		    =>
		    printf "guievent_sink()/GRAPHICS_EXPOSE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::NO_EXPOSE
		  { drawable:		evt::Drawable_Id,
		    major_opcode:		Unt,						# The graphics operation code.
		    minor_opcode:		Unt						# Always 0 for core protocol.
		  }
		    =>
		    printf "guievent_sink()/NO_EXPOSE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::VISIBILITY_NOTIFY
		  { changed_window_id:	evt::Window_Id,						# The window with changed visibility state.
		    state:			evt::Visibility					# The new visibility state.
		  }
		    =>
		    printf "guievent_sink()/VISIBILITY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::CREATE_NOTIFY
		  { parent_window_id:	evt::Window_Id,						# The created window's parent.
		    created_window_id:	evt::Window_Id,						# The created window.
		    box:			g2d::Box,					# The window's rectangle.
		    border_wid:		Int,							# The width of the border.
		    override_redirect:	Bool							#  
		  }
		    =>
		    printf "guievent_sink()/CREATE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::DESTROY_NOTIFY
		  { event_window_id:	evt::Window_Id,						# The window on which this was generated.
		    destroyed_window_id:	evt::Window_Id					# The destroyed window.
		  }
		    =>
		    printf "guievent_sink()/DESTROY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::UNMAP_NOTIFY
		  { event_window_id:	evt::Window_Id,						# The window on which this was generated.
		    unmapped_window_id:	evt::Window_Id,						# The window being unmapped.
		    from_config:		Bool						# TRUE if parent was resized.
		  }
		    =>
		    printf "guievent_sink()/UNMAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::MAP_NOTIFY
		  { event_window_id:	evt::Window_Id,						# The window on which this was generated.
		    mapped_window_id:	evt::Window_Id,						# The window being mapped.
		    override_redirect:	Bool							#  
		  }
		    =>
		    printf "guievent_sink()/MAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::MAP_REQUEST
		  { parent_window_id:	evt::Window_Id,						# The parent.
		    mapped_window_id:	evt::Window_Id						# The mapped window.
		  }
		    =>
		    printf "guievent_sink()/MAP_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::REPARENT_NOTIFY
		  { event_window_id:	evt::Window_Id,						# The window on which this was generated.
		    parent_window_id:      	evt::Window_Id,					# The new parent.
		    rerooted_window_id:    	evt::Window_Id,					# The re-rooted window.
		    upperleft_corner:	g2d::Point,						# The upper-left corner.
		    override_redirect:	Bool							#  
		  }
		    =>
		    printf "guievent_sink()/REPARENT_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::CONFIGURE_NOTIFY
		  { event_window_id:       	evt::Window_Id,					# The window on which this was generated.
		    configured_window_id:	evt::Window_Id,					# The reconfigured window.
		    sibling_window_id:	Null_Or(evt::Window_Id),				# The sibling that window is above (if any).
		    box:			g2d::Box,					# The window's rectangle.
		    border_wid:  		Int,						# The width of the border.
		    override_redirect:	Bool							#  
		  }
		    =>
		    {
			printf "guievent_sink()/CONFIGURE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);
		    };

		evt::x::CONFIGURE_REQUEST
		  { parent_window_id:	evt::Window_Id,						# The parent.
		    configure_window_id:	evt::Window_Id,					# The window to reconfigure.
		    sibling_window_id:  	Null_Or(evt::Window_Id),			# The new sibling (if any).
		    x:           		Null_Or(Int),					# The window's rectangle.
		    y:           		Null_Or(Int),
		    wide:        		Null_Or(Int),
		    high:        		Null_Or(Int),
		    border_wid:  		Null_Or(Int),					# The width of the border.
		    stack_mode: 		Null_Or(evt::Stack_Mode)			# The mode for stacking windows.
		  }
		    =>
		    printf "guievent_sink()/CONFIGURE_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::GRAVITY_NOTIFY
		  {
		    event_window_id:	evt::Window_Id,						# The window on which this was generated.
		    moved_window_id:   	evt::Window_Id,						# The window being moved.
		    upperleft_corner:	g2d::Point						# Upper-left corner of window.
		  }		
		    =>
		    printf "guievent_sink()/GRAVITY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::RESIZE_REQUEST
		  {
		    resize_window_id:	evt::Window_Id,						# The window to resize.
		    req_size:		g2d::Size						# The requested new size.
		  }
		    =>
		    printf "guievent_sink()/RESIZE_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::CIRCULATE_NOTIFY
		  {
		    event_window_id:	evt::Window_Id,						# The window on which this was generated.
		    circulated_window_id:	evt::Window_Id,					# The window being circulated.
		    parent_window_id:	evt::Window_Id,						# The parent.
		    place:			evt::Stack_Pos					# The new place.
		  }
		    =>
		    printf "guievent_sink()/CIRCULATE_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::CIRCULATE_REQUEST
		  {
		    parent_window_id:	evt::Window_Id,						# The parent.
		    circulate_window_id:	evt::Window_Id,					# The window to circulate.
		    place:			evt::Stack_Pos					# The place to circulate the window to.
		  }
		    =>
		    printf "guievent_sink()/CIRCULATE_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::PROPERTY_NOTIFY
		  {
		    changed_window_id:	evt::Window_Id,						# The window with the changed property.
		    atom:        		evt::Atom,					# The affected property.
		    timestamp:  		evt::t::Xserver_Timestamp,			# When the property was changed.
		    deleted:     		Bool						# TRUE if the property was deleted.
		  }
		    =>
		    printf "guievent_sink()/PROPERTY_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::SELECTION_CLEAR
		  {
		    owning_window_id:	evt::Window_Id,						# The current owner of the selection.
		    selection:		evt::Atom,						# The selection.
		    timestamp:		evt::t::Xserver_Timestamp				# The last-change time.
		  }		
		    =>
		    printf "guievent_sink()/SELECTION_CLEAR: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::SELECTION_REQUEST
		  {
		    owning_window_id:	evt::Window_Id,						# The owner of the selection.
		    selection:		evt::Atom,						# The selection.
		    target:			evt::Atom,					# The requested type for the selection.
		    requesting_window_id:	evt::Window_Id,					# The requesting window.
		    property:		Null_Or( evt::Atom ),					# The property to store the selection in. 
		    timestamp:		evt::Timestamp						#  
		  }
		    =>
		    printf "guievent_sink()/SELECTION_REQUEST: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::SELECTION_NOTIFY
		  {
		    requesting_window_id:	evt::Window_Id,					# The requestor of the selection.
		    selection:		evt::Atom,						# The selection.
		    target:			evt::Atom, 					# The requested type of the selection.
		    property:		Null_Or( evt::Atom ),					# The property to store the selection in.
		    timestamp:		evt::Timestamp  					#  
		  }
		    =>
		    printf "guievent_sink()/SELECTION_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::COLORMAP_NOTIFY
		  {
		    window_id:		evt::Window_Id,						# The affected window.
		    cmap:			Null_Or( evt::Colormap_Id ),			# The colormap.
		    new:			Bool,						# TRUE, if the colormap attribute is changed.
		    installed: 		Bool							# TRUE, if the colormap is installed.
		  }
		    =>
		    printf "guievent_sink()/COLORMAP_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::CLIENT_MESSAGE
		  {
		    window_id:		evt::Window_Id,						#  
		    type:			evt::Atom,					# The type of the message.
		    value:			evt::Raw_Data					# The message value.
		  }
		    =>
		    printf "guievent_sink()/CLIENT_MESSAGE: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::MODIFIER_MAPPING_NOTIFY							# Really a MappingNotify event.
		    =>
		    printf "guievent_sink()/MODIFIER_MAPPING_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::KEYBOARD_MAPPING_NOTIFY							# Really a MappingNotify event.
		  {
		    first_keycode:  	evt::Keycode,
		    count:          	Int
		  }
		    =>
		    printf "guievent_sink()/KEYBOARD_MAPPING_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

		evt::x::POINTER_MAPPING_NOTIFY							# Really a MappingNotify event.
		    =>
		    printf "guievent_sink()/POINTER_MAPPING_NOTIFY: ignoring '%s' Gui_Event    -- guiboss-imp.pkg\n" (gts::gui_event_to_string event);

	    esac;										# NB: We avoid a '_' case here because if an event is added to evt::x::Event we want a compile error as a reminder to handle it.
    };
end;





##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
