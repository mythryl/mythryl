## guiboss-imp.pkg
#
# For the big picture see the imp dataflow diagrams in
#
#     src/lib/x-kit/xclient/src/window/xclient-ximps.pkg
#
# The vision here is to implement a simple, flexible, easy-to-customize
# GUI widget infrastructure portable to various rendering layers like
# X, OpenGL and javascript.  The allow small teams to efficiently develop
# (for example) GUI-driven custom scientific, stock-trading and programming
# support apps.  As such, the emphasis is on simplicity, portability,
# cleanliness, smooth integration with Mythryl facilities such as the
# type system, garbage collector and package system.  Competing with
# commercial GUI toolkits for glitter factor is NOT a priority.
#
# guiboss_imp is the master imp responsible for starting up and shutting
# down running GUIs.
#
# Most of its major types and supporting code for handling them is in
#     src/lib/x-kit/widget/gui/guiboss-types.pkg
#
# guiboss_imp GUIs divide into three types of spaces:
#     widgetspace, for conventional row/column widget layout.
#     objectspace, for draw and paint functionality and also
#                  free-form drop-and-drag knob-and-tube GUIs.
#     spritespace, for 2D (and eventually 3D) animation.
#
# At the moment (2014-11-20) only widgetspace is at all well developed.
#
# guiboss_imp delegates management of these three kinds of spaces
# (in particular widget layout) to
#     src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg
#     src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
#     src/lib/x-kit/widget/space/object/objectspace-imp.pkg
#  
# guiboss_imp is designed to be portable, but at the moment the only
# rendering layer implemented is for X, using the interface exported by
#     src/lib/x-kit/widget/xkit/app/guishim-imp-for-x.pkg
#  
# We refer to mouse-sensitive controls as "gadgets".
# Each of our three spaces has its own flavor of gadget:
#     widgetspace: Widgets, base implementation being   src/lib/x-kit/widget/xkit/theme/widget/default/look/widget-imp.pkg
#     objectsapce: Objects, base implementation being   src/lib/x-kit/widget/xkit/theme/widget/default/look/object-imp.pkg
#     spritespace: Sprites, base implementation being   src/lib/x-kit/widget/xkit/theme/widget/default/look/sprite-imp.pkg
#     

# Compiled by:
#     src/lib/x-kit/widget/xkit-widget.sublib


stipulate
    include package   threadkit;				# threadkit				is from   src/lib/src/lib/thread-kit/src/core-thread-kit/threadkit.pkg
    #
#   package ap  =  client_to_atom;				# client_to_atom			is from   src/lib/x-kit/xclient/src/iccc/client-to-atom.pkg
#   package au  =  authentication;				# authentication			is from   src/lib/x-kit/xclient/src/stuff/authentication.pkg
#   package cpm =  cs_pixmap;					# cs_pixmap				is from   src/lib/x-kit/xclient/src/window/cs-pixmap.pkg
#   package cpt =  cs_pixmat;					# cs_pixmat				is from   src/lib/x-kit/xclient/src/window/cs-pixmat.pkg
#   package dy  =  display;					# display				is from   src/lib/x-kit/xclient/src/wire/display.pkg
#   package fil =  file__premicrothread;			# file__premicrothread			is from   src/lib/std/src/posix/file--premicrothread.pkg
#   package fti =  font_index;					# font_index				is from	  src/lib/x-kit/xclient/src/window/font-index.pkg
#   package r2k =  xevent_router_to_keymap;			# xevent_router_to_keymap		is from   src/lib/x-kit/xclient/src/window/xevent-router-to-keymap.pkg
#   package mtx =  rw_matrix;					# rw_matrix				is from   src/lib/std/src/rw-matrix.pkg
#   package rop =  ro_pixmap;					# ro_pixmap				is from   src/lib/x-kit/xclient/src/window/ro-pixmap.pkg
#   package rw  =  root_window;					# root_window				is from   src/lib/x-kit/widget/lib/root-window.pkg
#   package rwv =  rw_vector;					# rw_vector				is from   src/lib/std/src/rw-vector.pkg
#   package sep =  client_to_selection;				# client_to_selection			is from   src/lib/x-kit/xclient/src/window/client-to-selection.pkg
#   package shp =  shade;					# shade					is from   src/lib/x-kit/widget/lib/shade.pkg
#   package sj  =  socket_junk;					# socket_junk				is from   src/lib/internet/socket-junk.pkg
#   package x2s =  xclient_to_sequencer;			# xclient_to_sequencer			is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
#   package tr  =  logger;					# logger				is from   src/lib/src/lib/thread-kit/src/lib/logger.pkg
#   package tsr =  thread_scheduler_is_running;			# thread_scheduler_is_running		is from   src/lib/src/lib/thread-kit/src/core-thread-kit/thread-scheduler-is-running.pkg
#   package u1  =  one_byte_unt;				# one_byte_unt				is from   src/lib/std/one-byte-unt.pkg
#   package v1u =  vector_of_one_byte_unts;			# vector_of_one_byte_unts		is from   src/lib/std/src/vector-of-one-byte-unts.pkg
#   package v2w =  value_to_wire;				# value_to_wire				is from   src/lib/x-kit/xclient/src/wire/value-to-wire.pkg
#   package wg  =  widget;					# widget				is from   src/lib/x-kit/widget/old/basic/widget.pkg
#   package wi  =  window;					# window				is from   src/lib/x-kit/xclient/src/window/window.pkg
#   package wme =  window_map_event_sink;			# window_map_event_sink			is from   src/lib/x-kit/xclient/src/window/window-map-event-sink.pkg
#   package wpp =  client_to_window_watcher;			# client_to_window_watcher		is from   src/lib/x-kit/xclient/src/window/client-to-window-watcher.pkg
#   package wy  =  widget_style;				# widget_style				is from   src/lib/x-kit/widget/lib/widget-style.pkg
#   package xc  =  xclient;					# xclient				is from   src/lib/x-kit/xclient/xclient.pkg
#   package xj  =  xsession_junk;				# xsession_junk				is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
#   package xtr =  xlogger;					# xlogger				is from   src/lib/x-kit/xclient/src/stuff/xlogger.pkg
    #

    #
    package gtr =  translate_guiplan_to_guipane;		# translate_guiplan_to_guipane		is from   src/lib/x-kit/widget/gui/translate-guiplan-to-guipane.pkg
    package ged =  guiboss_event_dispatch;			# guiboss_event_dispatch		is from   src/lib/x-kit/widget/gui/guiboss-event-dispatch.pkg
    package evt =  gui_event_types;				# gui_event_types			is from   src/lib/x-kit/widget/gui/gui-event-types.pkg
    package gts =  gui_event_to_string;				# gui_event_to_string			is from   src/lib/x-kit/widget/gui/gui-event-to-string.pkg
    package gt  =  guiboss_types;				# guiboss_types				is from   src/lib/x-kit/widget/gui/guiboss-types.pkg
    package gtj =  guiboss_types_junk;				# guiboss_types_junk			is from   src/lib/x-kit/widget/gui/guiboss-types-junk.pkg
    package gpj =  guiboss_popup_junk;				# guiboss_popup_junk			is from   src/lib/x-kit/widget/gui/guiboss-popup-junk.pkg
    package gwl =  guiboss_widget_layout;			# guiboss_widget_layout			is from   src/lib/x-kit/widget/gui/guiboss-widget-layout.pkg

    package a2r =  windowsystem_to_xevent_router;		# windowsystem_to_xevent_router		is from   src/lib/x-kit/xclient/src/window/windowsystem-to-xevent-router.pkg

    package gd  =  gui_displaylist;				# gui_displaylist			is from   src/lib/x-kit/widget/theme/gui-displaylist.pkg

    package pp  =  standard_prettyprint_mill;			# standard_prettyprint_mill		is from   src/lib/prettyprint/big/src/standard-prettyprint-mill.pkg
    package err =  error_message;				# error_message				is from   src/lib/compiler/front/basics/errormsg/error-message.pkg

    package bt  =  gui_to_sprite_theme;				# gui_to_sprite_theme			is from   src/lib/x-kit/widget/theme/sprite/gui-to-sprite-theme.pkg
    package ct  =  gui_to_object_theme;				# gui_to_object_theme			is from   src/lib/x-kit/widget/theme/object/gui-to-object-theme.pkg
    package wt  =  widget_theme;				# widget_theme				is from   src/lib/x-kit/widget/theme/widget/widget-theme.pkg

    package boi =  spritespace_imp;				# spritespace_imp			is from   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
    package cai =  objectspace_imp;				# objectspace_imp			is from   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
    package pai =  widgetspace_imp;				# widgetspace_imp			is from   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg

    #    
    package gtg =  guiboss_to_guishim;				# guiboss_to_guishim			is from   src/lib/x-kit/widget/theme/guiboss-to-guishim.pkg

    package b2s =  spritespace_to_sprite;			# spritespace_to_sprite			is from   src/lib/x-kit/widget/space/sprite/spritespace-to-sprite.pkg
    package c2o =  objectspace_to_object;			# objectspace_to_object			is from   src/lib/x-kit/widget/space/object/objectspace-to-object.pkg

    package s2s =  sprite_to_spritespace;			# sprite_to_spritespace			is from   src/lib/x-kit/widget/space/sprite/sprite-to-spritespace.pkg
    package o2o =  object_to_objectspace;			# object_to_objectspace			is from   src/lib/x-kit/widget/space/object/object-to-objectspace.pkg

#   package s2g =   space_to_gui;				# space_to_gui				is from   src/lib/x-kit/widget/gui/space-to-gui.pkg
    package g2p =  gadget_to_pixmap;				# gadget_to_pixmap			is from   src/lib/x-kit/widget/theme/gadget-to-pixmap.pkg

    package frm =  frame;					# frame					is from   src/lib/x-kit/widget/leaf/frame.pkg

    package iul =  issue_unique_look_id;			# issue_unique_look_id			is from   src/lib/x-kit/widget/gui/issue-unique-look-id.pkg

    package im  =  int_red_black_map;				# int_red_black_map			is from   src/lib/src/int-red-black-map.pkg
#   package is  =  int_red_black_set;				# int_red_black_set			is from   src/lib/src/int-red-black-set.pkg

    package r8  =  rgb8;					# rgb8					is from   src/lib/x-kit/xclient/src/color/rgb8.pkg
    package r64 =  rgb;						# rgb					is from   src/lib/x-kit/xclient/src/color/rgb.pkg
    package g2d =  geometry2d;					# geometry2d				is from   src/lib/std/2d/geometry2d.pkg
    package g2j =  geometry2d_junk;				# geometry2d_junk			is from   src/lib/std/2d/geometry2d-junk.pkg

    package ebi =  editboss_imp;				# editboss_imp				is from   src/lib/x-kit/widget/edit/editboss-imp.pkg
    package e2g =  editboss_to_guiboss;				# editboss_to_guiboss			is from   src/lib/x-kit/widget/edit/editboss-to-guiboss.pkg

    package t2t =  texteditor_to_textbuffer;			# texteditor_to_textbuffer		is from   src/lib/x-kit/widget/edit/texteditor-to-textbuffer.pkg
#   package tbi =  textbuffer_imp;				# textbuffer_imp			is from   src/lib/x-kit/widget/edit/textbuffer-imp.pkg

    package rtx =  translate_guipane_to_guipith;		# translate_guipane_to_guipith		is from   src/lib/x-kit/widget/gui/translate-guipane-to-guipith.pkg

    tracefile   =  "widget-unit-test.trace.log";

    nb = log::note_on_stderr;					# log					is from   src/lib/std/src/log.pkg

Dummy1 = ebi::Editboss_Option;				# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
dummy2 = rtx::guipane__to__guipith;			# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy3 = gwl::Dummy;					# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy4 = gpj::Dummy;					# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.
Dummy5 = popupframe::App_To_Popupframe;			# XXX SUCKO DELETEME. This is a quick hack to make sure the package compiles during early development of it.

herein

    package guiboss_imp
    :       Guiboss_Imp													# Guiboss_Imp		is from   src/lib/x-kit/widget/gui/guiboss-imp.api
    {
	Client_To_Guiboss
	  =
	  { id:			Id,											# Unique id to facilitate storing guiboss instances in indexed datastructures like red-black trees.
	    #
	    get_sprite_theme:	Void -> bt::Gui_To_Sprite_Theme,
	    get_object_theme:	Void -> ct::Gui_To_Object_Theme,
	    get_widget_theme:	Void -> wt::Widget_Theme,
	    #
	    make_topwindow:	 gtg::Topwindow_Hints			    ->  gtg::Guiboss_To_Topwindow,		# 
	    #
	    start_gui:		(gtg::Guiboss_To_Topwindow, gt::Guiplan)   -> (Void -> gt::Client_To_Guiwindow),	# Calling return value will block microthread until gui-plan    startup is complete.

# XXX SUCKO FIXME restart_gui should likely
# be phased out because
#  1) it is an added burden for widget-creators
#  2) it isn't being used and isn't debugged
#  3) Guipith seems to have taken over that
#     Paused_Gui's ecological niche and to be
#     a better approach.
# I'm currently waiting on this because I'm not
# yet 100% convinced that we won't find a good
# independent reason/need for Paused_Gui/restart_gui
# functionality.  -- 2015-02-10 CrT
	    restart_gui:	(gtg::Guiboss_To_Topwindow, gt::Paused_Gui) -> (Void -> gt::Client_To_Guiwindow)	# Calling return value will block microthread until stopped-gui restart is complete.
	  };

	Guiboss_Option
	  #
	  =  MICROTHREAD_NAME	String											# 
	  |  ID			Id											# Stable, unique id for imp.
	  ;	

	Guiboss_Arg =  List(Guiboss_Option);										# Currently no required component.

	Imports = {													# Ports we use, provided by other imps.
		    int_sink:			Int -> Void,
		    guiboss_to_guishim:		gtg::Guiboss_To_Guishim,	
		    gui_to_sprite_theme:	bt::Gui_To_Sprite_Theme,
		    gui_to_object_theme:	ct::Gui_To_Object_Theme,
		    theme:			wt::Widget_Theme
		  };


	Me_Slot = Mailslot( { imports:		Imports,
			      me:		gt::Guiboss_State,
			      guiboss_arg:	Guiboss_Arg,
			      run_gun':		Run_Gun,
			      end_gun':		End_Gun
			    }
			  );

	Exports	= {													# Ports we provide for use by other imps.
		    client_to_guiboss:	Client_To_Guiboss
		  };


	Guiboss_Egg =  Void -> (Exports,   (Imports, Run_Gun, End_Gun) -> Void);


	Runstate =    {													# These values will be statically globally visible throughout the code body for the imp.
			id:			Id,
			me:			gt::Guiboss_State,							# State which is preserved across imp shutdown/restart cycles.
			guiboss_arg:		Guiboss_Arg,
			gadget_to_editboss:	t2t::Gadget_To_Editboss,
			imports:		Imports,								# Imps to which we send requests.
			to:			Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
			end_gun':		End_Gun									# We shut down the microthread when this fires.
		      };

	Guiboss_Q    = Mailqueue( Runstate -> Void );


	fun run ( guiboss_q:			Guiboss_Q,								# 
		  #
		  runstate as
		  {													# These values will be statically globally visible throughout the code body for the imp.
		    me:				gt::Guiboss_State,							# State which is preserved across imp shutdown/restart cycles.
		    guiboss_arg:		Guiboss_Arg,
		    gadget_to_editboss:		t2t::Gadget_To_Editboss,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# 
		    id:				Id
		  }
		)
	    =
	    {	loop ();
	    }
	    where


		#
		fun loop ()												# Outer loop for the imp.
		    =
		    {   do_one_mailop' to [
			    #
			    end_gun'                       ==>  shut_down_guiboss_imp',
			    take_from_mailqueue' guiboss_q ==>  do_guiboss_plea
			];

			loop ();
		    }	
		    where
			fun do_guiboss_plea  thunk
			    =
			    thunk runstate;
			#
			fun shut_down_guiboss_imp' ()
			    =
			    {
				thread_exit { success => TRUE };							# Will not return.	
			    };
		    end;
	    end;	

	#
	fun kill_gui'
	      (
		runstate as
		{ me:				gt::Guiboss_State,							# State which is preserved across imp shutdown/restart cycles.
		  guiboss_arg:			Guiboss_Arg,
		  gadget_to_editboss:		t2t::Gadget_To_Editboss,
		  imports:			Imports,								# Imps to which we send requests.
		  to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		  end_gun':			End_Gun,								# 
		  id:				Id
		}:				Runstate,
		( guipane:			gt::Guipane,
		  topwindow_info:		gt::Topwindow_Info,
		  redraw_window_when_done:	Bool
		)
	      )
	    =
	    {	# Recursively kill off all running guis
		# which are children of current running gui:
		#
		case guipane.subwindow_info
		    #
		    gt::SUBWINDOW_DATA r
			=>
			apply kill_one_subgui *r.popups
			where
			    fun kill_one_subgui (subwindow_info: gt::Subwindow_Data)
				=
				case subwindow_info
				    #
				    gt::SUBWINDOW_DATA r
					=>
					case *r.guipane
					    #
					    THE guipane => kill_gui' (runstate, (guipane, topwindow_info, FALSE));

					    NULL => ();
					esac;
				esac;
			end;
		esac;
		

		gpj::kill__guipane__imps        (guipane, me);
		gpj::free__guipane__resources   (guipane, me);

		case guipane.subwindow_info
		    #
		    gt::SUBWINDOW_DATA r
			=>
			{   # If we have a parent, remove ourself from parent's list of active popups:
			    #	
			    case r.parent
				#
				THE parent_subwindow_info
				    =>
				    # We do have a parent -- remove ourself from parent's list of active popups:
				    #	
				    case parent_subwindow_info
					#
					gt::SUBWINDOW_DATA q
					    =>
					    q.popups := list::remove  is_us  *q.popups
							where
							    fun is_us (bp: gt::Subwindow_Data)
								=
								case bp
								    #
								    gt::SUBWINDOW_DATA r'
									=>
									same_id (r.pixmap.id, r'.pixmap.id);
								esac;
							end;
				    esac;

				NULL =>
				    {
					();
				    };
			    esac;
			};
		esac;

		case guipane.subwindow_info										# If we're the toplevel gui, remember we no longer have a gui running on this topwindow.
		    #
		    gt::SUBWINDOW_DATA r
			=>
			case r.parent
			    #
			    NULL  =>    topwindow_info.subwindow_info :=  NULL;						# We're killing the toplevel gui for this topwindow so remember that we no longer have a gui running on this topwindow.
			    THE _ =>    ();										# We're pausing a secondary popup gui for this topwindow.
			esac;
		esac;

		case *topwindow_info.subwindow_info									# Redraw the window if there are any running guis left to redraw.
		    #
		    THE subwindow_info
			=>		
			{
 			    gwl::redraw_all_guipanes
 			      (
 				subwindow_info,										# This provides redraw_all_guipanes an entrypoint into the remaining Subwindow_Or_View tree. Any Subwindow_Or_View in the tree would do.
 				topwindow_info.guiboss_to_topwindow
 			      );
			};

		    NULL =>												# No running guis left on window so clear it to black.
			case guipane.subwindow_info
			    #
			    gt::SUBWINDOW_DATA r
				=>
				{   entire_window =  g2d::box::make  (g2d::point::zero,  r.pixmap.size);
				    #	
				    midpoint      =  g2d::box::midpoint entire_window;

				    text	  =  [ gd::PUT_TEXT (gd::CENTERED_ON_POINT, [ gd::TEXT (midpoint, "No GUI running.") ]) ];
				    text	  =  [ gd::FONT ([ "-*-courier-bold-r-*-*-20-*-*-*-*-*-*-*", "9x15" ], text) ];

				    topwindow_info.guiboss_to_topwindow.draw_displaylist
				      [
					gd::COLOR (r64::black,  [ gd::FILLED_BOXES [ entire_window ]] ),
					gd::COLOR (r64::white,  text)
				      ];
				};
			esac;
		esac;
	    };


	#
	fun pause_gui'
	      (
		{ me:				gt::Guiboss_State,							# State which is preserved across imp shutdown/restart cycles.
		  guiboss_arg:			Guiboss_Arg,
		  gadget_to_editboss:		t2t::Gadget_To_Editboss,
		  imports:			Imports,								# Imps to which we send requests.
		  to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		  end_gun':			End_Gun,								# 
		  id:				Id
		}:				Runstate,
		( guipane:			gt::Guipane,
		  topwindow_info:		gt::Topwindow_Info
		)
	      )
	    =
	    {
		result =  gtr::guipane__to__paused_gui  (me, guipane);							# Return sufficient information to edit the GUI layout.

		gpj::kill__guipane__imps        (guipane, me);
		gpj::free__guipane__resources   (guipane, me);								# Should we be doing this?  We're not actually using pause_gui' these days, so this is all hypothetical.

		# Clear state which is only valid while a toplevel gui is running:
		#
		case guipane.subwindow_info
		    #
		    gt::SUBWINDOW_DATA r
			=>												# guipane is from
			{   case r.parent
				#
				NULL  =>    {   topwindow_info.subwindow_info	    :=  NULL;				# We're pausing the toplevel gui for this topwindow so remember that we no longer have a gui running on this topwindow.
					    };

				THE _ =>    ();										# We're pausing a secondary popup gui for this topwindow.
			    esac;
			};
		esac;

		result:				gt::Paused_Gui;
	    };														#


	fun make_subwindow_info_for_popup										# Create a g2p::Gadget_To_Rw_Pixmap instance, wrap it in a gt::SUBWINDOW_INFO, and enter the latter into the tree of SUBWINDOW_INFO.
	      (
		make_rw_pixmap:			g2d::Size -> g2p::Gadget_To_Rw_Pixmap,
		next_stacking_order: 		Ref(Int),
		parent:				gt::Subwindow_Data,
		site:				g2d::Box
	      )	
	    =
	    {   p = case parent     gt::SUBWINDOW_DATA p =>  p;
		    esac;
 

		(g2d::box::upperleft_and_size site)
		    ->
		    (origin as { row, col }, size as { high, wide }); 

		parent_size = p.pixmap.size;

		my (origin, size)											# Select actual site for popup.  We need it to fit entirely within parent.
		    =
		    {   row = max (row, 0);										# Let's start by ensuring that popup origin is not left of or above origin of parent coordinate system..
			col = max (col, 0);										#

			high = max (high, 1);										# Next let's make sure the requested size is positive...
			wide = max (wide, 1);										#

			high = min (high, parent_size.high);								# Now let's ensure that popup can in fact fit within parent.
			wide = min (wide, parent_size.wide);								# 

			row  = min (row, parent_size.high - high);							# Now slide the popup left and/or up as necessary to make it actually fit within parent.
			col  = min (col, parent_size.wide - wide);							#

			({ row, col },  { high, wide });								# That should do it!
		    };

		pixmap =  make_rw_pixmap  size;										# We're blocking for a round-trip here, which is not great.  We probably should implement imports.guiboss_to_guishim.pass_fresh_rw_pixmap to allow this to be nonblocking. XXX SUCKO FIXME

		stacking_order = *next_stacking_order;
		#
		next_stacking_order := stacking_order + 1;

		new_subwindow_info
		    =
		    gt::SUBWINDOW_DATA
		      {
			guipane		=>   REF NULL,
			pixmap,												# Main backing store for this running gui.
			popups		=>   REF ([]: List( gt::Subwindow_Data)),
			parent		=>   THE parent,
			origin		=>   REF origin,
			#
			stacking_order
		      };

		p.popups :=  new_subwindow_info ! *p.popups;								# Remember that parent subwindow has a new child subwindow.

		site = g2d::box::make (origin, size);

		(site, new_subwindow_info);
	    };


	#
	fun restart_gui'												# We actually only 'start' here, never 'restart', since the Pause_Gui idea was stillborn.
	      (
		runstate as
		  { me:				gt::Guiboss_State,							# State which is preserved across imp shutdown/restart cycles.
		    guiboss_arg:		Guiboss_Arg,
		    gadget_to_editboss:		t2t::Gadget_To_Editboss,
		    imports:			Imports,								# Imps to which we send requests.
		    to:				Replyqueue,								# The name makes   foo::pass_something(imp) to {. ... }   syntax read well.
		    end_gun':			End_Gun,								# We shut down the guiboss microthread when end_gun' fires.
		    id:				Id
		  }:				Runstate,
	
		topwindow_for_gui:		gtg::Guiboss_To_Topwindow,
		subwindow_info:			gt::Subwindow_Data,
		paused_gui:			gt::Paused_Gui,

		gui_startup_complete':		Oneshot_Maildrop( gt::Client_To_Guiwindow ),
		guiboss_q:			Guiboss_Q,
		pause_gui:			(gt::Guipane, gt::Topwindow_Info) -> gt::Paused_Gui,
		kill_gui:			(gt::Guipane, gt::Topwindow_Info) -> Void
	      )
	    =
	    {
		case subwindow_info
		    #
		    gt::SUBWINDOW_DATA r
			=>												# guipane is from
			{   r.guipane := THE guipane;									#      guipane = paused_gui__to__guipane  paused_gui;
			    #												# in below 'where' clause. so as to be available in make_popup().
			    case r.parent
				#
				NULL  =>    topwindow_info.subwindow_info :=  THE subwindow_info;			# We're starting a toplevel gui for this topwindow so remember that we now have a gui running on this topwindow.
				THE _ =>    ();										# We're starting a secondary popup gui for this topwindow.
			    esac;
			};
		esac;

		fire_run_gun ();

		topwindow_for_gui.pass_window_site to
		    #
		    (\\ ({ size => { high => topwindow_high, wide => topwindow_wide }, ... }: g2d::Window_Site)		# topwindow_high and topwindow_wide are currently unused, but you'd think we'd need them eventually.
			=
			{
			    my (high, wide)
				=
				case subwindow_info
				    #
				    gt::SUBWINDOW_DATA r
					=>
					{   r.pixmap.size -> { high, wide };
					    (high, wide);
					};
				esac;

			    site =  { col => 0,  high,									# Allocate all of window pixel area to widgets in guipane.rg_widget widget-tree.
				      row => 0,  wide
				    }
				    : g2d::Box;

			    apply  note_hint  (im::keyvals_list  widget_layout_hints)					# Add them to our global collection of layout hints.
				where
				    widget_layout_hints									# Collect gt:::Widget_Layout_Hint values for all widgets in new guipane.
					=
					gwl::gather_widget_layout_hints { me, guipane };

				    fun note_hint
					  ( id:		Int,
					    hint:	gt::Widget_Layout_Hint
					  )
					=
					me.widget_layout_hints :=  im::set (*me.widget_layout_hints, id, hint);
				end;

			    sites = gwl::lay_out_guipane								# Assign to each widget in given widget-tree a pixel-rectangle on which to draw itself, in window coordinates.
				      {
					me,
					site,										# This is the available window rectangle to divide between our widgets.
					rg_widget		=> guipane.rg_widget,					# This is the tree of widgets -- possibly a single leaf widget.
					subwindow_info		=> guipane.subwindow_info,
					widget_layout_hints	=> *me.widget_layout_hints
				      };

			    apply   do_site (im::vals_list sites)
				    where
					fun do_site (widget_site_info: gwl::Widget_Site_Info)
					    =
					    {   widget_site_info ->  { id, subwindow_or_view, site     };
						note_widget_site'    { id, subwindow_or_view, site, me };		# Sets 'needs_redraw_request' flag for widget if its site has changed.
					    };
				    end;

			    gtj::guipane_apply										# If a view pixmap is too small to fill its scrollport there will be undefined pixels showing in the scrollport.
			      (												# By setting the origin to its default 0,0 we trigger the logic to black out these undefined areas.
				guipane,										# Does doing so result in a double-draw of views at GUI startup?  If so, that might someday prove problematic: XXX QUERO FIXME
				[ gtj::RG_SCROLLPORT_FN
				    (\\ (arg: gt::Rg_Scrollport)
					=
					{   (*arg.scroller).set_scrollport_origin
						{ row => 0, col => 0 };
					}
				    )
				]
			      );

			    client_to_guiwindow
			      =
			      { id		=>  issue_unique_id (),
				pause_gui	=>  {. pause_gui (guipane, topwindow_info); },
				kill_gui	=>  {.  kill_gui (guipane, topwindow_info); }
			      }
			      : gt::Client_To_Guiwindow
			      ;

			    put_in_oneshot (gui_startup_complete', client_to_guiwindow);

# 			    guipane.guiboss_to_widgetspace.pass_re_siting_done_flag
# 				( site,
# 				  guipane.subwindow_info,
# 				  guipane.rg_widget,
# 				  *me.widget_layout_hints
# 				)
# 				to
# 				{.
# 				    gtj::guipane_apply									# If a view pixmap is too small to fill its scrollport there will be undefined pixels showing in the scrollport.
# 				      (											# By setting the origin to its default 0,0 we trigger the logic to black out these undefined areas.
# 					guipane,									# Does doing so result in a double-draw of views at GUI startup?  If so, that might someday prove problematic: XXX QUERO FIXME
# 					[ gtj::RG_SCROLLPORT_FN
# 					    (\\ (arg: gt::Rg_Scrollport)
# 						=
# 						{   (*arg.scroller).set_scrollport_origin
# 						        { row => 0, col => 0 };
# 						}
# 					    )
# 					]
# 				      );
# 
# 				    client_to_guiwindow
# 				      =
# 				      { id		=>  issue_unique_id (),
# 					pause_gui	=>  {. pause_gui (guipane, topwindow_info); },
# 					kill_gui	=>  {.  kill_gui (guipane, topwindow_info); }
# 				      }
# 				      : gt::Client_To_Guiwindow
# 				      ;
# 
# 				    put_in_oneshot (gui_startup_complete', client_to_guiwindow);
# 				}; 

			}
		    );
	    }
	    where
		we_are_a_popup_gui
		    =
		    case subwindow_info
			#
			gt::SUBWINDOW_DATA r
			    =>
			    {   case r.parent
				    #
				    NULL  =>    FALSE;									# We're starting the primary (toplevel) gui  for this topwindow.
				    THE _ =>    TRUE;									# We're starting a secondary popup gui for this topwindow.
				esac;
			    };
		    esac;

		(make_run_gun ()) ->   { run_gun', fire_run_gun };							# Run gun to start up widgets. We don't use an end_gun with them because they wander between guipane instances which start/stop independently, so it would be a mess.

		topwindow_info = im::get_or_raise_exception_not_found (*me.topwindows, id_to_int topwindow_for_gui.id)
				 except
				     NOT_FOUND = {   printf                "*me.topwindows contains no entry for topwindow %d?!   -- restart_gui' in guiboss-imp.pkg\n" (id_to_int topwindow_for_gui.id);
						     log::fatal (sprintf "*me.topwindows contains no entry for topwindow %d?!   -- restart_gui' in guiboss-imp.pkg" (id_to_int topwindow_for_gui.id));
						     raise exception NOT_FOUND;						# Execution will never reach this point, but the compiler doesn't know that log::fatal doesn't return.
						 };
		current_frame_number		=  topwindow_info.current_frame_number;
		seconds_per_frame		=  topwindow_info.seconds_per_frame;

		done_extra_redraw_request_this_frame
						=  topwindow_info.done_extra_redraw_request_this_frame;

		# We expect the following fns to capture the above values:
		# that is why we define them here rather than more globally.

		#


		fun set__needs_redraw_request__flag (i: gt::Gadget_Imp_Info)
		    =
		    {
			i.needs_redraw_request :=  TRUE;
		    };

		#################################################################################
		# space_to_gui interface fns:

		fun note_widget_site'
		      {
			id:			iul::Id,
			subwindow_or_view:	gt::Subwindow_Or_View,							# A widget can be located either directly on a subwindow, or via a scrollport (which is ultimately visible on a subwindow, possibly via aother scrollports).
			site:			g2d::Box,
			me:			gt::Guiboss_State
		      }													# PUBLIC.
		    =
		    {   i = gtj::get_gadget_imp_info (me.gadget_imps, id);
			#
			if (site != *i.site										# Has the window site of this widget changed?
			or   (not (same_id ( gtj::subwindow_or_view_id_of    subwindow_or_view,
					     gtj::subwindow_or_view_id_of *i.subwindow_or_view
			    ) )   )        )
			    #												# Yes.
			    i.site :=  site;										# Note site for widget.

			    i.subwindow_or_view :=  subwindow_or_view;							# Note pixmap for widget.

			    set__needs_redraw_request__flag i;
			fi;
		    };

		#
		fun note_widget_site											# PUBLIC.
		      {
			id:			iul::Id,
			subwindow_or_view:	gt::Subwindow_Or_View,							# A widget can be located either directly on a subwindow, or via a scrollport (which is ultimately visible on a subwindow, possibly via aother scrollports).
			site:			g2d::Box
		      }
		    =	
		    # This fn is called by
		    #
		    #   src/lib/x-kit/widget/space/sprite/spritespace-imp.pkg
		    #   src/lib/x-kit/widget/space/object/objectspace-imp.pkg
		    #   src/lib/x-kit/widget/space/widget/widgetspace-imp.pkg  
		    #
		    # when they assign a widget a new site in response to our call
		    #
		    #     guiboss_to_widgetspace.pass_re_siting_done_flag
		    #
		    put_in_mailqueue  (guiboss_q,
			#
			\\ ({ me, ... }: Runstate)
			    =
			    note_widget_site' { id, subwindow_or_view, site, me }
		    );

		space_to_gui =	      { id => topwindow_for_gui.id,							# Since each topwindow has a unique id and we will have only one space_to_gui per topwindow, using topwindow_for_gui.id
					#										# here ensures a unique id per space_to_gui. It also makes space_to_gui.id stable across gui stop/restart cycles.
					note_widget_site
				      };


		#################################################################################
		# widget_to_guiboss interface fns:
		#

		fun note_widget_layout_hint
		      {
			id:			iul::Id,
			widget_layout_hint:	gt::Widget_Layout_Hint
		      }
		    :				Void
		    =
		    put_in_mailqueue  (guiboss_q,
			#
			\\ ({ me, ... }: Runstate)
			    =
			    {   i		=  iul::id_to_int  id;
				#
				gadget_imp_info =  gtj::get_gadget_imp_info  (me.gadget_imps, id);

				need_re_layout_and_redraw
				    =
				    case  (im::get (*me.widget_layout_hints, i))
					#
					NULL                =>  TRUE;
					THE old_layout_hint =>  widget_layout_hint != old_layout_hint;
				    esac;

				if need_re_layout_and_redraw
				    #
				    me.widget_layout_hints
					:=
					im::set   (*me.widget_layout_hints, i, widget_layout_hint);

				    case (gtj::find__guipane__containing_gadget  gadget_imp_info)
					#
					THE guipane
					    =>
					    guipane.needs_layout_and_redraw := TRUE;

					NULL => ();										# Assume this is a stale request and ignore it.
				    esac;
				fi;
			    }
		    );


		#################################################################################
		# gadget_to_guiboss interface fns:
		#
		fun needs_redraw_gadget_request										# PUBLIC.
		      (
			id:		iul::Id
		      )
		    =	
		    # The point of this call is to alert us that the
		    # GUI display needs refreshing.
		    # If no widget calls this, we can stop the frame-
		    # redisplay cycle to conserve CPU cycles:
		    #
		    {
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate as { me, imports, ... }:	Runstate)
				=
				{   i = gtj::get_gadget_imp_info (me.gadget_imps, id);
				    #
				    if *done_extra_redraw_request_this_frame
					#
					set__needs_redraw_request__flag i;						# This is the "normal" codepath -- we just remember that this gadget needs a redraw. We'll send it a redraw_gadget_request next time "frameclock" nudges us to run display_one_frame().
				    else
					#										# This is a special codepath intended to reduce user-input response latency in the common case of only one mouseclick or such per frametime (10-100 ms).  For background see Note[3].
					done_extra_redraw_request_this_frame := TRUE;					# Throttle this codepath to at most once per "frameclock" tick, to prevent runaway gadgets from overwhelming the CPU+GPU with redraw_gadget() calls.
					#
					i -> { guiboss_to_gadget, site, gadget_mode, needs_redraw_request, ... };

					guiboss_to_gadget.redraw_gadget_request						# Give the gadget an instant redraw_gadget_request() in response to its needs_redraw_gadget_request() call to us, instead of making it wait until start of next frame (== next time "frameclock" microthread wakes up).
					  {
					    frame_number	=>  *current_frame_number,
					    site		=>  *site,
					    duration_in_seconds =>  0.0,
					    gadget_mode		=>  *gadget_mode,
					    theme		=>  imports.theme,
					    popup_nesting_depth =>  gpj::popup_nesting_depth_of_gadget (id, me)
					  };
				    fi;
				}
		        );
		    };

		fun draw_gadget (clip_box, gui_displaylist, gadget_imp_info: gt::Gadget_Imp_Info)
		    =
		    {
			gui_displaylist = [ gd::CLIP_TO (clip_box, gui_displaylist) ];					# Clip gadget's displaylist to its assigned site so it won't traspass on neighboring gadgets if it gets sloppy.
			#
			gadget_to_rw_pixmap
				=
				gtj::gadget_to_rw_pixmap__of  *gadget_imp_info.subwindow_or_view;			# Find gadget's assigned off-screen backing pixmap.

			gadget_to_rw_pixmap.draw_displaylist  gui_displaylist;						# Draw updated gadget appearance into its off-screen backing-pixmap home site.

															# Now to update on-screen image of gadget (if it is visible).
															#
															# We'll update the gadget on the visible window by doing a rectangular blit
															# from offscreen backing pixmap to on-screen pixel refresh buffer.
															#
															# Just redrawing gui_displaylist a second time would be another strategy.
															# The blit has the advantage that the worst case is pretty fast, whereas
															# the worst case for redrawing gui_displaylist can be arbitrarily slow.
															#
															# Also, draw-offscreen-and-blit completely eliminates redraw flicker
															# where "flicker" == partly-redrawn widget being visible momentarily:
															# it is essentially a primitive form of double-buffering.

			from_box =  *gadget_imp_info.site;								# Where should we copy pixels from, on gadget's home pixmap?  We initialize this to the full site for the gadget; later it may get clipped by scrollports.
			pixmap	 =  *gadget_imp_info.subwindow_or_view;							
			#		
			gpj::update_offscreen_parent_pixmaps_and_then_topwindow
			    #
			    (pixmap, from_box, topwindow_for_gui);
		    };

		#
		fun redraw_gadget											# Update gadget appearance in response to a guiboss_to_gadget.redraw_gadget_request {...} call.
		      {
			id:			iul::Id,
		        site:			g2d::Box,								# This should be the 'site' value handed to Guiboss_To_Gadget.redraw_gadget_request: guiboss_imp uses this value to detect (and discard) stale redraw_gadget messages.
			displaylist:		gd::Gui_Displaylist,
			point_in_gadget:	Null_Or( g2d::Point -> Bool )						# Optional function deciding if (e.g.) a mouseclick location is within the gadget. This allows more geometric accuracy than a simple bounding box or such.
		      }
		    =
		    # The point of this call is to update the appearance
		    # of the gadget.  This call is normally made in response
		    # to  guiboss_to_gadget.redraw_gadget_request {}							# guiboss_to_gadget	is from   src/lib/x-kit/widget/gui/guiboss-to-gadget.pkg
		    #
		    {
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ me, ... }: Runstate)
				=
				{   i = gtj::get_gadget_imp_info (me.gadget_imps, id);
				    #
# XXX BUGGO FIXME Here we should be comparing 'site' in call with 'site' in our internal db,
# and discarding this redraw if they do not match.  This is to prevent stale redraws to
# no-longer-valid sites from corrupting the visible display.
				    i.point_in_gadget := point_in_gadget; 

				    draw_gadget (*i.site, displaylist, i);
				}
		        );
		    };



		fun pass_guipane_offset
			#
			(id:		iul::Id)
			(replyqueue:	Replyqueue)
			(reply_handler: g2d::Point -> Void)
		    =
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( g2d::Point );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ me, ... }: Runstate)
				=
				{   i = gtj::get_gadget_imp_info (me.gadget_imps, id);
				    #
				    case  (gtj::find__guipane__containing_gadget  i)
					#
					THE guipane =>
					    {
						subwindow_info =  gtj::subwindow_info_of_subwindow_data  guipane.subwindow_info;
						#
						guipane_origin =  *subwindow_info.origin;

						put_in_oneshot (reply_oneshot, guipane_origin);
					    };  

					NULL => {   msg = "pass_guipane_offset: find__guipane__containing_gadget returned NULL.";
						    log::fatal msg;
						    raise exception FAIL msg;
						};
				    esac;
				}
			);

			put_in_replyqueue (replyqueue, (get_from_oneshot' reply_oneshot) ==> reply_handler);
		    };

		fun set_guipane_offset											# Gadget request to  change  value of Subwindow_Info.origin for guipane containing gadget.
		      (
			id:		iul::Id,
			offset: 	g2d::Point
		      )	
		    =
		    put_in_mailqueue  (guiboss_q,
			#
			\\ (runstate: Runstate)
			    =
			    {   i = gtj::get_gadget_imp_info (me.gadget_imps, id);
				#
				case  (gtj::find__guipane__containing_gadget  i)
				    #
				    THE guipane =>
					{
					    subwindow_info =  gtj::subwindow_info_of_subwindow_data  guipane.subwindow_info;

# NEED SOME VALIDATION HERE!!
#					    subwindow_info.origin := offset;

# NEED TO CALL refresh_topwindow_rectangle() HERE TO MAKE DISPLAY UPDATE!!!
					};  

				    NULL => {   msg = "set_guipane_offset: find__guipane__containing_gadget returned NULL.";
						log::fatal msg;
						raise exception FAIL msg;
					    };
				esac;
			    }
		    );



	
		#
		fun note_changed_gadget_activity									# PUBLIC.
		      {
			id:		iul::Id,
			is_active:	Bool
		      }
		    =	
		    # The point of this call is to mark gadget as not
		    # eligible for user input.  It will often be drawn grayed-out.
		    #
		    {   put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ me, ... }: Runstate)
				=
				{
				    i = gtj::get_gadget_imp_info (me.gadget_imps, id);
				    #
				  (*i.gadget_mode) -> { is_active => _, has_mouse_focus, has_keyboard_focus };
				    i.gadget_mode  := { is_active,      has_mouse_focus, has_keyboard_focus };
				}
		        );
		    };


		fun wake_me														# Used to schedule guiboss_to_gadget.wakeup calls.
		      {
			id:		iul::Id,
			options:	List( gt::Wake_Me_Option )
		      }
		    =
		    # The point of this call is to set up (or cancel)
		    # wakeup calls to a given widget.
		    #
		    {
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{   i = gtj::get_gadget_imp_info (me.gadget_imps, id);
				    #
				    apply  do_option  options
					where
					    fun do_option (option: gt::Wake_Me_Option)
						=
						case option
						    #
						    gt::AT_FRAME_N	NULL			    =>  i.at_frame_n	    :=  NULL;
						    gt::EVERY_N_FRAMES  NULL			    =>  i.every_n_frames    :=  NULL;
						    #
						    gt::AT_FRAME_N     (THE (at_frame, wakeup_fn))  =>  i.at_frame_n	    :=  THE { at_frame, wakeup_fn };
						    gt::EVERY_N_FRAMES (THE (n,        wakeup_fn))  =>  i.every_n_frames    :=  THE { n,        wakeup_fn, next => REF (*current_frame_number + n) };
						esac;
					end;
				}
		        );
		    };


#		redo_layout_and_redisplay:	Void -> Void,										# WRITTEN BUT CURRENTLY UNTESTED! 2015-01-17
# THIS IS CURRENTLY NOT CALLED ANYWHERE NOR EXTERNALLY VISIBLE
# 		fun redo_layout_and_redisplay ()											# PUBLIC
# 		    =
# 		    {   put_in_mailqueue  (guiboss_q,
# 			    #
# 			    \\ (runstate as { me, to, ... }: Runstate)
# 				=
# 				{   gpj::lay_out_all_guipanes (subwindow_info, topwindow_for_gui, me, to);
# 				    gpj::redraw_all_guipanes (subwindow_info, topwindow_for_gui);
# 				}
# 		        );
# 		    };

		fun get_guipith ()													# See Note[1] in src/lib/x-kit/widget/gui/translate-guipane-to-guipith.pkg
		    =
# Dummy placeholder pending actual implementation XXX BUGGO FIXME
		    gt::XI_NULL_WIDGET;

		fun morph_guipane (gui_update:	gt::Guipith)										# Update guiboss_imp's running gui per supplied Guipith, which should be a suitably edited version of return value from get_guipith. See Note[1] in src/lib/x-kit/widget/gui/translate-guipane-to-guipith.pkg
		    =															# See Note[1] in src/lib/x-kit/widget/gui/translate-guipane-to-guipith.pkg
# Dummy placeholder pending actual implementation XXX BUGGO FIXME
		    ();


		fun make_popup														# PUBLIC. Create popup pane on given window in given site.  Given site is adjusted to lie entirely within parent (if necessary) and returned.
		      (
			requested_site:		g2d::Box,
			guiplan:		gt::Guiplan
		      )
		    : (
			g2d::Box,
			gt::Client_To_Guiwindow
		      )
		    =
		    {	gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Client_To_Guiwindow );
			#
			actual_site_and_subwindow_info'
			    =
			    make_oneshot_maildrop():  Oneshot_Maildrop( (g2d::Box, gt::Subwindow_Data) );
			#
			put_in_mailqueue  (guiboss_q,											# make_popup() is intended to be called by widget code, so our first task is to transition from caller's microthread to the guiboss-imp microthread.
			    #
			    \\ (runstate as { me, imports, ... }: Runstate)								# Once into the body of this fn we are running in the guiboss-imp microthread.
				=
				{
				    (make_subwindow_info_for_popup									# Make a new rw_pixmap, wrap it in a SUBWINDOW_DATA, enter latter into the SUBWINDOW_DATA popup hierarchy for this gui.
				      (
					imports.guiboss_to_guishim.make_rw_pixmap,							# To allocate the actual rw_pimap for the Subwindow_Or_View.
					topwindow_info.next_stacking_order,								# To allocate a 'stacking_order' value for Subwindow_Or_View.
					subwindow_info,											# Our parent Subwindow_Or_View.
					requested_site											# Where to put popup on parent Subwindow_Or_View.
				      )
				    ) -> (actual_site, subwindow_info);

				    put_in_oneshot											# Pass actual site of popup back to calling microthread, plus backing pixmap for popup GUI.
				      (
					actual_site_and_subwindow_info',
					(actual_site, subwindow_info)
				      );

				    start_gui'
				      (
					runstate: 			Runstate,
					#	
					topwindow_for_gui:		gtg::Guiboss_To_Topwindow,
					subwindow_info:			gt::Subwindow_Data,
					guiplan:			gt::Guiplan,

					gui_startup_complete':		Oneshot_Maildrop( gt::Client_To_Guiwindow ),
					guiboss_q:			Guiboss_Q,
					pause_gui:			(gt::Guipane, gt::Topwindow_Info) -> gt::Paused_Gui,
					kill_gui:			(gt::Guipane, gt::Topwindow_Info) -> Void
				      );
				}
			);

			(get_from_oneshot  actual_site_and_subwindow_info')
			    ->
			    (actual_site, subwindow_info);		  								# Read actual site of popup back from guiboss-imp microthread, also backing pixmap for popup GUI.

			client_to_guiwindow =  get_from_oneshot  gui_startup_complete'; 						# Wait until popup startup is complete.  We do this in caller's thread to reduce risk of lockup -- caller is typically a button that can afford to sleep a bit.

			( actual_site,
			  client_to_guiwindow												# Return port to the running popup.
			);
		    };


		guipaneref = REF (NULL: Null_Or(gt::Guipane));										# Another skanky little hack to resolve cyclic dependencies.  We set guipaneref just below, immediately after creating guipane, and never change it thereafter.
		#
		fun kill_popup ()
		    =
		    case *guipaneref		
			#
			THE guipane =>  kill_gui (guipane, topwindow_info);
			#
			NULL 	=>  {   msg = "guipaneref NULL in kill_gui! -- guiboss-imp.pkg";
					log::fatal msg;
					raise exception FAIL msg;
				    };
		    esac;

		gadget_to_guiboss =       { id => topwindow_for_gui.id,									# Since each topwindow has a unique id and we will have only one gadget_to_guiboss per topwindow, using topwindow_for_gui.id
					    #												# here ensures a unique id per gadget_to_guiboss. It also makes gadget_to_guiboss.id stable across gui stop/restart cycles.
					    needs_redraw_gadget_request,
					    #
					    redraw_gadget,
					    note_changed_gadget_activity,
					    wake_me,
					    get_guipith,
					    morph_guipane,
					    #
					    pass_guipane_offset,
					    set_guipane_offset,
					    #
					    gadget_to_editboss,
					    #
					    make_popup,
					    kill_popup
					  };	

		widget_to_guiboss =       { id =>  topwindow_for_gui.id,								# Since each topwindow has a unique id and we will have only one widget_to_guiboss per topwindow, using topwindow_for_gui.id
					    g  =>  gadget_to_guiboss,
					    #												# here ensures a unique id per widget_to_guiboss. It also makes widget_to_guiboss.id stable across gui stop/restart cycles.
					    note_widget_layout_hint
					  };






		#################################################################################
		# frameclock microthread -- wakes us up 10 times/sec to draw a frame.
		#

		fun paused_gui__to__guipane
		    (
		      paused_gui
		      as	
		      ( widgetspace_arg:	gt::Widgetspace_Arg,
		        pg_widget:		gt::Pg_Widget
		      )
		    )
		    : gt::Guipane
		    =
		    {
			(gtr::pg_widget__to__rg_widget											# 
			  {
			    pg_widget,
			    arg         =>  gtr::PRIMARY { widgetspace_arg },
			    #
			    run_gun',
			    subwindow_info,
			    me,
			    widget_to_guiboss,
			    gadget_to_guiboss,
			    guiboss_to_guishim					=>  imports.guiboss_to_guishim,
			    topwindow_for_gui,
			    space_to_gui,
			    clear_box_in_pixmap 				=>  gpj::clear_box_in_pixmap,
			    update_offscreen_parent_pixmaps_and_then_topwindow	=>  gpj::update_offscreen_parent_pixmaps_and_then_topwindow
			  }
			)
			 -> ( rg_widget,
			      #	
			      {	guiboss_to_widgetspace:   gt::Guiboss_To_Widgetspace,
				endstate_oneshot:	  Oneshot_Maildrop( gt::Widgetspace_Arg  )
			      }
			    );

			{ guiboss_to_widgetspace,
			  rg_widget,
			  subwindow_info,
			  topwindow		  =>  topwindow_for_gui,
			  needs_layout_and_redraw =>  REF FALSE
			};
		    };


		#
		guipane     =  paused_gui__to__guipane  paused_gui;										# Starts up all widget look-imps and state-imps plus the object- sprite- and widgetspace imps,
		guipaneref :=  THE guipane;
																	# and populates our spritespace_imps, objectspace_imps, widgetspace_imps and gadget_imps maps.

		if (not we_are_a_popup_gui)												# One frameclock microthread per topwindow is quite sufficient, so we avoid starting extra ones up each time we start up a secondary (popup) gui.
		    #
		    make_thread'  [ THREAD_NAME "frameclock" ]  frameclock  end_gun'							# Start up frameclock thread which tells us when it is time to draw a new frame.
			where
			    fun display_one_frame ({ me, imports, to, ... }: Runstate)							# THIS FUNCTION RUNS IN THE REGULAR GUIBOSS_IMP MICROTHREAD, NOT THE "frameclock" MICROTHREAD.
				=
				{
				    current_frame_number := *current_frame_number + 1;
				    #
				    done_extra_redraw_request_this_frame	:= FALSE;						# See Note[3].

				    imps =  im::vals_list  *me.gadget_imps;

				    apply' imps  {.
					#
					#imp -> { guiboss_to_gadget,
						  site,
						  gadget_mode,
						  needs_redraw_request,
						  sent__initialize_gadget,
						  subwindow_or_view,
						  pixmaps,
						  ...
						};

					if (not *sent__initialize_gadget  and  *site != g2d::box::zero)					# If *site==g2d::box::zero then widgetspace_imp has not yet done layout and we cannot yet call initialize_gadget or redraw_gadget_request, since both require a valid site.
					    #
					    fun make_rw_pixmap (size: g2d::Size):  g2p::Gadget_To_Rw_Pixmap
						=
						{   rw_pixmap = imports.guiboss_to_guishim.make_rw_pixmap( size );
						    #
						    subwindow_info
							=
							gtj::subwindow_info_of_subwindow_or_view
							    #
							    *subwindow_or_view;

						    pixmaps :=  im::set ( *pixmaps,
									  id_to_int  rw_pixmap.id,
									  rw_pixmap
									);
						    #
						    rw_pixmap;	
						};

					    guiboss_to_gadget.initialize_gadget   { site		=> *site,
										    theme		=>  imports.theme,
										    get_font		=>  topwindow_for_gui.get_font,
										    pass_font		=>  topwindow_for_gui.pass_font,
										    make_rw_pixmap
										  };

					    sent__initialize_gadget := TRUE;
					    needs_redraw_request    := TRUE;
					fi;
				    };

				    apply' imps  {.
					#imp -> { guiboss_to_gadget, site, gadget_mode, needs_redraw_request, at_frame_n, every_n_frames, ... };
					    #

					if (*site != g2d::box::zero)									# If *site==g2d::box::zero then widgetspace_imp has not yet done layout and we cannot yet call redraw_gadget_request because it requires a valid site.
					    #
					    case *at_frame_n
						#
						THE { at_frame:	    Int,
						      wakeup_fn:    gt::Wakeup_Arg -> Void
						    }
						    =>
						    if   (*current_frame_number == at_frame)
							#
							guiboss_to_gadget.wakeup
							  {
							    frame_number	=>  *current_frame_number,
							    site		=>  *site,
							    #
							    duration_in_seconds	=>  0.0,
							    gadget_mode	    	=>  *gadget_mode,
							    wakeup_fn
							  };

						    elif (*current_frame_number  > at_frame)
							#
							at_frame_n := NULL;
						    fi;

						NULL => ();
					    esac;

					    case *every_n_frames
						#
						THE { n:	    Int,
						      next:	    Ref(Int),
						      wakeup_fn:    gt::Wakeup_Arg -> Void
						    }
						    =>
						    if  (*current_frame_number >= *next)
							#
							guiboss_to_gadget.wakeup
							  {
							    frame_number	=>  *current_frame_number,
							    site		=>  *site,
							    #
							    duration_in_seconds	=>  0.0,
							    gadget_mode	    	=>  *gadget_mode,
							    wakeup_fn
							  };

							next := *current_frame_number + n;
						    fi;

						NULL => ();
					    esac;

					    if (*needs_redraw_request)
						#
						guiboss_to_gadget.redraw_gadget_request
						  {
						    frame_number	=>  *current_frame_number,
						    site		=>  *site,
						    #
						    duration_in_seconds	=>  0.0,
						    gadget_mode	    	=>  *gadget_mode,
						    theme		=>  imports.theme,
						    popup_nesting_depth =>  gpj::popup_nesting_depth_of_gadget (guiboss_to_gadget.id, me)
						  };

						needs_redraw_request := FALSE;
					    fi;
					fi;
				    };

				    # Start re-layout-and-redraw of any running guis which need one:
				    #
				    apply' (im::vals_list *me.topwindows)
					#
					(\\ (topwindow_info: gt::Topwindow_Info) = {
					    #
					    gtj::guipanes_apply topwindow_info
						#
						(\\ (guipane: gt::Guipane) = {
						    #
						    if(*guipane.needs_layout_and_redraw)
							guipane.needs_layout_and_redraw := FALSE;

							my (high, wide)
							    =
							    case guipane.subwindow_info
								#
								gt::SUBWINDOW_DATA r
								    =>
								    {   r.pixmap.size -> { high, wide };
									(high, wide);
								    };
							    esac;

							site =  { col => 0,  high,									# Allocate all of window pixel area to widgets in guipane.rg_widget widget-tree.
								  row => 0,  wide
								}
								: g2d::Box;


							sites = gwl::lay_out_guipane									# Assign to each widget in given widget-tree a pixel-rectangle on which to draw itself, in window coordinates.
								  {
								    me,
								    site,										# This is the available window rectangle to divide between our widgets.
								    rg_widget		=> guipane.rg_widget,						# This is the tree of widgets -- possibly a single leaf widget.
								    subwindow_info		=> guipane.subwindow_info,
								    widget_layout_hints	=> *me.widget_layout_hints
								  };

							apply   do_site (im::vals_list sites)
								where
								    fun do_site (widget_site_info: gwl::Widget_Site_Info)
									=
									{   widget_site_info ->  { id, subwindow_or_view, site     };
									    note_widget_site'    { id, subwindow_or_view, site, me };			# Sets 'needs_redraw_request' flag for widget if its site has changed.
									};
								end;
						    fi;
						});
					});
				};


# XXX SUCKO FIXME we should probably just use the 50HZ timeslicing clock.
			    # This fn provides the body for a little microthread which just
			    # loops ten times a second telling our main thread to disply frame:
			    #
			    fun frameclock end_gun'													# THIS FUNCTION RUNS IN THE "frameclock" MICROTHREAD.
				=
				loop ()
				where
				    count = REF 19;
				    #
				    fun loop ()
					=
					{
					    do_one_mailop [
						#
						end_gun'
						    ==>
						    {.
							thread_exit { success => TRUE };
						    },
						#
						timeout_in' *seconds_per_frame
						    ==>
						    {.
							put_in_mailqueue  (guiboss_q, display_one_frame);
						    }
					    ];

					    loop ();
					};
				end;
			end;
		    ();
		fi;
	    end																		# fun restart_gui'

	#

	also															# restart_gui'() and start_gui'() need to be mutually recursive so make_popup() can call start_gui'.
	fun start_gui'
	      (
		runstate: 		Runstate,
		#	
		topwindow_for_gui:	gtg::Guiboss_To_Topwindow,
		subwindow_info:		gt::Subwindow_Data,
		guiplan:		gt::Guiplan,

		gui_startup_complete':	Oneshot_Maildrop( gt::Client_To_Guiwindow ),
		guiboss_q:		Guiboss_Q,
		pause_gui:		(gt::Guipane, gt::Topwindow_Info) -> gt::Paused_Gui,
		kill_gui:		(gt::Guipane, gt::Topwindow_Info) -> Void
	      )
	    =
	    {   gp_widget  =  guiplan;												# Currently a gui-plan is just a guiplan-widget.
		pg_widget  =  gtr::gp_widget__to__pg_widget  gp_widget;

		paused_gui =  ( []:			gt::Widgetspace_Arg,
				pg_widget:		gt::Pg_Widget
			      );
		#
	        restart_gui' (runstate, topwindow_for_gui, subwindow_info, paused_gui, gui_startup_complete', guiboss_q, pause_gui, kill_gui);
	    };

	#
	fun startup   (id: Id,   reply_oneshot:  Oneshot_Maildrop( (Me_Slot, Exports) ))   ()					# Root fn of imp microthread.  Note currying.
	    =
	    {   me_slot  =  make_mailslot  ()	:  Me_Slot;
		#
		client_to_guiboss =   { id,
					make_topwindow,
					start_gui,
					restart_gui,
					get_sprite_theme,
					get_object_theme,
					get_widget_theme
				      };

		editboss_to_guiboss = { id											# Exported interface for use by    src/lib/x-kit/widget/edit/editboss-imp.pkg
				      };

		to          =  make_replyqueue();
		#
		put_in_oneshot (reply_oneshot, (me_slot, { client_to_guiboss }));						# Return value from guiboss_egg'().

		(take_from_mailslot  me_slot)											# Imports from guiboss_egg'().
		    ->
		    { me, guiboss_arg, imports, run_gun', end_gun' };



		editboss_egg = ebi::make_editboss_egg [];									# Set up editboss_imp, our delegate responsible for central
		#														# coordination of emacs-flavored text editing functionality,
		(editboss_egg())												# such as tracking all active textbuffers, editpanes etc.
		    ->
		    (editboss_exports, editboss_egg');
		#
		editboss_egg' ({ editboss_to_guiboss }, run_gun', end_gun');

		editboss_exports
		  ->
		  { gadget_to_editboss };

		block_until_mailop_fires  run_gun';										# Wait for the starting gun.


		run ( guiboss_q,		 										# Will not return.
		      { me,
			guiboss_arg,
			gadget_to_editboss,
			imports,
			to,
			end_gun',
			id
		      }
		);
	    }
	    where
		guiboss_q     =  make_mailqueue (get_current_microthread()):  Guiboss_Q;



		#################################################################################
		# guiboss interface fns::
		#
		#

		fun make_guievent_sink
		      (
			topwindow_info:		gt::Topwindow_Info,
			saved_events:		Ref (List( (a2r::Envelope_Route, evt::x::Event) ) )				# Somewhere for initial_guievent_sink to save any events it gets.
		      )
		    =	
		    guievent_sink
		    where
			fun guievent_sink (arg as (route: a2r::Envelope_Route, event: evt::x::Event))				# The production Gui_Event handling routine, which locks in the value of 'topwindow_info'.
			    =													# This will run in client's thread.
			    put_in_mailqueue  (guiboss_q,									# Incoming Gui_Event values MUST be run through the guiboss_q to guarantee mutual exclusion on access to internal guiboss datastructures.
				#
				\\ (runstate as { me, imports, ... }: Runstate)							# Now we're running in our own thread, with mutual exclusion and access to our core datastructures.
				    =
				    {
					case *topwindow_info.subwindow_info
					    #
					    NULL => {   saved_events := arg ! *saved_events;					# When no GUI is running, all we can do is save user input for later processing. (Or maybe discard it?)
printf "guievent_sink()/guiboss: received '%s' Gui_Event but saved it because *topwindow_info.guipane is NULL.    -- guiboss-imp.pkg\n"
    (gts::gui_event_to_string event);
						    };
					    THE (gt::SUBWINDOW_DATA r)
						=>
						case *r.guipane
						    #
						    NULL => {   saved_events := arg ! *saved_events;					# When no GUI is running, all we can do is save user input for later processing. (Or maybe discard it?)
printf "guievent_sink()/guiboss: received '%s' Gui_Event but saved it because *topwindow_info.guipane is NULL.    -- guiboss-imp.pkg\n"
	    (gts::gui_event_to_string event);
							    };

						    THE guipane
							 =>	{
								case *saved_events
								    #
								    [] =>   ged::dispatch_event (arg, me, imports.theme, topwindow_info);

								    _  =>   {										# Woops, we have prior events that came in before we were ready to process them.
										saved_events := arg ! *saved_events;					# Add latest event to saved-events list.
										events = reverse *saved_events;						# Reverse saved-events list so we process them in first-in-first-out order.
										saved_events := [];							# Clear saved-events so  we don't process any of them twice.
										apply guievent_sink events;						# Recursively process all saved events in order.  NB: Any new events that arrive during this will just accumulate on guiboss_q. That's fine.
									    };										# 
								esac;
							    };

						esac;
					esac;
				    }															# In-private-thread part of fun guievent_sink.
			    );																# fun guievent_sink
		    end;

		fun make_topwindow  (hints:	gtg::Topwindow_Hints)											# PUBLIC.
		    :				gtg::Guiboss_To_Topwindow
		    =																	# This will run in client's thread.
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( gtg::Guiboss_To_Topwindow );
# reply_oneshot is NOT locked into guievent_sink.
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ me, imports, ... }: Runstate)												# Now we're running in our own thread, with mutual exclusion and access to our core datastructures.
				=
				{   # We have to do an awkward little dance here because we
				    # must hand a guievent_sink() TO make_topwindow() but we
				    # want guievent_sink() to lock in the 'topwindow' result
				    # FROM make_topwindow():

# saved_events IS directly locked into guievent_sink 
				    saved_events = REF ([]: List( (a2r::Envelope_Route, evt::x::Event) ) );						# Somewhere for initial_guievent_sink to save any events it gets.

# guievent_sink_fn is NOT directly locked into  guievent_sink()  (but it is indirectly locked via topwindow_info -> guiboss_to_topwindow).
				    guievent_sink_fn
					=
					REF initial_guievent_sink
					where
					    fun initial_guievent_sink (arg as (route: a2r::Envelope_Route, event: evt::x::Event))			# An initial version which just saves events in 'saved_events' until we're ready to process them, since we don't yet have 'topwindow' available.
						=													# This will run in client's thread.
						saved_events :=  arg ! *saved_events;
				        end;


				    guiboss_to_topwindow
					=
					imports.guiboss_to_guishim.make_topwindow									# XXX SUCKO FIXME we're blocking until we get the result from guishim.
					    #
					    (hints, guievent_sink_wrapper)
					    where
						fun guievent_sink_wrapper (arg as (route: a2r::Envelope_Route, event: evt::x::Event))			# A wrapper which initially calls initial_guievent_sink but almost immediately switches to calling the production guievent_sink.
						    =													# This will run in client's thread.
						    *guievent_sink_fn  arg;
				    	    end;


				    topwindow_info       =    { guiboss_to_topwindow,									# Remember our handle for the topwindow.
								subwindow_info				=>   REF NULL,					# Remember that we do not yet have a GUI running on the topwindow.
								#
								current_frame_number			=>   REF 1,					# We count frames for convenience of widgets and debugging.
								seconds_per_frame			=>   REF 0.01,					# Let's initially assume a nominal ten frames per second. Passed to widgets primarily so widgets can do motion blurring if they wish.
								#
								done_extra_redraw_request_this_frame	=>   REF FALSE,
								#
								next_stacking_order			=>   REF 2
							      };

				    me.topwindows													# Remember that we have a new topwindow to manage.
					:=
					im::set ( *me.topwindows,
						  id_to_int guiboss_to_topwindow.id,
						  topwindow_info
						);

				    guievent_sink
					=
					make_guievent_sink (topwindow_info, saved_events);

				    guievent_sink_fn  :=  guievent_sink;										# Switch guievent_sink_wrapper() over from using initial_guievent_sink() to using guievent_sink().


				    put_in_oneshot (reply_oneshot, guiboss_to_topwindow);

				    imports.theme.guiboss_to_topwindow :=  THE guiboss_to_topwindow;							# So widget-theme-imp.pkg can make  guiboss_to_topwindow.get_font()  calls.

				}															# In-private-thread part of fun make_topwindow.
		        );																# put_in_mailqueue call.

			get_from_oneshot  reply_oneshot;
		    };																	# fun make_topwindow

		#
		fun pause_gui
		      (
			guipane:		gt::Guipane,											# Private
			topwindow_info:		gt::Topwindow_Info
		      )
		      : gt::Paused_Gui
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Paused_Gui );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				put_in_oneshot  (reply_oneshot,  pause_gui' (runstate, (guipane, topwindow_info)))
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun kill_gui
		      (
			guipane:		gt::Guipane,											# Private
			topwindow_info:		gt::Topwindow_Info
		      )
		      : Void
		    =	
		    {
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				kill_gui' (runstate, (guipane, topwindow_info, TRUE))
			);

			();
		    };
		#
		fun start_gui																# PUBLIC.
		      (
			topwindow_for_gui:	gtg::Guiboss_To_Topwindow,
			guiplan:		gt::Guiplan
		      )
		    : (Void -> gt::Client_To_Guiwindow)
		    =	
		    {   gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Client_To_Guiwindow );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{   subwindow_info =  gtj::make_base_subwindow_data  topwindow_for_gui.subwindow_or_view;
				    #
				    start_gui' (runstate, topwindow_for_gui, subwindow_info, guiplan, gui_startup_complete', guiboss_q, pause_gui, kill_gui);
				}
		        );

			{.   get_from_oneshot  gui_startup_complete';   };
		    };

		#
		fun restart_gui																# PUBLIC.
		      (
			topwindow_for_gui:	gtg::Guiboss_To_Topwindow,
			paused_gui: 		gt::Paused_Gui
		      )
		    : (Void -> gt::Client_To_Guiwindow)
		    =	
		    {   gui_startup_complete' =  make_oneshot_maildrop():  Oneshot_Maildrop( gt::Client_To_Guiwindow );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ (runstate: Runstate)
				=
				{   subwindow_info =  gtj::make_base_subwindow_data topwindow_for_gui.subwindow_or_view;
				    #
				    restart_gui' (runstate, topwindow_for_gui, subwindow_info, paused_gui, gui_startup_complete', guiboss_q, pause_gui, kill_gui);
				}
		        );

			{.   get_from_oneshot  gui_startup_complete';   };
		    };

		#
		fun get_sprite_theme ()															# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( bt::Gui_To_Sprite_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.gui_to_sprite_theme)
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun get_object_theme ()															# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( ct::Gui_To_Object_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.gui_to_object_theme)
			);

			get_from_oneshot reply_oneshot;
		    };
		#
		fun get_widget_theme ()															# PUBLIC.
		    =	
		    {   reply_oneshot =  make_oneshot_maildrop():  Oneshot_Maildrop( wt::Widget_Theme );
			#
			put_in_mailqueue  (guiboss_q,
			    #
			    \\ ({ imports, ... }: Runstate)
				=
				put_in_oneshot (reply_oneshot, imports.theme)
			);

			get_from_oneshot reply_oneshot;
		    };
	    end;

	#
	fun process_options (options: List(Guiboss_Option), { name, id })
	    =
	    {   my_name			=  REF name;
		my_id			=  REF id;
		#
		apply  do_option  options
		where
		    fun do_option (MICROTHREAD_NAME	n) =>   my_name			:=  n;
			do_option (ID			i) =>   my_id                   :=  i;
		    end;
		end;

		{ name			=>  *my_name,
		  id 			=>   *my_id
		};
	    };


        ##########################################################################################
	# PUBLIC.
	#
	fun make_guiboss_egg
	      (guiboss_arg:		Guiboss_Arg)													# PUBLIC. PHASE 1: Construct our state and initialize from 'options'.
	    =
	    {	guiboss_arg ->  (guiboss_options);													# Currently no guiboss_needs component, so this is a no-op.
		#
		(process_options
		  ( guiboss_options,
		    { name		=> "guiboss",
		      id		=>  id_zero
		    }
		) )
		    ->
		    { name,
		      id
		    };
	
		my (id, guiboss_options)
		    =
		    if (id_to_int(id) == 0)
			id = issue_unique_id();														# Allocate unique imp id.
			(id, ID id ! guiboss_options);													# Make our id stable across stop/restart cycles.
		    else
			(id, guiboss_options);
		    fi;

		guiboss_arg = (guiboss_options);													# Currently no guiboss_needs component, so this is a no-op.

		me =  {
			topwindows		=>   REF im::empty,											# Track all topwindows created by our make_topwindow() entrypoint.
			mouse_is		=>   REF gt::CROSSING_NONGADGET,									# Mouse is not currently dragging, and in fact not currently known to be on any particular widget.
			last_button_changed	=>   REF evt::button1,											# Track last button clicked, so we can pass it to drag_fn clients. (evt::Motion_Xevtinfo contain no 'mouse_button' field, unlike evt::Button_Xevtinfo values.) Cnoice of initial value does not matter.
								#
			#
			spritespace_imps	=>  (REF im::empty): gt::Spritespace_Imps,								# Holds our gt::Guiboss_To_Spritespace instances.
			objectspace_imps	=>  (REF im::empty): gt::Objectspace_Imps,								# Holds our gt::Guiboss_To_Objectspace instances.
			widgetspace_imps	=>  (REF im::empty): gt::Widgetspace_Imps,								# Holds our gt::Guiboss_To_Widgetspace instances.
			gadget_imps		=>  (REF im::empty): gt::Gadget_Imps,									# 
			widget_layout_hints	=>  (REF im::empty): gt::Widget_Layout_Hints								# 
		      };

		\\ () = {   reply_oneshot = make_oneshot_maildrop():  Oneshot_Maildrop( (Me_Slot, Exports) );						# PUBLIC. PHASE 2: Start our microthread and return our Exports to caller.
			    #
			    xlogger::make_thread  name  (startup  (id, reply_oneshot));									# Note that startup() is curried.

			    (get_from_oneshot  reply_oneshot) -> (me_slot, exports);

			    fun phase3															# PUBLIC. PHASE 3: Accept our Imports, then wait for Run_Gun to fire.
				(
				  imports:	Imports,
				  run_gun':	Run_Gun,	
				  end_gun':	End_Gun
				)
				=
				{
				    put_in_mailslot  (me_slot, { me, guiboss_arg, imports, run_gun', end_gun' });
				};

			    (exports, phase3);
			};
	    };
    };

end;


##########################################################################
# Note[2]  Pop-up Design Considerations:
#
# o As a practical matter we expect typically just one
#   popup at a time, either a tooltip or a dialog, so
#   we try to avoid adding too much semantic and implementation
#   complexity in service of the remaining rarer cases.
#
#   Also, we don't worry much about the efficiency of the
#   complex cases which we expect to be vanishingly rare:
#   we use simple O(N**2) algorithms for our overlapping-
#   update cases rather than implementing and using
#   sophisticated spatial datastructures.
#
# o For simplicity and portability we do popups entirely
#   within guiboss-imp, as opposed to using one separate
#   X window per popup.  This leaves the door open to
#   ports to non-X substrates which do not naturally
#   support extra windows, perhaps OpenGL or simple
#   hardware framebuffers.
#
# o We support multiple simultaneous popups on a given
#   topwindow because this has the simplest, most natural
#   semantics:  on a big GUI on a 30" monitor there is no
#   reason that a popup or tooltip in one corner should
#   block a popup or tooltip in another corner.
#
# o We expect each popup to fit entirely within its parent,
#   but it seems unnatural and inconvenient to insist that
#   sibling popups sharing a parent not overlap, so for
#   simplest semantics we allow such overlaps.  
#
# o For similar considerations of clean semantics we support
#   popups on popups:  We want each popup to support the same
#   GUI semantics as the underlying parent gui window.
#
# o We resolve sibling overlaps via a global stacking order,
#   with younger windows overlaying older ones.  At some point
#   we may want to support popping windows to the top of the
#   stacking order:  In that case we'll have to make stacking_order
#   fields mutuable and trigger a redraw after updating them.
#
# o I do not see any need to have pop-ups belong to viewables and
#   thus be partially visible through a scrollport.  The point
#   of a popup is to be attention-getting and visible, so having
#   hidden popups seems counterproductive.  Consequently we do not
#   (further!) complicate the implementation problem by requiring
#   support for that.

##########################################################################
# Note[3]  Gadget Redraw Protocol Design Considerations:
#
# A core idea here is that if a gadget updates its state say 100,000
# times a second (counting incoming ethernet packets, perhaps),
# we do NOT want it redrawing that often because it would overwhelm
# the rendering subsystem (and anyhow waste a lot of CPU + CPU time).
#
# Rather than have each gadget (most likely FAIL to) include redraw
# frequency throttling logic, we centralize this functionality here
# in guiboss_imp:
#
#  o  When a gadget updates its state, it calls							# See for example   src/lib/x-kit/gadget/leaf/arrowbutton.pkg
#         gadget_to_guiboss.needs_redraw_gadget_request
#     which results in guiboss_imp setting the gadget's
#         gadget_imp_info.needs_redraw_request := TRUE;
#
#  o  Each time guiboss_imp's   "frameclock"  thread wakes up					#   As a special tweak, once per frame guiboss_imp will send a
#     (10-100 times per second, say), it sends a						#	guiboss_to_gadget.redraw_gadget_request
#         guiboss_to_gadget.redraw_gadget_request						#   immediately upon receiving a
#     all to each gadget with gadget_imp_info.needs_redraw_request == TRUE;				#	gadget_to_guiboss.needs_redraw_gadget_request
#												#   The intention here is to reduce GUI user-response latency
#  o  When (and only when) a gadget receives a redraw_gadget_request				#   by ten to a hundred milliseconds in the common case of only
#     call, it does a										#   one user mouselick (or other input) per frameclock tick,
#         gadget_to_guiboss.redraw_gadget							#   without risking runaway redraws.
#     call to actually redraw itself.								#   This mechanism is implemented via
#												#       done_extra_redraw_request_this_frame:	Ref(Bool),
# In general it is the gadget's responsibility to call
#     gadget_to_guiboss.needs_redraw_gadget_request
# when it needs to be redrawn.  There are exactly two
# situations in which guiboss_imp will send a
#     guiboss_to_gadget.redraw_gadget_request
# without such prompting:
#
#  1) At GUI startup guiboss_imp sends a redraw_gadget_request
#     to every gadget in the GUI, to establish the initial
#     visual appearance of the GUI.
#
#  2) When a widget's assigned site changes (say, due to the					# Window resizing is actually not supported as of 2014-11-28
#     user resizing the window).
# 
# Originally, to be helpful, guiboss_imp would spontaneously send a
# a redraw_gadget_request() to any gadget receiving a mouse event
# or such, but I eventually concluded that this was more confusing
# than helpful, and retreated to the above simple, easy-to-remember
# policy.  (Also, spontaneous redraw_gadget_requests() could cause
# needless redraws, which for some gadgets might be quite expensive.)
#
# Note that there is no actual logic or interlock in place to
# prevent a gadget from ignoring the 
#     gadget_to_guiboss.needs_redraw_gadget_request
#     guiboss_to_gadget.redraw_gadget_request
# handshake and simply sending
#     gadget_to_guiboss.redraw_gadget
# There may be widget implementation problems for which this is
# actually a good solution, but it should be done only occasionally,
# after careful consideration of the alternatives and risks.
#
#                                      -- CrT 2014-11-28



##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"			 		 #
# End:									 #
##########################################################################


## Original code by Jeff Prothero Copyright (c) 2014-2014,
## released per terms of SMLNJ-COPYRIGHT.
