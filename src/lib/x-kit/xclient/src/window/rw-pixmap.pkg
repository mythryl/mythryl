## rw-pixmap.pkg
#
#   The three kinds of X server rectangular arrays of pixels
#   supported by x-kit are window, rw_pixmap and ro_pixmap.
#
#      o 'window': are on-screen  and on the X-server.
#      o 'rw_pixmap': are off-screen and on the X-server.
#      o 'ro_pixmap': offscreeen, immutable and on the X-server.
#
#   These all have 'depth' (bits per pixel) and
#   'size' (in pixel rows and cols) information.
#   Windows have in addition 'upperleft' position
#   (relative to parent window) and border width in pixels.
#
#   (A fourth kind of rectangular array of pixels is the
#   client-side 'cs_pixmap_old'.  These are not 'drawable', but
#   pixels can be bitblt-ed between them and server-side
#   windows and pixmaps.)
#
# See also:
#     src/lib/x-kit/xclient/src/window/ro-pixmap-old.pkg
#     src/lib/x-kit/xclient/src/window/window-old.pkg
#     src/lib/x-kit/xclient/src/window/cs-pixmap-old.pkg

# Compiled by:
#     src/lib/x-kit/xclient/xclient-internals.sublib


stipulate
    package di  =  xserver_ximp;				# xserver_ximp		is from   src/lib/x-kit/xclient/src/window/xserver-ximp.pkg
#   package w2x =  widget_to_xserver;				# widget_to_xserver	is from   src/lib/x-kit/xclient/src/window/widget-to-xserver.pkg
    package dt  =  draw_types;					# draw_types		is from   src/lib/x-kit/xclient/src/window/draw-types.pkg
    package dy  =  display;					# display		is from   src/lib/x-kit/xclient/src/wire/display.pkg
    package xg  =  xgeometry;					# xgeometry		is from   src/lib/std/2d/xgeometry.pkg
    package sn  =  xsession_junk;				# xsession_junk		is from   src/lib/x-kit/xclient/src/window/xsession-junk.pkg
    package sp  =  xclient_to_sequencer;			# xclient_to_sequencer	is from   src/lib/x-kit/xclient/src/wire/xclient-to-sequencer.pkg
herein

    package rw_pixmap {
	#
	exception BAD_PIXMAP_PARAMETER;

        # Create uninitialized pixel array:
	#
	fun make_readwrite_pixmap  screen  (size, depth)
            =
            {   screen ->               { screen_info =>  { xscreen  =>  { root_window_id, ... }: dy::Xscreen, ... }: sn::Screen_Info,
					  xsession    =>     { xdisplay => { next_xid,       ... }: dy::Xdisplay, xclient_to_sequencer, ... }: sn::Xsession
					}: sn::Screen;

		per_depth_imps = sn::per_depth_imps_for_depth (screen, depth)
		except
                    xgripe::XERROR _   = raise exception BAD_PIXMAP_PARAMETER;

		pixmap_id =  next_xid ();

		if (not (xg::valid_size  size))
		    #
                    raise exception BAD_PIXMAP_PARAMETER;
                fi;

		xclient_to_sequencer.send_xrequest
		  ( value_to_wire::encode_create_pixmap
		      {
		        pixmap_id,
                        drawable_id =>  root_window_id,
                        size,
                        depth
		      }
                  );

		dt::RW_PIXMAP { pixmap_id, screen, size, per_depth_imps };
	    };

	# Destroy an offscreen window.
	# We do this via draw_imp to avoid a race with
	# any pending draw requests on the window.
	#
	fun destroy_rw_pixmap  (dt::RW_PIXMAP { pixmap_id, per_depth_imps => { widget_to_xserver, ... }: sn::Per_Depth_Imps, ... } )
            =
	    widget_to_xserver.destroy_pixmap  pixmap_id;

    };						# package pixmap 
end;



## COPYRIGHT (c) 1990, 1991 by John H. Reppy.  See SMLNJ-COPYRIGHT file for details.
## Subsequent changes by Jeff Prothero Copyright (c) 2010-2014,
## released per terms of SMLNJ-COPYRIGHT.
