# The public interface to make7's tools mechanism.
#   (This generic must be expanded after the rest of make7 is
#    already in place because it uses load_plugin.)
#
#   (C) 2000 Lucent Technologies, Bell Laboratories
#
# Author: Matthias Blume (blume@kurims.kyoto-u.ac.jp)

# Compiled by:
#     src/app/make7/Make7.make6



							# Tools			is from   src/app/make7/tools/main/public-tools.api
							# anchor_dictionary	is from   src/app/make7/paths/anchor-dictionary.pkg
							# private_tools		is from   src/app/make7/tools/main/private-tools.pkg
							# winix			is from   src/lib/std/winix.pkg
							# string_substitution	is from   src/app/make7/util/string-substitution.pkg
							# file			is from   src/lib/std/src/unix/file.pkg
stipulate
	package sub =   string_substitution;
	package ad  =   anchor_dictionary;
herein

    # This generic invoked in:
    #     src/app/make7/main/make7-g.pkg
    #
    generic package tools_g (

	load_plugin'     :   anchor_dictionary::File -> Bool;
	anchor_dictionary:   anchor_dictionary::Anchor_Dictionary;
    )
    : (weak)
    Tools
    {
	include private_tools;				# Moving this into the outer stipulate is a pain; most of the components are re-exported via api Tools.




	say  = file::say;
	vsay = file::vsay;


	# Find the executable binary for this command.
	# There are three cases:
	#
	#    /bin/foo   is interpreted as an abosolute path.
	#
	#     bin/foo   is interpreted as a path relative
	#               to anchor_dictionary::get_anchor "ROOT"
	#
	#         foo   is interpreted as $foo/foo
	#               if foo is a defined anchor.
	#
	# The result of this function SHOULD NOT be cached.
	# Otherwise a later addition or change of an anchor
	# will go unnoticed.
	#
	fun resolve_command_path
		file					# command as a standard path.
	    =
	    if (string::get (file, 0) == '/')		# Does path start with '/'?
		 file;					# Yes, use it as-is
	    else
		 case (ad::get_anchor			# Is it defined as an anchor?
			  ( anchor_dictionary,
			    file
			  ))

		      THE dir				# Yes, treat it as $foo/foo
			  =>
			  winix::path::from_dir_file { dir, file };

		      NULL					# No, treat it as $ROOT/foo
			  =>
			  (the (ad::get_anchor( anchor_dictionary, "ROOT"))) + "/" + file;
		 esac;
	    fi;

	fun note_standard_shell_command_tool
		args
	    =
	    {   args -> { tool,
			  ilk,
			  suffixes,
			  command_standard_path,
			  extension_style,
			  template,
			  dflopts
			};

		template = the_else (template, "%c %u %s");

		fun err m
		    =
		    raise exception TOOL_ERROR { tool, msg => m };

		fun rule { spec, context, native2pathmaker, default_ilk_of, sysinfo }
		    =
		    {   spec ->  { name, make_path, opts => oto, derived, ... } :  Spec;

			opts = the_else (oto, dflopts);

			my sol  		#  only use STRING options for %o 
			    =
			    {   fun so (SUBOPTS _)
					=>
					NULL;

				    so (STRING s)
					=>
					THE (native_spec (srcpath (s.make_path ())));
				end;

				list::map_maybe_null_fn so opts;
			    };

							    # list		is from   src/lib/std/src/list.pkg

			p =  srcpath (make_path ());

			native_name =  native_spec p;

			tfiles = extend_filename extension_style (native_name, oto);

			partial_expansion
			    =
			    ( { source_files => [],
				make7_files => [],
				sources => [(p, { ilk, derived } )]
			      },
			      map (fn (f, co, too) = { name      => f,
						       ilk       => co,
						       opts      => too,
						       derived   => TRUE,
						       make_path => native2pathmaker f
						      }
				  )
				  tfiles
			    );

			fun run_command ()
			    =
			    {   my (csp, shelloptions)		# "csp" == "command as a standard path" -- see "resolve_command_path" comments.
				    =
				    command_standard_path ();

				command_path
				    =
				    resolve_command_path  csp;

				cmd =
				    sub::substitute
					[
					  { prefix => "%",

					    substitutions
						=>
						[ sub::subfor "%c" command_path,
						  sub::subfor "%s" native_name,
						  sub::subfor "%%" "%",

						  sub::subnsel  (1, 'o', fn x = x, " ")  sol,
						  sub::subnsel  (1, 't', #1,       " ")  tfiles,
						  sub::subnsel  (1, 'u', fn x = x, " ")  shelloptions
						]
					  }
					]
					template;


				include  winix::process;

				#
				if   (system cmd != success)

				     err cmd;
				fi;
			    };

			fun rulefn ()
			    =
			    {   if   (outdated tool (map #1 tfiles, native_name))

				     run_command ();
				fi;

				partial_expansion;
			    };

			context rulefn;
		    };

		fun do_suffix  suffix
		    =
		    note_filename_classifier (standard_filename_suffix_classifier { suffix, ilk } );

		note_ilk (ilk, rule);

		apply do_suffix suffixes;
	    };

	stipulate

	    tool_ilk   = "tool";
	    suffix_ilk = "suffix";

	    empty_expansion
		=
		( { make7_files  => [],
		    source_files => [],
		    sources  => []
		  },
		  []
		);

	    fun tool_rule { spec, context, native2pathmaker, default_ilk_of, sysinfo }
		=
		{   spec ->  { name, make_path, opts, ... } :  Spec;

		    fun err m
			=
			raise exception TOOL_ERROR { tool => tool_ilk, msg => m };

		    p =  srcpath (make_path ());

		    case opts

			NULL
			    =>
			    if (with_plugin p (fn () =  load_plugin' p))
				#
				empty_expansion;
			    else
				err "tool registration failed";
			    fi;

			THE _
			    =>
			    err "no tool options are recognized";
		    esac;
		};


	    fun suffix_rule { spec, context, native2pathmaker, default_ilk_of, sysinfo }
		=
		{   spec ->  { name => suffix, opts, ... } :  Spec;

		    fun err m
			=
			raise exception TOOL_ERROR { tool => suffix_ilk, msg => m };

		    fun note ilk
			=
			{   note_filename_classifier
				(standard_filename_suffix_classifier { suffix, ilk } );

			    empty_expansion;
			};

		    case opts

			 THE [STRING c]
			     =>
			     note c.name;

			 THE [SUBOPTS { name => "ilk", opts => [STRING c] } ]
			     =>
			     note c.name;

			 _   =>
			     err "invalid options";
		    esac;
		};
	herein
											my _ = 
	    note_ilk (tool_ilk,     tool_rule);						my _ = 
	    note_ilk (suffix_ilk, suffix_rule);
	end;

	fun make_boolean_control (name, doc, default)
	    =
	    make7_defaults::make_control
		(
		  control_utilities::convert::bool,
		  name,
		  doc,
		  default
		);

						    # control_utilities	is from   src/lib/controls/control-util.pkg
						    # make7_defaults	is from   src/app/make7/util/make7-defaults.pkg


    };
end;