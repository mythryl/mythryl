## make7file-g.pkg  -- Toplevel interpreter .make6 file syntax.
## (C) 1999 Lucent Technologies, Bell Laboratories
## Author: Matthias Blume (blume@kurims.kyoto-u.ac.jp)

# Compiled by:
#     src/app/make7/Make7.make6



# This is the Mythryl .make6-file parser.
#
# Our primary input is the filename
# of a root .make6 file.
#
# We parse that .make6 file and all
# .make6 files recursively reachable
# from it, then return a dependency
# graph with a node for each .make6 file
# and an edge for each reference of
# a .make6 file from another one.
#
# Our dependency graph is defined in:
#
#     src/app/make7/depend/inter-library-dependency-graph.pkg
#
#
# If our   freeze_policy   argument is FREEZE_ALL,
# which it is when we are called from the
#
#     src/app/make7/make-compiler/make-compiler-g.pkg
#
# file, then we recursively build .frozen freezefiles for
# all real libraries, which of course requires first
# compiling all their .api and .pkg sourcefiles down
# to .o7 object-code files.  (In this case, the actual
# compiles take place as a side-effect of our
#
#     freezefile::write_freezefile ()
#
# calls -- see
#
#     src/app/make7/freezefile/freezefile-g.pkg
#
#
# If our   freeze_policy   argument is FREEZE_NONE,
# which it is when we are called from the
#
#     src/app/make7/main/make7-g.pkg
#
# files, then in general all compiling of .api and
# .pkg files down to .o7 files is done later via:
#
#     src/app/make7/compile/compile-treewalk-g.pkg
#
# Both the standard and the bootstrap compiler
# call us to build their inter-library dependency
# graphs.
#
# E.g., our
#
#     make7file_g
#
# generic is invoked from both
#
#     src/app/make7/main/make7-g.pkg
#     src/app/make7/make-compiler/make-compiler-g.pkg
#
# at compiletime, and both also invoke our
#
#     build_interlibrary_dependency_graph_from_make7file_tree()
#
# entrypoint at runtime. 



###      "In general, they do what you want,
###       unless you want consistency."
###
###             -- Larry Wall, [perl manpage]



api Make7file {

    build_interlibrary_dependency_graph_from_make7file_tree
        :
        { make7_file_to_read:      anchor_dictionary::File,                  #  Our primary input, "foo.make6" or whatever. 

          load_plugin:            anchor_dictionary::Path_Root -> String -> Bool,
	  library_source_index:   library_source_index::Library_Source_Index,

	  make7_session:          make7_state::Make7_Session,
	  freeze_policy:          freeze_policy::Freeze_Policy,		# FREEZE_NONE | FREEZE_ONE | FREEZE_ALL; 

	  primordial_make7file:   make7grammar_actions::Library,
	  paranoid:               Bool
        }
        ->
        Null_Or (
            ( make7grammar_actions::Library,		# == inter_library_dependency_graph::Library
              make7_state::Make7_State
            )
	);

    reset:               Void -> Void;
    list_freezefiles:    Void -> List( anchor_dictionary::File );
    clear_pickle_cache:  Void -> Void;
    dismiss_freezefile:  anchor_dictionary::File -> Void;
};

							# inter_library_dependency_graph	is from   src/app/make7/depend/inter-library-dependency-graph.pkg
							# anchor_dictionary			is from   src/app/make7/paths/anchor-dictionary.pkg
							# library_source_index			is from   src/app/make7/semant/library-source-index.pkg
							# make7_state				is from   src/app/make7/main/make7-state.pkg
							# make7grammar_actions			is from   src/app/make7/semant/make7-grammar-actions.pkg
							# symbol_map				is from   src/app/make7/util/symbol-map.pkg
							# inter_library_dependency_graph	is from   src/app/make7/depend/inter-library-dependency-graph.pkg

generic package make7file_g (

    evict_stale:           Void -> Void;

    package freezefile_map:   Freezefile_Map;		# Freezefile_Map			is from   src/app/make7/freezefile/freezefile-map-g.pkg
    package freezefile:       Freezefile;		# Freezefile				is from   src/app/make7/freezefile/freezefile-g.pkg
)
:
Make7file
{
    package verify_freezefile
        =
        verify_freezefile_g (package freezefile = freezefile;);

    lookahead = 30;

    package s  = source_code_source;			# source_code_source			is from   src/lib/compiler/frontend/basics/source/source-code-source.pkg
    package em = error_message;				# error_message				is from   src/lib/compiler/frontend/basics/errormsg/error-message.pkg

    package sm = source_map;				# source_map				is from   src/lib/compiler/frontend/basics/source/source-map.pkg
    package lg = inter_library_dependency_graph;	# inter_library_dependency_graph	is from   src/app/make7/depend/inter-library-dependency-graph.pkg
    package sg = intra_library_dependency_graph;	# intra_library_dependency_graph	is from   src/app/make7/depend/intra-library-dependency-graph.pkg

							# lr_parser				is from   src/app/yacc/lib/parser2.pkg
							# join_with_arg_g			def in    src/app/yacc/lib/join.pkg

    package ad = anchor_dictionary;			# anchor_dictionary			is from   src/app/make7/paths/anchor-dictionary.pkg

    package cm_lr_vals = cm_lr_vals_fun (package token  = lr_parser::token;);
    package cmlex      = make7_lex_g   (package tokens = cm_lr_vals::tokens;);

    package make7file
        =
	join_with_arg_g (

            package parser_data =  cm_lr_vals::parser_data;
	    package lex         =  cmlex;
	    package lr_parser   =  lr_parser;
        );


    freezefile_cache
        =
        REF (source_path_map::empty
                 :
                 source_path_map::Map(
                     make7grammar_actions::Library
                 )
            );

    #
    fun reset ()
        =
        freezefile_cache := source_path_map::empty;

    #
    fun do_major_garbage_collection ()
        =
        runtime_internals::garbage_collection::collect_garbage 7;

    #
    fun get_freezefile_cache_entry (makefile_path, primordial_make7file as lg::LIBRARY { library_path, ... } )
	    =>
	    if   (ad::compare (makefile_path, library_path) == EQUAL)
	        
                 THE primordial_make7file;
	    else
                 source_path_map::get (*freezefile_cache, makefile_path);
            fi;

        get_freezefile_cache_entry (_, lg::ERROR_LIBRARY)
            =>
            NULL;
    end;



    # When an entry A vanishes from the freezefile cache
    # (this only happens in paranoid mode), then all
    # the other ones that refer to A must vanish, too.
    #
    # They might still be valid themselves,
    # but if they had been unpickled before
    # A became invalid they will point to
    # invalid data.
    #
    # By removing them from the cache we force
    # them to be re-read and re-unpickled.
    # This restores sanity.
    #
    fun delete_cached_freezefile
            (
                make7_state: make7_state::Make7_State,
                p,
                version,					# XXX BUGGO FIXME 'version' here can die, I think.
                lg::LIBRARY { library_path => igp, ... }
            )
	    =>
	    {   changed = REF TRUE;

		policy =  make7_state.make7_session.filename_policy;


		freezefile_name
                    =
                    filename_policy::make_freezefile_name
                        policy
                        p;
								# filename_policy	is from   src/app/make7/main/filename-policy.pkg
		#
		fun can_stay lg::ERROR_LIBRARY
			=>
                        TRUE; #  Doesn't matter 

		    can_stay (lg::LIBRARY { sublibraries, ... } )
			=>
			canstay
                        where
			    fun good_sublib (p, library_thunk
                                                             , _	# MUSTDIE
                                                             )
				=
				case (library_thunk ())
				  
				     lg::LIBRARY { real_or_virtual => lg::REAL { frozen_or_thawed => lg::FROZEN _, ... }, ... }
					 =>
					 ad::compare (p, igp) == EQUAL
					 or
					 source_path_map::contains_key (*freezefile_cache, p);

				     _   => TRUE;
                                esac;

			    canstay = list::all good_sublib sublibraries;

			    if   (not canstay)
                                
                                 changed := TRUE;
                            fi;
			end;
		end;



		# Logically remove the freezefile from the registry:
		#
		(freezefile_cache := #1 (source_path_map::drop (*freezefile_cache, p)))
		except
		    lib_base::NOT_FOUND = ();



		# Physically remove the freezefile:
		#
		winix::file::remove_file  freezefile_name
		except
		    _ = ();



		# Restore sanity in the registry:
		#
		for (*changed) {

		    changed := FALSE;

		    freezefile_cache
			:=
			source_path_map::filter  can_stay  *freezefile_cache;
	        };
	    };

        delete_cached_freezefile (_, _, _, lg::ERROR_LIBRARY)
            =>
            ();
    end;

    #
    fun list_freezefiles ()
        =
        map #1 (source_path_map::keyvals_list  *freezefile_cache);



    # This function will be used to delete
    # in-memory picklestrings to conserve memory
    # if the mythryld commandline switch
    #
    #     -Ccm.conserve-memory=TRUE 
    #
    # is given.
    #
    # It is called only from
    #
    #     src/app/make7/main/make7-g.pkg
    #
    fun clear_pickle_cache ()
        =
	source_path_map::apply
            delete
            *freezefile_cache
        where
            fun delete
                    (lg::LIBRARY
                        {
			  real_or_virtual
                              =>
                              lg::REAL
				  {
				    frozen_or_thawed
                                        =>
                                        lg::FROZEN clear_pickle_cache,
				    ...
				  },
			  ...
                        }
                    )
		    =>
		    clear_pickle_cache ();

	        delete _
                    => ();
            end;
	end;

    #
    fun dismiss_freezefile l
        =
	{   freezefile_map::reset ();

	    freezefile_cache
                :=
                #1 (source_path_map::drop (*freezefile_cache, l));
        }
	except
            lib_base::NOT_FOUND = ();


						# anchor_dictionary	is from   src/app/make7/paths/anchor-dictionary.pkg
						# source_path_map	is from   src/app/make7/paths/source-path-map.pkg
						# prettyprinter		is from   src/lib/prettyprint/src/prettyprinter.pkg
						# library_source_index	is from   src/app/make7/semant/library-source-index.pkg

    # Recursively parse the tree of .make6 files
    # rooted at make7_file_to_read, returning their
    # contents in the form of a dependency graph
    # with one node per .make6 file.
    #
    # NB: Technically, the .make6 "tree" is in
    #     fact a lattice, since a given .make6
    #     file may have many parents as well as
    #     many children.  Which is to say, many
    #     libraries may use a given low-level
    #     library like file.
    #
    fun build_interlibrary_dependency_graph_from_make7file_tree {

          make7_file_to_read,		# Our primary input, foo.make6 or such. 
          load_plugin,			# Function to load a plugin given its directory and filename.
          library_source_index,		# Maps make7 filenames to instances of source_code_source::Input_Source.
          make7_session,		# Holds 'filename_policy', 'keep_going', 'server_mode' ...
          freeze_policy,		# See explanation in   src/app/make7/parse/freeze-policy.api
          primordial_make7file,		# Preparsed copy of src/lib/core/init/init.cmi since we can't parse it ourself (uses different syntax).
          paranoid			# TRUE to do extra validity checking.
        }
        =
        {
	    ad::sync ();

            # Write per-makefile .compile.log files.
            # We don't currently put anything interesting
            # in them, but just creating them distinguishes
            # live .make6 files from deadwood:
	    #
            makefile_filename		# Something like "/pub/home/.../root.make6"
                =
                ad::os_string  make7_file_to_read;

	    unparse_filename	# Construct      "/pub/home/.../root.make6.compile.log"
		=
		makefile_filename + ".compile.log";

	    pp  = prettyprinter::make_file_prettyprinter  unparse_filename;

	    pp.lit "This logfile generated by src/app/make7/parse/parse-make7-g.pkg\n";
            pp.flush ();
            pp.close ();



	    primordial_make7file_path
		=
		case primordial_make7file
		  
		     lg::LIBRARY x     =>  x.library_path;
		     lg::ERROR_LIBRARY =>  em::impossible "parse-make7-g.pkg: parse: bad primordial_make7file value";
		esac;


	    freeze_this_library  =  freeze_policy != freeze_policy::FREEZE_NONE;
	    freeze_all_libraries =  freeze_policy == freeze_policy::FREEZE_ALL;

	    library_source_index =  library_source_index;
	    plaint_sink          =  em::default_plaint_sink ();
	    youngest             =  REF  time_stamp::ancient;
	    #
	    fun libname library
		=
		the_else
                    (
                      null_or::map ad::describe  library,
		      "<toplevel>"
		    );

	    make7_state0
                =
                {   make7_session,
		    library_source_index,

		    plaint_sink,
		    youngest
		};

	    keep_going
                =
                make7_session.keep_going;

								# null_or		is from   src/lib/std/src/null-or.pkg
								# iced_o7_map		is from   src/app/make7/freezefile/iced-o7-map.pkg
								# freeze_policy		is from   src/app/make7/parse/freeze-policy.pkg
								# source_path_map	is from   src/app/make7/paths/source-path-map.pkg

	    # The make7file cache saves the results of
            # processing .make6 files, for possible
	    # re-use later.
	    #
	    # Having NULL registered for a .make6 file means
	    # that a previous attempt to run it failed.
	    #
	    # We initialize it with a parsed copy of the
	    # primordial library because it uses special
	    # special that this file's logic will choke on:
	    #
	    make7file_cache
                =
                REF (source_path_map::singleton
                        ( primordial_make7file_path,		# "src/lib/core/init/init.cmi"
                          THE primordial_make7file		# Parsed version of init.cmi.
                        )
                    );


	    exports_map
		=
		REF  iced_o7_map::empty;

	    #
	    fun update_exports_map				# Called only in paranoid mode after verifying ns_g (producing s_g).
                    ( lg::LIBRARY ns_g,
                      lg::LIBRARY  s_g
                    )
		    =>
		    {   s_e =  s_g.o7_views_by_name;
			#
			fun add (symbol, (sourcefile_node_thunk, _, _))
			    =
			    case (sourcefile_node_thunk ())
			      
			         ( _,
                                   sg::O7_IS_BARE
                                       (sg::BARE_O7  sourcefile_node)
                                 )
				     =>
				     case (symbol_map::get (s_e, symbol))
				       
					  NULL => ();

					  THE (freezefile_node_thunk, _, _)
					      =>
					      case (freezefile_node_thunk ())
					        
						   ( _,
                                                     sg::O7_IS_ICED
                                                         ( sg::ICED_O7  freezefile_node,
                                                           _,
                                                           _
                                                         )
                                                   )
						       =>
						       exports_map
                                                           :=
                                                           iced_o7_map::set (
                                                               *exports_map,
                                                               freezefile_node.iced_o7,
							       sourcefile_node.bare_o7
                                                           );

						   _ => ();
                                              esac;
                                     esac;


			         _   => ();
                            esac;

			symbol_map::keyed_apply
                            add
                            ns_g.o7_views_by_name;
		    };

	        update_exports_map _
                    =>
                    ();
            end;

	    #
	    fun register_new_freezefile (gpath, g)
                =
		{  freezefile_cache
                       :=
                       source_path_map::set (*freezefile_cache, gpath, g);

		   source_path_set::apply
                       (bare_o7::clean_library  TRUE)
                       (reachable::groups_of  g);

		   evict_stale ();

		   {   make7file_cache
                           :=
                           #1 (source_path_map::drop (*make7file_cache, gpath));

		       #  ... and for good measure: 
		       do_major_garbage_collection ();
                   }
		   except
                       lib_base::NOT_FOUND = ();
                };

	    #
	    fun has_cycle (root_library, library_stack)
                =
                {   #  Check for cycles among libraries and print them nicely: 
		    #
		    fun find_cycle ([], _)
                            =>
                            [];

		        find_cycle ((h as (this_library, (s, p1, p2))) ! t, cycle)
			    =>
			    if   (ad::compare (this_library, root_library) == EQUAL)
			         reverse (h ! cycle);
			    else find_cycle (t, h ! cycle);
                            fi;
                    end;
		    #
		    fun report ((this_library, (s, p1, p2)), hist)
                        =
                        {   fun pphist pps
                                =
			        loop (this_library, hist)
                                where
                                    fun loop (_, [])
                                            =>
                                           ();

				        loop (g0, (this_library, (s, p1, p2)) ! t)
					    =>
					    {   s =  em::match_error_string s (p1, p2);

						prettyprint::newline  pps;
						prettyprint::string   pps s;
						prettyprint::string   pps ": importing ";
						prettyprint::string   pps (ad::describe g0);
						loop (this_library,   t);
					    };
                                    end;
				end;
			
			    em::error s (p1, p2) em::ERROR
				       ("library hierarchy forms a cycle with " +
					ad::describe root_library)
				       pphist;
			};
		
		    case (find_cycle (library_stack, []))
		      
		         h ! t
                             =>
                             {  report (h, t);
                                TRUE;
                             };

		        []   =>
                             FALSE;
                    esac;
		};

	    #
	    fun main_parse (

		    make7_file_to_read,
		    version,
		    library_stack,
		    p_err_flag,
		    freeze_this_library,
		    this_lib,
		    make7_state,
		    anchor_renamings,	# MUSTDIE
		    error
		)
                =
                {
                    fun load_freezefile_from_disk

                            freezefile_stack

                            ( make7_state,
                              makefile_path,
                              version			# XXX BUGGO DELETEME
                              ,  anchor_renamings	# MUSTDIE
                            )
                        =
                        {   # Detect cycles among freezefiles.
			    #
			    # Such cycles should never occur
			    # unless someone purposely renames
			    # freezefiles in a bad way:

			    fun find_cycle ([], _)
                                    =>
                                    NULL;

			        find_cycle (h ! t, cycle)
                                    =>
                                   if   (ad::compare (h, makefile_path) == EQUAL)
				        THE (h ! cycle);
				   else find_cycle (t, h ! cycle);
                                   fi;
                            end;

			    #
			    fun report cycle
                                =
                                {   fun pphist pps
                                        =
				        loop (reverse cycle)
                                        where
                                            fun loop []
						    =>
						    ();

					        loop (h ! t)
						    =>
						    {   prettyprint::newline pps;
						        prettyprint::string pps (ad::describe h);
						        loop t;
						    };
                                            end;
					end;
				
				    em::error_no_file

                                        (plaint_sink, p_err_flag)
					sm::null_region
					em::ERROR
					("freezefiles form a cycle with " + ad::describe makefile_path)
					pphist;
				};

			    #
			    fun load_freezefile ()
                                =
                                {
                                    maybe_afreezefile
                                        =
                                        freezefile::load_freezefile
					    {
                                              get_library =>  load_freezefile_from_disk (makefile_path ! freezefile_stack),
					      any_errors  =>  p_err_flag
					    }

					    ( make7_state,
                                              makefile_path,
                                              version		# XXX BUGGO DELETEME
                                                , anchor_renamings	# MUSTDIE
                                            );
				
				    case maybe_afreezefile
				      
				         NULL
                                             =>
                                             {
                                                 NULL;
                                             };

				         THE freezefile
					     =>
					     {
					        register_new_freezefile (makefile_path, freezefile);

						file::vsay [   "\n         app/make7/parse/make7file-g.pkg:   Library                 ",
							     ad::describe makefile_path,
							     " (",
							     ad::abbreviate  (ad::os_string'  makefile_path),
							     ")     is up to date.\n\n"
							 ];

						THE freezefile;
					     };
                                    esac;
				};
			
			    case (find_cycle (freezefile_stack, []))
			      
			         THE cycle
                                     =>
                                     {   report cycle;
                                         NULL;
                                     };

			         NULL
                                     =>
                                     case (get_freezefile_cache_entry (makefile_path, primordial_make7file))
				       
				          THE freezefile => {
                                                               THE freezefile;
                                                             };
					  NULL            => {
                                                               load_freezefile ();
                                                              };
                                     esac;
                            esac;
			};                                                              #  fun load_freezefile_from_disk 

		    #
		    fun freeze_library (NULL
                                         , _	# MUSTDIE
                                       )
                            =>
                            NULL;

		        freeze_library (THE library
                                         , anchor_renamings	# MUSTDIE
                                       )
			    =>
			    # We may not freeze VIRTUAL libraries,
			    # only REAL ones, so start by checking
			    # its 'real_or_virtual' field:
			    #
			    case library
			      
				 lg::ERROR_LIBRARY => NULL;

				 lg::LIBRARY { real_or_virtual => lg::REAL _, ... }
				     =>
				     {
                                         frozen_library
					     =
					     freezefile::write_freezefile

						      make7_state

						      { library,
							any_errors  => p_err_flag
						      ,renamings => anchor_renamings   # MUSTDIE
						      };

					case frozen_library
					  
					     NULL
						 =>
						 NULL;

					     THE library'
						 =>
						 {
                                                      register_new_freezefile (make7_file_to_read, library');

						      THE library';
						 };
					esac;
				    };

				_ => THE library;
			    esac;

                    end;			# fun freeze_library
		
		                                # (resuming: fun main_parse)

                    # A VIRTUAL library must be a member of
                    # exactly one REAL library.  Check this:
		    #
		    case (source_path_map::get (*make7file_cache, make7_file_to_read))
		      
		         THE library_or_null
			     =>
			     library_or_null
                             where
			         case library_or_null
				   
				       THE (lg::LIBRARY { real_or_virtual => lg::VIRTUAL { owner, ... }, ... } )
					   =>
					   {
					       fun eq (NULL, NULL)
						       =>
						       TRUE;

						   eq (THE p, THE p')
						       =>
						       ad::compare (p, p') == EQUAL;

						   eq _ => FALSE;
					       end;

					       if   (not (eq (this_lib, owner)))
					           
						    error (cat ["library ",
								    ad::describe make7_file_to_read,
								    " appears as member of \
								    \two different libraries: ",
								    libname owner, " and ",
								    libname this_lib, "\n"]);

						     p_err_flag := TRUE;
					       fi;

					   };

				       _   => ();
                                 esac;

			     end;

		         NULL
                             =>
			     {   fun find_and_load_freezefile ()
				     =
				     load_freezefile_from_disk [] (make7_state, make7_file_to_read, version
                                                          , anchor_renamings	# MUSTDIE
                                                       );

				 #
				 fun find_and_parse_make7file ()
				     =
				     parse' (make7_file_to_read, library_stack, p_err_flag, this_lib, make7_state
                                                 , anchor_renamings	# MUSTDIE
                                            );

				 #
				 fun add_makefile_to_cache  library_or_null
				     =
				     {    make7file_cache
                                              :=
                                              source_path_map::set
                                                  (
                                                    *make7file_cache,
                                                    make7_file_to_read,
                                                    library_or_null
                                                  );
					  library_or_null;
				     };
								# source_path_map	is from   src/app/make7/paths/source-path-map.pkg
								# bare_o7		is from   src/app/make7/o7/bare-o7.pkg
				 #
				 fun cache_and_maybe_freeze_library  library_or_null
				     =
				     add_makefile_to_cache (

					 if   freeze_this_library

                                              freeze_library (library_or_null
                                                                , anchor_renamings	# MUSTDIE
                                                             );
					 else
                                              bare_o7::clean_library FALSE make7_file_to_read;
                                              library_or_null;
                                         fi
				     );

				 if   (not paranoid) 
				     
				      case (find_and_load_freezefile ())
				        
					   THE lib =>  add_makefile_to_cache (THE lib);
					   NULL    =>  cache_and_maybe_freeze_library (find_and_parse_make7file ());
                                      esac;
				 else
				      case (find_and_parse_make7file ())
				        
					   NULL
                                               =>
                                               add_makefile_to_cache NULL;

					   THE lib
					       =>
					       {   library_or_null'
						       =
						       if   (verify_freezefile::verify make7_state  *exports_map  lib)
						           
							    add_makefile_to_cache (

								case (find_and_load_freezefile ())
								  
								     THE lib' =>  THE lib';
								     NULL   =>  THE lib;
                                                                esac
							    );
						       else
							    delete_cached_freezefile (make7_state, make7_file_to_read, version, primordial_make7file);
							    cache_and_maybe_freeze_library (THE lib);
                                                       fi;

						 case library_or_null'
						   
						      THE lib'
                                                          =>
                                                          {   update_exports_map (lib, lib');
							      THE lib';
							  };

						      NULL => NULL;
                                                 esac;
					     };
                                      esac;
                                 fi;
			     };
                    esac;
		}                                                    # fun main_parse 


	    # Parse' is used when we are sure
	    # that we don't want to load a
	    # freezefile:
	    #
	    also
	    fun parse' (make7_file_to_read, library_stack, p_err_flag, this_lib, make7_state
                                , anchor_renamings	# MUSTDIE XXX BUGGO FIXME should kill anchor_renamings arg.
                       )
                =
                {   # Normal processing -- used when
		    # there is no cycle to report:
		    #
		    fun normal_processing ()
			=
			{   file::vsay [
                                "                   parse/make7file-g.pkg:   Reading   make   file   ",
                                (number_string::pad_right ' ' 50 (ad::abbreviate (ad::os_string' make7_file_to_read))),
                                "\ton behalf of ",
                                libname this_lib,
                                "\n"
                            ];

			    context
                                =
                                ad::dir
                                    make7_file_to_read;

			    local_index
                                =
                                make7grammar_actions::make_tool_index ();

			    #
			    safely::do
				{
				  open_it  => .{ file::open_for_read (ad::os_string  make7_file_to_read); },
				  close_it =>  file::close_input,
				  cleanup  =>  fn _ =  ()
				}
			       .{   source
                                        =
                                        s::make_source (
                                            ad::abbreviate  (ad::os_string   make7_file_to_read),
                                            1,
                                            #stream,
                                            FALSE,
                                            plaint_sink
                                        );

				    source_map
                                        =
                                        source.source_map;
												      

				    library_source_index::register
                                        library_source_index
                                        (make7_file_to_read,  source);


				    # We can hard-wire the source into this
				    # error function because the function
                                    # is only for immediate use and doesn't
				    # get stored into persistent data structures:
				    #
				    fun error r m
                                        =
                                        em::error source r em::ERROR m em::null_error_body;

				    #
				    fun obsolete r
                                        =
                                        if   (make7_defaults::warn_on_obsolete_syntax.get ())
				            
                                             em::error source r em::WARNING "old-style feature (obsolete)" em::null_error_body;
                                        fi;


				    # Return value of 'recursive_parse' is a library (never NULL).
				    # This function is used to parse sub-libraries.
				    # Errors are propagated by explicitly setting the
				    # "any_errors" flag of the parent library:
				    #
				    fun recursive_parse
                                            (src_pos1, src_pos2)
                                            this_lib
                                            (make7_file_to_parse,
                                                 version	# XXX BUGGO DELEME 'version' should die
                                                 , anchor_renamings	# MUSTDIE
                                            )
					=
					{
                                            library_stack'
                                                =
                                                (make7_file_to_read,  (source, src_pos1, src_pos2))
                                                !
                                                library_stack;

					    any_errors = source.any_errors;
					
					    # Unless we are in keep-going mode we do no further
					    # recursive treewalks once there was an error on
					    # this makefile:
					    #
					    if   (*any_errors  and  not keep_going)
					        
                                                 lg::ERROR_LIBRARY;
					    else
                                                 case (main_parse (
                                                          make7_file_to_parse,			#  New .make6 file to run recursively. 
							  version,
							  library_stack',
							  any_errors,
							  freeze_all_libraries,
							  this_lib,
							  make7_state,
							  anchor_renamings,		# MUSTDIE
							  error (src_pos1, src_pos2)
						      ))
						   
						      THE result =>  {
                                                                         result;
                                                                     };
						      NULL       =>  {   any_errors := TRUE;
                                                                         lg::ERROR_LIBRARY;
                                                                     };
                                                 esac;
                                            fi;
					}
					except
                                            exn as io_exceptions::IO _
						=
						{   error
                                                        (src_pos1, src_pos2)
                                                        (exceptions::exception_message exn);

						    lg::ERROR_LIBRARY;
						};

							# make7grammar_actions		is from   src/app/make7/semant/make7-grammar-actions.pkg
                                    #  
				    fun make_member
                                            (
                                              { name, make_path },
                                              src_pos1, src_pos2,
                                              ilk,
                                              tool_options
                                            )
					=
					make7grammar_actions::make_member

                                            {   make7_state,
					        load_plugin,
					        recursive_parse =>  recursive_parse (src_pos1, src_pos2)
					    }

					    {   name,
					        make_path,
					        ilk,

					        tool_options,
					        library     => (make7_file_to_read, (src_pos1, src_pos2)),

					        local_index,
					        context
					    };

				    # Build the argument for the lexer.
                                    # The lexer's local state is
                                    # encapsulated here to make sure
				    # the parser is re-entrant:
				    #
				    lexarg
                                        =
                                        {   #  Local state: 
					    depth     =  REF 0;
					    curstring =  REF [];
					    startpos  =  REF 0;
					    instring  =  REF FALSE;

					    #  Handling comments: 
					    fun enter_comment ()
                                                =
                                                depth := *depth + 1;

					    #
					    fun leave_comment ()
                                                =
                                                {   d = *depth - 1;
						
						    depth := d;
						    d == 0;
						};


					    #  Handling strings: 
					    fun new_string pos
                                                =
                                                {   instring  :=  TRUE;
						    curstring :=  [];
						    startpos  :=  pos;
                                                };

					    #
					    fun add_string c
                                                =
                                                curstring :=  c ! *curstring;

					    #
					    fun add_character (s, offs)
                                                =
                                                add_string (char::from_int (char::to_int (string::get (s, 2)) - offs));

					    #
					    fun add_number (s, pos)
                                                =
                                                {   ns =  substring (s, 1, 3);
						    n  =  int::from_string ns;
						
						    add_string (char::from_int (the n))
						    except _
                                                        =
							error (pos, pos + size s)
								 ("illegal decimal char spec: " + ns);
						};

					    #
					    fun get_string (pos, tok)
                                                =
                                                {   instring := FALSE;
						    tok (implode (reverse *curstring), *startpos, pos);
                                                };


					    #  Handling EOF: 
					    fun handle_eof ()
                                                =
						pos
                                                where
                                                    pos =  sm::last_change  source_map;
						
						    if   (*depth > 0)
						        
                                                         error (pos, pos) "unexpected end of input in comment";
						    else
                                                         if *instring
                                                              error (pos, pos) "unexpected end of input in string";
							 fi;
                                                    fi;
						end;

					    #
					    fun newline  pos			#  Handling line breaks
                                                =
                                                sm::newline  source_map  pos;

					    #
					    fun sync (p, t)			#  Handling #line directives
                                                =
                                                {   fun sep c
                                                        =
                                                        c == '#'  or  char::is_space c;

						    #
						    fun convert s
                                                        =
                                                        the_else (int::from_string s, 0);

						    #
						    fun r (line, col, file)
                                                        =
                                                        sm::resynch
                                                            source_map
							    (p, { file_name => file,
								  line, column => col } );
						

						    case (string::tokens sep t)
						      
							 [_, line            ]   =>   r (convert line, NULL,              NULL    );
							 [_, line, file      ]   =>   r (convert line, NULL,              THE file);
							 [_, line, col, file ]   =>   r (convert line, THE (convert col), THE file);
							  _                      =>   error (p, p + size t) "illegal #line directive";
                                                    esac;
						};
					
					    { enter_comment,
					      leave_comment,

					      new_string,
					      add_string,

					      add_character,
					      add_number,
					      get_string,

					      handle_eof,
					      newline,
					      obsolete,

					      error,
					      sync,

					      in_section2 =>  REF FALSE
					   };
					};

				    #
				    fun inputc k
                                        =
                                        file::read  #stream;


				    token_stream
                                        =
                                        make7file::make_lexer  inputc  lexarg;


				    parsearg
                                        =
                                        {   library_path => make7_file_to_read,
					    context,
					    obsolete,

					    error,
					    make_member,
					    this_lib,

					    make7_state,
					    primordial_make7file
					};

				    my (parse_result, _)
                                        =
                                        make7file::parse (
                                            lookahead,
					    token_stream,
					    fn (s, p1, p2) =  error (p1, p2) s,
					    parsearg
					);
				
				    if *source.any_errors   NULL;
				    else                    THE parse_result;     fi;
				};
			    #
                                
			
			}
		        except
                            lr_parser::PARSE_ERROR = NULL;
		
		    if   (has_cycle (make7_file_to_read, library_stack))
		         NULL;
		    else normal_processing ();  fi;
		};                                                                #  fun parse' 
	
	    bare_o7::new_generation ();

	    case (main_parse (
                     make7_file_to_read,
                     NULL,			# version
                     [],			# library_stack
                     REF FALSE,			# p_err_flag
                     freeze_this_library,
                     NULL,			# this_lib
                     make7_state0,
                    [],				# anchor_renamings	# MUSTDIE
                    fn _ = ()
                 ))
	      
	         NULL  =>  NULL;
	         THE g =>  THE (g, make7_state0);
            esac;
	};                                       #  fun build_interlibrary_dependency_graph_from_make7file_tree 
};










##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[{ \t]*\\(fun \\)"				 	 #
# End:									 #
##########################################################################
