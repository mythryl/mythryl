// heap-debug-stuff.c
//
// Heap-centric debug-support code for Heisenbug hunting.

#include "../mythryl-config.h"

#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <pthread.h>

#ifdef HAVE_LIBDIS_H
#include <libdis.h>	// x86 disasembler library from Debian packages:  libdisasm0 + libdisasm-dev
#endif

#if HAVE_SYS_TIME_H
#  include <sys/time.h>
#endif

#include "runtime-base.h"
#include "runtime-configuration.h"
#include "runtime-values.h"
#include "get-quire-from-os.h"
#include "coarse-inter-agegroup-pointers-map.h"
#include "heap.h"
#include "hexdump-if.h"


//////////////////////////////////////////////////////////////////////////////////////
//            RAMLOG
//
// The bulk of the logic for this facility is in
//
//     src/c/h/runtime-base.h
//        
// -- see the overview comments there.
//
Ramlog_Entry ramlog_circular_queue[  RAMLOG_ENTRIES  ];
int          ramlog_next_entry_to_write = 0;


//
static char*  val_sized_unt_as_ascii(  char* buf,  Val_Sized_Unt u ) {
    //        ======================
    //
    char* p = buf;
    //
    for (int i = 0;
             i < sizeof(Val_Sized_Unt);
             i++
    ){
	//
	char c =  u & 0xFF;
	u      =  u >> 8;
	*p++ = (c >= ' ' && c <= '~') ? c : '.';
    } 

    *p++ = '\0';

    return buf;
}

//
static FILE*   open_heapdump_logfile   (char* filename_buf, size_t bufsize, char* dumptype) {
    //         =====================
    //
    // The idea here is to write each heap snapshot to a separate file
    // to facilitate diff-ing between them and to avoid spamming the
    // main logfile for the process.
    //
    // We want to minimize the chance of two dumps clobbering
    // each other, so we make the snapshot filename depend on:
    //
    //     getpid()
    //     pthread_self()
    //     gettimeofday()
    //     sequentially assigned dump number.
    //
    struct timeval tv;
    //
    if (gettimeofday(&tv,NULL)) {
	fprintf(stderr,"open_heapdump_logfile: gettimeofday failed: %s\n", strerror(errno) );
	exit(1);
    }

    static int dump_number = 0;

    int pid    = getpid();
    int	c_sec  = tv.tv_sec;									// Current time to second accuracy.
    int	c_usec = tv.tv_usec;									// Fractional current time to nominal microsecond accuracy, usually actually good to roughly millisecond resolution.
    int ptid   = (int)(pthread_self());
    //
    snprintf(filename_buf, bufsize, "%s-%08x-%08x-%08d.%06d-%d.log", dumptype, pid, ptid, c_sec, c_usec, dump_number++);

    FILE* fd = fopen(filename_buf, "w");
    if (!fd) {
	fprintf(stderr,"open_heapdump_logfile: Unable to fopen(%s): %s\n", filename_buf, strerror(errno) );
	exit(1);
    }
    return fd;
}
//
static void   close_heapdump_logfile   (FILE* fd, char* filename) {
    //        ======================
    //
    if (fclose(fd)) {
	fprintf(stderr,"close_heapdump_logfile: Unable to fclose(%s): %s\n", filename, strerror(errno) );
	exit(1);
    }
}
//
static unsigned int   v2u   (Val v) { return (unsigned int) v; }		// More type-safe than using a cast:  Ensures that we really are converting a Val.
//                    ===

// Write to logfile contents of a Task record:
//
static void   dump_task__guts   (FILE* fd, Task* task, char* caller) {
    //        ===============
    //
    fprintf(fd,"Task dump generated by dump_task__guts in src/c/heapcleaner/heap-debug-stuff.c\n"	);
    fprintf(fd,"\n"										);
    fprintf(fd,"                          caller s=%s\n",  caller);
    fprintf(fd,"                            task p=%p\n",  task);
    fprintf(fd,"                            heap p=%p\n",  task->heap);
    fprintf(fd,"                         pthread p=%p\n",  task->pthread);
    fprintf(fd,"                     pthread->id x=%x\n",  (unsigned int)(task->pthread->tid));
    fprintf(fd,"         heap_allocation_buffer  p=%p\n",  task->heap_allocation_buffer);
    fprintf(fd,"         heap_allocation_pointer p=%p\n",  task->heap_allocation_pointer);
    fprintf(fd,"           heap_allocation_limit p=%p\n",  task->heap_allocation_limit);
    fprintf(fd,"      real_heap_allocation_limit p=%p\n",  task->real_heap_allocation_limit);
    fprintf(fd,"                        argument x=%x\n",  v2u( task->argument ));
    fprintf(fd,"                            fate x=%x\n",  v2u( task->fate ));
    fprintf(fd,"                 current_closure x=%x\n",  v2u( task->current_closure ));
    fprintf(fd,"                   link_register px=%x\n", v2u( task->link_register ));
    fprintf(fd,"                 program_counter x=%x\n",  v2u( task->program_counter ));
    fprintf(fd,"                  exception_fate x=%x\n",  v2u( task->exception_fate ));
    fprintf(fd,"                  current_thread x=%x\n",  v2u( task->current_thread ));
    fprintf(fd,"                  heap_changelog x=%x\n",  v2u( task->heap_changelog ));
    fprintf(fd,"                 fault_exception x=%x\n",  v2u( task->fault_exception ));
    fprintf(fd,"        faulting_program_counter x=%x\n",  (unsigned int) task->faulting_program_counter);	// Val_Sized_Unt.
    fprintf(fd,"                 protected_c_arg p=%p\n",  task->protected_c_arg);
    fprintf(fd,"                       &heapvoid p=%p\n", &task->heapvoid);
    fprintf(fd," Following stuff is in task->heap:\n");
    fprintf(fd,"         agegroup0_master_buffer p=%p\n",  task->heap->agegroup0_master_buffer);
    fprintf(fd,"agegroup0_master_buffer_bytesize x=%x\n",  (unsigned int) task->heap->agegroup0_master_buffer_bytesize);	// Punt
    fprintf(fd,"                sum of above two p=%p\n",  (char*)(task->heap->agegroup0_master_buffer) + task->heap->agegroup0_master_buffer_bytesize);
    fprintf(fd,"                           quire p=%p\n",  task->heap->quire);
    fprintf(fd,"                active_agegroups d=%d\n",  task->heap->active_agegroups);
    fprintf(fd,"       hugechunk_ramregion_count d=%d\n",  task->heap->hugechunk_ramregion_count);
    fprintf(fd,"           total_bytes_allocated x=(%x,%x) (millions, 1s)\n",  (unsigned int)task->heap->total_bytes_allocated.millions, (unsigned int)task->heap->total_bytes_allocated.ones );
    fprintf(fd,"oldest_agegroup_keeping_idle_fromspace_buffers d=%d\n",  task->heap->oldest_agegroup_keeping_idle_fromspace_buffers);

    for (int i = 0;
             i < task->heap->active_agegroups;
             i++
    ){
	//
	Agegroup* a = task->heap->agegroup[ i ];
	fprintf(fd,"           agegroup[%d] p=%p (holds agegroup %d)\n",  i, a, i+1);
	fprintf(fd,"           a->age       d=%d\n",  a->age);
	fprintf(fd,"           a->cleanings d=%d\n",  a->cleanings);
	fprintf(fd,"           a->ratio     x=%x (Desired number of collections of the previous agegroup for one collection of this agegroup)\n",  a->ratio);
	fprintf(fd,"           a->last_cleaning_count_of_younger_agegroup d=%d\n",  a->last_cleaning_count_of_younger_agegroup);

	for (int s = 0;
                 s < MAX_PLAIN_SIBS;
                 s++
        ){
	    //
	    fprintf(fd,"\n");
	    fprintf(fd,"          a->sib[%d]    p=%p\n",  s, a->sib[s]);
	    fprintf(fd,"          a->sib[%d].id d=%d\n",  s, a->sib[s]->id);
	    fprintf(fd,"\n");
	    fprintf(fd,"          a->sib[%d].tospace            p=%p\n",  s, a->sib[s]->tospace);
	    fprintf(fd,"          a->sib[%d].tospace_bytesize   p=%p\n",  s, (void*)a->sib[s]->tospace_bytesize);		// Punt
	    fprintf(fd,"          a->sib[%d].tospace_limit      p=%p\n",  s, a->sib[s]->tospace_limit);
	    fprintf(fd,"\n");
	    fprintf(fd,"          a->sib[%d].fromspace          p=%p\n",  s, a->sib[s]->fromspace);
	    fprintf(fd,"          a->sib[%d].fromspace_bytesize x=%x\n",  s, (unsigned int) a->sib[s]->fromspace_bytesize);	// Val_Sized_Unt
	    fprintf(fd,"          a->sib[%d].fromspace_used_end p=%p\n",  s, a->sib[s]->fromspace_used_end);
	    fprintf(fd,"\n");
	    fprintf(fd,"          a->sib[%d].next_tospace_word_to_allocate p=%p\n",  s, a->sib[s]->next_tospace_word_to_allocate);
	    fprintf(fd,"          a->sib[%d].next_word_to_sweep_in_tospace p=%p\n",  s, a->sib[s]->next_word_to_sweep_in_tospace);
	    fprintf(fd,"          a->sib[%d].repairlist p=%p\n",  s, a->sib[s]->repairlist);
	    fprintf(fd,"          a->sib[%d].end_of_fromespace_oldstuff p=%p\n",  s, a->sib[s]->end_of_fromspace_oldstuff);
	}
    }
}
void   dump_task   (Task* task, char* caller) {
    // =========
    //
    char filename[ 1024 ];
    FILE* fd = open_heapdump_logfile( filename, 1024, "dump_task" );
    //
    log_if("dump_task: Starting dump to '%s'", filename);

    dump_task__guts   (fd, task, caller);

    close_heapdump_logfile( fd, filename );
    log_if("dump_task: Dump to '%s' now complete.", filename);
}

//
static void   dump_gen0_tripwire_buffers__guts   (FILE* fd, Task* task, char* caller) {
    //        ================================
    //
    fprintf(fd,"\n\n\n"																);
    fprintf(fd,"======================================================================================================================\n"	);
    fprintf(fd,"Generation-0 tripwire buffer dump generated by  dump_gen0_tripwire_buffers()  in  src/c/heapcleaner/heap-debug-stuff.c\n"	);

    for (int t = 0;  t < MAX_PTHREADS;  ++t) {
        //
        task =  pthread_table__global[ t ]->task;
        //
	unsigned char* buf_as_ucharptr  =  (((unsigned char*)(task->real_heap_allocation_limit)) + MIN_FREE_BYTES_IN_AGEGROUP0_BUFFER);
	Val_Sized_Int* buf_as_valintptr =  (Val_Sized_Int*) buf_as_ucharptr;

        fprintf(fd,"\n"																);
	fprintf(fd,"--------------------------------------\n"											);
	fprintf(fd,"Hexdump of overrun buffer for pthread %d -- should be all zeros:\n\n", t );
	//
	hexdump_to_file  (fd, "", buf_as_ucharptr, AGEGROUP0_OVERRUN_TRIPWIRE_BUFFER_SIZE_IN_WORDS * sizeof(Val_Sized_Int));

	fprintf(fd,"Same buffer listed as hex words:\n\n" );
	//
	for (int i = 0;  i < AGEGROUP0_OVERRUN_TRIPWIRE_BUFFER_SIZE_IN_WORDS;  ++i) {
	    //
	    fprintf(fd,"%p: %08x\n",  buf_as_valintptr + i,  (unsigned int) buf_as_valintptr[ i ]);
	}
    }
}
void   dump_gen0_tripwire_buffers   (Task* task, char* caller) {
    // ==========================
    //
    char filename[ 1024 ];
    FILE* fd = open_heapdump_logfile( filename, 1024, "dump_gen0_tripwire_buffers" );
    //
    log_if("dump_gen0_tripwire_buffers: Starting dump to '%s'", filename);

    dump_gen0_tripwire_buffers__guts   (fd, task, caller);

    close_heapdump_logfile( fd, filename );
    log_if("dump_gen0_tripwire_buffers: Dump to '%s' now complete.", filename);
}

//
static void   dump_records   (FILE* fd, Val* start, Val* stop) {
    //        ============
    //    
    int words_left_in_record = 0;
    //
    for (Val* p = start;
	      p < stop;
	      p++
    ){
	//
	if (words_left_in_record > 0
	||  !IS_TAGWORD(*p)
	){
	    if (!words_left_in_record)   fprintf(fd,"\n");
	    //
	    char buf[ 132 ];
	    char* as_ascii = val_sized_unt_as_ascii(buf,(Val_Sized_Unt)(*p));
	    fprintf(fd," %8p: %08x  %s",  p, v2u(*p), as_ascii);
	    //
	    if (!words_left_in_record
	    && (!(((int)p)&4))					// We use padwords to 64-bit align a record payload, which non-64-bits-aligns the record tagword itself -- so the padword itself is 64-bit aligned.  Unintuitive.
	    && IS_TAGWORD(p[1])
	    && GET_BTAG_FROM_TAGWORD(p[1])==EIGHT_BYTE_ALIGNED_NONPOINTER_DATA_BTAG
	    ){
		fprintf(fd,"    (padword to 64-bit align payload of following record)");
	    }
	    //
	    fprintf(fd,"\n");
	    --words_left_in_record;

	} else {

	    int   words = GET_LENGTH_IN_WORDS_FROM_TAGWORD(*p);
	    Bool  words_is_bogus = FALSE;
	    Bool    tag_is_bogus = FALSE;
	    char* tag;

	    switch (GET_BTAG_FROM_TAGWORD(*p)) {
	    //
	    case PAIRS_AND_RECORDS_BTAG:				tag = "RECORD";					break;
	    //
	    case RW_VECTOR_HEADER_BTAG:
		words_is_bogus = TRUE;				// 'words' field is abused for additional tag info in this case -- length is implicitly fixed at 2 words.
		switch (words) {
		case VECTOR_OF_EIGHT_BYTE_FLOATS_CTAG:			tag = "FLOAT64_RW_VECTOR HEADER";		break;
		case TYPEAGNOSTIC_VECTOR_CTAG:				tag = "TYPEAGNOSTIC_RW_VECTOR HEADER";		break;
		case VECTOR_OF_ONE_BYTE_UNTS_CTAG:			tag = "UNT8_RW_VECTOR HEADER";			break;
		default:	tag_is_bogus = TRUE;			tag = "???_RW_VECTOR HEADER";			break;
		}
		words = 2;
		break;
	    //
	    case RO_VECTOR_HEADER_BTAG:
		words_is_bogus = TRUE;				// 'words' field is abused for additional tag info in this case -- length is implicitly fixed at 2 words.
		switch (words) {
		case TYPEAGNOSTIC_VECTOR_CTAG:			tag = "TYPEAGNOSTIC_RO_VECTOR HEADER";		break;
		case VECTOR_OF_ONE_BYTE_UNTS_CTAG:			tag = "STRING / UNT8_RO_VECTOR HEADER";		break;
		default:	tag_is_bogus = TRUE;			tag = "???_RO_VECTOR HEADER";			break;
		}
		words = 2;
		break;
	    //
	    case RW_VECTOR_DATA_BTAG:				tag = "RW_VECTOR_DATA";				break;
	    case FOUR_BYTE_ALIGNED_NONPOINTER_DATA_BTAG:		tag = "NONPTR_DATA4";				break;
	    case EIGHT_BYTE_ALIGNED_NONPOINTER_DATA_BTAG:		tag = "NONPTR_DATA8";				break;
	    case EXTERNAL_REFERENCE_IN_EXPORTED_HEAP_IMAGE_BTAG:	tag = "EXTERNAL_REF";				break;
	    case FORWARDED_CHUNK_BTAG:				tag = "FORWARDED";				break;
	    //
	    case WEAK_POINTER_OR_SUSPENSION_BTAG:
		words_is_bogus = TRUE;				// 'words' field is abused for additional tag info in this case -- length is implicitly fixed at 2 words.
		switch (words) {
		case UNEVALUATED_LAZY_SUSPENSION_CTAG:		tag = "UNEVAL_SUSPENSION";			break;
		case   EVALUATED_LAZY_SUSPENSION_CTAG:		tag =   "EVAL_SUSPENSION";			break;
		case                WEAK_POINTER_CTAG:		tag = "WEAK_PTR";				break;
		case         NULLED_WEAK_POINTER_CTAG:		tag = "NULLED_WEAK_PTR";			break;
		default:	tag_is_bogus = TRUE;			tag = "??? (bogus WEAK/LAZY)";			break;
		}	
		words = 1;
		break;
	    //
	    default:	tag_is_bogus = TRUE;			tag = "???";					break;
	    }

	    if (!tag_is_bogus)	words_left_in_record = words;		// If the tag is bogus, the length probably is too, so ignore it.

	    if (words_is_bogus)	fprintf(fd,"\n %8p: %08x %s\n",          p, v2u(*p),        tag);
	    else			fprintf(fd,"\n %8p: %08x %d-word %s\n",  p, v2u(*p), words, tag);
	}
    }
}


// Write to logfile contents of the generation0
// buffer for a given Task.  No attempt is made
// to distinguish live from dead data.
//
static void   dump_gen0__guts   (FILE* fd, Task* task, char* caller) {
    //        ===============
    //
    fprintf(fd,"Generation-0 dump generated by dump_gen0__guts in src/c/heapcleaner/heap-debug-stuff.c\n"	);
    fprintf(fd,"\n"											);
    fprintf(fd," generation-0 heapbuffer dump for pthread->id x=%x, called by %s\n",  (unsigned int)(task->pthread->tid), caller);
    fprintf(fd,"         agegroup0_master_buffer p=%p\n",  task->heap->agegroup0_master_buffer);
    fprintf(fd,"agegroup0_master_buffer_bytesize x=%x\n",  (unsigned int)task->heap->agegroup0_master_buffer_bytesize);				// Punt
    fprintf(fd,"                sum of above two p=%p\n",  (char*)(task->heap->agegroup0_master_buffer) + task->heap->agegroup0_master_buffer_bytesize);
    fprintf(fd,"         heap_allocation_pointer p=%p\n",  task->heap_allocation_pointer);
    fprintf(fd,"           heap_allocation_limit p=%p\n",  task->heap_allocation_limit);
    fprintf(fd,"      real_heap_allocation_limit p=%p\n",  task->real_heap_allocation_limit);
    fprintf(fd," gen0 buffer contents:\n\n");
    //
    dump_records( fd, task->heap_allocation_buffer, task->heap_allocation_pointer );
}
//
void   dump_gen0   (Task* task, char* caller) {
    // =========
    //
    char filename[ 1024 ];
    FILE* fd = open_heapdump_logfile( filename, 1024, "dump_gen0" );

    log_if("dump_gen0: Starting dump to '%s'", filename);

    dump_gen0__guts( fd, task, caller );

    close_heapdump_logfile( fd, filename );
    log_if("dump_gen0: Dump to '%s' now complete.", filename);
}
//
static void   dump_gen0s__guts   (FILE* fd, Task* task, char* caller) {
    //        ================
    //
    for (int i = 0;  i < MAX_PTHREADS;  ++i) {
        //
        task = pthread_table__global[i]->task;
	//
	fprintf(fd,"Generation-0 dump generated by dump_gen0__guts in src/c/heapcleaner/heap-debug-stuff.c\n"	);
	fprintf(fd,"\n"											);
	fprintf(fd," generation-0 heapbuffer dump for pthread->id x=%x, called by %s\n",  (unsigned int)(task->pthread->tid), caller);
	fprintf(fd,"    agegroup0_master_buffer p=%p\n",  task->heap->agegroup0_master_buffer);
	fprintf(fd,"  agegroup0_master_buffer_bytesize x=%x\n",  (unsigned int)task->heap->agegroup0_master_buffer_bytesize);				// Punt
	fprintf(fd,"           sum of above two p=%p\n",  (char*)(task->heap->agegroup0_master_buffer) + task->heap->agegroup0_master_buffer_bytesize);
	fprintf(fd,"    heap_allocation_pointer p=%p\n",  task->heap_allocation_pointer);
	fprintf(fd,"      heap_allocation_limit p=%p\n",  task->heap_allocation_limit);
	fprintf(fd," real_heap_allocation_limit p=%p\n",  task->real_heap_allocation_limit);
	fprintf(fd," gen0 buffer contents:\n\n");
    }

    dump_records( fd, task->heap->agegroup0_master_buffer, task->heap_allocation_pointer );		// BUGGO, task->heap->agegroup0_master_buffer is for all tasks combined.
}
//
void   dump_gen0s   (Task* task, char* caller) {
    // ==========
    //
    char filename[ 1024 ];
    FILE* fd = open_heapdump_logfile( filename, 1024, "dump_gen0s" );

    log_if("dump_gen0s: Starting dump to '%s'", filename);

    dump_gen0s__guts( fd, task, caller );

    close_heapdump_logfile( fd, filename );
    log_if("dump_gen0: Dump to '%s' now complete.", filename);
}


//
static void   dump_sib   (Task* task, FILE* fd, Sib* sib) {
    //        ========
    fprintf(fd,"                     sib->id x= %04x  = id%01x/kind%02x/age%01x\n",	sib->id, GET_ID_FROM_SIBID(sib->id), GET_KIND_FROM_SIBID(sib->id), GET_AGE_FROM_SIBID(sib->id)	);
    fprintf(fd,"                     sib->next_tospace_word_to_allocate p= %p\n",	sib->next_tospace_word_to_allocate			);
    fprintf(fd,"\n"																);
    fprintf(fd,"                     sib->tospace          p= %p\n",				sib->tospace					);
    fprintf(fd,"                     sib->tospace_bytesize x= 0x%08x\n",	(unsigned int)  sib->tospace_bytesize				);
    fprintf(fd,"                     sib->tospace_limit    p= %p\n",				sib->tospace_limit				);
    fprintf(fd,"\n"																);
    fprintf(fd,"                     sib->next_word_to_sweep_in_tospace p= %p\n",		sib->next_word_to_sweep_in_tospace		);
    fprintf(fd,"                     sib->repairlist p= %p\n",					sib->repairlist					);
    fprintf(fd,"\n"																);
    fprintf(fd,"                     sib->fromspace          p= %p\n",				sib->fromspace					);
    fprintf(fd,"                     sib->fromspace_bytesize x= 0x%08x\n",(unsigned int)	sib->fromspace_bytesize				);
    fprintf(fd,"                     sib->fromspace_used_end p= %p\n",				sib->fromspace_used_end				);
    fprintf(fd,"\n"																);
    fprintf(fd,"                     sib->end_of_fromspace_oldstuff p= %p\n",		sib->end_of_fromspace_oldstuff				);
    fprintf(fd,"                     sib->sib_for_promoted_chunks   p= %p\n",		sib->sib_for_promoted_chunks				);
    fprintf(fd,"\n"																);
    fprintf(fd,"                     sib->heap_needs_repair b= %s\n",			sib->heap_needs_repair ? "TRUE" : "FALSE"		);
    fprintf(fd,"\n"																);
    fprintf(fd,"                     sib->requested_sib_buffer_bytesize x= %08x\n",	(unsigned int) sib->requested_sib_buffer_bytesize	);
    fprintf(fd,"                     sib->soft_max_bytesize             x= %08x\n",	(unsigned int) sib->soft_max_bytesize			);
}


//
static void   dump_record_sib   (Task* task, FILE* fd, Sib* sib) {
    //        ===============
    //
    dump_records   (fd, sib->tospace, sib->next_tospace_word_to_allocate);
}
//
static void   dump_pair_sib   (Task* task, FILE* fd, Sib* sib) {	// The pairs in the pair sib have no tag/length word -- avoiding that overhead is the main point of having a separate sib for pairs.
    //        =============
    for (Val* p = sib->tospace;
	      p < sib->next_tospace_word_to_allocate;
	      p += 2
    ){
	fprintf(fd,"\n");
	fprintf(fd," %8p: %08x\n",  p, v2u(*p));
	fprintf(fd," %8p: %08x\n",  p, v2u(*p));
    }    
}
//
static void   dump_string_sib   (Task* task, FILE* fd, Sib* sib) {
    //        ===============
    //
    for (Val* p = sib->tospace;
	      p < sib->next_tospace_word_to_allocate;
	      p++
    ){
	char buf[ 132 ];
	char* as_ascii = val_sized_unt_as_ascii(buf,(Val_Sized_Unt)(*p));
	fprintf(fd," %8p: %08x  %s\n",  p, v2u(*p), as_ascii);
    }    
}
//
static void   dump_vector_sib   (Task* task, FILE* fd, Sib* sib) {
    //        ===============
    //
    dump_records   (fd, sib->tospace, sib->next_tospace_word_to_allocate);

//    for (Val* p = sib->tospace;
//	      p < sib->next_tospace_word_to_allocate;
//	      p++
//    ){
//	fprintf(fd," %8p: %08x\n",  p, v2u(*p));
//    }    
}



// Write to logfile contents of the generation-1
// buffer for a given Task.  No attempt is made
// to distinguish live from dead data.
//
static void   dump_gens__guts   (FILE* fd, Task* task, char* caller) {
    //        ===============
    //
    Heap*     heap =  task->heap;

    fprintf(fd,"Generation-1 dump generated by dump_gens__guts in src/c/heapcleaner/heap-debug-stuff.c\n"							);
    fprintf(fd,"\n"																	);

    for (int a = 0;
             a < task->heap->active_agegroups;
             a++
    ){
	fprintf(fd,"\n"																	);
	fprintf(fd,"\n"																	);
	fprintf(fd,"=====================\n"														);
	fprintf(fd,"Dump of generation %d\n", a+1);
	fprintf(fd,"\n"																	);

	Agegroup* ag  =  heap->agegroup[a];		// Get pointer to our agegroup.

	fprintf(fd,"                     task p= %p\n",					task								);
	fprintf(fd,"                     heap p= %p  (task->heap)\n",			heap								);
	fprintf(fd,"                      ag p= %p  (agegroup%d)\n",			ag, a+1								);
	fprintf(fd,"\n"																	);
	fprintf(fd,"                 ag->age d= %d\n",						ag->age							);
	fprintf(fd,"                 ag->cleanings d= %d\n",					ag->cleanings						);
	fprintf(fd,"                 ag->ratio     d= %d\n",					ag->ratio						);
	fprintf(fd,"                 ag->last_cleaning_count_of_younger_agegroup d= %d\n",	ag->last_cleaning_count_of_younger_agegroup		);
	fprintf(fd,"                 ag->tospace_ram_region p= %p\n",				ag->tospace_ram_region					);
	fprintf(fd,"                 ag->fromspace_ram_region p= %p\n",				ag->fromspace_ram_region				);
	fprintf(fd,"                 ag->saved_fromspace_ram_region p= %p\n",			ag->saved_fromspace_ram_region				);
	fprintf(fd,"                 ag->coarse_inter_agegroup_pointers_map p= %p\n",		ag->coarse_inter_agegroup_pointers_map			);


	fprintf(fd,"                 ag->hugechunks[0] p= %p   (CODE__HUGE_SIB)\n",		ag->hugechunks[0]					);

	fprintf(fd,"                 ag->sib[%d] p= %p    (RECORD_SIB)\n",			RECORD_SIB,	ag->sib[RECORD_SIB]			);
	fprintf(fd,"                 ag->sib[%d] p= %p    (  PAIR_SIB)\n",			  PAIR_SIB,	ag->sib[  PAIR_SIB]			);
	fprintf(fd,"                 ag->sib[%d] p= %p    (STRING_SIB)\n",			STRING_SIB,	ag->sib[STRING_SIB]			);
	fprintf(fd,"                 ag->sib[%d] p= %p    (VECTOR_SIB)\n",			VECTOR_SIB,	ag->sib[VECTOR_SIB]			);


	fprintf(fd,"\n------------------------\nRECORD_ILK sib details:\n");    dump_sib(task,fd, ag->sib[RECORD_SIB] );
	fprintf(fd,"\n------------------------\n  PAIR_SIB sib details:\n");    dump_sib(task,fd, ag->sib[  PAIR_SIB] );
	fprintf(fd,"\n------------------------\nSTRING_ILK sib details:\n");    dump_sib(task,fd, ag->sib[STRING_SIB] );
	fprintf(fd,"\n------------------------\nVECTOR_ILK sib details:\n");    dump_sib(task,fd, ag->sib[VECTOR_SIB] );


	fprintf(fd,"\n------------------------\nRECORD_ILK sib contents -- immutable pointerblocks:\n");		dump_record_sib( task, fd, ag->sib[RECORD_SIB] );
	fprintf(fd,"\n------------------------\n  PAIR_SIB sib contents -- immutable pointerpairs:\n");			  dump_pair_sib( task, fd, ag->sib[  PAIR_SIB] );
	fprintf(fd,"\n------------------------\nSTRING_ILK sib contents -- immutable nonpointer stuff:\n");		dump_string_sib( task, fd, ag->sib[STRING_SIB] );
	fprintf(fd,"\n------------------------\nVECTOR_ILK sib contents -- all mutable data goes in this sib:\n");	dump_vector_sib( task, fd, ag->sib[VECTOR_SIB] );
    }
}
//
void   dump_gens   (Task* task, char* caller) {
    // =========
    //

    char filename[ 1024 ];
    FILE* fd = open_heapdump_logfile( filename, 1024, "dump_gens" );

    log_if("dump_gens: Starting dump to '%s'", filename);

    dump_gens__guts   (fd, task, caller);

    close_heapdump_logfile( fd, filename );
    log_if("dump_gens: Dump to '%s' now complete.", filename);
}
//
static char* chunkstate_to_string( unsigned char state ) {
    //
    switch (state) {
    //
    case FREE_HUGECHUNK:			return "FREE_HUGECHUNK";
    case YOUNG_HUGECHUNK:			return "YOUNG_HUGECHUNK";
    case YOUNG_FORWARDED_HUGECHUNK:		return "YOUNG_FORWARDED_HUGECHUNK";
    case OLD_HUGECHUNK:				return "OLD_HUGECHUNK";
    case OLD_PROMOTED_HUGECHUNK:		return "OLD_PROMOTED_HUGECHUNK";
    //
    default:
	return "???";
    }
}
//
static void   dump_hugechunk   (FILE* fd, Hugechunk* p) {
    //        ==============
    //
    fprintf(fd,"\nHugechunk list entry %p:\n", p);
    fprintf(fd,"    next     p= %p\n", p->next);
    fprintf(fd,"    prev     p= %p\n", p->prev);
    fprintf(fd,"    chunk    p= %p   (This is the actual free chunk itself)\n", (void*)p->chunk);
    fprintf(fd,"    bytesize x= %x\n", (unsigned int)p->bytesize);							// Punt
    fprintf(fd,"    huge_ilk d= %d  (Currently always CODE__HUGE_SIB=%d) \n", p->huge_ilk, CODE__HUGE_SIB);		// unsigned char
    fprintf(fd,"    state     = %s  (One of FREE_HUGECHUNK/YOUNG_HUGECHUNK/YOUNG_FORWARDED_HUGECHUNK/OLD_HUGECHUNK/OLD_PROMOTED_HUGECHUNK) \n", chunkstate_to_string(p->hugechunk_state));	// unsigned char
    fprintf(fd,"    age      d= %d  (Chunk's agegroup)\n", (int)p->age);						// unsigned char
    fprintf(fd,"    region   p= %p  (Hugechunk_Region containing hugechunk)\n", p->region);
}
//
static void   expand_tabs   (char* outbuf, char* inbuf) {
    //        ===========
    //
    int col = 0;
    
    for (int c = *inbuf++;
             c;
             c = *inbuf++
    ){
	if (c != '\t') {
	    *outbuf++ = tolower(c);			// libdisasm0 generates upper-case hex constants and I prefer lowercase hex constants, hence the tolower() here.
	    col++;
	} else {
	    do {
		*outbuf++ = ' ';
		col++;
	    } while (col & 7);
	}
    }
    *outbuf++ = '\0';
}

// Write to logfile summary of the Hugechunk datastructures.
// (In practice this means all the compiledfiles in ram.)
//
static void   dump_hugechunks_summary__guts   (FILE* fd, Task* task, char* caller) {
    //        =============================
    //
    Heap*     heap =  task->heap;

    fprintf(fd,"Hugechunk datastructures dump generated by dump_hugechunks_summary__guts in src/c/heapcleaner/heap-debug-stuff.c\n"			);
    fprintf(fd,"Most of this stuff is defined in one of:\n"												);
    fprintf(fd,"\n"																	);
    fprintf(fd,"    src/c/h/runtime-base.h\n"														);
    fprintf(fd,"    src/c/h/heap.h\n"															);
    fprintf(fd,"    src/c/h/sibid.h\n"															);
    fprintf(fd,"    src/c/h/heap-tags.h\n"														);
    fprintf(fd,"\n"																	);



    fprintf(fd,"\n\n--------------------------------------\nHugechunk region list contains %d regions:\n", heap->hugechunk_ramregion_count		);
    for (Hugechunk_Region* r = heap->hugechunk_ramregions;
			   r;
			   r = r->next
    ){
        fprintf(fd,"\n"																	);
	fprintf(fd,"    hugechunk_region header r p= %p\n",	 	r										);
	fprintf(fd,"    r->next                   p= %p\n",		r->next										);
	fprintf(fd,"    r->first_ram_quantum      x= %p\n", (void*)	r->first_ram_quantum								);
	fprintf(fd,"    r->page_count             x= %08x\n",		r->page_count									);
	fprintf(fd,"    r->free_pages             x= %08x\n",		r->page_count									);
	fprintf(fd,"    r->ram_region             p= %p\n",		r->ram_region									);
	fprintf(fd,"    r->ram_region->base       p= %p\n",(void*)	BASE_ADDRESS_OF_QUIRE(r->ram_region)				);
	fprintf(fd,"    r->ram_region->bytesize   p= %p\n",(void*)	BYTESIZE_OF_QUIRE(r->ram_region)					);
	fprintf(fd,"    r->ram_region->...           (remaining fields are OS-dependent and not shown)\n"						);
	fprintf(fd,"    r->age_of_youngest_live_chunk_in_region   x= %08x\n",		r->age_of_youngest_live_chunk_in_region				);
	
    }



    Hugechunk* freelist_header = heap->hugechunk_freelist;

    int free_hugechunks = 0;
    for (Hugechunk* p  = freelist_header->next;
                    p != freelist_header;
                    p  = p->next
    ){
	++ free_hugechunks;
    }

    fprintf(fd,"\n\n--------------------------------------\nHugechunk freelist contains %d blocks:\n", free_hugechunks					);

    for (Hugechunk* p  = freelist_header->next;
                    p != freelist_header;
                    p  = p->next
    ){
	dump_hugechunk( fd, p );
    }

    for (int a = 0;
             a < task->heap->active_agegroups;
             a++
    ){
	fprintf(fd,"\n"																	);
	fprintf(fd,"\n"																	);
	fprintf(fd,"---------------------\n"														);
	fprintf(fd,"Summary of hugechunks for generation %d\n", a+1);
	fprintf(fd,"\n"																	);

	Agegroup* ag  =  heap->agegroup[a];		// Get pointer to our agegroup.

	
	for (Hugechunk* p =  ag->hugechunks[ CODE__HUGE_SIB ];
			p;
			p =  p->next
	){
	    dump_hugechunk( fd, p );
	}
    }
}

//
void   dump_hugechunks_summary   (Task* task, char* caller) {
    // =======================
    //
    char filename[ 1024 ];
    FILE* fd = open_heapdump_logfile( filename, 1024, "dump_hugechunks_summary" );

    log_if("dump_hugechunks_summary: Starting dump to '%s'", filename);

    dump_hugechunks_summary__guts   (fd, task, caller);

    close_heapdump_logfile( fd, filename );
    log_if("dump_hugechunks_summary: Dump to '%s' now complete.", filename);
}

// Write to logfile contents of the Hugechunk datastructures.
// (In practice this means all the compiledfiles in ram.)
//
static void   dump_hugechunks_contents__guts  (FILE* fd, Task* task, char* caller) {
    //        ==============================
    //
    Heap*     heap =  task->heap;

    fprintf(fd,"Hugechunk datastructures contents dump generated by dump_hugechunks_contents__guts in src/c/heapcleaner/heap-debug-stuff.c\n"		);
    fprintf(fd,"Most of this stuff is defined in one of:\n"												);
    fprintf(fd,"\n"																	);
    fprintf(fd,"    src/c/h/runtime-base.h\n"														);
    fprintf(fd,"    src/c/h/heap.h\n"															);
    fprintf(fd,"    src/c/h/sibid.h\n"															);
    fprintf(fd,"    src/c/h/heap-tags.h\n"														);
    fprintf(fd,"\n"																	);



    for (int a = 0;
             a < task->heap->active_agegroups;
             a++
    ){
	fprintf(fd,"\n"																	);
	fprintf(fd,"\n"																	);
	fprintf(fd,"---------------------\n"														);
	fprintf(fd,"Dump of hugechunks for generation %d\n", a+1);
	fprintf(fd,"\n"																	);

	Agegroup* ag  =  heap->agegroup[a];		// Get pointer to our agegroup.

	
	for (Hugechunk* p =  ag->hugechunks[ CODE__HUGE_SIB ];
			p;
			p =  p->next
	){
	    dump_hugechunk( fd, p );

	    unsigned char* chunk     = (unsigned char*)p->chunk;
	    int            chunk_len = (int)           p->bytesize;

	    hexdump_to_file  (fd, "", chunk, chunk_len);

#ifdef HAVE_LIBDIS_H
	    // Disassemble the compiled code using libdisasm. (For altenatives and discussion see Note[1].)
	    // For background see:        http://bastard.sourceforge.net/libdisasm.html
	    // Debian packages this as:   libdisasm0 libdisasm-dev
	    //
	    {

		#define LINE_SIZE 256

		char line0[LINE_SIZE];   // Disassembled code.
		char line1[LINE_SIZE];   // Disassembled code with tabs converted to blanks.

		int pos = 0;             // Number of bytes disassembled so far.
		int size;                // Number of bytes in this instruction.
		x86_insn_t insn;         // This instruction, in abstract form.

		x86_init(opt_none, NULL, NULL);

		fprintf(fd,"\n\nAbove buffer as inte32 assembly code:\n\n");
		while (pos < chunk_len) {
		    //
		    // Disassemble one instruction:
		    //
		    size = x86_disasm(chunk, chunk_len, (unsigned int)chunk, pos, &insn);
		    if (size) {
		        // Print instruction:
		        x86_format_insn(&insn, line0, LINE_SIZE, intel_syntax);
			expand_tabs( line1, line0 );
			fprintf(fd,"%08x: %-40s ;", (unsigned int)(chunk + pos), line1);
                        for (int i = 0; i < 10; ++i) {
			    if (i < size) fprintf(fd," %02x", *(chunk + pos + i));
			    else          fprintf(fd,"   ");
			}
                        for (int i = 0; i < size; ++i) {
			    int c = *(chunk + pos + i);
			    if (c < ' ' || c > '~')  c = '.';
			    fprintf(fd,"%c", c);
			}
			fprintf(fd,"\n");
			pos += size;
		    } else {
			fprintf(fd,"%08x: %-40s ; %02x\n", (unsigned int)(chunk + pos), "[Invalid instruction]", *(chunk + pos));
			pos++;
		    }
		}

		x86_cleanup();
	    }
#else
	    fprintf(fd,"[ Unable to disassemble x86 compiled code because libdisasm not available -- see HAVE_LIBDIS_H in src/c/config.h ]\n");
#endif
	}
    }
}

//
void   dump_hugechunks_contents   (Task* task, char* caller) {
    // ========================
    //
    char filename[ 1024 ];
    FILE* fd = open_heapdump_logfile( filename, 1024, "dump_hugechunks_contents" );

    log_if("dump_hugechunks_summary: Starting dump to '%s'", filename);

    dump_hugechunks_summary__guts   (fd, task, caller);

    close_heapdump_logfile( fd, filename );
    log_if("dump_hugechunks_summary: Dump to '%s' now complete.", filename);
}

//
static void   dump_ramlog__guts   (FILE*fd, Task* task, char* caller) {
    //        =================
    //
    fprintf(fd,"Ramlog dump generated by dump_ramlog__guts() in src/c/heapcleaner/heap-debug-stuff.c\n");

    fprintf(fd,"\nLast %d calls made from Mythryl to C, in reverse time order\n", RAMLOG_ENTRIES);
    fprintf(fd,  "(most recent first) with task->pthread->id listed at the left:\n\n");

    {   int e = ramlog_next_entry_to_write;
	int i = RAMLOG_ENTRIES - 1;
        do {
	    e = ramlog_prev( e );

	    Ramlog_Entry* r =  &ramlog_circular_queue[ e ];	

	    if (r->fn_name) {
	        //
		fprintf(fd,"%4d: %2d  %s\n", i, r->id, r->fn_name );
		++i;
	    }


	} while (e != ramlog_next_entry_to_write);
    }
}

//
void   dump_ramlog   (Task* task, char* caller) {
    // ===========
    //

    char filename[ 1024 ];
    FILE* fd = open_heapdump_logfile( filename, 1024, "dump_ramlog" );

    dump_ramlog__guts (fd, task, caller);

    log_if("dump_ramlog: Starting dump to '%s'", filename);

    close_heapdump_logfile( fd, filename );
    log_if("dump_ramlog: Dump to '%s' now complete.", filename);
}

//
void   dump_whatever   (Task* task, char* caller) {
    // =============
    //
    // This provides a place to implement ad hoc dumping of whatever
    // is needed during a major debug thrash;  in production code it
    // does nothing interesting.
    //

    char filename[ 1024 ];
    FILE* fd = open_heapdump_logfile( filename, 1024, "dump_whatever" );

    log_if("dump_whatever: Starting dump to '%s'", filename);

    fprintf(fd,"Ad hoc dump generated by dump_whatever() in src/c/heapcleaner/heap-debug-stuff.c\n");

    ///////////////////////////////////////////////////////////////
    // Put stuff here :-)
    ///////////////////////////////////////////////////////////////

    close_heapdump_logfile( fd, filename );
    log_if("dump_whatever: Dump to '%s' now complete.", filename);
}

//
void   dump_all   (Task* task, char* caller) {
    // ========
    //
    char filename[ 1024 ];
    FILE* fd = open_heapdump_logfile( filename, 1024, "dump_all" );

    log_if("dump_all: Starting dump to '%s'", filename);

    fprintf(fd,"Dump generated by dump_all() in src/c/heapcleaner/heap-debug-stuff.c\n");

    dump_task__guts			(fd, task, caller);
    dump_gen0s__guts			(fd, task, caller);
    dump_gen0_tripwire_buffers__guts	(fd, task, caller);
    dump_gens__guts			(fd, task, caller);
    dump_ramlog__guts			(fd, task, caller);
    dump_hugechunks_summary__guts	(fd, task, caller);
    dump_hugechunks_contents__guts	(fd, task, caller);

    close_heapdump_logfile( fd, filename );
    log_if("dump_all: Dump to '%s' now complete.", filename);
}

//
void   dump_all_but_hugechunks_contents   (Task* task, char* caller) {
    // ================================
    //
    char filename[ 1024 ];
    FILE* fd = open_heapdump_logfile( filename, 1024, "dump_all_but_hugechunks_contents" );

    log_if("dump_all_but_hugechunks_contents: Starting dump to '%s'", filename);

    fprintf(fd,"Dump generated by dump_all_but_hugechunks_contents() in src/c/heapcleaner/heap-debug-stuff.c\n");

    dump_task__guts			(fd, task, caller);
    dump_gen0s__guts			(fd, task, caller);
    dump_gen0_tripwire_buffers__guts	(fd, task, caller);
    dump_gens__guts			(fd, task, caller);
    dump_ramlog__guts			(fd, task, caller);
    dump_hugechunks_summary__guts	(fd, task, caller);

    close_heapdump_logfile( fd, filename );
    log_if("dump_all_but_hugechunks_contents: Dump to '%s' now complete.", filename);
}

//
void   zero_agegroup0_overrun_tripwire_buffer( Task* task ) {
    // ==========================================
    //
    // To detect allocation buffer overrun, we maintain
    // an always-all-zeros buffer of AGEGROUP0_OVERRUN_TRIPWIRE_BUFFER_SIZE_IN_WORDS
    // Val_Sized_Ints at the end of each agegroup0 buffer.
    // Here we zero that out:
    //
    Val_Sized_Int* p = (Val_Sized_Int*) (((char*)(task->real_heap_allocation_limit)) + MIN_FREE_BYTES_IN_AGEGROUP0_BUFFER);
    //
    for (int i = 0;
             i < AGEGROUP0_OVERRUN_TRIPWIRE_BUFFER_SIZE_IN_WORDS;
             i++
    ){
	//
	p[i] = 0;
    }
//  log_if("zero_agegroup0_overrun_tripwire_buffer: Done zeroing %x -> %x", p, p+(AGEGROUP0_OVERRUN_TRIPWIRE_BUFFER_SIZE_IN_WORDS-1));	// Commented out because it spams the logfile with gigabytes of text.
}

//
void   check_agegroup0_overrun_tripwire_buffer   (Task* task, char* caller)   {
    // =======================================
    //
    // To detect allocation buffer overrun, we maintain
    // an always-all-zeros buffer of AGEGROUP0_OVERRUN_TRIPWIRE_BUFFER_SIZE_IN_WORDS
    // Val_Sized_Ints at the end of each agegroup0 buffer.
    // Here we verify that it is all zeros:
    //
#ifdef SOON
    Val_Sized_Int* p = (Val_Sized_Int*) (((char*)(task->real_heap_allocation_limit)) + MIN_FREE_BYTES_IN_AGEGROUP0_BUFFER);
    //
    for (int i = AGEGROUP0_OVERRUN_TRIPWIRE_BUFFER_SIZE_IN_WORDS; i --> 0; ) {
	//
	if (p[i] != 0) {
	    //
	    log_if("check_agegroup0_overrun_tripwire_buffer:  While checking %x -> %x agegroup0 buffer overrun of %d words detected. (%s)", p, p+(AGEGROUP0_OVERRUN_TRIPWIRE_BUFFER_SIZE_IN_WORDS-1), i+1, caller);
	    dump_all_but_hugechunks_contents( task, caller );
	    die( "check_agegroup0_overrun_tripwire_buffer:  Overran agegroup0 buffer by %d words so did dump_all_but_hugechunks_contents() -- see logfile for details.", i+1);
	    exit(1);										// die() should never return, so this should never execute. But gcc understands it better.
	}
    }
#endif
}

//////////////////////////////////////////////////////////////////////////
// Note[1]: x86 and AMD64 disassemblers: Problems and alternatives 
//
// I picked   libdisasm   on the spur of the moment because it is
// packaged on Debian and seems to do the job.  -- 2011-12-31 CrT
//  
// Hue White reports that it is not available on Fedora. 
//  
//     From: LoveLightAwareness <lovelightawareness@gmail.com> 
//     Subject: Re: [Mythryl] Mythryl now depends upon libdisasm0 + libdisasm-dev 
//     To: Cynbe ru Taren <cynbe@mythryl.org> 
//     Date: Thu, 29 Dec 2011 06:39:38 -0800 
//      
//     Hi Cynbe, 
//      
//     You might also like to consider udis at?http://sourceforge.net/projects/udis86/ 
//     for both x86 and amd64. 
//     I am using it in my code (http://code.google.com/p/openvmtil/) and it works 
//     well. Factor, the language, uses it also and is where i got the idea. 
 


// Jeff Prothero Copyright (c) 2010-2011,
// released under Gnu Public Licence version 3.






/*
##########################################################################
#   The following is support for outline-minor-mode in emacs.		 #
#  ^C @ ^T hides all Text. (Leaves all headings.)			 #
#  ^C @ ^A shows All of file.						 #
#  ^C @ ^Q Quickfolds entire file. (Leaves only top-level headings.)	 #
#  ^C @ ^I shows Immediate children of node.				 #
#  ^C @ ^S Shows all of a node.						 #
#  ^C @ ^D hiDes all of a node.						 #
#  ^HFoutline-mode gives more details.					 #
#  (Or do ^HI and read emacs:outline mode.)				 #
#									 #
# Local variables:							 #
# mode: outline-minor							 #
# outline-regexp: "[A-Za-z]"			 		 	 #
# End:									 #
##########################################################################
*/

