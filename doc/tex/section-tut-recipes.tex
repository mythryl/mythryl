\label{section:tut:recipes}

% --------------------------------------------------------------------------------
\subsection{Preface}
\cutdef*{subsubsection}
\label{section:tut:recipes:preface}

\begin{quote}\begin{tiny}
       ``Simple things should be simple;\newline
         ~~complex things should be possible.''\newline
         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~---{\em Alan~~Kay}
\end{tiny}\end{quote}

This section gathers together typical solutions to simple, common Mythryl programming tasks.
\cutend*

% --------------------------------------------------------------------------------
\subsection{Iterate from 1 to n}
\cutdef*{subsubsection}

Iterate from 1 to n:
\begin{verbatim}
    eval:  n = 3;
    eval:  for (i=1; i <= n; ++i)  printf "%d\n" i;
    1
    2
    3
\end{verbatim}

Iterate from 1 to n, second way:
\begin{verbatim}
    eval:  n = 3;
    eval:  foreach (1..n) {. printf "%d\n" #i; };
    1
    2
    3
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Iterate over a list}
\cutdef*{subsubsection}

Iterate over a list:
\begin{verbatim}
    eval:  foreach [ "red", "green", "blue" ] {. printf "%s\n" #color; };
    red
    green
    blue
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Generate a list of numbers}
\cutdef*{subsubsection}

Generate a list of consecutive numbers:
\begin{verbatim}
    eval:  1..3
    [1, 2, 3]
\end{verbatim}

Generate a list of odd numbers:
\begin{verbatim}
    eval:  [ i for i in 1..10 where i & 1 == 1 ];
    [1, 3, 5, 7, 9]
\end{verbatim}

Generate a list of even numbers as strings:
\begin{verbatim}
    eval:  [ sprintf "%d" i for i in 1..10 where i & 1 == 0 ];
    ["2", "4", "6", "8", "10"]
\end{verbatim}

Generate a list of prime pairs:
\begin{verbatim}
    eval:  [ (i, i+2) for i in 1..1000 where (isprime i and isprime (i+2)) ];
    [ (1, 3), (3, 5), (5, 7), (11, 13), (17, 19), (29, 31), 
      (41, 43), (59, 61), (71, 73), (101, 103), (107, 109), 
      (137, 139), (149, 151), (179, 181), (191, 193), 
      (197, 199), (227, 229), (239, 241), (269, 271), 
      (281, 283), (311, 313), (347, 349), (419, 421), 
      (431, 433), (461, 463), (521, 523), (569, 571), 
      (599, 601), (617, 619), (641, 643), (659, 661), 
      (809, 811), (821, 823), (827, 829), (857, 859), 
      (881, 883) ]
\end{verbatim}


\cutend*

% --------------------------------------------------------------------------------
\subsection{Capture text output from a shell command}
\cutdef*{subsubsection}

Use backquotes to capture text output from a shell command:
\begin{verbatim}
    eval:  printf "%s" `date`;
    Fri Feb 22 23:48:59 CST 2008
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Compile and execute a string containing Mythryl source code}
\cutdef*{subsubsection}

Compile and execute a string containing Mythryl source code:
\begin{verbatim}
    eval:  evali "2+2";
    4
\end{verbatim}

This generates optimized native code for the given expression, 
so it can be a good way of producing on the fly efficient code 
specialized to the need at hand in cases where runtime needs 
are too unpredictable to permit compiling all needed code 
ahead of time.  For example, a raytracer might use this to 
interactively compile efficient native code for the scene being 
rendered.

To avoid tricky type issues, currently only a handful of 
{\tt eval} variants with common return types are supported:
\begin{itemize}
\item {\tt eval: String -> Void} 
\item {\tt evali: String -> Int} 
\item {\tt evalf: String -> Float} 
\item {\tt evals: String -> String} 
\item {\tt evalli: String -> List(Int)} 
\item {\tt evallf: String -> List(Float)} 
\item {\tt evalls: String -> List(String)} 
\end{itemize}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Look up a key in the linux environment}
\cutdef*{subsubsection}

Look up a key in the unix environment:
\begin{verbatim}
    eval:  the (getenv "LOGNAME");
    "jcb"
\end{verbatim}

Look up a key in the linux environment, 
providing a fallback value in case 
the key is not found:
\begin{verbatim}
    eval:  the_else ((getenv "LOGNAME"), "???");
    "jcb"
\end{verbatim}

Do different things depending on whether 
key was found:
\begin{verbatim}
    eval:  case  (getenv "LOGNAME")   THE name => printf "%s\n" name; NULL => print "LOGNAME not set?!\n"; esac;
    jcb
\end{verbatim}

Print the complete unix environment:
\begin{verbatim}
    eval:  apply  {. printf "%s\n" #arg; } (environ ());
    SHELL=/bin/sh
    PATH=/usr/bin:/bin
    HOME=/home/jcb
    LOGNAME=jcb
    USER=jcb
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Print the script's commandline arguments}
\cutdef*{subsubsection}

Print the script's commandline arguments 
--- a poor man's {\tt echo}:
\begin{verbatim}
    #!/usr/bin/mythryl

    foreach (argv()) {. printf "%s " #arg; };

    print "\n";

    exit 0;
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Compute the length of a string}
\cutdef*{subsubsection}

Compute the length of a string:
\begin{verbatim}
    eval:  printf "%d\n" (strlen `date`);
    29
    eval:  printf "%d\n" (string::length `date`);
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Compute the length of a list}
\cutdef*{subsubsection}

Compute the length of a list:
\begin{verbatim}
    eval:  printf "%d\n" (length [ "red", "green", "blue" ] );
    3
    eval:  printf "%d\n" (list::length [ "red", "green", "blue" ] );
    3
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Read an int from a string}
\cutdef*{subsubsection}

Read an int from a string:
\begin{verbatim}
    f = atoi "23";
\end{verbatim}

Read an int from a string, II:
\begin{verbatim}
    f = int::from_string "23";
\end{verbatim}

Read an int from a string, III:
\begin{verbatim}
    eval:  sscanf "123" "%d";

    THE [INT 123]

    eval:  scanf::sscanf "123" "%d";

    THE [INT 123]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Read a float from a string}
\cutdef*{subsubsection}

Read a float from a string:
\begin{verbatim}
    f = atod "2.3";
\end{verbatim}

Read a float from a string, II:
\begin{verbatim}
    f = float::from_string "2.3";
\end{verbatim}

Read a float from a string, III:
\begin{verbatim}
    eval:  sscanf "12.3" "%f";

    THE [FLOAT 12.3]

    eval:  scanf::sscanf "12.3" "%f";

    THE [FLOAT 12.3]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Read multiple numbers from a string}
\cutdef*{subsubsection}

\begin{verbatim}
    eval:  sscanf "1,3,12.3" "%d,%d,%f";

    THE [INT 1, INT 3, FLOAT 12.3]

    eval:  scanf::sscanf "1,3,12.3" "%d,%d,%f";

    THE [INT 1, INT 3, FLOAT 12.3]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Round a float to an int}
\cutdef*{subsubsection}

Round a float to an int: 
\begin{verbatim}
    i = round f;
\end{verbatim}

Round a float to an int, II:
\begin{verbatim}
    i = float::to_int ieee_float::TO_NEAREST f;
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Sort a list of strings}
\cutdef*{subsubsection}

Sort a list of strings:
\begin{verbatim}
    eval:  sort  string::(>)   [ "red", "green", "blue" ];
    ["blue", "green", "red"]                     
\end{verbatim}

Another way:
\begin{verbatim}
    eval:  list_mergesort::sort string::(>)   [ "red", "green", "blue" ];

    ["blue", "green", "red"]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Sort a list of integers}
\cutdef*{subsubsection}

Sort a list of integers:
\begin{verbatim}
    eval:  sort  int::(>)   [ 13, 11, 17 ];
    [11, 13, 17]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Sort a list of floats}
\cutdef*{subsubsection}

Sort a list of floats:
\begin{verbatim}
    eval:  sort  float::(>)   [ 13.0, 11.0, 17.0 ];
    [11.0, 13.0, 17.0]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Sort a list of tuples or records}
\cutdef*{subsubsection}

Sort a list of string-pairs by first element:
\begin{verbatim}
    eval:  sort  (\\ ((a,_),(b,_)) =  a > b)    [ ("abc","xyz"), ("xyz","abc"), ("jkl","mno") ];

    [("abc", "xyz"), ("jkl", "mno"), ("xyz", "abc")]
\end{verbatim}
(The above will work no matter what the type of the the second element.)

Sort a list of string-pairs by second element:
\begin{verbatim}
    eval:  sort  (\\ ((_,a),(_,b)) =  a > b)    [ ("abc","xyz"), ("xyz","abc"), ("jkl","mno") ];

    [("xyz", "abc"), ("jkl", "mno"), ("abc", "xyz")]
\end{verbatim}
(The above will work no matter what type the type of the first element.)

Sort a list of records by some field:
\begin{verbatim}
    eval:  sort  (\\ (a,b) =  a.key > b.key)    [ { key => "abc", value => "xyz" }, { key => "xyz", value => "abc" }, { key => "jkl", value => "mno" } ];

    [{ key="abc", value="xyz" }, 
     { key="jkl", value="mno" }, 
     { key="xyz", value="abc" }]
\end{verbatim}

In a program (vs a script) you will want to replace {\tt sort} by {\tt list\_mergesort::sort}.

\cutend*

% --------------------------------------------------------------------------------
\subsection{Sort a list of strings, dropping duplicates}
\cutdef*{subsubsection}

Sort a list of strings, dropping duplicates:
\begin{verbatim}
    eval:  uniquesort  string::compare   [ "red", "green", "blue", "red", "green", "blue" ];
    ["blue", "green", "red"]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Sort a list of integers, dropping duplicates}
\cutdef*{subsubsection}

Sort a list of integers, dropping duplicates:
\begin{verbatim}
    eval:  uniquesort  int::compare   [ 13, 11, 17, 13, 11, 17 ];
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Sort a list of floats, dropping duplicates}
\cutdef*{subsubsection}

Sort a list of floats, dropping duplicates:
\begin{verbatim}
    eval:  uniquesort  float::compare   [ 13.0, 11.0, 17.0, 13.0, 11.0, 17.0 ];
    [11.0, 13.0, 17.0]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Concatenate two lists}
\cutdef*{subsubsection}

Concatenate two lists:
\begin{verbatim}
    eval:  [ "red", "green", "blue" ] @ [ "red", "green", "blue" ]
    ["red", "green", "blue", "red", "green", "blue"]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Reverse a list}
\cutdef*{subsubsection}

Reverse a list:
\begin{verbatim}
    eval:  reverse [ "red", "green", "blue" ];
    ["blue", "green", "red"]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Shuffle a list pseudo-randomly}
\cutdef*{subsubsection}

Shuffle a list pseudo-randomly:
\begin{verbatim}
    eval:  shuffle (1..10);
    [10, 9, 8, 3, 4, 5, 6, 7, 2, 1]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Get first element of list (Lisp {\sc CAR})}
\cutdef*{subsubsection}

Get first element of list (what lisp calls ``car''):
\begin{verbatim}
    eval:  head [ "red", "green", "blue" ];
    "red"
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Get rest of list (Lisp {\sc CDR})}
\cutdef*{subsubsection}

Get rest of list following first element of list (what lisp calls ``cdr''):
\begin{verbatim}
    eval:  tail [ "red", "green", "blue" ];
    ["green", "blue"]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Prepend element to list (Lisp {\sc CONS})}
\cutdef*{subsubsection}

Add an element to start of list (what lisp calls ``cons''):
\begin{verbatim}
    eval:  "red" ! [ "green", "blue" ];
    ["red", "green", "blue"]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Select first/second element of each of a list of pairs}
\cutdef*{subsubsection}

Select first/second element of each of a list of pairs:
\begin{verbatim}
    eval:  posix::uname ();                              # Generate example list of pairs
    [("sysname", "Linux"), ("nodename", "maw"), 
     ("release", "2.6.14"), 
     ("version", "#9 SMP Sat Jan 28 22:31:10 CST 2006"), 
     ("machine", "i686")]

    eval:  map #1 (posix::uname());                       # First elements from above pairs.
    ["sysname", "nodename", "release", "version", "machine"]

    eval:  map #2 (posix::uname());                       # Second elements from above pairs.
    ["Linux", "maw", "2.6.14", 
     "#9 SMP Sat Jan 28 22:31:10 CST 2006", "i686"]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Drop the first N characters of a string}
\cutdef*{subsubsection}

Drop the first character of a string:
\begin{verbatim}
    eval:  string::extract ("fubar", 1, NULL);
    "ubar"
\end{verbatim}

Another way:
\begin{verbatim}
    eval:  regex::find_first_match_to_ith_group 1 ./^.(.*)$/ "fubar";
    THE "ubar"
\end{verbatim}

Drop the first two characters of a string:
\begin{verbatim}
    eval:  string::extract ("fubar", 2, NULL);
    "bar"
\end{verbatim}

Another way:
\begin{verbatim}
eval:  regex::find_first_match_to_ith_group 1 ./^..(.*)$/ "fubar";
THE "bar"
\end{verbatim}
\cutend*

% --------------------------------------------------------------------------------
\subsection{Drop last N characters of a string}
\cutdef*{subsubsection}

Drop the last character of a string:
\begin{verbatim}
    eval:  string::extract ("fubar", 0, THE (string::length "fubar" - 1));
    "fuba"
\end{verbatim}

Another way:
\begin{verbatim}
    eval:  regex::find_first_match_to_ith_group 1 ./^(.*).$/ "fubar";
    THE "fuba"
\end{verbatim}

Drop the last two characters of a string:
\begin{verbatim}
    eval:  string::extract ("fubar", 0, THE (string::length "fubar" - 2));
    "fub"
\end{verbatim}

Another way:
\begin{verbatim}
eval:  regex::find_first_match_to_ith_group 1 ./^(.*)..$/ "fubar";
THE "fub"
\end{verbatim}

\cutend*



% --------------------------------------------------------------------------------
\subsection{Extract a substring of string}
\cutdef*{subsubsection}

Extract second and third characters of a string as a string:
\begin{verbatim}
    eval:  string::extract ("fubar", 1, THE 2);
    "ub"
\end{verbatim}

Another way:
\begin{verbatim}
    eval:  regex::find_first_match_to_ith_group 1 ./^.(..).*$/ "fubar";
    THE "ub"
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Explode a string into a list of characters}
\cutdef*{subsubsection}

Explode a string into a list of characters:
\begin{verbatim}
    eval:  explode "green";
    ['g', 'r', 'e', 'e', 'n']
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Implode a list of characters into a string}
\cutdef*{subsubsection}

Implode a list of characters into a string:
\begin{verbatim}
    eval:  implode ['g', 'r', 'e', 'e', 'n'];
    "green"
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Reverse a string}
\cutdef*{subsubsection}

Reverse a string:
\begin{verbatim}
    eval:  implode (reverse (explode "green"));
    "neerg"
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Force a string to upper case}
\cutdef*{subsubsection}

Force a string to upper case:
\begin{verbatim}
    eval:  toupper "Green";
    "GREEN"
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Force a string to lower case}
\cutdef*{subsubsection}

Force a string to lower case:
\begin{verbatim}
    eval:  tolower "Green";
    "green"
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Force a list of strings to upper case}
\cutdef*{subsubsection}

Force a list of strings to upper case:
\begin{verbatim}
    eval: map toupper [ "red", "green", "blue" ];
    ["RED", "GREEN", "BLUE"]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Concatenate two strings}
\cutdef*{subsubsection}

Concatenate two strings:
\begin{verbatim}
    eval:  "red" + "green";
    "redgreen"
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Concatenate a list of strings}
\cutdef*{subsubsection}

Concatenate a list of strings:
\begin{verbatim}
    eval:  cat [ "red", "green", "blue" ];
    "redgreenblue"
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Concatenate a list of strings, with a given separator}
\cutdef*{subsubsection}

Concatenate a list of strings, with a given separator:
\begin{verbatim}
    eval:  join " " [ "red", "green", "blue" ];
    "red green blue"
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Break a string into whitespace-separated words}
\cutdef*{subsubsection}

Break a string into whitespace-separated words:
\begin{verbatim}
    eval:  words "the quick brown fox";
    ["the", "quick", "brown", "fox"]
\end{verbatim}

Same, using an abbreviated syntax ({\tt dot\_\_qquotes}):

\begin{verbatim}
    eval:  ."the quick brown fox";
    ["the", "quick", "brown", "fox"]
\end{verbatim}

Ditto, a bit more laboriously:
\begin{verbatim}
    eval:  tokens char::is_space "the quick brown fox";
    ["the", "quick", "brown", "fox"]
\end{verbatim}

\cutend*


% --------------------------------------------------------------------------------
\subsection{Break a string into colon-separated fields:}
\cutdef*{subsubsection}

Break a string into colon-separated fields:
\begin{verbatim}
    eval:  fields {. #c == ':'; } "jcb:x:133:133::/home/jcb:/bin/sh";
    ["jcb", "x", "133", "133", "", "/home/jcb", "/bin/sh"]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Break some text into lines}
\cutdef*{subsubsection}

Break some text into lines:
\begin{verbatim}
    eval:  fields {. #c == '\n'; } "Now is the\ntime for all good men\nto party hardy.\n";
    ["Now is the", "time for all good men", "to party hardy.", ""]
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Regular expressions}
\cutdef*{subsubsection}
\label{section:tut:recipe:regular-expressions}

See if a string matches a regular expression:
\begin{verbatim}
    eval:  "foo bar zot" =~ ./^f.*a.*t$/;
    TRUE
    eval:  "foo bar zot" =~ ./^f.*q.*t$/;
    FALSE
\end{verbatim}

Find location of first 'foo' in a string:

\begin{verbatim}
    eval:  strlen (regex::find_first_match_to_ith_group 1 ./^(.*)foo/ "the fool on the hill");
    THE 4
\end{verbatim}



Select all strings in a list matching a regular expression:
\begin{verbatim}
    eval:  filter {. #file =~ ./ee/; } [ "red", "green", "blue" ];
    ["green"]
\end{verbatim}

Drop leading and trailing whitespace from a string:
\begin{verbatim}
    eval:  regex::find_first_match_to_ith_group 1 ./^\s*(\S.*\S)\s*$/ " foo ";
    THE "foo"

    eval:  trim  " foo ";                             # Better!
    "foo"

    eval:  makelib::scripting_globals::trim  " foo ";   # In programs.
    "foo"
\end{verbatim}


Match 'regex' once against 'text' and return {\sc THE} matched substring,
returning {\sc NULL} if no match was found:
\begin{verbatim}
    eval:  regex::find_first_match_to_regex ./f.t/ "the fat father futzed"
    THE "fat" 
\end{verbatim}


Return all substrings of 'text' which match 'regex'.
\begin{verbatim}
    eval:  regex::find_all_matches_to_regex ./f.t/ "the fat father futzed"; 
    ["fat", "fat", "fut"]
\end{verbatim}

Match 'regex' once against 'text'. 
Return {\sc NULL} if no match found, 
else {\sc THE} list of substrings 
constituting the match.
\begin{verbatim}
    eval:  regex::find_first_match_to_regex_and_return_all_groups ./(f.)(t)/ "the fat father futzed";
    THE ["fa", "t"]
\end{verbatim}

For each match of the regex, return what the second 
set of parens matched:
\begin{verbatim}
    eval:  regex::find_all_matches_to_regex_and_return_values_of_ith_group 2 ./(f)(.)t/ "the fat father futzed";
    ["a", "a", "u"]
\end{verbatim}

Replace first match of regex by given substring:
\begin{verbatim}
    eval:  regex::replace_first ./f.t/ "FAT" "the fat father futzed";
    "the FAT father futzed"
\end{verbatim}

Replace all matches of regex by given substring:
\begin{verbatim}
    eval:  regex::replace_all ./f.t/ "FAT" "the fat father futzed";
    "the FAT FATher FATzed"
\end{verbatim}

Find first match of regex in text. 
Pass match as a list of strings to given function. 
Splice returned string into text in place of match:
\begin{verbatim}
    eval:  regex::replace_first_via_fn ./(f.t)/ {. toupper (head #matchlist); }  "the fat father futzed";
    "the FAT father futzed"
\end{verbatim}

As above, but process all matches of regex in text:
\begin{verbatim}
    eval:  regex::replace_all_via_fn ./(f.t)/ {. toupper (head #matchlist); }  "the fat father futzed";
    "the FAT FATher FUTzed"
\end{verbatim}

See also:
\begin{quotation}
\ahrefloc{section:libref:perl5-regular-expressions:overview}{Perl5 Regular Expressions Library Reference}.\newline 
\ahrefloc{section:tut:bare-essentials:regex}{bare-essentials tutorial}.\newline 
\ahrefloc{section:tut:full-monte:regex}{full-monte tutorial}.\newline
\ahrefloc{src/lib/regex/glue/regular-expression-matcher.api}{src/lib/regex/glue/regular-expression-matcher.api}\newline
\end{quotation}
\cutend*


% --------------------------------------------------------------------------------
\subsection{Read a text file}
\cutdef*{subsubsection}

The simplest way to read a text file {\tt foo.txt} as a list of lines is 
to use the {\tt lines} function from the 
\ahrefloc{pkg:file}{file} package:

\begin{verbatim}
    line_list = file::as_lines "foo.txt";
\end{verbatim}

Thus, for example, a quick and easy way to print out the contents of a file is

\begin{verbatim}
    foreach (file::as_lines "foo.txt") {. print #line; };
\end{verbatim}

If you like to see more of what is going on under the hood, {\tt file::as\_lines} 
is equivalent to

\begin{verbatim}
    fun lines filename
        =
        {    fd = file::open_for_read filename;
             line_list = file::read_lines fd;
             file::close_input fd;
             line_list;
        };
\end{verbatim}

where in turn {\tt file::read\_lines} is equivalent to

\begin{verbatim}
    fun read_lines input_stream
        =
        read_lines' (input_stream, [])
        where
            fun read_lines' (input_stream, lines_so_far)
                =
                case (file::read_line input_stream)
                    NULL     => reverse lines_so_far; 
                    THE line => read_lines' (input_stream, line ! lines_so_far);
                esac;
        end;
\end{verbatim}

If you want to trap failures to open the specified file,
issue an error message, and continue, you can write

\begin{verbatim}
    fun lines filename
        =
        {    fd = file::open_for_read filename;
             line_list = file::read_lines fd;
             file::close_input fd;
             line_list;
        }
        except io_exceptions::IO _
            =
            {   fprintf stderr "Could not open %s to read, treating it as empty.\n" filename;
                [];
            };
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Write a text file}
\cutdef*{subsubsection}

Write a text file:
\begin{verbatim}
    fd = file::open_for_write "foo.txt";
    file::write (fd, "There is no royal road to mathematics.\n");
    fprintf      fd  "Mathematics is the %s of the sciences.\n" "queen";
    file::flush  fd;
    file::close_output  fd;
\end{verbatim}

Here is another way of doing the same thing:

\begin{verbatim}
    file::from_lines
        "foo.txt"
        [ "There is no royal road to mathematics.\n",
          sprintf "Mathematics is the %s of the sciences.\n" "queen"
        ];
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Append text to a file}
\cutdef*{subsubsection}

Append text to a file:
\begin{verbatim}
    fd = file::open_for_append "foo.txt";
    file::write (fd, "Let none ignorant of geometry enter here.\n"); 
    fprintf      fd  "%s alone has looked on Beauty bare.\n" "Euclid";
    file::flush  fd;
    file::close  fd;
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Filter a text file}
\cutdef*{subsubsection}

A frequent requirement is to read a text file, make line by line 
changes to its contents, and then write the result back.

Suppose you want to convert the contents of file {\tt foo.txt} 
to upper case.  Here is one solution:

\begin{verbatim}
    filename = "foo.txt";
    lines    = file::as_lines filename;
    lines    = map string::to_upper lines;
    file::from_lines filename lines; 
\end{verbatim}

If you suffer from One-Liner Disease, you might write this as

\begin{verbatim}
    file::from_lines "foo.txt" (map string::to_upper (file::as_lines "foo.txt"));
\end{verbatim}

Or if you enjoy writing C in Mythryl, you might do

\begin{verbatim}
    #!/usr/bin/mythryl
    fd_in  = file::open_for_read "foo.txt";
    fd_out = file::open       "foo.txt.new";
    for (line = file::read_line fd_in;
         line != NULL;
         line = file::read_line fd_in
    ){
        line = string::to_upper (the line);
        file::write (fd_out, line);
    };
    file::close_input fd_in;
    file::close       fd_out;
    winix__premicrothread::file::remove_file "foo.txt";
    winix__premicrothread::file::rename_file { from => "foo.txt.new", to => "foo.txt" };
    exit 0;
\end{verbatim}

As Larry Wall says, any code is ok if it gets the job done before you get fired!

For more ideas on transforming lines as you filter a file, see the section on 
\ahrefloc{section:tut:recipe:regular-expressions}{regular expression recipes}.
\cutend*

% --------------------------------------------------------------------------------
\subsection{Delete a file}
\cutdef*{subsubsection}

Delete a file:
\begin{verbatim}
    eval:  winix::file::remove_file "foo.txt";
\end{verbatim}

Another way:
\begin{verbatim}
    eval:  posix::unlink "foo.txt";
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Rename a file}
\cutdef*{subsubsection}

Rename a file:
\begin{verbatim}
    winix::file::rename_file { from => "foo.txt", to => "bar.txt" };
\end{verbatim}

Another way:
\begin{verbatim}
    posix::rename { old => "foo.txt", new => "bar.txt" };
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Check File Existence}
\cutdef*{subsubsection}

Check that a file exists:
\begin{verbatim}
    eval:  isfile "foo.txt";
    TRUE
\end{verbatim}

A shorter synonym for Perl afficionados:
\begin{verbatim}
    eval:  -F "foo.txt";
    TRUE
\end{verbatim}

The full form, for programs (vs scripts):
\begin{verbatim}
    eval:  posix::stat::is_file      (posix::stat  "foo.txt")  except _ = FALSE;
    TRUE
\end{verbatim}

Related tests: 
\begin{tabular}{|l|l|l|} \hline
-D & isdir      & posix::stat::is\_directory  \\ \hline
-P & ispipe     & posix::stat::is\_pipe       \\ \hline
-L & issymlink  & posix::stat::is\_symlink    \\ \hline
-S & issocket   & posix::stat::is\_socket     \\ \hline
-C & ischardev  & posix::stat::is\_char\_dev   \\ \hline
-B & isblockdev & posix::stat::is\_block\_dev  \\ \hline
\end{tabular}


\cutend*

% --------------------------------------------------------------------------------
\subsection{Check File Readability}
\cutdef*{subsubsection}

Check that a file is readable:
\begin{verbatim}
    eval:  mayread "foo.txt";
    TRUE
\end{verbatim}

A shorter synonym for Perl afficionados:
\begin{verbatim}
    eval:  -R "foo.txt";
    TRUE
\end{verbatim}

The full form, for programs (vs scripts):
\begin{verbatim}
    eval:  winix::file::access (filename, [winix::file::MAY_READ])     except _ = FALSE;
    TRUE
\end{verbatim}

Related tests: 
\begin{tabular}{|l|l|l|} \hline
-W & maywrite   & winix::file::MAY\_WRITE    \\ \hline
-X & mayexecute & winix::file::MAY\_EXECUTE  \\ \hline
\end{tabular}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Get the size of a file}
\cutdef*{subsubsection}

Get the size of a file:
\begin{verbatim}
    eval:  (stat "foo.txt").size;
    124518
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Set file mode}
\cutdef*{subsubsection}

Set file mode:
\begin{verbatim}
    eval:  `chmod 644 foo.txt`;
\end{verbatim}

Set file mode, II:
\begin{verbatim}
    eval:  bin_sh' "chmod 644 foo.txt";
\end{verbatim}

Set file mode, III:
\begin{verbatim}
    winix::process::bin_sh' "chmod 644 foo.txt";
\end{verbatim}

Set file mode, IV:
\begin{verbatim}
    posix::chmod ("foo.txt", posix::mode_0644);
\end{verbatim}

Set file mode, V:
\begin{verbatim}
    posix::chmod ("foo.txt", posix::s::flags [ posix::s::iwusr, posix::s::irusr, posix::s::irgrp, posix::s::iroth ]);
\end{verbatim}

Set file mode, VI:
\begin{verbatim}
    include package posix;
    chmod ("foo.txt", s::flags [ s::iwusr, s::irusr, s::irgrp, s::iroth ]);
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Get current directory}
\cutdef*{subsubsection}

Three mostly equivalent ways to get the current directory:
\begin{verbatim}
    eval:  getcwd ();
    "/home/jcb"
    eval:  winix::file::current_directory ();
    "/home/jcb"
    eval:  posix::current_directory ();
    "/home/jcb"
\end{verbatim}

\cutend*

% --------------------------------------------------------------------------------
\subsection{Process contents of directories and directory trees}
\cutdef*{subsubsection}

Alphabetically list all vanilla names 
(names not starting with a dot) in 
current directory:
\begin{verbatim}
    eval:  foreach (dir::entry_names ".") {. printf "%s\n" #filename; };
    bar
    foo
    zot
\end{verbatim}

Alphabetically list all names in current directory, except for ``.'' and ``..'':
\begin{verbatim}
    eval:  foreach (dir::entry_names' ".") {. printf "%s\n" #filename; };
    .bashrc
    .emacs
    bar
    foo
    src
    zot
\end{verbatim}

Alphabetically list all filenames in current directory, including ``.'' and ``..'':
\begin{verbatim}
    eval:  foreach (dir::entry_names'' ".") {. printf "%s\n" #filename; };
    .
    ..
    .bashrc
    .emacs
    bar
    foo
    src
    zot
\end{verbatim}

Alphabetically list names of all vanilla files in current directory, 
ignoring directories, pipes etc:
\begin{verbatim}
    eval:  foreach (dir::file_names ".") {. printf "%s\n" #filename; };
    .bashrc
    .emacs
    bar
    foo
    zot
\end{verbatim}

Count number of entries in current directory:
\begin{verbatim}
    eval:  length (dir::entry_names'' ".");
    7
\end{verbatim}

Alphabetically list paths of all vanilla names in current directory:
\begin{verbatim}
    eval:  foreach (dir::entries ".") {. printf "%s\n" #filename; };
    /home/jcb/bar
    /home/jcb/foo
    /home/jcb/src
    /home/jcb/zot
\end{verbatim}

Alphabetically list paths of all names in current directory except for ``.'' and ``..'':
\begin{verbatim}
    eval:  foreach (dir::entries' ".") {. printf "%s\n" #filename; };
    /home/jcb/.bashrc
    /home/jcb/.emacs
    /home/jcb/bar
    /home/jcb/foo
    /home/jcb/src
    /home/jcb/zot
\end{verbatim}

Alphabetically list paths of all names in current directory, including ``.'' and ``..'':
\begin{verbatim}
    eval:  foreach (dir::entries'' ".") {. printf "%s\n" #filename; };
    /home/jcb/.
    /home/jcb/..
    /home/jcb/.bashrc
    /home/jcb/.emacs
    /home/jcb/bar
    /home/jcb/foo
    /home/jcb/src
    /home/jcb/zot
\end{verbatim}

Alphabetically list paths of all vanilla files in current directory, 
ignoring directories, pipes etc:
\begin{verbatim}
    eval:  foreach (dir::files ".") {. printf "%s\n" #filename; };
    /home/jcb/.bashrc
    /home/jcb/.emacs
    /home/jcb/bar
    /home/jcb/foo
    /home/jcb/zot
\end{verbatim}

Print the sizes and names of all vanilla files in current directory:
\begin{verbatim}
    eval:  foreach (dir::file_names ".") {. printf "%8d %s\n" (stat #filename).size #filename; };
         328 .bashrc
      240553 .emacs
       29559 bar
       24963 foo
      124518 zot
\end{verbatim}

Build a list of (filename, filesize) pairs for current directory:
\begin{verbatim}
    eval:  pair_list = map {. (#name, (stat #name).size); } (dir::file_names ".");
    [(".bashrc", 328), 
     ("bar", 29559), ("foot", 24963), 
     ("zot", 126542)]
\end{verbatim}

Build a list of (filename, filesize) pairs for current directory II:
\begin{verbatim}
    eval:  [ (filename, (stat filename).size) for filename in dir::file_names "." ];
    [(".bashrc", 328), 
     ("bar", 29559), ("foot", 24963), 
     ("zot", 126542)]
\end{verbatim}

Sort the above list by size:
\begin{verbatim}
    eval:  sorted_list = sort {. #2 #a < #2 #b; } pair_list;
    [(".emacs", 240547), ("zot", 126542),
     ("bar", 29559), (".bashrc", 328)]
\end{verbatim}

Print above size-sorted list:
\begin{verbatim}
    eval:  apply  {. printf "%8d %s\n" (#2 #a) (#1 #a); }  sorted_list;
      240547 .emacs
      126542 zot
       29559 bar
         328 .bashrc
\end{verbatim}

Print names of the immediate subdirectories of the current directory:
\begin{verbatim}
    eval:  foreach (dir::entry_names ".") {. if (-D #name) printf "%s\n" #name; fi; };
    src
\end{verbatim}

Print names of all files matching a given regular expression:
\begin{verbatim}
    eval:  foreach (dir::file_names ".") {. if (#name =~ ./o/) printf "%s\n" #name; fi; };
    foo
    zot
\end{verbatim}

Build a map from file names to file sizes, then print it out:
\begin{verbatim}
    #!/usr/bin/mythryl

    include package string_map;

    # Build a string-map (balanced binary tree)
    # where the keys are the file names and the
    # values are the file sizes:
    #
    name_to_size
        =
        for (result = empty,  input = dir::file_names ".";
             length input > 0; input = tail input;
             result
            )
            {  name    = head input;
               result $= (name, (stat name).size);
            };

    # Iterate over all keys in the map, fetching
    # corresponding sizes and printing the two out:
    #
    foreach (keys_list name_to_size) {.
        size = the (get (name_to_size, #name));
        printf "%8d %s\n" size #name;
    };

    exit 0;
\end{verbatim}


List all plain files in or below current directory:
\begin{verbatim}
    eval:  foreach (dir_tree::files ".") {. printf "%s\n" #file; };
    /home/jcb/.bashrc
    /home/jcb/.emacs
    /home/jcb/bar
    /home/jcb/foo
    /home/jcb/src/test.c
    /home/jcb/zot
\end{verbatim}

List sizes of all plain files in or below current directory:
\begin{verbatim}
    eval:  foreach (dir_tree::files ".") {. printf "%8d %s\n" (stat #file).size #file; };
         328 /home/jcb/.bashrc
      240553 /home/jcb/.emacs
       29559 /home/jcb/bar
       24963 /home/jcb/foo
        1978 /home/jcb/src/test.c
      124518 /home/jcb/zot
\end{verbatim}

Count number of plain files in or below current directory:
\begin{verbatim}
    eval:  length (dir_tree::files ".");
    6
\end{verbatim}

Print all .c files in or below current directory:
\begin{verbatim}
    eval:  foreach (dir_tree::files ".") {. if (#file =~ ./\\.c$/) printf "%s\n" #file; fi; };
    /home/jcb/src/test.c
\end{verbatim}

Print all .c files in or below current directory, another way:
\begin{verbatim}
    eval:  foreach (filter {. #file =~ ./\\.c$/; } (dir_tree::files ".")) {. printf "%s\n" #file; };
    /home/jcb/src/test.c
\end{verbatim}

Count number of .c files in or below current directory:
\begin{verbatim}
    eval:  length (filter {. #file =~ ./\\.c$/; } (dir_tree::files "."));
    1
\end{verbatim}

Two equivalent ways to count the number of 
directories in or below a directory:
\begin{verbatim}
    eval:  length (filter {. isdir #file; } (dir_tree::entries' "."));
    1
    eval:  length (filter {. -D #file; } (dir_tree::entries' "."));
\end{verbatim}

To count other things, you can replace {\tt isdir} above by one of 
{\tt ispipe}, 
{\tt issymlink}, 
{\tt issocket}, 
{\tt ischardev} or 
{\tt isblockdev}, or equivalently replace {\tt -D} by one of 
{\tt -P}, 
{\tt -L}, 
{\tt -S}, 
{\tt -C} or 
{\tt -B}.

To follow symlinks to directories, change {\tt dir\_tree} to 
{\tt link\_tree} in the above examples.  (To avoid symlink 
loops, {\tt link\_tree} remembers which directories it has 
already visited, by dev-inode number, and visits each one at 
most once.)


\cutend*

% --------------------------------------------------------------------------------
\subsection{Run a long-lived Linux subprocess}
\cutdef*{subsubsection}


The easiest way to run a subprocess is to use 
{\tt bin\_sh'}, but they are no help if you need to 
run a persistent subprocess to respond to multiple commands.

The easiest way to do that is to use the {\tt spawn} package, 
which hides the messy details of {\tt fork}ing and setting 
up pipes:
\begin{verbatim}
    #!/usr/bin/mythryl

    fun run_subprocess ()
        = 
        {
            (spawn__premicrothread::spawn ("/bin/sh", []))
                ->
                { from_stream, to_stream, ... };                                        # spawn__premicrothread is from   src/lib/std/src/posix/spawn--premicrothread.pkg

            file::write (to_stream, "echo 'xyzzy'\n");                                  # file__premicrothread  is from   src/lib/std/src/posix/file--premicrothread.pkg
            file::flush to_stream;

            printf "Read from subprocess: '%s'\n" (string::chomp (the (file::read_line  from_stream) ) );

            exit 0;
        };

    run_subprocess ();

\end{verbatim}
\cutend*


% --------------------------------------------------------------------------------
\subsection{Count the number of cores available on host}
\cutdef*{subsubsection}

This does not appear to be well standardized at present. 
The best Mythryl-level solution currently appears to be to do 

\begin{verbatim}
    core_count =  posixlib::sysconf  "NPROCESSORS_ONLN";
\end{verbatim}

(The complete list of values available via {\tt sysconf} on your system may be 
found in {\tt src/c/lib/posix-process-environment/ml\_sysconf.h} 
which is synthesized at build time by {\tt src/c/config/generate-posix-names.sh} 
from (typically) {\tt /usr/include/unistd.h}.)

\cutend*


% --------------------------------------------------------------------------------
\subsection{Set the exit status of a Mythryl script or program}
\cutdef*{subsubsection}

Posix/Linux/Unix systems traditionally allow a program on exit to 
return a status value in the range {\tt 0-255}, which may then be 
examined by the calling program.  The standard convention is that 
successful programs and scripts return a zero exit status, while 
nonzero values indicate failure.  (There is no general convention 
as to what different nonzero status values mean.)

In Mythryl, as in most languages, the exit status is specified as 
an integer argument to  the {\tt exit} function;  it may be checked 
in most shells by  examining the {\tt \$?} special variable: 

\begin{verbatim}
    linux% cat myscript
    #!/usr/bin/mythryl
    exit(13);

    linux% ./myscript; echo $?
    13
\end{verbatim}

Mythryl programs are expected to emphasize clarity over brevity 
to a greater extent than Mythryl scripts, so in a Mythryl program 
instead of calling {\tt exit(13)} one would usually call 

\begin{verbatim}
    winix::process::exit( 13 );
\end{verbatim}

\cutend*


